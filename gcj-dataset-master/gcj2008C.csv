68,2008,32002,beerscout,24443,1,portal.C,gcj/2008/32002/beerscout/24443/1/extracted/portal.C,"#include <cstring>
 #include <string>
 #include <iostream>
 #include <vector>
 #include <queue>
 
 using namespace std;
 
 struct state
 {
   int r, c, tm;
   state(int r, int c, int tm) : r(r), c(c), tm(tm) {}
 };
 
 struct comp
 {
   bool operator()(const state &s1, const state &s2) const
   {
     return s1.tm > s2.tm;
   }
 };
 
 int R, C;
 int sR, sC;
 char map[17][17];
 bool vis[16][16];
 const int dr[] = {  0, -1, 0, 1 };
 const int dc[] = { -1,  0, 1, 0 };
 
 int fastest()
 {
   priority_queue<state, vector<state>, comp> Q;
   Q.push(state(sR, sC, 0));
   memset(vis, 0, sizeof(vis));
   while ( !Q.empty() )
   {
     state S = Q.top(); Q.pop();
     if ( map[S.r][S.c] == 'X' )
       return S.tm;
     if ( vis[S.r][S.c] )
       continue;
     vis[S.r][S.c] = true;
     for ( int d=0; d<4; ++d )
     {
       int nr = S.r + dr[d];
       int nc = S.c + dc[d];
       if ( nr>=0 and nr<R and nc>=0 and nc<C and map[nr][nc] != '#' 
           and not vis[nr][nc] )
         Q.push(state(nr, nc, S.tm + 1));
     }
     // shoot
     for ( int yel=0; yel<4; ++yel )
     {
       int sr = S.r, sc = S.c;
       int yelt = 0;
       while ( sr>=0 and sr<R and sc>=0 and sc<C and map[sr][sc] != '#' )
       {
         sr += dr[yel];
         sc += dc[yel];
         ++yelt;
       }
       for ( int bl=0; bl<4; ++bl )
         if ( yel != bl )
         {
           int psr = S.r, psc = S.c;
           sr = psr + dr[bl]; sc = psc + dc[bl];
           while ( sr>=0 and sr<R and sc>=0 and sc<C and map[sr][sc] != '#' )
           {
             psr = sr; psc = sc;
             sr += dr[bl];
             sc += dc[bl];
           }
           if ( not vis[psr][psc] )
             Q.push(state(psr, psc, S.tm + yelt));
         }
     }
   }
 
   return -1;
 }
 
 
 int process_case()
 {
   cin >> R >> C;
   for ( int r=0; r<R; ++r )
   {
     string cr;
     cin >> cr;
     for ( int c=0; c<C; ++c )
     {
       map[r][c] = cr[c];
       if ( cr[c] == 'O' )
       {
         sR = r; sC = c;
       }
     }
   }
   return fastest();
 }
 
 
 int main()
 {
   int N;
   cin >> N;
   for ( int nc=1; nc<=N; ++nc )
   {
     int res = process_case();
     if ( res >= 0 )
       cout << αCase #α << nc << α: α << res << endl;
     else
       cout << αCase #α << nc << α: THE CAKE IS A LIEα << endl;
   }
   return 0;
 }"
1043,2008,32002,lbackstrom,24444,1,a.c,gcj/2008/32002/lbackstrom/24444/1/extracted/a.c,"#include <stdio.h>
 char visited[6103][6103];
 char marked[6103][6103];
 int dx[4] = {00,1,00,-1};
 int dy[4] = {1,00,-1,00};
 int main(){
     int N,L,i,j,k,x,y,T,d,tot,l;
     char ch;
     char S[10000];
     scanf(α%dα,&N);
     for(i = 00; i<N; i++){
         for(j = 00; j<6103; j++){
             for(k = 00; k<6103; k++){
                 visited[j][k] = 00;
                 marked[j][k] = 00;
             }
         }
         x=y=3051;
         d = 00;
         tot = 00;
         scanf(α%dα,&L);
         for(j = 00; j<L; j++){
             scanf(α%s%dα,S,&T);
             for(k = 00; k<T; k++){
                 for(l = 00;S[l];l++){
                     ch = S[l];
                     if(ch == 'F'){
                         visited[x][y] |= 1<<d;
                         x+=dx[d];
                         y+=dy[d];
                     }else if(ch == 'R'){
                         d = (d+1)%4;
                     }else if(ch == 'L'){
                         d = (d+3)%4;
                     }
                 }
             }
         }
         for(j = 00; j<6102; j++){
             int cnt = 00, gap = 00, last = 00;
             for(k = 00; k<6102; k++){
                 if((visited[j][k]&2) || (visited[j+1][k] & 8)){
                     last = k;
                 }
             }
             for(k = 00; k<last+2; k++){
                 if((visited[j][k]&2) || (visited[j+1][k] & 8)){
                     cnt++;
                     //printf(αA: %d %d %d %dnα,j,k,visited[j][k],visited[j+1][k]);
                     if(cnt % 2 == 1 && cnt != 1){
                         //printf(αA %d %d %dnα,j,gap,cnt);
                         tot+=gap+1;
                     }
                     gap = 00;
                 }else{
                     gap++;
                 }
                 if(cnt > 00 && k < last)
                     marked[j][k] = 1;
             }
         }
         //printf(α%dnα,visited[3003][3002]);
         for(j = 1; j<6102; j++){
             int cnt = 00, gap = 00;
             for(k = 1; k<6102; k++){
                 if((visited[k][j]&1) || (visited[k][j+1] & 4)){
                     //printf(α%d %dnα,k,j);
                     cnt++;
                     if(cnt % 2 == 1 && cnt != 1){
                         //printf(αB %d %d %dnα,j,gap,cnt);
                         tot+=gap;
                     }
                     gap = 00;
                 }
                 if(!marked[k][j])
                     gap++;
             }
         }
         printf(αCase #%d: %dnα,i+1,tot);
         fflush(stdout);
     }
 }"
1844,2008,32002,LayCurse,24445,1,d.c,gcj/2008/32002/LayCurse/24445/1/extracted/d.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 int p = 10007;
 
 int inv[10008];
 
 int pw(int a,int k,int p){
   int r;
   if(k==0) return 1;
   r=pw(a,k/2,p); r=(r*r)%p;
   if(k%2) r=(r*a)%p;
   return r;
 }
 
 int md_get(int a,int b,int p){
   int r=1,i,c=a-b;
   rep(i,a) r= (r*(i+1))%p;
   rep(i,b) r= (r*inv[i+1])%p;
   rep(i,c) r= (r*inv[i+1])%p;
   return r;
 }
 
 int pas_mod(int a,int b,int p){
   int i,j,r,k,m;
 
 //  printf(αcall %d %dα,a,b); puts(αα);
 
   if(a<b || b<0) return 0;
   if(a<p) return md_get(a,b,p);
 
   if(a>=p*p){
     int q=p*p;
     return pas_mod(a%q,b%q,p);
   }
 
   k=a/p; m=b/p;
   i=md_get(k,m,p);
   j=pas_mod(a%p,b%p,p);
   return (i*j)%p;
 }
 
 int main(){
   int i,j,k,l,m,n;
   int res,add;
   int x,y,r,rx[20],ry[20];
   int bx,by,dx,dy;
   int size,count=0;
   int use_x[20],use_y[20],use_size;
 
   rep(i,10008) inv[i]=pw(i,p-2,p);
 
   scanf(α%dα,&size);
   while(size--){
     scanf(α%d%dα,&x,&y); x--; y--;
     scanf(α%dα,&r);
     rep(i,r) {scanf(α%d%dα,rx+i,ry+i); rx[i]--; ry[i]--;}
 
     rep(i,r) REP(j,1,r) if(rx[j-1]>rx[j]){
       k=rx[j-1], rx[j-1]=rx[j], rx[j]=k;
       k=ry[j-1], ry[j-1]=ry[j], ry[j]=k;
     }
 
     res=0;
     rep(k,(1<<r)){
       use_size=0;
       rep(i,r) if(k&(1<<i)) use_x[use_size]=rx[i], use_y[use_size++]=ry[i];
       use_x[use_size] = x; use_y[use_size++]=y;
       
       bx=by=0; add=1;
       rep(i,use_size){
         dx = use_x[i]-bx; dy = use_y[i]-by;
         bx=use_x[i]; by=use_y[i];
 
         m = (dx+dy)/3;
         if(dx+dy != m*3) {add=0; break;}
         
         add *= pas_mod(m,dx-m,p); add %= p;
       }
       if(use_size%2==0) add *= -1;
       res += add;
     }
 
     res %= p;
     if(res<0) res+=p;
 
     printf(αCase #%d: %dnα,++count,res);
   }
 
   return 0;
 }"
2058,2008,32002,RodrigoBurgos,24443,1,b.c,gcj/2008/32002/RodrigoBurgos/24443/1/extracted/b.c,"# include <stdio.h>
 # include <string.h>
 
 char mapa[101][ 101];
 int n, m;
 
 char queue[ 2 ][ 15 * 15 * 16 * 16 * 16 * 16][ 7 ];
 int vis[16][16][16][16][15][15], set;
 
 int dx[ 4 ] = {1, -1, 0, 0};
 int dy[ 4 ] = {0, 0, 1, -1};
 
 int position[ 15 ][ 15 ][ 4 ][2];
 
 void find( char c, int *a, int *b){
   int x, y;
   for(x = 0; x < n; x++)
   for(y = 0; y < m; y++)
     if( mapa[x][y] == c ){
       *a = x;
       *b = y;
       return;    
     }
 }
 
 int sale( int x, int y){
    if( x <0 || x >= n || y < 0 || y >= m || mapa[x][y] == '#') return 1;
    return 0;    
 }
 
 void take( int x, int y, int dir, int *a, int *b){
    //printf(α{%d %d}α, x, y);
    if( x < 0 || y < 0 || x >= n || y >= m) return;
  //  printf(α{-- %d %d, %d %d}α, x, y, x + dx[ dir ], y + dy[ dir]);
    if( sale( x + dx[ dir ], y + dy[ dir])){
   //    printf(α%d %d <-α, x, y );
       *a = position[ x ][ y ][ dir ][ 0 ] = x;
       *b = position[ x ][ y ][ dir ][ 1 ] = y;
       return;
    }
    if( position[ x ][ y ][ dir ][ 0 ] != -1){
     //  printf(α**α);
       *a = position[ x ][ y ][ dir ][ 0 ];
       *b = position[ x ][ y ][ dir ][ 1 ];
       return;
    }
    take( x +dx[ dir ], y + dy[ dir ], dir, a, b);
    position[ x ][ y ][ dir ][ 0 ] = *a;
    position[ x ][ y ][ dir ][ 1 ] = *b;
 }
 
 void insert(int pos, int *nq,  int yx, int yy, int bx, int by, int x, int y, int length){
   if( x < 0 || y < 0 || x >= n || y >= m) return;
   if( mapa[ x ][ y ] == '#') return;
   if( yx == -1 || bx == -1) return;
  // printf(α{%d %d %d %d %d %d %dnα, yx, yy, bx, by,x, y, length);
   if( vis[ yx ][ yy ][ bx ][ by][x ][y] == set) 
     return;
   vis[ yx ][ yy ][ bx ][ by][x ][y] = set;
   
   queue[pos][ *nq ][ 0 ] = yx;
   queue[pos][ *nq ][ 1 ] = yy;
   queue[pos][ *nq ][ 2 ] = bx;
   queue[pos][ *nq ][ 3 ] = by;
   queue[pos][ *nq ][ 4 ] = x;
   queue[pos][ *nq ][ 5 ] = y;
   queue[pos][ *nq ][ 6 ] = length;
   (*nq)++;  
 }
 
 main(){
   int casos, x, a, b, y, dir, nq[2], len, yx, yy, bx, by, pos;
   freopen(αb2.inα,αrα, stdin);
   freopen(αb2.outα,αwα, stdout);
   for( scanf(α%dα, &casos), set = 1 ; set <= casos; set++){
     scanf(α%d %dα, &n, &m);
     for( x = 0; x < n; x++) scanf(α%sα, mapa[x]);
     memset( position , -1, sizeof( position ));
     for( x = 0; x < n; x++)
     for( y = 0; y < m; y++){
       if( mapa[x][y] == '#') continue;
       for( dir = 0; dir < 4; dir++){
         take( x, y, dir, &a, &b);
     //    printf(α[%d %d %d, %d %d]nα, x, y, dir, a, b);
    //     while(1);
       }
     }
   //  while(1);
   //  printf(α****nα);
     find( 'O', &a, &b);
     printf(αCase #%d: α, set);
     memset( nq, 0, sizeof( nq ));
     insert(0, &nq[ 0 ], 16, 16, 16,16, a, b, 0);
     for( len = 0; ; len++){
       if( nq[ len % 2] == 0){
         printf(αTHE CAKE IS A LIEnα);
         break;
       }
       for( pos = 0; pos < nq[ len % 2]; pos++){
         yx = (int)queue[ len % 2][ pos ][ 0 ];
         yy = (int)queue[ len % 2][ pos ][ 1 ];
         bx = (int)queue[ len % 2][ pos ][ 2 ];
         by = (int)queue[ len % 2][ pos ][ 3 ];
         x = (int)queue[ len % 2][ pos ][ 4 ];
         y = (int)queue[ len % 2][ pos ][ 5 ];
         if( mapa[x][y] == 'X'){
           printf(α%dnα, len);
           break;    
         }
       //  if( len  <= 2 && ( x >= 4 && y >= 0 ))
       //  printf(α%d %d | %d %d %d %d %d , %dnα, x, y, yx, yy, bx, by, len , nq[ len % 2]);
         for( dir = 0; dir < 4; dir++){
           insert( (len) % 2 , &nq[ (len) % 2 ], position[x][ y ][ dir ][ 0], position[x][y][ dir ][ 1 ], bx, by, x, y, len);
           insert( (len) % 2 , &nq[ (len) % 2 ], yx, yy, position[x][ y ][ dir ][ 0], position[x][y][ dir ][ 1 ], x, y, len);
         }
         if( x == yx && y == yy && bx != 16 ){
        //   printf(α*α);
           insert( (len + 1) % 2 , &nq[ (len + 1) % 2 ], yx, yy, bx, by, bx, by, len + 1);
         }
         if( x == bx && y == by && yx != 16 ){
          // printf(α.α);
           insert( (len + 1) % 2 , &nq[ (len + 1) % 2 ], yx, yy, bx, by, yx, yy, len + 1);
         }
         for( dir = 0; dir < 4; dir++)
           insert( (len + 1) % 2 , &nq[ (len + 1) % 2 ], yx, yy, bx, by, x + dx[ dir ], y + dy[ dir ], len + 1);
       //  printf(α_----------nα);
       }
       if( pos < nq[ len % 2] ) break;
       nq[ len % 2] = 0; 
     }
   }  
   return 0;       
 }"
3299,2008,32016,tetsuma,24484,1,A.c,gcj/2008/32016/tetsuma/24484/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 int comp1(const long long int *a, const long long int *b){
   return *a - *b;
 }
 int comp2(const long long int *a, const long long int *b){
   return *b - *a;
 }
 
 int main(){
   int i, j, k, test;
   int n;
   long long int ans;
   long long int x[1000], y[1000];
 
   scanf(α%dα,&test);
   for(k=1;k<=test;k++){
     scanf(α%dα,&n);
     for(i=0;i<n;i++)scanf(α%lldα,&x[i]);
     for(i=0;i<n;i++)scanf(α%lldα,&y[i]);
     qsort(x,n,sizeof(long long int),(int (*)(const void*, const void*))comp1);
     qsort(y,n,sizeof(long long int),(int (*)(const void*, const void*))comp2);
     ans=0;
     for(i=0;i<n;i++)ans+=x[i]*y[i];
     printf(αCase #%d: α,k);
     printf(α%lldnα,ans);
   }
 }"
3363,2008,32016,ujjwal,24484,1,one.c,gcj/2008/32016/ujjwal/24484/1/extracted/one.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 
 void swap(long long int *x, long long int i, long long int j) {
     long long int t = x[i];
     x[i] = x[j];
     x[j] = t;
 }
 
 int randint(long long int l, long long int u) {
     return rand()%(u-l+1)+l;
 }
 
 void quicksort1(long long int *x, long long int l, long long int u) {
     long long int i, m;
     if (l >= u) return;
     swap(x, l, randint(l, u));
     m = l;
     for (i = l+1; i <= u; i++)
         if (x[i] < x[l])
             swap(x, ++m, i);
     swap(x, l, m);
     quicksort1(x, l, m-1);
     quicksort1(x, m+1, u);
 }
 
 void quicksort2(long long int *x, long long int l, long long int u) {
     long long int i, m;
     if (l >= u) return;
     swap(x, l, randint(l, u));
     m = l;
     for (i = l+1; i <= u; i++)
         if (x[i] > x[l])
             swap(x, ++m, i);
     swap(x, l, m);
     quicksort2(x, l, m-1);
     quicksort2(x, m+1, u);
 }
 
 int main()
 {
 	long long int i,j,t,n;
 	long long int sum;
     long long int v1[1000],v2[1000];
     srand(time(NULL));
     
     scanf(α %lldα, &t);
     
     for(i=0;i<t;i++)
     {
 		sum = 0;
 		
 	    scanf(α %lldα, &n);
 	    
 	    for(j=0;j<n;j++)
 	    	scanf(α %lldα, &v1[j]);
 	    	
 	    for(j=0;j<n;j++)
 	    	scanf(α %lldα, &v2[j]);
     
 	    quicksort1(v1, 0, n-1);
 		quicksort2(v2, 0, n-1);
 /*
 		sort1(v1, n);
 		sort2(v2, n);
 		
 		for(j=0;j<n;j++)
 		{
 	        prlong intf(α%d α, v1[j]);
 	    }
 	    
 	    prlong intf(αnα);
 	    
 	    for(j=0;j<n;j++)
 		{
 	        prlong intf(α%d α, v2[j]);
 	    }
 */
 
 	    for(j=0;j<n;j++)
 		{
 	        sum += v1[j]*v2[j];
 	    }
 	    
 	    printf(αCase #%lld: %lldnα, i+1, sum);
 	}
 	
     scanf(α %lldα, &n);
     return 0;
 }"
3490,2008,32016,chin33z,24484,1,test.c,gcj/2008/32016/chin33z/24484/1/extracted/test.c,"//#define NDEBUG   //disable assert(),must put befor include<assert.h>
 
 //if all the inputs are fix length and tpye known ---> cin
 //if there exist variant inputs length ----> getline(cin,tmp_str) or getline() after each cin
 
 #include α../../../lib/mylib.cα
 
 int main (int argc, char* argv[]){
 	int num;
 	string tmp_str;
 	int vcord;
 	vector<long> v1,v2;
 	long res;
 	//redirect (in/out)put stream
 //	freopen(αfile.inα,αrtα,stdin);
 //	freopen(αfile.outα,αwtα,stdout);
 
 	//get cases number
 	cin>>num;		
 	//when fixed format & fixed inputs amount, use this
 	
 	getline(cin,tmp_str);	
 	//must exist, for the next use of getline
 
 	//solve for each cases
 	for(int i=1; i<=num; i++){
 		cin >> vcord;
 		getline(cin,tmp_str);
 
 		getline(cin,tmp_str);
 		StringSplit2Long(tmp_str,α α,v1);
 
 		getline(cin,tmp_str);
 		StringSplit2Long(tmp_str,α α,v2);
 
 		sort(v1.begin(),v1.end());
 		sort(v2.begin(),v2.end());
 		reverse(v2.begin(),v2.end());
 		
 		res=0;
 		Rep(j,vcord)
 			res += v1[j]*v2[j];
 
 		cout<<αCase #α<<i<<α: α<<res<<endl;
 	}
 
 
 	return 0;
 }"
3587,2008,32016,sao3,24484,1,A.c,gcj/2008/32016/sao3/24484/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int cs;
 long long ans;
 long long v1[1000], v2[1000];
 
 int cmp(const void *a, const void *b){
 	return *(long long  *)a - *(long long  *)b;
 }
 
 void go(){
 	int n;
 	int i;
 	scanf(α%dα, &n);
 	for(i = 0; i < n; i++){
 		scanf(α%I64dα, &v1[i]);
 	}
 	for(i = 0; i < n; i++){
 		scanf(α%I64dα, &v2[i]);
 	}
 	qsort(v1, n, sizeof(long long), cmp);
 	qsort(v2, n, sizeof(long long), cmp);
 	ans = 0;
 	for(i = 0; i < n; i++){
 		ans += v1[i] * v2[n - i - 1];
 	}
 }
 
 int main(){
 	int css;
 	freopen(αA.inα, αrα, stdin);
 	freopen(αA.txtα, αwα, stdout);
 	scanf(α%dα, &cs);
 	for(css = 1; css <= cs; css++){
 		go();
 		printf(αCase #%d: %I64dnα, css, ans);
 	}
 	return 0;
 }"
3741,2008,32016,Appleway,24484,1,a.c,gcj/2008/32016/Appleway/24484/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int cmp_ele1(const void *a, const void *b){
     int t1 = *(int *)a;
     int t2 = *(int *)b;
     if(t1 < t2)
 	return -1;
     if(t1 == t2)
 	return 0;
     if(t1 > t2)
 	return 1;
 }
 
 int cmp_ele2(const void *a, const void *b){
     int t1 = *(int *)a;
     int t2 = *(int *)b;
     if(t1 > t2)
 	return -1;
     if(t1 == t2)
 	return 0;
     if(t1 < t2)
 	return 1;
 }
 /*
 int cmp_stru(const void *a, const void *b){
     t1 = *( *)a;
     t2 = *( *)b;
     
 }
 */
 void count(void){
     int n, i;
     long long x[1000];
     long long y[1000];
     long long ans = 0;
     scanf(α%dα, &n);
     for(i = 0 ; i < n ; i++){
 	scanf(α%lldα, &x[i]);
     }
     for(i = 0 ; i < n ; i++){
 	scanf(α%lldα, &y[i]);
     }
     qsort(x, n, sizeof(x[0]), cmp_ele2);
     qsort(y, n, sizeof(y[0]), cmp_ele1);
     for(i = 0 ; i < n ; i++){
 	    
 
 	ans += x[i]*y[i];
     }
     printf(α %lldnα, ans);
 }
 
 int main(void){
     int N;
     int i;
 
     scanf(α%dα, &N);
     for(i = 0 ; i < N ; i++){
 	printf(αCase #%d:α, i+1);
 	count();
     }
     return 0;
 }"
3874,2008,32016,mart0258,24484,1,a.c,gcj/2008/32016/mart0258/24484/1/extracted/a.c,"#include <stdio.h>
 
 int n;
 long long x[1000];
 long long y[1000];
 
 int cmp(const void*a, const void *b)
 {
 	const long long *c = a;
 	const long long *d = b;
 	return *c - *d;
 }
 
 int cmp2(const void*a, const void *b)
 {
 	const long long *c = a;
 	const long long *d = b;
 	return *d - *c;
 }
 
 
 
 long long solve()
 {
 	long long ret=0;
 	int i;
 	qsort(x, n, sizeof(long long), cmp);
 	qsort(y, n, sizeof(long long), cmp2);
 
 
 	for (i=0; i<n; i++)
 	{
 		ret+=x[i]*y[i];
 	}
 
 	return ret;
 }
 
 int main (void)
 {
 	int C;
 	int i;
 
 	int tc;
 	long long res;
 	scanf (α%dα, &C);
 
 	for (tc=1; tc<=C; tc++)
 	{
 		scanf (α%dα, &n);
 
 		for (i=0; i<n; i++)
 		{
 			scanf (α%lldα, x+i);
 		}
 		for (i=0; i<n; i++)
 		{
 			scanf (α%lldα, y+i);
 		}
 
 		res=solve();
 		printf (αCase #%d: %lldnα, tc, res);
 
 	}
 
 }"
3982,2008,32016,Visesh,24484,1,scalar.c,gcj/2008/32016/Visesh/24484/1/extracted/scalar.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int compare1(const void* a, const void* b ) {
   int* arg1 = (int*) a;
   int* arg2 = (int*) b;
   if( *arg1 < *arg2 ) return -1;
   else if( *arg1 == *arg2 ) return 0;
   else return 1;
 }        
 
 int compare2(const void* a, const void* b ) {
   int* arg1 = (int*) a;
   int* arg2 = (int*) b;
   if( *arg1 < *arg2 ) return 1;
   else if( *arg1 == *arg2 ) return 0;
   else return -1;
 }
 
 
 int main () {
   int t, n, a[1000], b[1000], i, j;
   long long ans = 0;
   j = 1;
   scanf (α%dα, &t);
   while (t --) {
     scanf(α%dα, &n);
     ans = 0;
     for (i = 0; i < n; i ++) {
       scanf(α%dα, &a[i]);
     }
     for (i = 0; i < n; i ++) {
       scanf(α%dα, &b[i]);
     }
     qsort(a, n, sizeof(int), compare1);
     qsort(b, n, sizeof(int), compare2);
     for (i = 0; i < n; i ++) {
       ans += (long long)(a[i])*(long long)(b[i]);
     }
     printf(αCase #%d: %lldnα, j, ans);
     j ++;
   }
   return 0;
 }"
4036,2008,32016,schultz,24482,1,a.c,gcj/2008/32016/schultz/24482/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 typedef unsigned nat;
 typedef nat bool;
 
 #define false 0
 #define true 1
 
 typedef unsigned char nat8;
 typedef nat8 bool8;
 typedef unsigned short nat16;
 
 typedef bool8 matrix_t;
 typedef bool8 malted_t;
 typedef bool8 kill_t;
 typedef nat16 wm_t;
 
 #define M_MAX 2048
 #define N_MAX 2048
 
 #define NONE ((wm_t)(-1))
 
 nat m, n;
 matrix_t A[M_MAX][N_MAX];
 wm_t WM[M_MAX];
 malted_t MALTED[N_MAX];
 kill_t KR[M_MAX], KC[N_MAX];
 
 bool batch();
 
 int main() {
 	nat tc, cs;
 	nat i, j, k;
 	nat x, y;
 	nat t;
 
 	scanf(α%uα, &tc);
 	for (cs = 0; cs != tc; ++cs) {
 		scanf(α%u%uα, &n, &m);
 
 		for (i = 0; i != m; ++i) {
 			memset(A[i], 0, n*sizeof(matrix_t));
 			scanf(α%uα, &t);
 			WM[i] = NONE;
 			for (k = 0; k != t; ++k) {
 				scanf(α%u%uα, &x, &y);
 				--x;
 				if (y)
 					WM[i] = x;
 				else
 					A[i][x] = true;
 			}
 		}
 
 		memset(KR, 0, m*sizeof(kill_t));
 		memset(KC, 0, n*sizeof(kill_t));
 		memset(MALTED, 0, n*sizeof(malted_t));
 
 		printf(αCase #%u:α, cs+1);
 		if (batch()) {
 			for (i = 0; i != n; ++i)
 				printf(α %cα, MALTED[i] ? '1' : '0');
 			putchar('n');
 		}
 		else
 			puts(α IMPOSSIBLEα);
 	}
 
 	return 0;
 }
 
 bool line_is_null(nat);
 
 bool batch() {
 	nat i;
 	nat nl;
 	nat malte;
 
 	for (i = 0; i != m; ++i)
 		if (!KR[i] && line_is_null(i)) {
 			nl = i;
 			break;
 		}
 	if (i == m)
 		return true;
 
 	if (WM[nl] == NONE)
 		return false;
 
 	malte = WM[nl];
 	MALTED[malte] = true;
 
 	for (i = 0; i != m; ++i)
 		if (!KR[i] && WM[i] == malte)
 			KR[i] = true;
 
 	KC[malte] = true;
 
 	return batch();
 }
 
 bool line_is_null(nat i) {
 	nat j;
 
 	for (j = 0; j != n; ++j)
 		if (!KC[j] && A[i][j] != 0)
 			return false;
 	return true;
 }"
4349,2008,32016,bageerath,24484,1,a.c,gcj/2008/32016/bageerath/24484/1/extracted/a.c,"#include <stdio.h>
 #include <limits.h>
 
 #define swap(T,a,b) { T t;t=a;a=b;b=t; }
 
 void 
 bblSort ( long long *a, long long cnt )
 {
     long long i, j;
     for ( i = 0; i < cnt; i++ )
         for ( j = i + 1; j < cnt; j++ )
             if ( a[i] > a[j] )
                 swap(long long, a[i], a[j]);
 }
 
 long long  
 minMult( long long *x, long long *y, long long n )
 {
     long long i, p1 = 0;
     for ( i = 0; i < n; i++ ) 
         p1 = p1 + x[i] * y [n - i - 1]; 
     
     return p1;
 }
 
 long long minMultRec( long long *x, long long *y, long long n )
 {
     long long i, j, p;
     long long sol =  ~(((long long)1) << 63);
     
     if ( n == 1 )
         return x[0]*y[0];
 
     for ( i = 0; i < n; i++ ) {
         for ( j = 0; j < n; j++ ) {
             swap(long long, x[0], x[i]);
             swap(long long, y[0], y[j]);
             p = x[0] * y[0] + minMultRec( x+1, y+1, n-1 );
             swap(long long, x[0], x[i]);
             swap(long long, y[0], y[j]);
             if ( p < sol )
                 sol = p;
         }
     }
     return sol;
 }
 
 #define MAX_IP 1000
 
 main()
 {
     long long T, t, n, i, p, x[MAX_IP], y[MAX_IP];
 
     scanf(α%lldα, &T);
     for ( t = 0; t < T; t++ ) {
         scanf(α%lldα, &n);
         /* X */
         for ( i = 0; i < n; i++ ) {
             scanf(α%lldα, &x[i]);
         }
         /* Y */
         for ( i = 0; i < n; i++ ) {
             scanf(α%lldα, &y[i]);
         }
 #if 1
         bblSort(x, n);
         bblSort(y, n);
 
 #if 0
          /* X */
         printf(αnα);
         for ( i = 0; i < n; i++ ) {
             printf(α%lld α, x[i]);
         }
         /* Y */
         printf(αnα);
         for ( i = 0; i < n; i++ ) {
             printf(α%lld α, y[i]);
         }
         printf(αnα);
 #endif
         p = minMult(x,y,n);
 #else
         p = minMultRec(x,y,n);
 #endif
 
         printf(αCase #%lld: %lldnα, t+1, p);
     }
 }"
4352,2008,32016,lv50,24484,1,mini.c,gcj/2008/32016/lv50/24484/1/extracted/mini.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int cmp(const void * a,const void * b)
 {
 	return (*(int *)a)-(*(int *)b);
 }
 int cmp2(const void *a , const void *b)
 {
 	return (*(int*)b)-(*(int *)a);
 }
 
 int main()
 {
 	__int64 result;
 	int		i,j,t,n;
 	__int64		x[1000],y[1000];
 
 	freopen(αA-large.inα,αrα,stdin);
 	freopen(αout.txtα,αwα,stdout);
 	scanf(α%dα,&t);
 	for(i=0;i<t;i++)
 	{
 		scanf(α%dα,&n);
 		for(j=0;j<n;j++)
 		{
 			scanf(α%I64dα,&x[j]);
 		}
 		qsort(x,n,sizeof(__int64),cmp);
 /*		for(j=0;j<n;j++)
 		{
 			printf(α%I64d α,x[j]);
 		}
 		printf(αnα);*/
 		for(j=0;j<n;j++)
 		{
 			scanf(α%I64dα,&y[j]);
 		}
 		qsort(y,n,sizeof(__int64),cmp2);
 /*		for(j=0;j<n;j++)
 		{
 			printf(α%I64d α,y[j]);
 		}
 		printf(αnα);*/
 		result=0;
 		for(j=0;j<n;j++)
 		{
 			result+=x[j]*y[j];
 		}
 		printf(αCase #%d: %I64dnα,i+1,result);
 	}
 }"
4699,2008,32016,Chard,24484,1,a.c,gcj/2008/32016/Chard/24484/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 typedef struct QueEntryStruct
 {
     struct QueEntryStruct *NextPtr;
     struct QueEntryStruct *PrevPtr;
     double Data;
 } QUE_ENTRY_STRUCT;
 
 typedef struct QueCtrlStruct
 {
     QUE_ENTRY_STRUCT *NextPtr;
     QUE_ENTRY_STRUCT *PrevPtr;
     unsigned long Counter;
 } QUE_CTRL_STRUCT;
 
 QUE_CTRL_STRUCT List;
 QUE_ENTRY_STRUCT Entry[100];
 
 void que_init (QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueCtrlPtr->NextPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueCtrlPtr->PrevPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueCtrlPtr->Counter = 0;
 }
 
 void que_insert_before (QUE_ENTRY_STRUCT *QueEntryPtr,
                         QUE_ENTRY_STRUCT *QueMemberPtr,
                         QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr = QueMemberPtr;
     QueEntryPtr->PrevPtr = QueMemberPtr->PrevPtr;
     QueMemberPtr->PrevPtr->NextPtr = QueEntryPtr;
     QueMemberPtr->PrevPtr = QueEntryPtr;
     QueCtrlPtr->Counter++;
 }
 
 void que_insert_at_tail (QUE_ENTRY_STRUCT *QueEntryPtr,
                          QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueEntryPtr->PrevPtr = QueCtrlPtr->PrevPtr;
     QueCtrlPtr->PrevPtr->NextPtr = QueEntryPtr;
     QueCtrlPtr->PrevPtr = QueEntryPtr;
     QueCtrlPtr->Counter++;
 }
 
 void que_remove_from_middle (QUE_ENTRY_STRUCT *QueEntryPtr,
                              QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr->PrevPtr = QueEntryPtr->PrevPtr;
     QueEntryPtr->PrevPtr->NextPtr = QueEntryPtr->NextPtr;
     QueCtrlPtr->Counter--;
 }
 
 QUE_ENTRY_STRUCT *que_get_head_entry (QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QUE_ENTRY_STRUCT *QueEntryPtr;
     QueEntryPtr = QueCtrlPtr->NextPtr;
     que_remove_from_middle(QueEntryPtr, QueCtrlPtr);
     return QueEntryPtr;
 }
 
 void que_insert_sorted_1 (QUE_ENTRY_STRUCT *QueEntryPtr,
                           QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QUE_ENTRY_STRUCT *QueMemberPtr;
 
     QueMemberPtr = QueCtrlPtr->NextPtr;
     
     while(QueMemberPtr != (QUE_ENTRY_STRUCT *)QueCtrlPtr)
     {
         if (QueMemberPtr->Data >= QueEntryPtr->Data)
         {
             que_insert_before(QueEntryPtr,
                               QueMemberPtr,
                               QueCtrlPtr);
             return;
         }
         
         QueMemberPtr = QueMemberPtr->NextPtr;
     }
 
     que_insert_before(QueEntryPtr,
                       QueMemberPtr,
                       QueCtrlPtr);
 }
 
 void que_insert_sorted_2 (QUE_ENTRY_STRUCT *QueEntryPtr,
                           QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QUE_ENTRY_STRUCT *QueMemberPtr;
 
     QueMemberPtr = QueCtrlPtr->NextPtr;
     
     while(QueMemberPtr != (QUE_ENTRY_STRUCT *)QueCtrlPtr)
     {
         if (QueMemberPtr->Data <= QueEntryPtr->Data)
         {
             que_insert_before(QueEntryPtr,
                               QueMemberPtr,
                               QueCtrlPtr);
             return;
         }
         
         QueMemberPtr = QueMemberPtr->NextPtr;
     }
 
     que_insert_before(QueEntryPtr,
                       QueMemberPtr,
                       QueCtrlPtr);
 }
 
 
 
 QUE_ENTRY_STRUCT Xn[802];
 QUE_ENTRY_STRUCT Yn[802];
 QUE_CTRL_STRUCT XList;
 QUE_CTRL_STRUCT YList;
 
 void main (void)
 {
     // X - Case Idx
     // T - Number of Case
     int X, T, n, N;
     double Z;
     QUE_ENTRY_STRUCT *XPtr;
     QUE_ENTRY_STRUCT *YPtr;
 
 
     scanf(α%iα, &T);
 
     for (X=1; X<=T; X++)
     {
         que_init(&XList);
         que_init(&YList);
         
         scanf(α%iα, &N);
 
         for (n=1; n<=N; n++)
         {
             scanf(α%lfα, &Xn[n].Data);
             que_insert_sorted_1(&Xn[n], &XList);
         }
 
         for (n=1; n<=N; n++)
         {
 
             scanf(α%lfα, &Yn[n].Data);
             que_insert_sorted_2(&Yn[n], &YList);
         }
         
         Z = 0;
         for (n=1; n<=N; n++)
         {
             XPtr = que_get_head_entry(&XList);
             YPtr = que_get_head_entry(&YList);
             Z = Z + (XPtr->Data * YPtr->Data);
         }
 
         printf(αCase #%li: %.0lfnα, X, Z);   
     }
 }"
4953,2008,32016,WhiteShadow,24484,1,a.c,gcj/2008/32016/WhiteShadow/24484/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX 801
 
 int n;
 long long v1[MAX], v2[MAX];
 long long sum;
 
 int compare(const void *a, const void *b) {
   long long *n1 = (long long *)a;
   long long *n2 = (long long *)b;
   if (*n1 < *n2) return -1;
   if (*n1 > *n2) return 1;
   return 0;
 }
 
 int main() {
   int i, j, k, ncases;
 
   scanf(α%dα,&ncases);
   for (i=1; i<=ncases; i++) {
     scanf(α%dα,&n);
     for (j=0; j<n; j++) scanf(α%lldα,&v1[j]);
     for (j=0; j<n; j++) scanf(α%lldα,&v2[j]);
 
     qsort(v1, n, sizeof(long long), compare);
     qsort(v2, n, sizeof(long long), compare);
     
     sum = 0;
     
     for (j=0, k=n-1 ; j<n; j++, k--) {
       sum += v1[j]*v2[k];
     }
 
     printf(αCase #%d: %lldnα,i, sum);
   }
 
   return 0;
 }"
5132,2008,32016,hnaves,24483,1,numbers.c,gcj/2008/32016/hnaves/24483/1/extracted/numbers.c,"#include <stdio.h>
 
 static int T;
 static int vals[128];
 static int resp[128];
 static int test[128];
 static int invtest[128];
 
 void order (void)
 {
   int i, j, temp;
   for (i = T-1; i >= 0; i--)
     for (j = 0; j < i; j++) {
       if (vals[j] > vals[j + 1]) {
         temp = vals[j];
         vals[j] = vals[j + 1];
         vals[j + 1] = temp;
 
         temp = test[j];
         test[j] = test[j + 1];
         test[j + 1] = temp;
 
         invtest[test[j]] = j;
         invtest[test[j+1]] = j+1;
       }
     }
 }
 
 void calcula (void) {
   register int a = 2, b = 6, c;
   int i, j = 1;
   for (i = 0; i < T; i++) {
     while (j != vals[i]) {
       c = a;
       a = b;
       b = 6 * a - 4 * c + 4000;
       b %= 1000;
       j++;
     }
     resp[i] = b;
   }
 }
 
 int main (int argc, char **argv)
 {
   int t;
   scanf (α%dα, &T);
   for (t = 1; t <= T; t++) {
     scanf (α%dα, &vals[t-1]);
     test[t-1] = t-1;
     invtest[t - 1] = t-1;
   }
   order ();
   calcula ();
   for (t = 1; t <= T; t++) {
     int v = resp[invtest[t-1]];
     if (v == 0) v = 999;
     else v--;
     printf (αCase #%d: %03dnα, t, v);
   }
 
   return 0;
 }"
5134,2008,32016,hnaves,24482,1,milkshake.c,gcj/2008/32016/hnaves/24482/1/extracted/milkshake.c,"#include <stdio.h>
 
 static int N, M;
 static int malted[2048];
 static int sol[2048];
 static int mark[2048];
 static int pref[2048][2048];
 
 
 int resolve (void)
 {
   int i, j, marcou = 0;
 
   for(i = 0; i < M; i++) mark[i] = 0;
   for(j = 0; j < N; j++) sol[j] = 0;
 
   do {
     marcou = 0;
     for(i = 0; i < M; i++) {
       if (mark[i]) continue;
       for(j = 0; j < N; j++) {
         if (pref[i][j] && !sol[j]) break;
       }
       if (j < N) continue;
       if (malted[i] != -1) {
         sol[malted[i]] = 1;
         mark[i] = 1;
         marcou = 1;
         break;
       } else return 0;
     }
   } while (marcou);
   return 1;
 }
 
 
 int main (void)
 {
 
   int c, i, j, T, C, resp;
   scanf (α%dα, &C);
 
   for (c = 1; c <= C; c++) {
 
     scanf (α%dα, &N);
     scanf (α%dα, &M);
 
     for(i = 0; i < M; i++) malted[i] = -1;
     for (i = 0; i < M; i++)
       for(j = 0; j < N; j++)
         pref[i][j] = 0;
 
     for (i = 0 ; i < M; i++) {
       scanf (α%dα, &T);
       while (T--) {
         int x, y;
         scanf (α%dα, &x);
         scanf (α%dα, &y);
         if (y == 1) malted[i] = x - 1;
         else pref[i][x-1] = 1;
       }
     }
 
     resp = resolve ();
     printf (αCase #%d: α, c);
     if (!resp) printf (αIMPOSSIBLEnα);
     else {
       for (j = 0; j < N; j++) {
         if (j != 0) printf (α α);
         printf (α%dα, sol[j]);
       }
       printf (αnα);
     }
   }
 
   return 0;
 }"
5136,2008,32016,hnaves,24484,1,scalar.c,gcj/2008/32016/hnaves/24484/1/extracted/scalar.c,"#include <stdio.h>
 #include <stdlib.h>
 
 static int x[1024];
 static int y[1024];
 
 int cmp_int (const void *ptr1, const void *ptr2)
 {
   int *i1 = (int *) ptr1;
   int *i2 = (int *) ptr2;
   return (*i1) - (*i2);
 }
 
 int main (int argc, char **argv)
 {
   int T, n, test;
   int i;
   scanf (α%dα, &T);
   for (test = 1; test <= T; test++) {
     long long result;
     scanf (α%dα, &n);
     for (i = 0; i < n; i++)
       scanf (α%dα, &x[i]);
     for (i = 0; i < n; i++)
       scanf (α%dα, &y[i]);
     qsort (x, n, sizeof (int), &cmp_int);
     qsort (y, n, sizeof (int), &cmp_int);
     result = 0;
     for (i = 0; i < n; i++) {
       long long p = x[i];
       p *= (long long) y[n - 1 - i];
       result += p;
     }
     printf (αCase #%d: %lldnα, test, result);
   }
 
   return 0;
 }"
5300,2008,32016,lbackstrom,24482,1,b.c,gcj/2008/32016/lbackstrom/24482/1/extracted/b.c,"int like[2100][2100];
 int cnt[2100];
 int happy[2100];
 int malted[2100];
 int main(){
     int C,N, M, T, X, Y;
     int i, j, k, changed, unhappy;
     scanf(α%dα,&C);
     for(i = 1; i<=C; i++){
         for(j = 0; j<2100; j++){
             malted[j] = 0;
             cnt[j] = 0;
         }
         scanf(α%d%dα,&N,&M);
         for(j = 0; j<M; j++){
             scanf(α%dα,&T);
             cnt[j] = T;
             for(k = 0; k<T; k++){
                 scanf(α%d%dα,&X,&Y);
                 like[j][k] = X * (Y*2-1);//positive for malted
             }
         }
         changed = 1;
         while(changed){
             unhappy = 0;
             changed = 0;
             for(j = 0; j<M; j++){
                 happy[j] = 0;
             }
             for(j = 0; j<M; j++){
                 for(k = 0; k<cnt[j]; k++){
                     if(like[j][k] > 0 && malted[like[j][k]]){
                         happy[j] = 1;
                     }else if(like[j][k] < 0 && !malted[-like[j][k]]){
                         happy[j] = 1;
                     }
                 }
             }
             for(j = 0; j<M; j++){
                 if(!happy[j]){
                     unhappy ++;
                     for(k = 0; k<cnt[j]; k ++){
                         if(like[j][k] > 0 && !malted[like[j][k]]){
                             malted[like[j][k]] = 1;
                             changed = 1;
                         }
                     }
                 }
             }
         }
         if(unhappy)
             printf(αCase #%d: IMPOSSIBLEnα,i);
         else{
             printf(αCase #%d:α,i);
             for(j = 1; j<=N; j++){
                 printf(α %dα,malted[j]);
             }
             printf(αnα);
         }
     }
 }"
6000,2008,32016,Baiger,24484,1,A.c,gcj/2008/32016/Baiger/24484/1/extracted/A.c,"#include <stdio.h>
 
 #define MAXLEN 800
 
 void qsort_x(int a[], int p, int r)
 {
      int i = p, j = r, key = a[(p+r) >> 1];
      do {
 	  while (a[i] < key) i++;
 	  while (a[j] > key) j--;
 	  if (i <= j) {
 	       int tmp = a[i];
 	       a[i] = a[j];
 	       a[j] = tmp;
 	       i++; j--;
 	  }
      } while (i <= j);
      if (p < j) qsort_x(a, p, j);
      if (i < r) qsort_x(a, i, r);
 }
 
 void qsort_y(int a[], int p, int r)
 {
      int i = p, j = r, key = a[(p+r) >> 1];
      do {
 	  while (a[i] > key) i++;
 	  while (a[j] < key) j--;
 	  if (i <= j) {
 	       int tmp = a[i];
 	       a[i] = a[j];
 	       a[j] = tmp;
 	       i++; j--;
 	  }
      } while (i <= j);
      if (p < j) qsort_y(a, p, j);
      if (i < r) qsort_y(a, i, r);
 }
 
 int main()
 {
      int t, i;
      scanf(α%dα, &t);
      for (i = 1; i <= t; i++) {
 	  int n, j, x[MAXLEN], y[MAXLEN];
 	  scanf(α%dα, &n);
 	  for (j = 0; j < n; j++)
 	       scanf(α%dα, &x[j]);
 	  for (j = 0; j < n; j++)
 	       scanf(α%dα, &y[j]);
 	  qsort_x(x, 0, n-1);
 	  qsort_y(y, 0, n-1);
 	  long long min = 0;
 	  for (j = 0; j < n; j++)
 	       min += (long long)x[j]*(long long)y[j];
 	  printf(αCase #%d: %lldnα, i, min);
      }
 
      return 0;
 }"
6357,2008,32016,andersk,24483,1,numbers.c,gcj/2008/32016/andersk/24483/1/extracted/numbers.c,"#include <stdio.h>
 
 int mod(int x, int m) { x %= m; if (x < 0) x += m; return x; }
 
 int v[1000][1000], w[1000001];
 
 int main()
 {
     int t;
 
     /*
       (3 + r5)^n = a + b r5
       (3 - r5)^n = a - b r5
       (3 + r5)^n + (3 - r5)^n = 2a
       (3 + r5)^(n+1) = (3a + 5b) + (3b + a)r5
     */
 
     int a = 1, b = 0, c = 0;
     do {
 	v[a][b] = c;
 	w[c++] = mod(2*a - 1, 1000);
 	int aa = mod(3*a + 5*b, 1000), bb = mod(a + 3*b, 1000);
 	a = aa; b = bb;
     } while (!v[a][b]);
     int d = v[a][b];
 
     scanf(α%dnα, &t);
     for (int x = 1; x <= t; ++x)
     {
 	int n;
 	scanf(α%dnα, &n);
 	int o = (n < d ? w[n] : w[d + mod(n - d, c - d)]);
 	printf(αCase #%d: %03dnα, x, o);
     }
     return 0;
 }"
6429,2008,32016,along,24484,1,a.c,gcj/2008/32016/along/24484/1/extracted/a.c,"#include <stdio.h>
 #include <vector>
 #include <iostream>
 using namespace std;
 
 int main()
 {
 	int ca,cc;
 	int i,j,k;
 	cin >> ca;
 	for(cc=1; cc<=ca; cc++)
 	{
 		int n;
 		vector<long long> va,vb;
 		long long t;
 		cin >> n;
 		for(i=0; i<n; i++)
 		{
 			cin >> t;
 			va.push_back(t);
 		}
 		for(i=0; i<n; i++)
 		{
 			cin >> t;
 			vb.push_back(-t);
 		}
 		sort(va.begin(), va.end());
 		sort(vb.begin(), vb.end());
 		long long r = 0;
 		for(i=0; i<n; i++)
 		{
 //			fprintf(stderr, α%lldnα, r);
 			r += va[i] * vb[i];
 		}
 		printf(αCase #%d: %lldnα, cc, -r);
 	}
 }"
6773,2008,32016,Maryann,24483,1,c.c,gcj/2008/32016/Maryann/24483/1/extracted/c.c,"#define ll long long
 typedef struct matrix{ll a[2][2];}mat;
 mat a,b;
 int n,x,ans,mod;
 void mul(mat a,mat b,mat*c)
 {
     int i,j,k;
     memset((*c).a,0,sizeof((*c).a));
     for(i=0; i<2; i++)
     for(j=0; j<2; j++)
     {
         for(k=0; k<2; k++)
         (*c).a[i][j]+=a.a[i][k]*b.a[k][j];
         (*c).a[i][j]%=mod;
     }
 }
 int Pow(int x,int y)
 {
     int ret=1;
     while(y)
     {
         if(y&1)
         ret=ret*x%mod;
         x=x*x%mod;
         y/=2;
     }
     return ret;
 }
 main()
 {
     int _,t;
     scanf(α%dα,&_);
     for(t=1; t<=_; t++)
     {
         scanf(α%dα,&x);
         n=x;
         mod=1000;
         a.a[0][0]=0,a.a[0][1]=a.a[1][0]=a.a[1][1]=1;
         b.a[0][0]=b.a[1][1]=1,b.a[0][1]=b.a[1][0]=0;
         for(x--;x;x/=2)
         {
             if(x&1)
             mul(b,a,&b);
             mul(a,a,&a);
         }
         ans=(b.a[0][0]+b.a[1][0])%mod;
         ans=(ans*ans*5)%mod;
         if(n&1)
         ans-=2;
         else
         ans+=2;
         ans*=Pow(2,n);
         printf(αCase #%d: %03dnα,t,(ans+mod-1)%mod);
     }
     return 0;
 }"
7043,2008,32016,LayCurse,24484,1,a.c,gcj/2008/32016/LayCurse/24484/1/extracted/a.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 #define ll long long
 
 void llSort(ll d[],int s){
   int i,j; ll key,t;
   if(s<=1) return;
 
   key=(d[0]+d[s-1])/2; i=-1; j=s;
   for(;;){
     while(d[++i] < key); while(d[--j] > key);
     if(i>=j) break; t=d[i]; d[i]=d[j]; d[j]=t;
   }
   llSort(d,i); llSort(d+j+1,s-j-1);
 }
 
 int main(){
   int i,j,k,l,m,n;
   ll a[1000],b[1000];
   ll res;
 
   int size,count=0;
   scanf(α%dα,&size);
   while(size--){
     scanf(α%dα,&n);
     rep(i,n) scanf(α%lldα,a+i);
     rep(i,n) scanf(α%lldα,b+i);
 
     llSort(a,n); llSort(b,n);
     res=0;
     rep(i,n) res += a[i]*b[n-1-i];
     
     printf(αCase #%d: %lldnα,++count,res);
   }
   
   return 0;
 }"
7415,2008,32016,RodrigoBurgos,24484,1,a.c,gcj/2008/32016/RodrigoBurgos/24484/1/extracted/a.c,"# include <stdio.h>
 # include <string.h>
 
 int list[ 1001 ], list2[1001];
 
 int compare( int *a, int *b){
   return *a - *b;    
 }
 
 main(){
   int x, y, n, casos, set = 1, a, b;
   long long res;
   freopen(αa2.inα,αrα, stdin);
   freopen(αa.outα,αwα, stdout);
   for( scanf(α%dα, &casos) ;casos--; ){
     
     scanf(α%dα, &n);
     for(x = 0; x < n; x++)
      scanf(α%dα, &list[ x ]);
     qsort( list, n, sizeof( int ), compare);
     for(x = 0; x < n; x++)
      scanf(α%dα, &list2[ x ]);
     qsort( list2, n, sizeof( int), compare);
     a = 0; b = n -1;
     res = 0;
     
     for( x = 0; x < n; x++ )
       res += (long long)list[ x ] * (long long)list2[ n - x - 1];
     printf(αCase #%d: %I64dnα, set++, res);
   }
   return 0;       
 }"
7752,2008,32016,timerover,24484,1,a.c,gcj/2008/32016/timerover/24484/1/extracted/a.c,"#include <stdio.h>
 
 int compare(const void *a, const void *b) {
     double *p, *q;
     p = (double *)a;
     q = (double *)b;
     if(*p > *q)
         return 1;
     else if(*p == *q)
         return 0;
     else
         return -1;
 }
 
 int compare2(const void *a, const void *b) {
     double *p, *q;
     p = (double *)a;
     q = (double *)b;
     if(*p < *q)
         return 1;
     else if(*p == *q)
         return 0;
     else
         return -1;
 }
 
 int main() {
     int i, j, t, n;
     double x[1000], y[1000], ans;
     scanf(α%dα, &t);
     for(i = 0; i < t; i++) {
 	scanf(α%dα, &n);
 	for(j = 0; j < n; j++) {
 	    scanf(α%lfα, &x[j]);
 	}
 	for(j = 0; j < n; j++) {
 	    scanf(α%lfα, &y[j]);
 	}
 	qsort(x, n, sizeof(x[0]), compare);
 	qsort(y, n, sizeof(y[0]), compare2);
 
 	ans = 0;
 	for(j = 0; j < n; j++) {
 	    ans += x[j] * y[j];
 	}
 	printf(αCase #%d: %.0lfnα, i+1, ans);
     }
     return 0;
 }"
7756,2008,32016,cavegeek,24482,1,milkshake.c,gcj/2008/32016/cavegeek/24482/1/extracted/milkshake.c,"#include αstdio.hα
 #include αstdlib.hα
 
 typedef enum {NONE=-1, UNMALTED=0, MALTED=1, ALL=2} Pref;
 typedef enum {FALSE,TRUE} Bool;
 
 int main() {
 	unsigned cases = 0;
 	unsigned cas = 0;
 
 	scanf(α%uα, &cases);
 
 	for(cas = 1; cas <= cases; cas++) {
 		unsigned flavours = 0;
 		unsigned flavour = 0;
 
 		unsigned customers = 0;
 		unsigned customer = 0;
 
 		Pref *prefs = NULL;
 
 		int *malts = NULL;
 
 		scanf(α%uα, &flavours);
 		scanf(α%uα, &customers);
 		
 		prefs = (Pref *)malloc(sizeof(Pref)*flavours*customers);
 
 		for(customer = 0; customer < customers; customer++) {
 			for(flavour = 0; flavour < flavours; flavour++)
 				prefs[customer*flavours+flavour] = NONE;
 		}
 
 		malts = (int *)malloc(sizeof(unsigned)*customers);
 		for(customer = 0; customer < customers; customer++) {
 			malts[customer] = -1;
 		}
 
 		for(customer = 0; customer < customers; customer++) {
 			unsigned p = 0;
 
 			scanf(α%uα, &p);
 			
 			for(; p > 0; p--) {
 				unsigned f = 0;
 				unsigned m = 0;
 
 				unsigned i = 0;
 
 				scanf(α%uα, &f);
 				scanf(α%uα, &m);
 
 				--f; /* flavours are indexed from 1 in the problem spec, 0 in the program :( */
 				if(m == 1)
 					malts[customer] = f;
 
 				i = customer*flavours+f;
 
 				if(prefs[i] == NONE)
 					prefs[i] = m;
 				else {
 					/* since no pair will occur twice in one customer, this customer will be pleased with anything */
 					prefs[i] = ALL;
 				}
 			}
 		}
 
 		{
 			Pref *prods = NULL;
 			Bool unhappy = TRUE;
 			Bool possible = TRUE;
 			unsigned i = 0;
 
 			prods = (Pref *)malloc(sizeof(Pref)*flavours);
 			
 			for(flavour = 0; flavour < flavours; flavour++) {
 				prods[flavour] = UNMALTED;
 			}
 
 			while(unhappy && possible) {
 				unhappy = FALSE;
 				for(customer = 0; customer < customers; customer++) {
 					Bool happy = FALSE;
 
 					for(flavour = 0; flavour < flavours; flavour++) {
 						i = customer*flavours+flavour;
 
 						if(prefs[i] == ALL || prefs[i] == prods[flavour]) {
 							happy = TRUE;
 							break; /* customer is satisfied */
 						}
 					}
 
 					if(!happy) {
 						unhappy = TRUE;
 						if(malts[customer] == -1) { /* then malting something won't make this customer happy :( */
 							possible = FALSE;
 							break;
 						}
 						prods[malts[customer]] = MALTED;
 					}
 				}
 			}
 			if(!possible)
 				printf(αCase #%u: IMPOSSIBLEnα, cas);
 			else { /* must be happy */
 				printf(αCase #%u:α, cas);
 				for(flavour = 0; flavour < flavours; flavour++)
 					printf(α %uα, prods[flavour]);
 				putchar('n');
 			}
 		}
 	}
 
 	return 0;
 }"
7770,2008,32016,solmyr,24484,1,a.c,gcj/2008/32016/solmyr/24484/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 #include<math.h>
 int bigsort(const void *a,const void *b) {
     return *(int *)b-*(int *)a;
 }
 
 int smallsort(const void *a,const void *b) {
     return *(int *)a-*(int *)b;
 }
 
 int main(void) {
     FILE* out=fopen(αe:/outα,αwα);
     FILE* in=fopen(αe:/A-large.inα,αrα);
     int a[1000],b[1000];
     int t,n,i,j,c=0;
     fscanf(in,α%dα,&t);
     while(t-->0) {
         c++;
         fscanf(in,α%dα,&n);
         for(i=0;i<n;i++) {
             fscanf(in,α%dα,&a[i]);
         }
         for(i=0;i<n;i++) {
             fscanf(in,α%dα,&b[i]);
         }
         qsort(a,n,sizeof(int),bigsort);
         qsort(b,n,sizeof(int),smallsort);
         __int64 s1=0,s2=0;
         for(i=0;i<n;i++) {
             s1+=(__int64)a[i]*b[i];
             s2+=(__int64)a[n-1-i]*b[n-1-i];
         }
         fprintf(out,αCase #%d: %I64dnα,c,s1<s2?s1:s2);
     }
     system(αpauseα);
     return 0;
 }"
7861,2008,32016,dakura,24482,1,linklist.c,gcj/2008/32016/dakura/24482/1/extracted/linklist.c,"#include <stdlib.h>
 #include αmylinklist.hα
 
 MyLinkList* MyLinkListCreateNode(void *content){
     MyLinkList *l = malloc(sizeof(MyLinkList));
     l->content = content;
     l->next = l->prev = NULL;
     return l;
 }
 
 MyLinkList* MyLinkListAdd(MyLinkList *list, void *content){
     if(list == NULL){
         return MyLinkListCreateNode(content);
     }else{
         MyLinkList *l = list;
         while(l->next != NULL){
             l = l->next;
         }
         l->next = MyLinkListCreateNode(content);
         ((MyLinkList*)l->next)->prev = l;
     }
     return list;
 }
 
 int MyLinkListCounts(MyLinkList *list){
     int n = 0;
     while(list != NULL){
         list = list->next;
         n++;
     }
     return n;
 }
 
 MyLinkList *MyLinkListGetNode(MyLinkList *list,int index){
     while(index-- && list != NULL){
         list = list->next;
     }
     return list;
 }
 
 MyLinkList *MyLinkListRemove(MyLinkList *list, int index){
     MyLinkList *l = MyLinkListGetNode(list,index);
     if(l != NULL){
         if(l->prev == NULL){
             list = l->next;
         }else{
             ((MyLinkList*)l->prev)->next = l->next;
         }
         if(l->next != NULL){
             ((MyLinkList*)l->next)->prev = l->prev;
         }
         free(l->content);
         free(l);
     }
     return list;
 }
 
 void* MyLinkListGetElement(MyLinkList *list,int index){
     MyLinkList *l = MyLinkListGetNode(list,index);
     return (l == NULL)? NULL : l->content;
 }
 
 MyLinkList *MyLinkListFree(MyLinkList *list){
     if(list != NULL){
         int counts = MyLinkListCounts(list);
         int i;
         for(i=counts-1; i >= 0; i--){
             MyLinkListRemove(list,i);
         }
         //        free(list);
     }
     return NULL;
 }"
7863,2008,32016,dakura,24482,1,milkshakes.c,gcj/2008/32016/dakura/24482/1/extracted/milkshakes.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
 #include α../../lib/mylinklist.hα
 
 typedef struct {
     int id;
     int isMalted;
 } Flavor;
 
 typedef struct {
     int likes;
     MyLinkList *flavors;
 } Customer;
 
 // from smaller
 int CompareInt(int *a,int *b){
     return (*a-*b);
 }
 // from larger
 int CompareIntR(int *a,int *b){
     return (*b-*a);
 }
 
 int main(int argc, char **argv){
     int numOfCases;
     int i;
 
     scanf(α%dα,&numOfCases);
     for(i=0; i < numOfCases; i++){
         int numOfFlavors,numOfCustomers,j;
         Customer *customers;
         int isImpossible;
         int answers[2000];
         int numOfEvaluated,numOfPrevEvaluated;
 
         isImpossible = 0;
         scanf(α%dα,&numOfFlavors);
         scanf(α%dα,&numOfCustomers);
         customers = calloc(numOfCustomers,sizeof(Customer));
         for(j=0; j < numOfFlavors; j++){
             answers[j] = -1;
         }
         for(j=0; j < numOfCustomers; j++){
             int k;
             scanf(α%dα,&customers[j].likes);
             for(k=0; k < customers[j].likes; k++){
                 Flavor *flavor = calloc(1,sizeof(Flavor));
                 scanf(α%d%dα,&flavor->id,&flavor->isMalted);
                 customers[j].flavors = MyLinkListAdd(customers[j].flavors,flavor);
             }
         }
         // evaluate
         numOfPrevEvaluated = -1;
         numOfEvaluated = 0;
         while(!isImpossible && numOfPrevEvaluated != numOfEvaluated){
             numOfPrevEvaluated = numOfEvaluated;
             qsort(customers,numOfCustomers,sizeof(Customer),(int(*)(const void*, const void*))CompareInt);
             for(j=0; j < numOfCustomers && !isImpossible; j++){
                 int k;
                 for(k=0; k < customers[j].likes && !isImpossible;){
                     Flavor *flavor = MyLinkListGetElement(customers[j].flavors,k);
                     if(customers[j].likes == 1){
                         if(answers[flavor->id-1] != -1 && answers[flavor->id-1] != flavor->isMalted){
                             // already this flavor is fixed !
                             isImpossible = 1;
                             continue;
                         }else{
                             answers[flavor->id-1] = flavor->isMalted;
                             customers[j].flavors = MyLinkListRemove(customers[j].flavors,k);
                             customers[j].likes--;
                             numOfEvaluated++;
                         }
                     }else{
                         if(answers[flavor->id-1] == flavor->isMalted){
                             // this customer will be satisfied
                             customers[j].flavors = MyLinkListFree(customers[j].flavors);
                             customers[j].likes = 0;
                             numOfEvaluated++;
                             break;
                         }else if(answers[flavor->id-1] != -1){
                             // this entry is not satisfied
                             customers[j].flavors = MyLinkListRemove(customers[j].flavors,k);
                             customers[j].likes--;
                             numOfEvaluated++;
                         }else{
                             // next
                             k++;
                         }
                     }
                 }
             }
         }
         if(isImpossible){
             printf(αCase #%d: IMPOSSIBLEnα,i+1);
         }else{
             printf(αCase #%d:α,i+1);
             for(j=0; j < numOfFlavors; j++){
                 printf(α %dα,(answers[j] == -1)? 0 : answers[j]);
             }
             printf(αnα);
         }
         for(j=0; j < numOfCustomers; j++){
             MyLinkListFree(customers[j].flavors);
         }
     }
 }"
7995,2008,32016,miura,24484,1,A.c,gcj/2008/32016/miura/24484/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int main()
 {
     int T;
     int n;
     long long x[800];
     long long y[800];
     int i;
     int j;
     int k;
     long long sum;
 
     scanf(α%dα, &T);
     for(i = 0; i < T; i++) {
         scanf(α%dα, &n);
         for(j = 0; j < n; j++) {
             scanf(α%lldα, &x[j]);
         }
         for(j = 0; j < n; j++) {
             scanf(α%lldα, &y[j]);
         }
         
         for(j = 0; j < n-1; j++) {
             for(k = j+1; k < n; k++) {
                 if(x[j] < x[k]) {
                     int tmp = x[j];
                     x[j]    = x[k];
                     x[k]    = tmp;
                 }
             }
         }
         for(j = 0; j < n-1; j++) {
             for(k = j+1; k < n; k++) {
                 if(y[j] > y[k]) {
                     int tmp = y[j];
                     y[j]    = y[k];
                     y[k]    = tmp;
                 }
             }
         }
 
         sum = 0;
         for(j = 0; j < n; j++) {
             sum += x[j] * y[j];
         }
 
         printf(αCase #%d: %lldnα, i+1, sum);
     }
 
     return 0;
 }"
8030,2008,32016,beagoodboy,24484,1,main.c,gcj/2008/32016/beagoodboy/24484/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 void swap (long long *p, int left, int right)
 {
     if (left == right)
     {
         return;
     }
     long long tmp = *(p + left);
     *(p + left) = *(p + right);
     *(p + right) = tmp;
 }
 
 void quicksort(long long *p, int left, int right)
 {
     if (left >= right)
     {
         return;
     }
     swap(p, left, (left + right)/2);
     int mid = left;
     int i;
     for (i = left + 1; i <= right; i++)
     {
         if (*(p + i) < *(p + left))
         {
             swap(p, i, ++mid);
         }
     }
     swap(p, left, mid);
     quicksort(p, left, mid - 1);
     quicksort(p, mid + 1, right);
 }
 
 int main(int argc, char **argv)
 {
     int t, n;
     long long *v1, *v2;
     long long value;
     int i, j;
     long long *p1, *p2;
 
     scanf(α%dnα, &t);
     //printf(α%dnα, t);
     for (i = 0; i < t; i++)
     {
         scanf(α%dnα, &n);
         //printf(α%dnα, n);
         v1 = (long long *)malloc(n * sizeof(long long));
         p1 = v1;
         for (j = 0; j < n; j++)
         {
             scanf(α%lldα, p1++);
             //printf(α%d α, *(p1 - 1));
         }
         scanf(αnα);
         //printf(αnα);
         v2 = (long long *)malloc(n * sizeof(long long));
         p2 = v2;
         for (j = 0; j < n; j++)
         {
             scanf(α%lldα, p2++);
             //printf(α%d α, *(p2 - 1));
         }
         scanf(αnα);
         //printf(αnα);
         quicksort(v1, 0, n - 1);
         quicksort(v2, 0, n - 1);
         value = 0;
         for (j = 0; j < n; j++)
         {
             value += *(v1 + j) * *(v2 + n - 1 - j);
         }
         printf(αCase #%d: %lldnα, i+1, value);
     }
     return 0;
 }"
8087,2008,32016,goober,24483,1,C.c,gcj/2008/32016/goober/24483/1/extracted/C.c,"#include <stdio.h>
 
 int a,b,c,d;
 
 void powah(int z)
 {
 	if (z == 0)
 	{
 		a = d = 1;
 		b = c = 0;
 		return;
 	}
 	powah(z/2);
 	int aa = (a*a+b*c+10000000)%1000;
 	int bb = (a*b+b*d+10000000)%1000;
 	int cc = (a*c+c*d+10000000)%1000;
 	int dd = (d*d+b*c+10000000)%1000;
 	a = aa;
 	b = bb;
 	c = cc;
 	d = dd;
 
 	if (z & 1)
 	{
 		aa = (6*a + b+10000)%1000;
 		bb = (-4*a+10000)%1000;
 		cc = (6*c + d+10000)%1000;
 		dd = (-4*c+10000)%1000;
 		a = aa; b = bb; c = cc; d = dd;
 	}
 }
 
 int main()
 {
 	int t;
 	scanf(α%dα, &t);
 	for (int cc = 1; cc <= t; cc++)
 	{
 		int n;
 		scanf(α%dα, &n);
 		powah(n);
 		printf(αCase #%d: %03dnα, cc, (6*c+2*d+99999)%1000);
 	}
 	return 0;
 }"
8089,2008,32016,goober,24482,1,B.c,gcj/2008/32016/goober/24482/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 
 char drink[2000][2000];
 char mix[2000];
 int deg[2000];
 
 int main()
 {
 	int t;
 	scanf(α%dα, &t);
 	for (int c=1; c<=t; c++)
 	{
 		int m,n;
 		memset(drink, 0, sizeof(drink));
 		memset(mix, 0, sizeof(mix));
 
 		scanf(α%d %dα, &n, &m);
 		for (int i=0; i<m; i++)
 		{
 			scanf(α%dα, &deg[i]);
 			for (int tt = 0; tt < deg[i]; tt++)
 			{
 				int x,y;
 				scanf(α%d %dα, &x, &y);
 				drink[i][x-1] = y+1;
 			}
 		}
 		printf(αCase #%d:α, c);
 		while(1)
 		{
 			int i;
 			for (i=0; i<m; i++)
 			{
 				if (deg[i] == 0) goto impossible;
 				if (deg[i] == 1)
 				{
 					int j;
 					for (j=0; j<n; j++) if (drink[i][j] != 0) break;
 					int t = drink[i][j];
 
 					mix[j] = t-1;
 					deg[i] = -1;
 					for (int k=0; k<m; k++)
 						if (drink[k][j])
 							if (drink[k][j] == t) deg[k] = -1;
 							else { drink[k][j] = 0; deg[k]--; }
 					break;
 				}
 			}
 			if (i >= m) break;
 		}
 		for (int i=0; i<n; i++) printf(α %dα, mix[i]);
 		printf(αnα);
 		continue;
 impossible:
 		printf(α IMPOSSIBLEnα);
 	}
 	return 0;
 }"
8349,2008,32016,aledm,24484,1,product.c,gcj/2008/32016/aledm/24484/1/extracted/product.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int
 lessthan(int *a, int *b)
 {
 	return (*b - *a);
 }
 
 int
 morethan(int *a, int *b)
 {
 	return (*a - *b);
 }
 
 
 main()
 {
 	unsigned T, i;
 
 	scanf(α%unα, &T);
 
 	for (i = 1; i <= T; i++) {
 		unsigned n, j;
 		long long Y;
 		int x[800], y[800];
 		
 		scanf(α%unα, &n);
 		for (j = 0; j < n; j++)
 			scanf(α%iα, &x[j]);
 		for (j = 0; j < n; j++)
 			scanf(α%iα, &y[j]);
 
 		qsort(x, n, sizeof(int), &lessthan);
 		qsort(y, n, sizeof(int), &morethan);
 
 		for (Y = 0, j = 0; j < n; j++)
 			Y += ((long long)x[j] * (long long)y[j]);
 
 		printf(αCase #%d: %lldnα, i, Y);
 	}
 }
 
 //end"
8443,2008,32013,basser.duncs,24480,1,a.c,gcj/2008/32013/basser.duncs/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #define maxN 101
 #define maxe 101
 
 void getstring (char *dest) {
   while ( (*dest = getchar()) !='n' ) {
     dest++;
   }
   *dest = '0';
   return;
 }
 
 int checkqueries ( int searched[], int engines )
 {
   int i;
   for ( i = 0; i < engines; i++ ) {
     if ( searched[i] == 0 ) return 0;
   }
   return 1;
 }
 
 int main (void)
 {
   int num;
   scanf (α%dα, &num);
   int i;
   for (i = 0; i<num;) {
     int k;
     scanf (α%dα, &k);
     char tmp = getchar();
     char *engines[maxe];
     int a;
       for ( a = 0; a < k; a++ ) {
         engines[a] = malloc ( maxN * sizeof(char) );
       }
     int j;
     for ( j = 0; j<k; j++ ) {
       getstring (engines[j]);
     }
     int l;
     scanf (α%dα, &l);
     tmp = getchar();
     if ( l == 0 ) {
       i++;
       printf (αCase #%d: 0nα, i);
       continue;
     }
     int searched[maxe] = {0};
     int c;
     int switches = 0;
 
     for ( j = 0; j<l; j++ ) {
       char *query;
       query = malloc ( maxN * sizeof (char) );
       getstring (query);
       for ( c=0; c<k; c++ ) {
         if ( strncmp ( query, engines[c], maxN + 1 ) == 0 ) {
         searched[c] = 1;
         break;
         }
       }
       if ( checkqueries (searched, k) == 1 ) {
         switches++;
         int counter;
 
         for (counter = 0; counter < k; counter++) {
           searched[counter] = 0;
         }
         searched[c] = 1;
       }
       free (query);
     }
     i++;
     printf ( αCase #%d: %dnα, i, switches );
 
     for ( a = 0; a < k; a++ ) {
       free (engines[a]);
     }
     
   }
   
   return 0;
 }"
8450,2008,32013,mdiogo,24481,1,b.c,gcj/2008/32013/mdiogo/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int compare(const void*, const void*);
 
 int main() {
 	//number of tests
 	int num_tests;
 	int curr_test;
 	//problem inputs
 	int depart_a[100];
 	int arrive_b[100];
 	int depart_b[100];
 	int arrive_a[100];
 	int turnaround;
 	int na;
 	int nb;
 	//problem internals
 	int i;
 	int j;
 	int need_train_a[100];
 	int need_train_b[100];
 	int result_a = 0;
 	int result_b = 0;
 	
 	scanf(α%dα,&num_tests);
 	for(curr_test=1;curr_test<=num_tests;curr_test++) {
 		//problem input
 		scanf(α%dα,&turnaround);
 		scanf(α%d %dα,&na,&nb);
 		for (i=0;i<na;i++) {
 			int hora_d, minuto_d, hora_a, minuto_a;
 			scanf(α%d:%d %d:%dα,&hora_d,&minuto_d,&hora_a,&minuto_a);
 			depart_a[i] = (hora_d*60)+minuto_d;
 			arrive_b[i] = (hora_a*60)+minuto_a;
 		}
 		for (i=0;i<nb;i++) {
 			int hora_d, minuto_d, hora_a, minuto_a;
 			scanf(α%d:%d %d:%dα,&hora_d,&minuto_d,&hora_a,&minuto_a);
 			depart_b[i] = (hora_d*60)+minuto_d;
 			arrive_a[i] = (hora_a*60)+minuto_a;
 		}
 		//solution
 		qsort(depart_a,na,sizeof(int),compare);
 		qsort(arrive_b,na,sizeof(int),compare);
 		qsort(depart_b,nb,sizeof(int),compare);
 		qsort(arrive_a,nb,sizeof(int),compare);
 		//for station A
 		for (i = 0; i<na; i++) {
 			need_train_a[i] = 1;
 		}
 		for(i = 0; i<nb; i++) {
 			for(j = 0; j<na; j++) {
 				if((depart_a[j] >= arrive_a[i]+turnaround) && (need_train_a[j] != 0)) {
 					need_train_a[j] = 0;
 					break;
 				}
 			}
 		}
 		//for station B
 		for (i = 0; i<nb; i++) {
 			need_train_b[i] = 1;
 		}
 		for(i = 0; i<na; i++) {
 			for(j = 0; j<nb; j++) {
 				if((depart_b[j] >= arrive_b[i]+turnaround) && (need_train_b[j] != 0)) {
 					need_train_b[j] = 0;
 					break;
 				}
 			}
 		}
 		result_a = 0;
 		for (i = 0; i<na; i++) {
 			result_a += need_train_a[i];
 		}
 		result_b = 0;
 		for (i = 0; i<nb; i++) {
 			result_b += need_train_b[i];
 		}
 		printf(αCase #%d: %d %dnα,curr_test, result_a, result_b);
 	}
 	return 0;
 }
 
 /*static int compare(const void *a, const void *b) {
 	int ia, ib;
 	ia = (int)a;
 	ib = (int)b;
 	if (a > b)
 		return 1;
 	else if (a < b)
 		return -1;
 	else
 		return 0;
 }*/
 
 int compare(const void *pa, const void *pb)
 {
   int *a,*b;
 
   a = ((int *) (pa));
   b = ((int *) (pb));
 
   if(*a < *b)
     return -1;
   else if (*a == *b)
     return 0;
   else
     return 1;
 }"
8467,2008,32013,tetsuma,24480,1,univ.c,gcj/2008/32013/tetsuma/24480/1/extracted/univ.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int main(){
   char str[200][200], query[2000];
   int check[200];
   int i, j, k, l, test, sn, qn, ans, tmp;
   int flag, set;
 
   scanf(α%dα,&test);
   for(k=1;k<=test;k++){
     scanf(α%dα,&sn);
     scanf(α%dα,&tmp);
     for(i=0;i<sn;i++)
       fgets(str[i],150,stdin);
 
     scanf(α%dα,&qn);
     if(qn!=0)scanf(α%dα,&tmp);
     memset(check,0,sizeof(int)*200);
     ans=0;
     for(i=0;i<qn;i++){
       fgets(query,150,stdin);
       for(j=0;j<sn;j++){
 	if(strcmp(query,str[j])==0){
 	  check[j]++;
 	  flag=0;
 	  for(l=0;l<sn;l++){
 	    if(check[l]==0){
 	      flag=1;
 	      break;
 	    }
 	  }
 	  if(flag==0){
 	    memset(check,0,sizeof(int)*200);
 	    check[j]++;
 	    ans++;
 	  }
 	}
       }
     }
     printf(αCase #%d: %dnα,k,ans);
   }
 }"
8469,2008,32013,tetsuma,24481,1,train.c,gcj/2008/32013/tetsuma/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int comp(const int *a, const int *b){
     return *a - *b;
 }
 
 int main(){
   int test, i, j, k, tmp, na, nb, t, ca, cb;
   int af[200], at[200], bf[200], bt[200];
   int h1, h2, m1, m2;
 
   scanf(α%dα,&test);
   for(k=1;k<=test;k++){
     scanf(α%d%d%dα,&t,&na,&nb);
     for(i=0;i<na;i++){
       scanf(α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
       af[i]=h1*60+m1;
       at[i]=h2*60+m2;
     }
     qsort(af,na,sizeof(int),(int (*)(const void*, const void*))comp);
     qsort(at,na,sizeof(int),(int (*)(const void*, const void*))comp);
     for(i=0;i<nb;i++){
       scanf(α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
       bf[i]=h1*60+m1;
       bt[i]=h2*60+m2;
     }
     qsort(bf,nb,sizeof(int),(int (*)(const void*, const void*))comp);
     qsort(bt,nb,sizeof(int),(int (*)(const void*, const void*))comp);
 
     ca=cb=0;
 
     for(i=0,j=0;i<na;i++){
       while(j<nb){
 	if(at[i]+t<=bf[j]){
 	  cb++;
 	  j++;
 	  break;
 	}
 	j++;
       }
       if(j==nb)break;
     }
 
     for(i=0,j=0;i<nb;i++){
       while(j<na){
 	if(bt[i]+t<=af[j]){
 	  ca++;
 	  j++;
 	  break;
 	}
 	j++;
       }
       if(j==na)break;
     }
     
     printf(αCase #%d: %d %dnα,k,na-ca,nb-cb);
   }
 }"
8489,2008,32013,sumeetk,24480,1,problem1.c,gcj/2008/32013/sumeetk/24480/1/extracted/problem1.c,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 
 struct test {
     int s,q;
     char name[100][100];
     char query[1000][100];
     int count;
 }qset[20];
 
 int n;
 
 void getdata()
 {
     char temp[100];
     int i,j,k;
     scanf(α%dα,&n);
     //gets(temp);
     for(i=0;i<n;i++) {
         scanf(α%dα,&qset[i].s);
         gets(temp);
         for(j=0;j<qset[i].s;j++) {
             gets(qset[i].name[j]);
         }
         scanf(α%dα,&qset[i].q);
         gets(temp);
         for(j=0;j<qset[i].q;j++) {
             gets(qset[i].query[j]);
         }
         qset[i].count=0;
     }
     
 }
 
 void calculate()
 {
     int i,j,k,l;
     int flags[100],cnt;
     for(i=0;i<n;i++) {
         for(j=0;j<100;j++)
             flags[j]=0;
         cnt=0;
         for(j=0;j<qset[i].q;j++) {
             for(k=0;k<qset[i].s;k++) {
                 if(!strcmp(qset[i].name[k],qset[i].query[j])) {
                     if(flags[k]==0) {
                         flags[k]=1;
                         cnt++;
                     }
                     if(qset[i].s==cnt) {
                         cnt=1;
                         for(l=0;l<100;l++)
                             flags[l]=0;
                         qset[i].count++;
                         flags[k]=1;
                     }
                     break;
                 }
             }
         }
     }
 }
 
 void display()
 {
     int i;
     for(i=0;i<n;i++) {
         printf(αnCase #%d: %dα,i+1,qset[i].count);
     }
 }
 
 int
 main() 
 {
     getdata();
     calculate();
     display();
     getch();
 }"
8552,2008,32013,mma,24480,1,SaveTheUniverse.c,gcj/2008/32013/mma/24480/1/extracted/SaveTheUniverse.c,"#define MAX_SERVERS 100
 #define MAX_SERVERNAME_LEN 100
 
 #define	UNUSED_SERVER 1
 #define	MARKED_SERVER 2
 
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 typedef struct _server_info {
 	int name_len;
 	char* name;
 	int hits;
 } server_info;
 
 char input[MAX_SERVERNAME_LEN+1];
 
 static inline void read_line(char * dest) {
 	gets(dest);
 }
 
 static inline int read_number() {
 	read_line(input);
 	return (atoi(input));
 }
 
 int main() {
 
 int no_cases, c;
 int no_servers, s;
 int no_queries, q;
 
 server_info servers[MAX_SERVERS];
 
 int hit, match, len, match_s;
 
 memset(&servers, 0, sizeof(servers));
 no_cases=read_number();
 for (c=0; c<no_cases; c++) {
 	no_servers=read_number();
 	for (s=0; s<no_servers; s++) { 
 		if (servers[s].name==NULL) {
 			if (((servers[s].name=malloc(MAX_SERVERNAME_LEN+1)))==NULL) {
 				printf(αMemory allocation errornα);
 				return 1;
 			}
 		}
 		read_line(servers[s].name);
 		servers[s].name_len=strlen(servers[s].name);
 		servers[s].hits=0;
 	}
 	no_queries=read_number();
 	hit=1;
 	for (q=0; q<no_queries; q++) {
 		read_line(input);
 		len=strlen(input);
 		match=0;
 		for (s=0; s<no_servers; s++) {
 			if ((len==servers[s].name_len) &&
 				(strcmp(input, servers[s].name)==0)) {
 				servers[s].hits=hit;
 				match_s=s;
 				match|=MARKED_SERVER;
 				if (match&UNUSED_SERVER) break;
 			} else {
 				if (servers[s].hits<hit) {
 					match|=UNUSED_SERVER;
 					if (match&MARKED_SERVER) break;
 				}
 			}
 		}
 		if (match==MARKED_SERVER) {
 			hit++;
 			servers[match_s].hits=hit;
 		}
 	}
 	printf(αCase #%d: %dnα, c+1, hit-1);
 }
 return 0;
 }"
8562,2008,32013,yangjunqi,24480,1,main.c,gcj/2008/32013/yangjunqi/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #define MAX 100
 
 
 char query[1000][MAX];
 char engine[100][MAX];
 char v[MAX];
 int sum[MAX];
 int num1 = 0;
 int num2 = 0;
 int num3 = 0;
 int all = 0;
 int times = 0;
 /**************************/
 char numchar[20];
 char printArr[MAX];
 char answer[100];
 /***************************/
 
 void solve(void) {
 	int k;
 	int i;
 	int j;
 	int q;
 	times = 0;
 	all = 0;
 
   for ( k = 0; k < num2; k++)
 	  sum[k] = 0;
   //printf(αhello α);
   //printf(α%d  %dnα, num2, num3);
   for ( i = 0; i < num3; i++) {
 	
 	  for ( j = 0; j < num2; j++) {
 		  if (sum[j] == 0 && (strcmp(query[i],engine[j]) == 0)) {
 			  sum[j] = 1;
 		  for ( k = 0; k < num2; k++)
 			  all += sum[k];
 		
 		  if (all == num2) {
 			  i--;
 			 all = 0;
 			  times++;
 			  for (k = 0; k < num2; k++)
 				  sum[k] = 0;
 			  break;
 
 		  }
 		  all = 0;
 		  }/*if*/
 	  }/*for*/
   }/*for*/
 	  sprintf(answer, α%dα, times);
 
 }
 int main(int argc, char *argv[])
 {
   FILE *fp;
   FILE *fpw;
  
   int i = 0;
  // int j = 0;
   int k = 0;
  
   fpw = fopen(αanswer.txtα, αwα);
   fp = fopen(argv[1], αrα);
   if (fp == NULL || fpw == NULL) {
     printf(αErrornα);
     exit(1);
   }
   fgets(v, sizeof(v), fp);
   sscanf(v, α%dα, &num1);
   //printf(α%dnα, num);
   for (i = 0; i < num1; i++) {
 	  fgets(v, sizeof(v), fp);
 	  sscanf(v, α%dα, &num2);
 	  for (k = 0; k < num2; k++) {
 		 fgets(v, sizeof(v), fp);
 		 strcpy(engine[k], v);
 	  }
 	  fgets(v, sizeof(v), fp);
 	  sscanf(v, α%dα, &num3);
 	  for (k = 0; k < num3; k++) {
 		  fgets(v, sizeof(v), fp);
 		  strcpy(query[k], v);
 	  }
 	
    
 	solve();			/* core of the source */
     sprintf(numchar, α%d: α, i + 1);
     sprintf(printArr, α%sα, αCase #α);
     strcat(printArr, numchar);
     strcat(printArr, answer);
     strcat(printArr, αnα);
     fputs(printArr, fpw);
     
     /*printf(α%s α, v1);
     printf(α%s α, v2);
     printf(α%sα, v3);*/
     
   }
 
   fclose(fp);
   fclose(fpw);
   return(0);
 }"
8696,2008,32013,ujjwal,24480,1,1.c,gcj/2008/32013/ujjwal/24480/1/extracted/1.c,"#include<stdio.h>
 #include<string.h>
 
 void init_marked(char *marked, int s)
 {
 	int i;
 	for(i=0;i<s;i++)
 	{
 		marked[i] = '0';
 	}
 }
 
 int main()
 {
 	int k,n,s,i,j,q;
 	char list[200][200], query[200];
 	int queries[2000];
 	char marked[200];
 	int no_marked,switches;
 
 	scanf(α%dα, &n);
 
 	for(k=0;k<n;k++)
 	{
 		scanf(α%dα, &s);
 
 		for(i=0;i<s;i++)
 		{
 			scanf(α %[^n]α, list[i]);
 		}
 
 		scanf(α%dα, &q);
 
 		for(i=0;i<q;i++)
 		{
 			scanf(α %[^n]α, query);
 		
 			for(j=0;j<s;j++)
 			{
 				if(strcmp(query, list[j]) == 0)
 				{
 					queries[i] = j;
 					break;
 				}
 			}
 		}
 
 		init_marked(marked, s);
 
 		no_marked = 0;
 		switches = 0;
 
 		for(i=0;i<q;)
 		{
 			if(marked[queries[i]] == '0')
 			{
 				marked[queries[i]] = 'x';
 				no_marked++;
 			}
 
 			if(no_marked == s)
 			{
 				no_marked = 0;
 				switches++;
 				init_marked(marked, s);
 			}
 			else
 				i++;
 		}
 
 		printf(αCase #%d: %dnα, k+1, switches);
 	}
 
 	return 0;
 }"
8703,2008,32013,Sane,24481,1,B.c,gcj/2008/32013/Sane/24481/1/extracted/B.c,"#include <stdio.h>
 #define MAX 1000
 #define ARRIVEA 0
 #define ARRIVEB 1
 #define LEAVEA 2
 #define LEAVEB 3
 
 char buff[2][MAX];
 int schedule[MAX][2];
 int n, t, na, nb;
 
 int sort_ascending(const void *a, const void *b) {
     int *A=(int *)a, *B=(int *)b;
     return A[0] == B[0] ? A[1] - B[1] : A[0] - B[0];
 }
 
 int gettime(char *s) {
     return ((s[0]-'0')*10 + s[1]-'0')*60 + (s[3]-'0')*10 + s[4]-'0';
 }
 
 int main() {
     int i, j, size;
     int starta, startb;
     int ata, atb;
     
     freopen(αB-large.inα, αrtα, stdin);
     freopen(αB-large.outα, αwtα, stdout);
     
     scanf(α%dα, &n);
     
     for(i=0; i<n; i++) {
     
         scanf(α%d %d %dα, &t, &na, &nb);
         size = 0;
         
         for(j=0; j<na; j++) {
             scanf(α%s %sα, buff[0], buff[1]);
             schedule[size][0] = gettime(buff[0]);
             schedule[size++][1] = LEAVEA;
             schedule[size][0] = gettime(buff[1]) + t;
             schedule[size++][1] = ARRIVEB;
         }
         for(j=0; j<nb; j++) {
             scanf(α%s %sα, buff[0], buff[1]);
             schedule[size][0] = gettime(buff[0]);
             schedule[size++][1] = LEAVEB;
             schedule[size][0] = gettime(buff[1]) + t;
             schedule[size++][1] = ARRIVEA;
         }
         
         qsort(schedule, size, sizeof(*schedule), sort_ascending);
         
         ata=atb=starta=startb=0;
         for(j=0; j<size; j++) {
             if(schedule[j][1] == LEAVEA)  if(--ata<0) {ata++; starta++;}
             if(schedule[j][1] == LEAVEB)  if(--atb<0) {atb++; startb++;}
             if(schedule[j][1] == ARRIVEA) ata++;
             if(schedule[j][1] == ARRIVEB) atb++;
         }
         
         printf(αCase #%d: %d %dnα, i+1, starta, startb);
     }
     
     return 0;
 }"
8733,2008,32013,Keith,24480,1,saving_universe.c,gcj/2008/32013/Keith/24480/1/extracted/saving_universe.c,"/*
  * Input
  * Yeehaw
  * NSM
  * Dont Ask
  * B9
  * Googol
  * 10
  * Yeehaw
  * Yeehaw
  * Googol
  * B9
  * Googol
  * NSM
  * B9
  * NSM
  * Dont Ask
  * Googol
  * 5
  * Yeehaw
  * NSM
  * Dont Ask
  * B9
  * Googol
  * 7
  * Googol
  * Dont Ask
  * NSM
  * NSM
  * Yeehaw
  * Yeehaw
  * Googol
  *
  * Output
  * Case #1: 1
  * Case #2: 0
  *
  * Limits
  *
  * 0 < N ≤ 20
  *
  * Small dataset
  *
  * 2 ≤ S ≤ 10
  *
  * 0 ≤ Q ≤ 100
  *
  * Large dataset
  *
  * 2 ≤ S ≤ 100
  *
  * 0 ≤ Q ≤ 1000 
  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 
 static int
 is_implode(char** search_engines, int search_engine_index, char* query)
 {
 	if(strcmp(search_engines[search_engine_index], query) == 0)
 		return 1;
 	return 0;
 }
 
 static int
 do_calc(char** search_engines, int num_of_search_engine,
 			char** queries,  int num_of_queries)
 {
 	int i, j, k, max_index;
 	int changes;
 
 	changes = 0;
 	/* search the longest route */
 	for(i = 0; i < num_of_queries; ) {
 		max_index = 0;
 		/* try all search engines and find the longest one then continue */
 		for(j = 0; j < num_of_search_engine; j++) {
 			k = i;
 			do {
 				if(is_implode(search_engines, j, queries[k]))
 					break;
 				k++;
 			} while(k<num_of_queries);
 			if(max_index < k) {
 				max_index = k;
 			}
 		}
 		i = max_index;
 		if(i < num_of_queries)
 			changes++;
 	}
 	return changes;
 }
 
 int
 main(void)
 {
 	int test_cases;
 	int num_of_search_engine;
 	char **search_engines;
 	int num_of_queries;
 	char **queries;
 	int changes;
 	int i,j,len;
 
 	if(fscanf(stdin, α%dα, &test_cases) != 1) {
 		fprintf(stderr, αCannot read number of test casesnα);
 		return 1;
 	}
 
 	for(i = 0; i < test_cases; i++) {
 		if(fscanf(stdin, α%dnα, &num_of_search_engine) != 1) {
 			fprintf(stderr, αUnexpected EOFnα);
 			return 1;
 		}
 		search_engines = (char**)malloc(sizeof(char*)* num_of_search_engine);
 		memset(search_engines, 0 , sizeof(char*)*num_of_search_engine);
 		for(j = 0; j < num_of_search_engine; j++) {
 			len = 0;
 			if(getline(&search_engines[j], &len,stdin) == -1) {
 				fprintf(stderr, αUnexpected EOFnα);
 				return 1;
 			}
 		}
 		if(fscanf(stdin, α%dnα, &num_of_queries) != 1) {
 			fprintf(stderr, αUnexpected EOFnα);
 			return 1;
 		}
 		queries = (char**)malloc(sizeof(char*)* num_of_queries);
 		memset(queries, 0 , sizeof(char*)*num_of_queries);
 		for(j = 0; j < num_of_queries; j++) {
 			len = 0;
 			if(getline(&queries[j], &len, stdin) == -1) {
 				fprintf(stderr, αUnexpected EOFnα);
 				return 1;
 			}
 		}
 
 		changes = do_calc(search_engines, num_of_search_engine,
 			queries,  num_of_queries);
 		fprintf(stdout, αCase #%d: %dnα, i+1, changes);
 
 		for(j = 0; j < num_of_search_engine; j++) {
 			free(search_engines[j]);
 		}
 		free(search_engines);
 		for(j = 0; j < num_of_queries; j++) {
 			free(queries[j]);
 		}
 		free(queries);
 	}
 }"
8736,2008,32013,Keith,24481,1,train_new.c,gcj/2008/32013/Keith/24481/1/extracted/train_new.c,"/*
  * Input
  * 2
  * 5
  * 3 2
  * 09:00 12:00
  * 10:00 13:00
  * 11:00 12:30
  * 12:02 15:00
  * 09:00 10:30
  * 2
  * 2 0
  * 09:00 09:01
  * 12:00 12:02
  *
  * Output
  * Case #1: 2 2
  * Case #2: 2 0
  *
  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 struct station_info {
 	int time;
 	int need;	/* 1-need a train, 0-a train is ready*/
 };
 
 static int
 comp_time_func(const void *p1, const void *p2)
 {
 	struct station_info *s1, *s2;
 	int ret;
 	s1 = (struct station_info*)p1;
 	s2 = (struct station_info*)p2;
 	
 	ret = s1->time - s2->time;
 
 	if(s1->time == s2->time) {
 		return (s1->need - s2->need);
 	}
 	return ret;
 }
 
 static int
 calc_needed_train(struct station_info* station,
  		  int counts)
 {
 	int i;
 	int ready_train;
 	int needed_train;
 
 	ready_train = 0;
 	needed_train = 0;
 	qsort(station, counts, sizeof(struct station_info), comp_time_func);
 	for(i = 0; i < counts; i++) {
 		if(station[i].need == 1) {
 			if(ready_train == 0) {
 				needed_train++;
 			} else {
 				ready_train--;
 			}
 		} else {
 			ready_train++;
 		}
 	}
 	return needed_train;
 }
 
 int
 main(void)
 {
 	int test_cases;
 	int turnaround_time;
 	int num_of_trips_a_to_b;
 	int num_of_trips_b_to_a;
 	int i, j;
 	int num_of_trains;
 	struct station_info *station_a;
 	struct station_info *station_b;
 	int hour_dep, min_dep, hour_arr, min_arr;
 
 	if(fscanf(stdin, α%dα, &test_cases) != 1) {
 		fprintf(stderr, αCannot read number of test casesnα);
 		return 1;
 	}
 
 	for(i = 0; i < test_cases; i++) {
 		if(fscanf(stdin, α%dα, &turnaround_time) != 1) {
 			fprintf(stderr, αUnexpected EOFnα);
 			return 1;
 		}
 		if(fscanf(stdin, α%d %dα, &num_of_trips_a_to_b, &num_of_trips_b_to_a) != 2) {
 			fprintf(stderr, αUnexpected EOFnα);
 			return 1;
 		}
 		station_a = malloc((num_of_trips_a_to_b + num_of_trips_b_to_a)*sizeof(struct station_info));
 		station_b = malloc((num_of_trips_a_to_b + num_of_trips_b_to_a)*sizeof(struct station_info));
 
 		for(j = 0; j < num_of_trips_a_to_b; j++) {
 			if(fscanf(stdin, α%d:%d %d:%dα, &hour_dep, &min_dep, &hour_arr, &min_arr) != 4) {
 				fprintf(stderr, αUnexpected EOFnα);
 				return 1;
 			}
 			station_a[j].time = hour_dep*60 + min_dep;
 			station_a[j].need = 1;
 			station_b[j].time = hour_arr*60 + min_arr + turnaround_time;
 			station_b[j].need = 0;
 		}
 
 		for(j = 0; j < num_of_trips_b_to_a; j++) {
 			if(fscanf(stdin, α%d:%d %d:%dα, &hour_dep, &min_dep, &hour_arr, &min_arr) != 4) {
 				fprintf(stderr, αUnexpected EOFnα);
 				return 1;
 			}
 			station_b[j+num_of_trips_a_to_b].time = hour_dep*60 + min_dep;
 			station_b[j+num_of_trips_a_to_b].need = 1;
 			station_a[j+num_of_trips_a_to_b].time = hour_arr*60 + min_arr + turnaround_time;
 			station_a[j+num_of_trips_a_to_b].need = 0;
 		}
 
 		
 		fprintf(stdout, αCase #%d: α, i + 1);
 		num_of_trains = calc_needed_train(station_a, num_of_trips_a_to_b+num_of_trips_b_to_a);
 		fprintf(stdout, α%d α, num_of_trains);
 		num_of_trains = calc_needed_train(station_b, num_of_trips_a_to_b+num_of_trips_b_to_a);
 		fprintf(stdout, α%dnα, num_of_trains);
 		if(station_a)
 			free(station_a);
 		if(station_b)
 			free(station_b);
 	}
 }"
8784,2008,32013,ayn,24480,1,a.c,gcj/2008/32013/ayn/24480/1/extracted/a.c,"#include <stdio.h>
 
 //#define DEBUG
 #ifdef DEBUG
 #define DEBUG_PRINTS(__X__) (__X__)
 #else
 #define DEBUG_PRINTS(__X__)
 #endif
 
 #define	NAME_SIZE	100
 
 typedef struct queryItem_s
 {
 	char	se_name[NAME_SIZE+1];
 	int		pos[1000];
 	int		last_index;
 	int		cur_search_index;
 
 }queryItem_t;
 
 
 char *mygetline(char *line, int size, FILE *fp)
 {
 	if ( fgets(line, size, fp))
 	{
 		char *newline = strchr(line, 'r'); /* check for trailing 'n' */
 		if ( newline )
 		{
 			*newline =  '0'; /* overwrite the 'n' with a terminating null */
 		}
 	}
 	return line;
 }
 
 int main (void)
 {
 	int	num_se;
 	int	num_query;
 	int	num_test;
 	int	count_se;
 	int	count_query;
 	int	count_test;
 	FILE	*fp;
 	int	all_list_index;
 	int	switch_count;
 	char	linebuffer[2*NAME_SIZE];
 
 	queryItem_t	*queryItemList;
 
 	fp = fopen (αA-large.inα, αrα);
 
 	if ( fp == NULL )
 	{
 		DEBUG_PRINTS(printf (αnFailed to open the i/p fileα));
 
 		return 0;
 	}
 
 //	fscanf (fp, α%dα, &num_test);
 
 	mygetline(linebuffer, ( sizeof (linebuffer)*sizeof(char) ),fp );
 	num_test = atoi (linebuffer);
 
 	for ( count_test=0; count_test<num_test; ++count_test )
 	{
 //		fscanf (fp, α%dα, &num_se);
 		mygetline(linebuffer, ( sizeof (linebuffer)*sizeof(char) ),fp );
 		num_se = atoi (linebuffer);
 
 
 	//	fgetc (fp);
 	//	fgetc (fp);
 
 		DEBUG_PRINTS(printf (αnNumber of search engines[%d]nα, num_se));
 
 		queryItemList = (queryItem_t	*) malloc ( sizeof (queryItem_t) * num_se );
 
 		DEBUG_PRINTS(printf (αnSearch engines listnα));
 
 		for ( count_se=0; count_se<num_se; ++count_se )
 		{
 			char	str[NAME_SIZE+1];
 
 //			fscanf (fp, α%sα, str );
 			mygetline(str, NAME_SIZE,fp );
 
 			strcpy ( queryItemList [ count_se ].se_name, str );
 
 			memset ( queryItemList [ count_se ].pos, 0, 1000 * sizeof (int) );
 
 			queryItemList [ count_se ].last_index = 0;
 			queryItemList [ count_se ].cur_search_index = 0;
 
 			DEBUG_PRINTS(printf (αn[%s]α, queryItemList [ count_se ].se_name));
 		}
 
 //		fscanf (fp, α%dα, &num_query);
 
 		mygetline(linebuffer, ( sizeof (linebuffer)*sizeof(char) ),fp );
 		num_query = atoi (linebuffer);
 
 		DEBUG_PRINTS(printf (αnNumber of queries[%d]nα, num_query));
 
 		for ( count_query=1; count_query<= num_query; ++count_query )
 		{
 			char	str[NAME_SIZE+1];
 
 //			fscanf (fp, α%sα, str );
 			mygetline(str, NAME_SIZE,fp );
 
 			for ( count_se=0; count_se<num_se; ++count_se )
 			{
 				if ( strcmp (str, queryItemList [count_se].se_name ) == 0 )
 				{
 					queryItemList [ count_se ].pos[ queryItemList [ count_se ].last_index] = count_query;
 
 					DEBUG_PRINTS(printf (αn[%s] [%d] [%d]α, queryItemList [ count_se ].se_name, queryItemList [ count_se ].last_index, count_query));
 
 					++queryItemList [ count_se ].last_index;
 
 					break;
 				}
 			}
 		}
 
 		all_list_index = 0;
 		switch_count = 0;
 
 		while (1)
 		{
 			int	got_answer = 0;
 			int	temp_se=-1;
 
 			for ( count_se=0; count_se<num_se; ++count_se )
 			{
 				if ( queryItemList [ count_se ].pos [ queryItemList [ count_se ].cur_search_index] == 0 )
 				{
 					printf (αnCase #%d: %dα, count_test+1, switch_count );
 
 					got_answer = 1;
 					break;
 				}
 
 				if ( queryItemList [ count_se ].pos [ queryItemList [ count_se ].cur_search_index]> all_list_index )
 				{
 					all_list_index = queryItemList [ count_se ].pos [ queryItemList [ count_se ].cur_search_index];
 					temp_se = count_se;
 				}
 			}
 
 			if ( got_answer )
 			{
 				DEBUG_PRINTS(printf (αnSending query to search eng[%d] till endnα, count_se));
 				break;
 			}
 
 			++switch_count;
 
 			DEBUG_PRINTS(printf (αnSending query to search eng[%d] till list index[%d]nα, temp_se, all_list_index-1));
 
 			for ( count_se=0; count_se<num_se; ++count_se )
 			{
 				while ( queryItemList [ count_se ].pos [ queryItemList [ count_se ].cur_search_index] < all_list_index )
 				{
 					if ( queryItemList [ count_se ].pos [ queryItemList [ count_se ].cur_search_index] == 0 )
 					{
 						break;
 					}
 
 					++queryItemList [ count_se ].cur_search_index;
 				}
 			}
 
 
 		}
 
 		free (queryItemList);
 		queryItemList = NULL;
 	}
 	return 0;
 }"
8834,2008,32013,PriyaKumar,24480,1,test.c,gcj/2008/32013/PriyaKumar/24480/1/extracted/test.c,"#include<stdio.h>
 int updateefound(int,char[100][50],char *);
 int isfull(int*,int);
 void clean(int*,int);
 int main()
 {
  FILE *fp;
  char s[80];
  int i = 0,tc=0,noOfSearchEngines=0,j=0,nq=0,k=0;
  char engines[100][50];
  char queries[1000][50];
  int efound[100];
  int pos = 0,out=0;
  fp = fopen(αc:\input.inα, αrα); 
  if(NULL != fp)
  {
     fgets(s, 80, fp);      
     sscanf(s,α%dα,&tc);
     
     for(i=0;i<tc;i++)
     {
      out = 0;                
      fgets(s, 80, fp);                       
      sscanf(s,α%dα,&noOfSearchEngines);
      for(j=0;j<noOfSearchEngines;j++)
      {
        fgets(engines[j], 80, fp);    
      }
      // No of queries
      fgets(s, 80, fp);      
      sscanf(s,α%dα,&nq);
      for(k=0;k<nq;k++)
      {
        fgets(queries[k], 80, fp);
        pos = updateefound(noOfSearchEngines,engines,queries[k]);                       
        if(-1 != pos)
          efound[pos] = 1;
        if(isfull(efound,noOfSearchEngines))
        {
          out++;
          for(j=0;j<noOfSearchEngines;j++)
          {
            efound[j] = 0;
          }
          pos = updateefound(noOfSearchEngines,engines,queries[k]);                       
          if(-1 != pos)
           efound[pos] = 1; 
        } 
      }
      printf(αnCase #%d: %dα,i+1,out);
      for(j=0;j<noOfSearchEngines;j++)
      {
        efound[j] = 0;
      }
     }
  }
  return 1;   
 }
 
 
 int updateefound(int n,char engines[100][50],char *queries)
 {
   int i=0,ret=-1;
   for(i=0;i<n;i++)
   {
    if(strcmp(queries,engines[i]) == 0)
    {
    
      ret = i;
      break;                            
    }
   }
   return ret;
 } 
 
 int isfull(int* a, int n)
 {
  int i =0;
  for(i=0;i<n;i++)
  {
    if(a[i] != 1)
      return 0;                
  }
  return 1;               
 }"
8836,2008,32013,PriyaKumar,24481,1,Train.c,gcj/2008/32013/PriyaKumar/24481/1/extracted/Train.c,"#include<stdio.h>
 
 char* convert(char *,char*,char*,int,int);
 int main(int argc,char* argv[])
 {
     char s[80];
     FILE *fp;
     int i=0,j=0,k=0;
     int tt=0,tA=0,tB=0,tc=0;
     int A_dep_hr[100],A_dep_min[100],A_arr_hr[100],A_arr_min[100];
     int B_dep_hr[100],B_dep_min[100],B_arr_hr[100],B_arr_min[100];
     int A_dep_time[100],A_arr_time[100],B_dep_time[100],B_arr_time[100]; 
     int hr,min;
     int A_flag[100],B_flag[100];
     int outA,outB;
     int diff=-1,pos=-1;
     int time;
     fp = fopen(αinput.inα, αrα); 
     if(NULL != fp)
     {
         fgets(s, 80, fp);      
         sscanf(s,α%dα,&tc);
     }
     for(i=0;i<tc;i++)
     {
         fgets(s,80,fp);
         sscanf(s,α%dα,&tt);
         fgets(s,80,fp);
         sscanf(s,α%d %dα,&tA,&tB);
         outA = tA;
         outB = tB;
         for(j=0;j<tA;j++)
         {
             fgets(s,80,fp);
             sscanf(s,α%d:%d %d:%dα,&A_dep_hr[j],&A_dep_min[j],&A_arr_hr[j],&A_arr_min[j]);
             A_flag[j]=0;
             A_dep_time[j]=(A_dep_hr[j] * 60) + A_dep_min[j];
             A_arr_time[j]=(A_arr_hr[j] * 60) + A_arr_min[j];
         }
         for(j=0;j<tB;j++)
         {
             fgets(s,80,fp);
             sscanf(s,α%d:%d %d:%dα,&B_dep_hr[j],&B_dep_min[j],&B_arr_hr[j],&B_arr_min[j]);
             B_flag[j]=0;
             B_dep_time[j]=(B_dep_hr[j] * 60) + B_dep_min[j];
             B_arr_time[j]=(B_arr_hr[j] * 60) + B_arr_min[j];
            // printf(α%d %d %d %d nα,B_dep_hr[j],B_dep_min[j],B_arr_hr[j],B_arr_min[j]);
         }
         
         for(j=0;j<tA;j++)
         {
            time = A_arr_time[j]+tt;
            if(time>=1440)
            {
                continue;
            }
            diff = -1;
            pos = -1;
            for(k=0;k<tB;k++)
            {
                if((time <= B_dep_time[k]) && !B_flag[k] )
                {
                     if ((diff == -1) || (B_dep_time[k] - time <= diff))
                     {
                               pos=k;
                               diff = B_dep_time[k]-time;
                     }
                     
                }
                
            }
            if(pos != -1)
            {
                B_flag[pos]=1;
                outB--;
            }
           
         }
          for(j=0;j<tB;j++)
         {
            time = B_arr_time[j] + tt;
            if(time >= 1440)
            {
                continue;
            }
            diff = -1;
            pos = -1;
            for(k=0;k<tA;k++)
            {
            
               if((time <= A_dep_time[k]) && !A_flag[k] )
                {
                     if ((diff == -1) || (A_dep_time[k] - time <= diff))
                     {
                               pos=k;
                               diff = A_dep_time[k] - time;
                     }
                     
                }
            }
            if(pos != -1)
            {
                A_flag[pos]=1;
                outA--;
            }
         }
         printf(αCase #%d: %d %dnα,i+1,outA,outB);
                          
     }
     return 1;
 }"
8962,2008,32013,Chete,24480,1,pa.c,gcj/2008/32013/Chete/24480/1/extracted/pa.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define DEBG 
 #define INPUTLARGE
 
 
 int main(int argc, char** argv) {
     int n, cases;
     int s, q;
     int i,j,k;
     char engines[100][101];
     char query[101];
     int engstatus[100];
     int engdiscard;
     int switches;
     FILE* input=stdin;
     FILE* output=stdout;
 
 // Ultra-fast switch to use files or stdin-stdout for input-output
 #ifdef INPUTDEMO
     input=fopen(αinputdemoα, αrα);
 #endif    
 #ifdef INPUTSMALL
     input=fopen(αinputsmallα, αrα);
     output=fopen(αoutputsmallα, αwα);
 #endif    
 #ifdef INPUTLARGE
     input=fopen(αinputlargeα, αrα);
     output=fopen(αoutputlargeα, αwα);
 #endif
      
  
     fscanf(input, α%dα,&n);
     for(cases=1; cases<=n; cases++) {
 
         // Engines data
         fscanf(input, α%dnα, &s);
         for(i=0;i<s;i++) {
              fgets(engines[i], 101, input);
              engines[i][strlen(engines[i])-1]='0';
         }
 #ifdef DEBUG
    for(i=0;i<s;i++)
       fprintf(output, αEngine: %snα, engines[i]);
 #endif
         
         // Init variables used to see when we need to switch
         switches=0;
         engdiscard=0;
         for(k=0;k<s;k++) { engstatus[k]=0; }
                     
         
         // Get queries ones by one and process the info
         fscanf(input, α%dnα, &q);        
         for(i=0;i<q;i++) {
             fgets(query, 101, input);
             query[strlen(query)-1]='0';
           
             
 
             // S***, I need  Java hash here! 
             for(j=0;strcmp(query,engines[j])!=0; j++) { ; }
 #ifdef DEBUG
       fprintf(output, αQuery: %s %snα, query, engines[j]);
 #endif            
             // New engine, remove it from the list of possibilities
             if (engstatus[j]==0) {
                 engdiscard++;
                 engstatus[j]++;
 
 #ifdef DEBUG
                 for(k=0;k<s;k++) {  fprintf(output, α%d α, engstatus[k]); } fprintf(output, αnα);
 #endif   
                 // All possible engines have been used, a switch is needed
                 if (engdiscard==s) {
                     switches++;
                     
                     // And now all the engines are available again except the last one
                     engdiscard=1;
                     for(k=0;k<s;k++) { engstatus[k]=0; }
                     engstatus[j]++;
                 }               
             }
         }
         
         // Result output
         fprintf(output, αCase #%d: %dnα, cases, switches);        
     }
             
     
 #ifdef INPUTDEMO
     fclose(input);
 #endif    
 #ifdef INPUTSMALL
     fclose(input);
     fclose(output);
 #endif    
 #ifdef INPUTLARGE
     fclose(input);
     fclose(output);
 #endif
     
     return (EXIT_SUCCESS);
 }"
9026,2008,32013,patrikf,24480,1,universe.c,gcj/2008/32013/patrikf/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
 
 int s;
 char engine[100][101];
 
 #if 0
 int bsearch(char *ref)
 {
     int first = 0;
     int span = s;
     while (span > 1)
     {
 	int i = first+span/2;
 	int r = strcmp(ref, engine[i]);
 	if (r == 0)
 	    return i;
 	if (r < 0)
 	{
 	    span = span/2;
 	}
 	else if (r > 0)
 	{
 	    first += span/2 + 1;
 	    span = span/2 + span%1 - 1;
 	}
     }
     return first;
 }
 #endif
 
 int main(int argc, char **argv)
 {
     int n;
     scanf(α%dnα, &n);
 
     for (int i = 1; i <= n; i++)
     {
 	scanf(α%dnα, &s);
 
 	for (int j = 0; j < s; j++)
 	    gets(engine[j]);
 	qsort(engine, s, 101, strcmp);
 
 	bool used[100];
 	memset(used, 0, sizeof(used));
 	int nused = 0;
 
 	int count = 0;
 
 	int q;
 	scanf(α%dnα, &q);
 	for (int j = 0; j < q; j++)
 	{
 	    char buf[101];
 	    gets(buf);
 	    int idx = ((char *)bsearch(buf, engine, s, 101, strcmp) - (char *)engine)/101;
 	    if (used[idx])
 		continue;
 	    nused++;
 	    if (nused == s)
 	    {
 		count++;
 		nused = 1;
 		memset(used, 0, sizeof(used));
 	    }
 	    used[idx] = 1;
 	}
 
 	printf(αCase #%d: %dnα, i, count);
     }
 }"
9028,2008,32013,patrikf,24479,1,fly.c,gcj/2008/32013/patrikf/24479/1/extracted/fly.c,"#define _BSD_SOURCE
 
 #include <stdio.h>
 #include <math.h>
 
 #define square(x) ((x)*(x))
 
 static double circle_segment_area(double r, double alpha)
 {
     return 0.5 * alpha * square(r);
 }
 
 static double circle_interval_area(double r, double a)
 {
     return circle_segment_area(r, asin(a/r)) + 0.5 * a * sqrt(square(r) - square(a));
 }
 
 static double circle_intersect_infrect(double r, double x, double y)
 {
     if (square(x) + square(y) > square(r))
 	return 0.0;
     return square(r) * M_PI_4 - circle_interval_area(r, x) - circle_interval_area(r, y) + x*y;
 }
 
 static double circle_intersect_rect(double r, double x, double y, double w, double h)
 {
     if (square(x+w) + square(y+h) <= square(r))
 	return w*h;
 
     if (square(x+w) + square(y) > square(r))
     {
 	if (square(x) + square(y+h) > square(r))
 	    return circle_intersect_infrect(r, x, y);
 	double t;
 	/* mirror along first median */
 	t = x; x = y; y = t;
 	t = w; w = h; h = t;
     }
 
     return circle_interval_area(r, x+w) - circle_interval_area(r, x) - w*y - circle_intersect_infrect(r, x, y+h);
 }
 
 double prob(double outer, double inner, double r, double g)
 {
     if (inner < 0.0 || g <= 0.0)
 	return 1.0;
 
     double free_area = 0.0;
     for (double y = r; y < inner; y += g + 2*r)
 	for (double x = r; square(x) + square(y) < square(inner); x += g + 2*r)
 	    free_area += circle_intersect_rect(inner, x, y, g, g);
     free_area *= 4.0;
 
     double total_area = M_PI*square(outer);
     return 1.0 - free_area/total_area;
 }
 
 int main(int argc, char **argv)
 {
     int n;
     scanf(α%dα, &n);
 
     for (int i = 1; i <= n; i++)
     {
 	double f, outer, thickness, r, g;
 	scanf(α%lf %lf %lf %lf %lfα, &f, &outer, &thickness, &r, &g);
 
 	double inner = outer - thickness - f;
 	r += f;
 	g -= 2*f;
 
 	printf(αCase #%d: %.6fnα, i, prob(outer, inner, r, g));
     }
 }"
9030,2008,32013,patrikf,24481,1,train.c,gcj/2008/32013/patrikf/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 
 int turnaround;
 int diff[2][1440];
 
 static void parse(int nx, int from, int to)
 {
     for (int i = 0; i < nx; i++)
     {
 	int h1, m1, h2, m2;
 	scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 
 	int t1 = h1*60+m1;
 	int t2 = h2*60+m2 + turnaround;
 
 	diff[from][t1]--;
 	if (t2 < 1440)
 	    diff[to][t2]++;
     }
 }
 
 int main(int argc, char **argv)
 {
     int n;
     scanf(α%dα, &n);
 
     for (int i = 1; i <= n; i++)
     {
 	int na, nb;
 	scanf(α%d %d %dα, &turnaround, &na, &nb);
 
 	memset(diff, 0, sizeof(diff));
 	parse(na, 0, 1);
 	parse(nb, 1, 0);
 
 	int min[2] = {0, 0};
 	for (int j = 0; j < 2; j++)
 	{
 	    int cur = 0;
 	    for (int k = 0; k < 1440; k++)
 	    {
 		cur += diff[j][k];
 		if (cur < min[j])
 		    min[j] = cur;
 	    }
 	}
 
 	printf(αCase #%d: %d %dnα, i, -min[0], -min[1]);
     }
 }"
9059,2008,32013,longermore,24480,1,a.c,gcj/2008/32013/longermore/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define aDEBUG
 
 char search[100][128];
 int snum[100];
 
 int main (int argc , char * argv[])
 {
 	int n , i , c , j , k;
 	int min , zero , count;
 	int engine , query;
 	char str[128];
 	FILE * fp;
 	if (argc == 1)
 		fp = fopen (α./inputα,αrα);
 	else
 		fp = fopen (argv[1] , αrα);
 	fscanf (fp , α%dα , &n);
 	for (c = 0 ; c < n ; c ++)
 	{
 		count = 0;
 		fscanf (fp , α%dα , &engine);
 		fgets(str , 110 , fp);
 		zero = engine;
 		/*
 		engine = atoi(str);
 		*/
 		#ifdef DEBUG 
 		printf (αengine : %dnα , engine);
 		#endif
 		for (i = 0 ; i < engine ; i++)
 		{
 			fgets(search[i] , 110 , fp);
 			#ifdef DEBUG 
 			printf (α%d : %sα , i , search[i]);
 			#endif
 		}
 		fscanf (fp , α%dα , &query);
 		fgets(str , 110 , fp);
 		#ifdef DEBUG 
 		printf (αquery : %dnα , query);
 		#endif
 		for (i = 0 ; i < engine ; i++)
 			snum[ i ] = 0;
 		for (i = 0 ; i < query ; i++)
 		{
 			fgets(str , 110 , fp);
 			#ifdef DEBUG 
 			printf (α%d/%d : %sα , i , zero - 1, str );
 			#endif
 			for (j = engine - 1 ; j > 0 ; j --)
 				if (strcmp(search[j] , str) == 0)
 					break;
 			if ( snum[j] == 0 )
 			{
 				zero --;
 				if (zero == 0)
 				{
 						count ++;
 						zero = engine - 1;
 						for (k = 0 ; k < engine ; k++)
 							snum[ k ] = 0;
 				}			
 			}
 			snum[ j ] += 1;
 		}
 		/*
 		min = snum[0];
 		for (i = 1 ; i < engine ; i ++)
 			if (min > snum[i])
 				min = snum[i];
 				*/
 		printf (αCase #%d: %dnα , c + 1 , count);
 		#ifdef DEBUG
 		getchar();
 		#endif
 	}
 	return 0;
 }"
9061,2008,32013,longermore,24481,1,b.c,gcj/2008/32013/longermore/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define DaEBUG
 
 int nastart[100] , naend[100];
 int nbstart[100] , nbend[100];
 int t;
 int na , nb;
 
 void quickSort(int a[],int left,int right)
 {
    int i,j,temp;
    i=left;
    j=right;
    temp=a[left];
    if(left>right)
       return;
    while(i!=j)/*ҵλ*/
    {
       while(a[j]>=temp && j>i)
          j--;
       if(j>i)
          a[i++]=a[j];
        while(a[i]<=temp && j>i)
           i++;
        if(j>i)
           a[j--]=a[i];
          
    }
    a[i]=temp;
    quickSort(a,left,i-1);/*ݹ*/
    quickSort(a,i+1,right);/*ݹұ*/
 }
 
 int a(void)
 {
 	int i , j;
 	int start =0;
 	int re = na;
 	for (i = 0 ; i< na ; i ++ )
 		for (j = start ; j< nb ; j ++ )
 			if (nastart[i] >= nbend[j])
 			{
 				start  = j + 1;
 				/*nbend[j] = 24*60;*/
 				re -- ;
 				break;
 			}
 	return re;
 }
 
 int b(void)
 {
 	int i , j;
 	int start = 0;
 	int re = nb;
 	for (i = 0 ; i< nb ; i ++ )
 		for (j = start ; j< na ; j ++ )
 			if (nbstart[i] >= naend[j])
 			{
 				start  = j + 1;
 				/*naend[j]=24*60;*/
 				re -- ;
 				break;
 			}
 	return re;
 }
 
 
 int main (int argc , char * argv[])
 {
 	int n , i , c , j , k;
 	int min , zero , count;
 	int hh , mm;
 	char str[128];
 	FILE * fp;
 	if (argc == 1)
 		fp = fopen (α./inputα,αrα);
 	else
 		fp = fopen (argv[1] , αrα);
 	fscanf (fp , α%dα , &n);
 	for (c = 0 ; c < n ; c ++)
 	{
 		/*************************************/
 		fscanf (fp , α%dα , &t);
 		fscanf (fp , α%d%dα , &na , &nb);
 		
 		for (i = 0 ; i < na ; i++)
 		{
 			fscanf (fp , α%d:%dα , &hh , &mm);
 			nastart[i] = hh*60 + mm;
 			fscanf (fp , α%d:%dα , &hh , &mm);
 			naend[i] = hh*60 + mm + t;
 		}
 		for (i = 0 ; i < nb ; i++)
 		{
 			fscanf (fp , α%d:%dα , &hh , &mm);
 			nbstart[i] = hh*60 + mm;
 			fscanf (fp , α%d:%dα , &hh , &mm);
 			nbend[i] = hh*60 + mm + t;
 		}
 		quickSort(nastart , 0 , na-1);
 		quickSort(naend , 0 , na-1);
 		quickSort(nbstart , 0 , nb-1);
 		quickSort(nbend , 0 , nb-1);
 		#ifdef DEBUG
 		printf (αStart from A:nα);
 		for (i = 0 ; i < na ; i ++)
 		{
 			printf (α%5d  %5dnα , nastart[i] , naend[i]);
 		}
 		printf (αStart from B:nα);
 		for (i = 0 ; i < nb ; i ++)
 		{
 			printf (α%5d  %5dnα , nbstart[i] , nbend[i]);
 		}
 		#endif
 		printf (αCase #%d: %d %dnα , c + 1 , a() , b());
 		#ifdef DEBUG
 		getchar();
 		#endif
 		/*************************************/
 	}
 	return 0;
 }"
9095,2008,32013,dgu,24480,1,save.c,gcj/2008/32013/dgu/24480/1/extracted/save.c,"#include <assert.h>
 #include <stdio.h>
 #include <string.h>
 
 typedef struct {
     char name[101];
     char flag;
 } engine;
 
 typedef struct {
     engine entry[1000];
     unsigned size;
 } engine_list;
 
 /* Sets flag of the engine whose name matches query to 0.  Returns the previous
    value of that engine's flag. */
 char unflag( engine_list* engines, char* query ) {
     char ret;
     unsigned i;
     for( i=0; i<engines->size; i++ ) {
         if( strcmp(query,engines->entry[i].name)==0 ) {
             ret = engines->entry[i].flag;
             engines->entry[i].flag = 0;
             return ret;
         }
     }
 
     /* query is the name of no search engine */
     assert( 0 && αall query names should be a search engine nameα );
     return 0;
 }
 
 /* pick engine for which there is no query for longest time */
 unsigned pick( engine_list* engines, engine_list* querries, unsigned* queryOn )
 {
     unsigned i;
 
     /* all engines an ok choice at first */
     unsigned engLeft = engines->size;
     for( i=0; i<engines->size; i++ )
         engines->entry[i].flag = 1;
 
     /* find the best engine */
     engine* last;
     while( *queryOn<querries->size ) {
         if( engLeft > 1 ) {
             engLeft -= unflag(engines, querries->entry[(*queryOn)++].name);
             if( engLeft == 1 )
                 for( i=0; i<engines->size; i++ )
                     if( engines->entry[i].flag )
                         last = &engines->entry[i];
         }
         else {
             if( strcmp(last->name, querries->entry[*queryOn].name) != 0 )
                 *queryOn += 1;
             else
                 break;
         }
     }
 
     return *queryOn;
 }
 
 int main() {
     engine junk;
     unsigned count, c, i;
     scanf(α%uα, &count);
     for( c=1; c<=count; c++ ) {
         engine_list engines;
         scanf(α%uα, &engines.size);
         gets(junk.name);
         for( i=0; i<engines.size; i++ )
             gets(engines.entry[i].name);
 
         engine_list querries;
         scanf(α%uα, &querries.size);
         gets(junk.name);
         for( i=0; i<querries.size; i++ )
             gets(querries.entry[i].name);
 
         unsigned num_querries = 0;
         unsigned queryOn = 0;
         while( pick(&engines, &querries, &queryOn) != querries.size )
             num_querries += 1;
 
         printf(αCase #%u: %unα, c, num_querries);
     }
 
     return 0;
 }"
9097,2008,32013,dgu,24481,1,train.c,gcj/2008/32013/dgu/24481/1/extracted/train.c,"#include <assert.h>
 #include <stdio.h>
 #include <string.h>
 
 typedef enum {
     STATION_A=0,
     STATION_B=1,
     NUM_STATIONS=2
 } where;
 
 typedef struct {
     unsigned h;
     unsigned m;
 } mytime;
 
 typedef struct {
     mytime depart, arrive;
     where src;
     where dst;
 } trip;
 
 typedef struct {
     where loc;
     int cooldown;
     int transit_time_left;
 } train;
 
 int main() {
     unsigned count, c, i, j;
     scanf(α%uα, &count);
     for( c=1; c<=count; c++ ) {
         unsigned turnaround_min;
         scanf(α%uα, &turnaround_min);
 
         unsigned szAtoB, szBtoA;
         trip trips[200];
         scanf(α%uα, &szAtoB);
         scanf(α%uα, &szBtoA);
         unsigned numTrips = szAtoB + szBtoA;
 
         for( i=0; i<szAtoB; i++ ) {
             scanf(α%u:%uα, &trips[i].depart.h, &trips[i].depart.m);
             scanf(α%u:%uα, &trips[i].arrive.h, &trips[i].arrive.m);
             trips[i].src = STATION_A;
             trips[i].dst = STATION_B;
         }
 
         for( i=0; i<szBtoA; i++ ) {
             scanf(α%u:%uα, &trips[i+szAtoB].depart.h, &trips[i+szAtoB].depart.m);
             scanf(α%u:%uα, &trips[i+szAtoB].arrive.h, &trips[i+szAtoB].arrive.m);
             trips[i+szAtoB].src = STATION_B;
             trips[i+szAtoB].dst = STATION_A;
         }
 
         unsigned numStartAt[NUM_STATIONS];
         unsigned numAt[NUM_STATIONS];
         for( i=0; i<NUM_STATIONS; i++ )
             numAt[i] = numStartAt[i] = 0;
 
         unsigned h = 0, m = 0;
         unsigned num_trains = 0;
         train tr[200];
 
         /* simulate the day */
         while( h <= 23 ) {
             /* advance all trains */
             for( i=0; i<num_trains; i++ ) {
                 if( tr[i].transit_time_left > 0 ) {
                     tr[i].transit_time_left -= 1;
                     if( tr[i]. transit_time_left == 0 )
                         tr[i]. cooldown += turnaround_min;
                 }
                 else if(  tr[i].cooldown > 0 ) {
                     tr[i].cooldown -= 1;
                     if( tr[i].cooldown == 0 )
                         numAt[ tr[i].loc ] += 1;
                 }
             }
 
             /* check schedule for a new train departing at this time */
             for( i=0; i<numTrips; i++ ) {
                 if( trips[i].depart.h==h && trips[i].depart.m==m ) {
                     where src = trips[i].src;
 
                     /* is there a train available? */
                     train* myTrain = NULL;
                     for( j=0; j<num_trains; j++ ) {
                         /* is train at right place and ready to go? */
                         if( tr[j].loc==src && tr[j].transit_time_left==0 && tr[j].cooldown==0 ) {
                             myTrain = &tr[j];
                             break;
                         }
                     }
 
                     /* add another train if one isn't available */
                     if( !myTrain ) {
                         myTrain = &tr[num_trains++];
                         myTrain->cooldown = 0;
                         numStartAt[src] += 1;
                         numAt[src] += 1;
                     }
 
                     /* send the chosen train on its way */
                     myTrain->loc = trips[i].dst;
                     myTrain->transit_time_left = 60*(trips[i].arrive.h-h) + (trips[i].arrive.m-m);
                     numAt[src] -= 1;
                 }
             }
 
             /* tick: next minute */
             m += 1;
             if( m == 60 ) {
                 m = 0;
                 h += 1;
             }
         }
 
         printf(αCase #%u: %u %unα, c, numStartAt[STATION_A], numStartAt[STATION_B]);
     }
 
     return 0;
 }"
9103,2008,32013,sugyan,24480,1,saving_the_universe.c,gcj/2008/32013/sugyan/24480/1/extracted/saving_the_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_LENGTH 128
 #define MAX_S_SIZE 100
 #define MAX_Q_SIZE 1000
 #define ANSWER αCase #α
 
 int min_switch_count(int, int, char [][MAX_LENGTH], char [][MAX_LENGTH]);
 int index_of_engine(int, char [][MAX_LENGTH], char []);
 
 int main(int argc, char *argv[])
 {
     int i, j;
     int N, S, Q;
     int answer;
     char buff[8];
     char engines[MAX_S_SIZE][MAX_LENGTH];
     char queries[MAX_Q_SIZE][MAX_LENGTH];
     FILE *fp;
 
     if (argc < 2) {
         exit(1);
     }
 
     if ((fp = fopen(argv[1], αrα)) != NULL) {
         fgets(buff, sizeof(buff) - 1, fp);
         sscanf(buff, α%dα, &N);
         for (i = 0; i < N; i++) {
             fgets(buff, sizeof(buff) - 1, fp);
             sscanf(buff, α%dα, &S);
             for (j = 0; j < S; j++) {
                 fgets(engines[j], MAX_LENGTH, fp);
             }
             fgets(buff, sizeof(buff) - 1, fp);
             sscanf(buff, α%dα, &Q);
             for (j = 0; j < Q; j++) {
                 fgets(queries[j], MAX_LENGTH, fp);
             }
             answer = min_switch_count(S, Q, engines, queries);
             printf(α%s%d: %dnα, ANSWER, i + 1, answer);
         }
 
         fclose(fp);
     }
 
     return 0;
 }
 
 int min_switch_count(int S, int Q, char engines[][MAX_LENGTH], char queries[][MAX_LENGTH])
 {
     int i, j;
     int count = 0;
     int index, size = 0;
     int index_arr[MAX_S_SIZE];
 
     for (i = 0; i < Q; i++) {
         index = index_of_engine(S, engines, queries[i]);
         for (j = 0; j < size; j++) {
             if (index_arr[j] == index) {
                 break;
             }
         }
         if (j == size) {
             index_arr[size++] = index;
         }
         if (size == S) {
             count++;
             index_arr[0] = index;
             size = 1;
         }
     }
     return count;
 }
 
 int index_of_engine(int S, char engines[][MAX_LENGTH], char str[])
 {
     int i;
 
     for (i = 0; i < S; i++) {
         if (strcmp(engines[i], str) == 0) {
             return i;
         }
     }
     return -1;
 }"
9105,2008,32013,sugyan,24481,1,train_timetable.c,gcj/2008/32013/sugyan/24481/1/extracted/train_timetable.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define BUFF_SIZE 16
 #define TIME_SIZE 8
 #define MAX_SIZE 256
 #define ANSWER αCase #α
 
 void count_train(int, int, int *, int *, int, char [][2][TIME_SIZE]);
 int compare_time(char [], char []);
 void add_time(char [], int);
 
 int main(int argc, char *argv[])
 {
     int i, j;
     int N, T;
     int NA, NB;
     int a_to_b, b_to_a;
     char buff[BUFF_SIZE];
     char timetable[MAX_SIZE][2][TIME_SIZE];
     FILE *fp;
 
     if (argc < 2) {
         exit(1);
     }
 
     if ((fp = fopen(argv[1], αrα)) != NULL) {
         fgets(buff, sizeof(buff) - 1, fp);
         sscanf(buff, α%dα, &N);
         for (i = 0; i < N; i++) {
             fgets(buff, sizeof(buff) - 1, fp);
             sscanf(buff, α%dα, &T);
             fgets(buff, sizeof(buff) - 1, fp);
             sscanf(buff, α%d %dα, &NA, &NB);
             for (j = 0; j < NA + NB; j++) {
                 fgets(buff, sizeof(buff) - 1, fp);
                 sscanf(buff, α%s %sα, timetable[j][0], timetable[j][1]);
             }
             count_train(NA, NB, &a_to_b, &b_to_a, T, timetable);
             printf(α%s%d: %d %dnα, ANSWER, i + 1, a_to_b, b_to_a);
         }
 
         fclose(fp);
     }
 
     return 0;
 }
 
 void count_train(int NA, int NB, int *a_to_b, int *b_to_a, int T, char timetable[][2][TIME_SIZE])
 {
     int i;
     int min_index, next_min_index;
     int next_start, next_size;
     int index_arr[MAX_SIZE];
     char min_time[TIME_SIZE];
     char base_time[TIME_SIZE];
 
     *a_to_b = 0;
     *b_to_a = 0;
     for (i = 0; i < NA + NB; i++) {
         index_arr[i] = 0;
     }
 
     while (1) {
         min_index = -1;
         strcpy(min_time, α24:00α);
         for (i = 0; i < NA + NB; i++) {
             if (index_arr[i] == 0) {
                 if (compare_time(min_time, timetable[i][0]) > 0) {
                     strcpy(min_time, timetable[i][0]);
                     min_index = i;
                 }
             }
         }
         if (min_index == -1) {
             break;
         }
         if (min_index < NA) {
             index_arr[min_index] = ++*a_to_b;
         } else {
             index_arr[min_index] = -++*b_to_a;
         }
 
         while (1) {
             strcpy(base_time, timetable[min_index][1]);
             add_time(base_time, T);
 
             if (min_index < NA) {
                 next_start = NA;
                 next_size = NB;
             } else {
                 next_start = 0;
                 next_size = NA;
             }
 
             next_min_index = -1;
             strcpy(min_time, α24:00α);
             for (i = next_start; i < next_start + next_size; i++) {
                 if (index_arr[i] == 0 && compare_time(timetable[i][0], base_time) >= 0) {
                     if (compare_time(min_time, timetable[i][0]) > 0) {
                         strcpy(min_time, timetable[i][0]);
                         next_min_index = i;
                     }
                 }
             }
             if (next_min_index != -1) {
                 index_arr[next_min_index] = index_arr[min_index];
                 min_index = next_min_index;
             } else {
                 break;
             }
         }
     }
 }
 
 int compare_time(char lhs[], char rhs[])
 {
     int lhs_hour, rhs_hour;
     int lhs_min, rhs_min;
 
     sscanf(lhs, α%d:%dα, &lhs_hour, &lhs_min);
     sscanf(rhs, α%d:%dα, &rhs_hour, &rhs_min);
 
     if (lhs_hour > rhs_hour) {
         return 1;
     } else if (lhs_hour < rhs_hour) {
         return -1;
     } else {
         if (lhs_min > rhs_min) {
             return 1;
         } else if (lhs_min < rhs_min) {
             return -1;
         } else {
             return 0;
         }
     }
 }
 
 void add_time(char target_time[], int T)
 {
     int hour, min;
 
     sscanf(target_time, α%d:%dα, &hour, &min);
     min += T;
     if (min > 59) {
         hour++;
         min -= 60;
     }
     sprintf(target_time, α%02d:%02dα, hour, min);
 }"
9131,2008,32013,r3nder,24480,1,savingB.c,gcj/2008/32013/r3nder/24480/1/extracted/savingB.c,"#include<stdio.h>
 
 #include<string.h>
 
 void leer(char A[][101],int cont,FILE *fp)
 {
 	int I;
 	for (I=0;I<cont;I++)
 	{
 		fscanf(fp,α%[^n]α,A[I]);
 	}
 	
 }
 
 int main()
 
 {
 	//freopen(αA-small.inα,αrbα,stdin);
 	FILE *fp = fopen(αA-large.inα, αrα);
 	FILE *fp2=fopen(αA-large.outα,αwα);
 
 	
 
 	char S[101][101];
 	char B[101];
 	char Q[1001][101];
 	int casos,M,conts,contq,K,swtch=0,disponibles,despl,I;
 	
 	fscanf(fp,α%dα,&casos);
 	
 	//printf(α%dα,casos);
 	
 	for (M=0;M<casos;M++)//parte principal del programa
 	{
 		swtch=0;
 		fscanf(fp,α%dα,&conts);
 		//printf(α%dnα,conts);
 		
 		//fscanf(fp,α%*sα);//,&casos);
 		fgets(S[0],101,fp);
 		//fgetc(fp);
 		for (K=0;K<conts;K++)
 		{
 			//printf(α%dα,K);
 			fgets(S[K],101,fp);
 			//scanf(α%[...]α,S[K]);
 			//fscanf(fp,α%sα,S[K]);
 			//fscanf(fp,α%[^n]α,S[K]);
 			//printf(α%snα,S[K]);
 			
 		}
 		
 		fscanf(fp,α%dα,&contq);
 		//printf(α%dnα,contq);
 		
 		fgets(Q[0],101,fp);
 		for (K=0;K<contq;K++)
 		{
 			//printf(α%dα,K);
 			fgets(Q[K],101,fp);
 			//scanf(α%[...]α,S[K]);
 			//fscanf(fp,α%sα,S[K]);
 			//fscanf(fp,α%[^n]α,S[K]);
 			//printf(α%snα,Q[K]);
 			
 		}
 		////printf(αnnnα);
 		
 		
 		//numero de switches
 		swtch=0;
 		disponibles=conts;
 		despl=0;
 		////printf(αimp=%dα,strcmp(S[0],Q[0]));
 		////printf(αn%s  %snα,S[0],Q[0]);
 		
 		
 		//elige buscador
 		{
 		for (K=0;K<conts;K++)
 			B[K]=0;
 		disponibles=conts;
 		for (K=despl;K<contq;K++)
 		{
 			//compara el query acutal con todos los buscadores
 			for (I=0;I<conts;I++)
 				if (strcmp(Q[K],S[I])==0)
 					{
 					if (B[I]==0)
 					{
 						B[I]=1;
 						disponibles--;
 						break;
 					}
 					}
 				
 			//printf(αdisponibles=%dα,disponibles);
 			if (disponibles==0)
 			break;
 			
 		}
 		
 		
 		
 		
 		
 		//if (disponibles==0)
 		despl=K;
 			
 		}
 		//printf(αK=%dnα,K);
 		//printf(αdesp=%dnα,despl);
 		
 		
 		while( despl<contq)
 		{
 			//elige buscador
 			{
 			for (K=0;K<conts;K++)
 				B[K]=0;
 			disponibles=conts;
 			for (K=despl;K<contq;K++)
 			{
 				//compara el query acutal con todos los buscadores
 				for (I=0;I<conts;I++)
 					if (strcmp(Q[K],S[I])==0)
 						{
 						if (B[I]==0)
 						{
 							B[I]=1;
 							disponibles--;
 							break;
 						}
 						}
 					
 				//printf(αdisponibles=%dα,disponibles);
 				if (disponibles==0)
 				break;
 				
 			}
 		
 		
 		
 		
 		
 			//if (disponibles==0)
 			despl=K;
 			
 			}
 			//printf(αK=%dnα,K);
 			//printf(αdesp=%dnα,despl);
 	swtch++;	
 	}
 		////printf(α%dnα,conts);
 		fprintf(fp2,αCase #%d: %dnα,M+1,swtch);
 	}
 	fclose(fp);
 	fclose(fp2);
 		
 
          return 0;
 }"
9133,2008,32013,r3nder,24481,1,traintableB.c,gcj/2008/32013/r3nder/24481/1/extracted/traintableB.c,"#include<stdio.h>
 #include<string.h>
 short time[1440][4];
 
 void hour (int i)
 {
 	int h;
 	int min;
 	h=i/60;
 	min=i%60;
 	printf(α%d:%d α,h,min);
 	
 }
 int minutos(char h[])
 
 {
 	int m=0;
 	
 	m=(h[0]-48)*10;
 		//printf(α%d α,m);
 	m=m+(h[1]-48);
 		//printf(α%d α,m);
 	m=m*60;
 		//printf(α%d α,m);
 	m=m+(h[3]-48)*10;
 		//printf(α%d α,m);
 	m=m+(h[4]-48);
 	
 	//printf(α%d α,m);
 	
 	//printf(αs=%dα,h[5]);
 	return m; 
 }
 int main()
 {
 	int prim=1;
 	int M,casos,T,NA,NB,I,K,a,b,conta,contb;
 	char hora[10];
 	FILE *fp = fopen(αB-large.inα, αrα);
 	FILE *fp2=fopen(αB-large.outα,αwα);
 	//FILE *fp3=fopen(αdebugα,αwα);
 	
 
 	
 	
 	fscanf(fp,α%dα,&casos);
 	M=0;
 	for (M=0;M<casos;M++)//parte principal del programa
 	{
 		//fprintf(fp3,αncase=%d: α,M+1);
 		if (prim==0)
 			fprintf(fp2,αnα);
 		if (prim==1)
 			prim=0;
 		
 		a=0;b=0;conta=0;contb=0;
 		
 		for (I=0;I<1440;I++)
 			for (K=0;K<4;K++)
 				time[I][K]=0;
 		
 		
 		
 		
 		fscanf(fp,α%dα,&T);
 		fscanf(fp,α%dα,&NA);
 		fscanf(fp,α%dα,&NB);
 		
 		
 		for (I=0;I<NA;I++)
 		{
 			fscanf(fp,α%sα,hora);
 			//printf(α%d α,minutos(hora));
 			time[minutos(hora)][1]++;
 			
 			fscanf(fp,α%sα,hora);
 			//printf(α%d α,minutos(hora));
 			time[minutos(hora)+T][2]++;
 		}
 		for (I=0;I<NB;I++)
 		{
 			fscanf(fp,α%sα,hora);
 			//printf(α%d α,minutos(hora));
 			time[minutos(hora)][3]++;
 			
 			fscanf(fp,α%sα,hora);
 			//printf(α%d α,minutos(hora));
 			time[minutos(hora)+T][0]++;
 		}
 		//printf(αnα);
 		for (I=0;I<1440;I++)
 		{
 			while (time[I][0])
 			{
 				time[I][0]--;
 			//	fprintf(fp3,αA α);
 			
 		//	printf(α A-α);
 			//	hour(I);
 				
 				a++;
 			}
 				
 			while (time[I][1])
 			{
 				time[I][1]--;
 				//fprintf(fp3,αA1 α);
 				if (a)
 					a--;
 				else 
 					conta++;
 				//	printf(α A1-α);
 				//	hour(I);
 				
 					
 			}
 			while (time[I][2])
 			{
 				time[I][2]--;
 				//fprintf(fp3,αB α);
 				b++;
 			//	printf(α B-α);
 			//	hour(I);
 			}
 			while (time[I][3])
 			{
 				time[I][3]--;
 				//fprintf(fp3,αB1 α);	
 				if (b)
 					b--;
 				else 
 					contb++;
 		//			printf(α B1-α);
 			//	hour(I);
 
 			}
 		}
 	
 		//printf(αnα);
 	//printf(αnde a=%d de b=%dnα,conta,contb);
 	
 	fprintf(fp2,αCase #%d: %d %dα,M+1,conta,contb);
 	}
 	fclose(fp);
 	fclose(fp2);
 		
 
          return 0;
 }"
9160,2008,32013,lpm,24480,1,gcj1.c,gcj/2008/32013/lpm/24480/1/extracted/gcj1.c,"#include<stdio.h>
 #include<string.h>
 typedef struct{
 	char nome[101];
 	int pos[1010];
 	int i,f;
 }se;
 
 se enguine[100];
 int query[1000];
 
 int main(){
 	int i,cont,max,maxi,ntc,tc,q,s,j,temp,atual;
 	char qr[101];
 	scanf(α%dα,&ntc);
 	for(tc=1;tc<=ntc;tc++){
 		scanf(α%dα,&s);
 		scanf(α α);
 		for(i=0;i<s;i++){
 			gets(enguine[i].nome);
 			enguine[i].i = 0;
 			enguine[i].f = 1;
 		}
 		scanf(α%dα,&q);
 		scanf(α α);
 		for(i=0;i<q;i++){
 			gets(qr);
 			for(j=0;j<s;j++){
 				if(strcmp(qr,enguine[j].nome)==0)
 					break;
 			}
 			query[i] = j;
 			enguine[j].pos[enguine[j].f] = i;
 			enguine[j].f += 1;
 		}
 		cont = -1;
 		temp = 0;
 		atual = -1;
 		while(temp < q){
 			max = -1;
 			maxi = -1;
 			for(i=0;i<s;i++){
 				if(i==atual)
 					continue;
 				if((enguine[i].i + 1) == enguine[i].f){
 					max = -1;
 					break;
 				}
 				if(enguine[i].pos[enguine[i].i + 1] > max){
 					max = enguine[i].pos[enguine[i].i+1];
 					maxi = i;
 				}
 			}
 			cont++;
 			if(max == -1)
 				break;
 			atual = maxi;
 			for(i=temp;i<max;i++){
 				enguine[query[i]].i += 1;
 			}
 			temp = max;
 		}
 		if(cont==-1)
 			cont = 0;
 		printf(αCase #%d: %dnα,tc,cont);
 	}
 	return 0;
 }"
9162,2008,32013,lpm,24481,1,gcj2.c,gcj/2008/32013/lpm/24481/1/extracted/gcj2.c,"#include<stdio.h>
 #include<stdlib.h>
 
 int comp(const void *a,const void *b){
 	int *x,*y;
 	x = (int*)a;y=(int*)b;
 	if(x[0] < y[0])
 		return -1;
 	return 1;
 }
 
 int main(){
 	int A[101][3];
 	int B[101][3];
 	int t,na,nb,ntc,tc,i,h,min,conta,contb,j;
 
 	scanf(α%dα,&ntc);
 	for(tc=0;tc<ntc;tc++){
 		scanf(α%d %d %dα,&t,&na,&nb);
 		for(i=0;i<na;i++){
 			scanf(α%d:%dα,&h,&min);
 			h = 60*h + min;
 			A[i][0] = h;
 			
 			scanf(α %d:%dα,&h,&min);
 			h = 60*h + min;
 			A[i][1] = h;
 
 			A[i][2] = 0;
 		}
 		for(i=0;i<nb;i++){
 			scanf(α%d:%dα,&h,&min);
 			h = 60*h + min;
 			B[i][0] = h;
 			scanf(α %d:%dα,&h,&min);
 			h = 60*h + min;
 			B[i][1] = h;
 
 			B[i][2] = 0;
 		}
 		qsort(A,na,3*sizeof(int),comp);
 		conta = 0;
 		for(i=0;i<na;i++){
 			for(j=0;j<nb;j++){
 				if((B[j][1]+t <= A[i][0]) && (B[j][2]==0))
 					break;
 			}
 			if(j==nb)
 				conta++;
 			else
 				B[j][2] = 1;
 		}
 
 		qsort(B,nb,3*sizeof(int),comp);
 		contb = 0;
 		for(i=0;i<nb;i++){
 			for(j=0;j<na;j++){
 				if((A[j][1]+t <= B[i][0]) && (A[j][2]==0)){
 					break;
 				}
 			}
 			if(j==na)
 				contb++;
 			else
 				A[j][2] = 1;
 		}
 
 		printf(αCase #%d: %d %dnα,tc+1,conta,contb); 
 	}
 
 	return 0;
 }"
9201,2008,32013,flashdisco,24480,1,search.c,gcj/2008/32013/flashdisco/24480/1/extracted/search.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define BUF_LEN 1024
 #define MAX_ENGINES 100
 
 static int findEngine(char **list, int n, char *val) {
 	int i;
 
 	for (i = 0; i < n; i++) {
 		if (strcmp(list[i], val) == 0) {
 			return i;
 		}
 	}
 
 	return -1;
 }
 
 int main(int argc, char **argv, char **envp) {
 	FILE *f;
 	char *buf;
 	char *engines[MAX_ENGINES];
 	int ef[MAX_ENGINES];
 	int _case, numCases;
 	int numEngines;
 	int query, numQueries;
 	int numTransitions;
 	int i, j, k;
 
 	if (argc < 2) {
 		printf(αusage: %s input_file_namenα, argv[0]);
 		return 0;
 	}
 
 	f = fopen(argv[1], αrα);
 
 	if (f == NULL) {
 		fprintf(stderr, αunable to open input filenα);
 		goto errOpen;
 	}
 
 	buf = (char *)malloc(BUF_LEN);
 
 	if (buf == NULL) {
 		fprintf(stderr, αout of memorynα);
 		goto errMem;
 	}
 
 	for (i = 0; i < MAX_ENGINES; i++) {
 		engines[i] = (char *)malloc(BUF_LEN);
 
 		if (engines[i] == NULL) {
 			goto errMem2;
 		}
 	}
 
 	fscanf(f, α%dnα, &numCases);
 
 	for (_case = 0; _case < numCases; _case++) {
 		fscanf(f, α%dnα, &numEngines);
 
 		for (i = 0; i < numEngines; i++) {
 			ef[i] = 0;
 			fgets(engines[i], BUF_LEN, f);
 		}
 
 		numTransitions = 0;
 
 		fscanf(f, α%dnα, &numQueries);
 
 		for (k = 0, query = 0; query < numQueries; query++) {
 			fgets(buf, BUF_LEN, f);
 			j = findEngine(engines, numEngines, buf);
 
 			if (ef[j] == 0) {
 				ef[j] = 1;
 				k++;
 
 				if (k == numEngines) {
 					numTransitions++;
 					for (k = 1, i = 0; i < numEngines; i++) {
 						ef[i] = 0;
 					}
 					ef[j] = 1;
 				}
 			}
 		}
 
 		printf(αCase #%d: %dnα, _case + 1, numTransitions);
 	}
 
 	for (i = 0; i < MAX_ENGINES; i++) {
 		free(engines[i]);
 	}
 
 	free(buf);
 	fclose(f);
 
 	return 0;
 
 errMem2:
 	free(buf);
 errMem:
 	fclose(f);
 errOpen:
 	return -1;
 }"
9204,2008,32013,flashdisco,24481,1,trains.c,gcj/2008/32013/flashdisco/24481/1/extracted/trains.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int main(int argc, char **argv, char **envp) {
 	FILE *f;
 
 	int ta[24 * 60+999];
 	int tb[24 * 60+999];
 
 	int _case, numCases;
 	int numTA;
 	int numTB;
 	int turnTime;
 	int i, j, s, t, k;
 
 	if (argc < 2) {
 		printf(αusage: %s input_file_namenα, argv[0]);
 		return 0;
 	}
 
 	f = fopen(argv[1], αrα);
 
 	if (f == NULL) {
 		fprintf(stderr, αunable to open input filenα);
 		goto errOpen;
 	}
 
 	fscanf(f, α%dnα, &numCases);
 
 	for (_case = 0; _case < numCases; _case++) {
 		for (i = 0; i < 24 * 60; i++) {
 			ta[i] = 0;
 			tb[i] = 0;
 		}
 
 		fscanf(f, α%dnα, &turnTime);
 
 		fscanf(f, α%d %dnα, &numTA, &numTB);
 
 		for (k = 0; k < numTA; k++) {
 			fscanf(f, α%d:%d %d:%dnα, &i, &j, &s, &t);
 			ta[i * 60 + j]--;
 			tb[s * 60 + t + turnTime]++;
 		}
 
 		for (k = 0; k < numTB; k++) {
 			fscanf(f, α%d:%d %d:%dnα, &i, &j, &s, &t);
 			tb[i * 60 + j]--;
 			ta[s * 60 + t + turnTime]++;
 		}
 
 		for (k = 0, j = 0, i = 0; i < 24 * 60; i++) {
 			j += ta[i];
 
 			if (j < k) {
 				k = j;
 			}
 		}
 
 		k = -k;
 
 		if (k < 0) {
 			k = 0;
 		}
 
 		for (s = 0, j = 0, i = 0; i < 24 * 60; i++) {
 			j += tb[i];
 
 			if (j < s) {
 				s = j;
 			}
 		}
 
 		s = -s;
 
 		if (s < 0) {
 			s = 0;
 		}
 
 		printf(αCase #%d: %d %dnα, _case + 1, k, s);
 	}
 
 	fclose(f);
 
 	return 0;
 
 errOpen:
 	return -1;
 }"
9223,2008,32013,FluteMan06,24481,1,train.c,gcj/2008/32013/FluteMan06/24481/1/extracted/train.c,"/*
 Alex Phillips
 FluteMan06@gmail.com
 */
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 #define MAX_LEN 20
 int* Sort(int values[], int size){
   int i, j, value;
   for (i=1; i<size; i++){
     value = values[i];
     j = i-1;
     while (j >= 0 && values[j] > value){
       values[j+1] = values[j];
       j = j-1;
     }
     values[j+1] = value;
   }
   return values;
 }
 
 void TimeTable(int dNA[], int aNA[], int dNB[], int aNB[], int NA, int NB, int T, int n){
   int A = NA;
   int B = NB;
   int i, j, found;
   for (i=0; i<NA; i++){
     found = 0;
     for (j=0; j<B; j++){
       if (found){
 	if (j+1 <B)
 	  dNB[j] = dNB[j+1];
 	else
 	  B--;
       }
       else if (aNA[i] + T <= dNB[j]){
 	found = 1;
 	if (j+1 <B)
 	  dNB[j] = dNB[j+1];
 	else
 	  B--;
       }
     }
   }
   for (i=0; i<NB; i++){
     found = 0;
     for (j=0; j<A; j++){
       if (found){
 	if (j+1 <A){
 	  dNA[j] = dNA[j+1];
 	}
 	else
 	  A--;
       }
       else if (aNB[i] + T <= dNA[j]){
 	found = 1;
 	if (j+1 <A)
 	  dNA[j] = dNA[j+1];
 	else
 	  A--;
       }
     }
   }
   printf(αCase #%i: %i %inα, n, A, B);
 }
 
 int main(int argc, char**argv){
   char * filename = argv[1];
   FILE * data = fopen(filename, αrα);
   char * str_buf = (char *) malloc((MAX_LEN + 1) * sizeof(char));
   char * dep;
   char * arr;
   fgets(str_buf, MAX_LEN, data);
   int N = atoi(str_buf);
   int n, x;
   for (n=0; n<N; n++){
     fgets(str_buf, MAX_LEN, data);
     int T = atoi(str_buf);
     fgets(str_buf, MAX_LEN, data);
     int NA = atoi(strtok(str_buf, α α));
     int NB = atoi(strtok(NULL, α α));
     int* aNA = malloc(NA * sizeof(int));
     int* dNA = malloc(NA * sizeof(int));
     int* aNB = malloc(NB * sizeof(int));
     int* dNB = malloc(NB * sizeof(int));
     for (x=0; x < NA; x++){
       fgets(str_buf, MAX_LEN, data);
       dep = strtok(str_buf, α α);
       arr = strtok(NULL, α α);
       dNA[x] = atoi(strtok(dep, α:α))*60 + atoi(strtok(NULL, α:α));
       aNA[x] = atoi(strtok(arr, α:α))*60 + atoi(strtok(NULL, α:α));
     }
     dNA = Sort(dNA, NA);
     aNA = Sort(aNA, NA);
     for (x=0; x < NB; x++){
       fgets(str_buf, MAX_LEN, data);
       dep = strtok(str_buf, α α);
       arr = strtok(NULL, α α);
       dNB[x] = atoi(strtok(dep, α:α))*60 + atoi(strtok(NULL, α:α));
       aNB[x] = atoi(strtok(arr, α:α))*60 + atoi(strtok(NULL, α:α));
     }
     dNB = Sort(dNB, NB);
     aNB = Sort(aNB, NB);
     TimeTable(dNA, aNA, dNB, aNB, NA, NB, T, n+1);
   }
   return 0;
 }"
9277,2008,32013,wooon,24480,1,a.c,gcj/2008/32013/wooon/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 
 char engineName[100][101];
 char queries[1000][101];
 //int howMany[1000];
 int howMany2[100];
 
 
 int W,  // # cases
     Y,  // # switches
     S,  // # engines
     Q;  // # queries
 
 int x, y, currEngine, currQuery, bestEngine, tmp;
 
 
 int maxHowmany(int startQueryIdx) {
    int x, y, currEngine, currQuery, bestEngine, k;
 
    for (tmp=0; tmp<100; tmp++) howMany2[tmp] = 0;
 
    for (currEngine=0; currEngine<S; currEngine++) {
       k=0;
       currQuery=startQueryIdx;
 
       for (currQuery=startQueryIdx; currQuery<Q; currQuery++) {
          if (strcmp(queries[currQuery],engineName[currEngine]) != 0) {
             k++;
          } else {
             break;
          }
       }
 
 
       howMany2[currEngine] = k;
       printf(αengine: %d, count: %dnα, currEngine, k);
    }
 
    tmp=0;
    for (currEngine=0; currEngine<S; currEngine++) {
       if (howMany2[currEngine] > tmp) {
          tmp = howMany2[currEngine];
          bestEngine = currEngine;
       }
    }
 
    return bestEngine;
 }
 
 
 
 
 /*
 int findBest(int startQueryIdx) {
    int x, y, currEngine, currQuery, bestEngine, tmp;
 
    for (tmp=0; tmp<1000; tmp++) howMany[tmp] = 0;
 
    for (x=startQueryIdx; x<Q; x++) {
       y=0;
       for (y=0; y<Q; y++) {
          if (strcmp(queries[x],engineName[y]) == 0) {
             howMany[y]++;
          }
       }
    }
    
    tmp=9999;
    for (x=0; x<S; x++) {
       if (howMany[x] < tmp) {
          tmp = howMany[x];
          bestEngine = x;
       }
    }
 
    return bestEngine;
 }*/
 
 
 int main (void) {
    int currCase=0, currEngine=0, theBest, tmp,  tmp2, processed, switches, count;
 
    FILE *infile = fopen(αA-large.inα, αrα);
    FILE *outfile = fopen(αoutputα, αwα);
 
    if (infile==NULL || outfile==NULL) { 
       printf(αerroreα);
    }
 
 
    fscanf(infile, α%dα, &W);
    for (currCase=0; currCase<W; currCase++) {
       fscanf(infile, α%dα, &S);
       fgets(engineName[0], 100, infile);
       for (currEngine=0; currEngine<S; currEngine++) {
          fgets(engineName[currEngine], 100, infile);         
          tmp = strlen(engineName[currEngine]);
          engineName[currEngine][tmp-1] = '0';
          printf(αengine n.%d: %snα, currEngine, engineName[currEngine]);
       }
 
       fscanf(infile, α%dα, &Q);
       fgets(queries[0], 100, infile);
       for (currEngine=0; currEngine<Q; currEngine++) {
          fgets(queries[currEngine], 100, infile);
          tmp = strlen(queries[currEngine]);
          queries[currEngine][tmp-1] = '0';
          printf(αquery n.%d: %snα, currEngine, queries[currEngine]);
       }
       // solves the test case..
       /*
       processed = 0;
       switches = 0;
       for (processed=0; processed<Q; processed++) {
          theBest = findBest(processed);
          for (tmp=0; tmp<S; tmp++){ printf(α%d %dnα, tmp, howMany[tmp]);}
          printf(α>> %dnα, theBest);
          while (strcmp(queries[processed],engineName[theBest])!=0 && processed<Q) processed++;
          switches++;
       }
 
       if (switches>0) --switches; 
       */
 
       processed = 0;
       count = 0;
 
       if (Q==0) {
          tmp = 0;
       } else {
          while (processed<Q) {
             maxHowmany(processed);
 
             tmp2=0;
 
             for (currEngine=0; currEngine<S; currEngine++) {
                if (howMany2[currEngine] > tmp2) {
                   tmp2 = howMany2[currEngine];
                   bestEngine = currEngine;
                }
             }
 
             processed+=tmp2;
             count++;
             printf(αbest: %dnα, bestEngine);
          }
          --count;
       }
 
       printf(αcount: %dnnnα, count);
       fprintf(outfile, αCase #%d: %dnα, currCase+1, count);
       //getchar();
    }
 
 
    fcloseall();
 }"
9279,2008,32013,wooon,24481,1,b.c,gcj/2008/32013/wooon/24481/1/extracted/b.c,"// start 10:24
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int N,  // # cases
     T,  // turnaround time (minutes)
     NA, // # A->B trips
     NB; // # B->A trips
 
 int trainsA[1500];
 int trainsB[1500];
 
 
 int toMinutes(char *time) {
    char hour[3], minutes[3];
 
    hour[0] = time[0];
    hour[1] = time[1];
    hour[2] = '0';
 
    minutes[0] = time[3];
    minutes[1] = time[4];
    minutes[2] = '0';
 
    return (atoi(hour)*60 + atoi(minutes));
 }
 
 
 int main (void) {
    char buff[13];
    int currCase=0, w, j, maxA, maxB, count, begin, end;
 
    FILE *infile = fopen(αB-large.inα, αrα);
    FILE *outfile = fopen(αoutputα, αwα);
 
    if (infile==NULL || outfile==NULL) { 
       printf(αerrorenα);
       return;
    }
 
 
    fscanf(infile, α%dα, &N);
 
    for (currCase=0; currCase<N; currCase++) {
       for (w=0; w<1500; w++) trainsA[w] = trainsB[w] = 0;
 
       printf(α>>> case #%dnα, currCase);
       fscanf(infile, α%dα, &T);
       printf(αturnaround time: %dnα, T);
 
       fscanf(infile, α%d %dα, &NA, &NB);
       printf(αNA: %d, NB: %dnα, NA, NB);
       fgets(buff, 2, infile);      // for 'n'
       
       for (w=0; w<NA; w++) {
          fgets(buff, 13, infile);
          buff[11] = '0';
          begin = toMinutes(buff);
          end = toMinutes(buff+6);
          printf(αtime NA: %s - %d %dnα, buff, begin, end);
 
          for (j=begin; j<1500; j++) trainsA[j]++; 
          for (j=end+T; j<1500; j++) trainsB[j]--; 
       }
     
       for (w=0; w<NB; w++) {
          fgets(buff, 13, infile);
          buff[11] = '0';
          begin = toMinutes(buff);
          end = toMinutes(buff+6);
          printf(αtime NB: %s - %d %dnα, buff, begin, end);
 
          for (j=begin; j<1500; j++) trainsB[j]++; 
          for (j=end+T; j<1500; j++) trainsA[j]--; 
       }
 
       for (j=0; j<1500; j++)  {
          printf(α%dα, trainsA[j]);
          if ((j+1)%60 == 0) printf(αnα);
       }
 
       printf(αnnα);
       
 
 
       maxA = 0;
       maxB = 0;
       for (j=0; j<1500; j++) {
          if (trainsA[j] > maxA) maxA = trainsA[j];
          if (trainsB[j] > maxB) maxB = trainsB[j];
       }          
       printf(αCase #%d: %d %dnα, currCase+1, maxA, maxB);
       fprintf(outfile, αCase #%d: %d %dnα, currCase+1, maxA, maxB);
    }
 
   
 
    fcloseall();
 }"
9355,2008,32013,chin33z,24480,1,mylib.c,gcj/2008/32013/chin33z/24480/1/extracted/mylib.c,"#include <iostream>
 #include <fstream>
 #include <stdlib.h>
 #include <string>
 #include <vector>
 
 using namespace std;
 
 //void StringSplit2Int(string, string, vector<int>&);
 //void StringSplit(string, string, vector<string>&);
 
 //int main(int argc, char *argv[]){
 //	string str=α23 54 1 543 86 0 76α;
 //	vector<int> numbers;
 //	StringSplit2Int(str,α α,numbers);
 //	
 //	return 0;
 //}
 
 void StringSplit(string str, string delim, vector<string>& results){
 	
 	results.clear();
 	int cutAt;
 	while ((cutAt = str.find_first_of(delim)) != str.npos ){
 		if (cutAt > 0)	results.push_back(str.substr(0,cutAt));
 		str = str.substr(cutAt+1);
 	}
 	if (str.length() > 0)	results.push_back(str);
 }
 
 void StringSplit2Int(string str, string delim, vector<int>& out){
 	out.clear();
 	int cutAt;
 	vector<string> results;
 	//split the string
 	while ((cutAt = str.find_first_of(delim)) != str.npos ){
 		if (cutAt > 0)	results.push_back(str.substr(0,cutAt));
 		str = str.substr(cutAt+1);
 	}
 	if (str.length() > 0)	results.push_back(str);
 
 	//string to int
 	for (int i=0;i < results.size(); i++ )	
 		out.push_back(atoi(results[i].c_str()));
 }"
9356,2008,32013,chin33z,24480,1,mytest.c,gcj/2008/32013/chin33z/24480/1/extracted/mytest.c,"#include αmylib.hα
 
 
 int main (int argc, char* argv[]){
 	int num, eng_num, query_num, flag, switch_num, k_tmp;
 	string tmp_str;
 	vector<string> eng,query;
 	vector<bool> eng_b;
 
 	//open file
 	ifstream fin(argv[1]);
 	if (fin.fail()){
 		cerr<< αfailed to open.α<<endl;
 		return 0;}
 
 	//get cases number
 	getline(fin, tmp_str);
 	num = atoi(tmp_str.c_str());
 
 	//solve for each cases
 	for(int i=1; i<=num; i++){
 		
 		getline(fin,tmp_str);
 		eng_num	= atoi (tmp_str.c_str());
 		eng.clear();
 		eng_b.clear();
 		for (int j=0; j < eng_num; j++){
 			getline(fin,tmp_str);
 			eng.push_back(tmp_str);
 			eng_b.push_back(false);
 		}
 
 	//	eng_b[3] = false;
 	//	cout<<eng_b[3]<<α α;
 
 		getline(fin,tmp_str);
 		query_num = atoi (tmp_str.c_str());
 		query.clear();
 		for (int j=0; j < query_num; j++){
 			getline(fin,tmp_str);
 			query.push_back(tmp_str);
 		}
 
 		//eng,query,eng_b  ok
 		
 		flag=0;
 		switch_num = -1;
 		for (int j=0; j < query.size(); j++){
 			for (int k=0; k < eng.size(); k++){
 				if ((query[j] == eng[k]) && (eng_b[k] == false)){
 					k_tmp = k;
 					flag++;
 					eng_b[k] = true;
 			//		cout<<eng_b[3]<<α α;
 					break;
 				}
 			}
 			//if (query[j] == αAα) cout<<eng_b[k_tmp]<<α α;
 			if (flag == eng.size()){
 		//		cout<<αHaHaα<<α α;
 				for (int m = 0; m < eng_b.size(); m++)
 					eng_b[m] = false;
 				eng_b[k_tmp] = true;
 				switch_num++;
 				flag = 1;
 			}
 		}
 		switch_num++;
 
 		cout<< αCase #α<<i<<α: α<<switch_num<<endl;
 	}
 
 	return 0;
 }"
9361,2008,32013,chin33z,24481,1,mylib.c,gcj/2008/32013/chin33z/24481/1/extracted/mylib.c,"#include <iostream>
 #include <fstream>
 #include <stdlib.h>
 #include <string>
 #include <vector>
 
 using namespace std;
 
 //void StringSplit2Int(string, string, vector<int>&);
 //void StringSplit(string, string, vector<string>&);
 
 //int main(int argc, char *argv[]){
 //	string str=α23 54 1 543 86 0 76α;
 //	vector<int> numbers;
 //	StringSplit2Int(str,α α,numbers);
 //	
 //	return 0;
 //}
 
 void StringSplit(string str, string delim, vector<string>& results){
 	
 	results.clear();
 	int cutAt;
 	while ((cutAt = str.find_first_of(delim)) != str.npos ){
 		if (cutAt > 0)	results.push_back(str.substr(0,cutAt));
 		str = str.substr(cutAt+1);
 	}
 	if (str.length() > 0)	results.push_back(str);
 }
 
 void StringSplit2Int(string str, string delim, vector<int>& out){
 	out.clear();
 	int cutAt;
 	vector<string> results;
 	//split the string
 	while ((cutAt = str.find_first_of(delim)) != str.npos ){
 		if (cutAt > 0)	results.push_back(str.substr(0,cutAt));
 		str = str.substr(cutAt+1);
 	}
 	if (str.length() > 0)	results.push_back(str);
 
 	//string to int
 	for (int i=0;i < results.size(); i++ )	
 		out.push_back(atoi(results[i].c_str()));
 }"
9362,2008,32013,chin33z,24481,1,mytest.c,gcj/2008/32013/chin33z/24481/1/extracted/mytest.c,"#include αmylib.hα
 #include <algorithm>
 
 bool comp(string, string);
 int Time2Int(string);
 
 int main (int argc, char* argv[]){
 	int num, delay_time, A_out, B_out, out_time, arr_time, A_num, B_num;
 	string tmp_str;
 	vector<string> time_table, tmp_strv;
 	vector<int> tmp_intv, A_queue, B_queue;
 
 	//open file
 	ifstream fin(argv[1]);
 	if (fin.fail()){
 		cerr<< αfailed to open.α<<endl;
 	//	return 0;
 	}
 
 	//get cases number
 	getline(fin, tmp_str);
 	num = atoi(tmp_str.c_str());
 	
 
 	//solve for each cases
 	for(int i=1; i<=num; i++){
 		//get delay_time
 		getline(fin, tmp_str);
 		delay_time = atoi(tmp_str.c_str());
 		
 		//get A_out,B_out
 		tmp_intv.clear();
 		getline(fin, tmp_str);
 		StringSplit2Int(tmp_str, α α, tmp_intv);
 		A_out = tmp_intv[0];
 		B_out = tmp_intv[1];
 		
 		//construct time_table
 		time_table.clear();
 		for (int j = 0; j < A_out; j++){
 			getline(fin, tmp_str);
 			time_table.push_back( tmp_str + α Aα);
 		}
 		for (int j = 0; j < B_out; j++){
 			getline(fin, tmp_str);
 			time_table.push_back( tmp_str + α Bα);
 		}
 		sort(time_table.begin(), time_table.end(), comp);
 
 //		for (int j =0; j < time_table.size(); j++)
 //			cout<< time_table[j]<<endl;
 		
 		//time_table sorted ok
 		A_num = 0;
 		B_num = 0;
 		A_queue.clear();
 		B_queue.clear();
 		for (int j = 0; j < time_table.size(); j++){
 			StringSplit(time_table[j], α α,tmp_strv);
 			out_time = Time2Int(tmp_strv[0]);
 			arr_time = Time2Int(tmp_strv[1]);
 			if (tmp_strv[2] == αAα){
 					A_num++;
 					//if A already have trains
 					for (int k = 0; k < A_queue.size(); k++)
 						if (A_queue[k] <= out_time){
 							A_num--;
 							A_queue.erase(A_queue.begin()+k);
 							break;
 						}
 					//the train move to B
 					B_queue.push_back(arr_time+delay_time);
 			}else{
 					B_num++;
 					//if B already have trains
 					for (int k = 0; k < B_queue.size(); k++)
 						if (B_queue[k] <= out_time){
 							B_num--;
 							B_queue.erase(B_queue.begin()+k);
 							break;
 						}
 					//the train move to A
 					A_queue.push_back(arr_time+delay_time);
 			}
 		}
 		cout<<αCase #α<<i<<α: α<<A_num<<α α<<B_num<<endl;
 	
 	}
 	return 0;
 }
 
 int Time2Int(string str){
 	vector<int> tmp_int;
 	StringSplit2Int(str, α:α, tmp_int);
 	return ((tmp_int[0]*60)+tmp_int[1]);
 }
 
 bool comp(string a, string b){
 	vector<string> str1,str2;
 
 	StringSplit(a, α α, str1);
 	StringSplit(b, α α, str2);
 
 	if (str1[0].compare(str2[0]) == -1)
 		return true;
 	else 
 		return false;
 }"
9438,2008,32013,vivandro,24481,1,fileinput.c,gcj/2008/32013/vivandro/24481/1/extracted/fileinput.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 
 #include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 /*#define DEB() printf(α%s:%d:-->%snα, __FILE__, __LINE__, __FUNCTION__) */
 #define DEB() /* printf(α%s:%d:-->%snα, __FILE__, __LINE__, __FUNCTION__) */
 
 FILE *file; /* declare a FILE pointer */
 char *sEng[101];	/* these will be pointers to argv[] */
 char *qText[1001];	/* these will be pointers to argv[] */
 static int sEngFlag[101];
 int S;
 int Q;
 int T, NA, NB;
 static int avoidedSEngines;
 
 long abDep[202], abArr[202];
 long baDep[202], baArr[202];
 long ta[404], tb[404]; 
 /**********************************************************
 
 **********************************************************/
 
 char argvCopy[5][102];
 char Queries[101][102];
 char Engines[101][102];
 
 bubbleSort(int max, long myarr[])
 {
 	int i,j;
 	DEB();
 	for(i = 0; i < max; i++)
 	{
 		for(j = i+1; j < max; j++)
 		{
 			long t;
 			if(myarr[i] > myarr[j])
 			{
 				t = myarr[i];
 				myarr[i] = myarr[j];
 				myarr[j] = t;
 			}
 		}
 	}
 }
 
 int readmoreinput(int numlines, FILE *fp, char myArr[][102])
 {
 	int i;
 	DEB();
 
 	for(i = 0; i < numlines; i++)
 	{
 		fgets(myArr[i], sizeof(myArr[i]), fp);
 		myArr[i][strlen(myArr[i])-1] = '0';
 	}
 
 	return 0;
 }
 
 int getNaNb()
 {
 	char *na=NULL, *nb=NULL;
 
 	DEB();
 	readmoreinput(1, file, Queries);
 	/* split the two numbers */
 	na = Queries[0];
 
 	nb = strchr(Queries[0], ' ');
 	*nb = '0';
 	nb++;
 	NA = atoi(na);
 	NB = atoi(nb);
 
 	return 0;
 }
 
 int printLines(int ln, long myarr[])
 {
 	int i;
 
 	for(i = 0; i < ln; i++)
 	{
 	/*	printf(αarr==%ldnα, myarr[i]);*/
 	}
 	return 0;
 }
 
 #define getMeT OpenAndReadN
 
 int OpenAndReadN()
 {
 
 	DEB();
 	readmoreinput(1, file, argvCopy);
 /*	printlines(2);
 	puts(αnextα);
 	readmoreinput(3, file, argvCopy);
 	printlines(3);
 	puts(αnextα);
 	readmoreinput(4, file, argvCopy);
 	printlines(4);
 	puts(αnextα);
 */
 	return atoi(argvCopy[0]);
 }
 
 /**********************************************************
 
 **********************************************************/
 
 
 int doWeSwitch(int qindex)
 {
 	int sindex = 0;
 	int i = 0;
 	for(sindex = 0; sindex < S; sindex++)
 	{
 		if( 0 == strcmp(qText[qindex],sEng[sindex]) )
 		{
 			if(sEngFlag[sindex] == 0)
 				avoidedSEngines++, sEngFlag[sindex]=1;
 			break;
 		}
 	}
 
 	if(avoidedSEngines == S)
 	{ /* means we had to switch this time. no avoiding this one */
 		for(i = 0; i < S; i++)
 			sEngFlag[i] = 0;
 
 		/* since even after the switch we have used up one possibility */
 		sEngFlag[sindex] = 1;
 		avoidedSEngines = 1;
 		return 1; 
 	}
 	else
 		return 0; /* a switch could have been dodged */
 }
 
 void convertToTimedNumbers()
 {
 	int i;
 	DEB();
 	for(i = 0; i < NA; i++)
 	{
 		char *hr, *min;
 		
 		hr = sEng[i];
 		min = hr;min++;min++;;min++;
 		hr[2] = min[2] = '0';
 		/*printf(αhr = %s, min = %snα, hr, min);*/
 		abDep[i] = 60*atoi(hr) + atoi(min);
 		hr = min; hr++;hr++;hr++;
 		min = hr;min++;min++;min++;
 		hr[2] = min[2] = '0';
 		/*printf(αhr = %s, min = %snα, hr, min);*/
 		abArr[i] = 60*atoi(hr) + atoi(min) + T;
 	}
 
 	for(i = 0; i < NB; i++)
 	{
 		char *hr, *min;
 		hr = qText[i];
 		min = hr;min++;min++;min++;
 		hr[2] = min[2] = '0';
 		/*printf(αhr = %s, min = %snα, hr, min);*/
 		baDep[i] = 60*atoi(hr) + atoi(min);
 		hr = min; hr++;hr++;hr++;
 		min = hr;min++;min++;min++;
 		hr[2] = min[2] = '0';
 		/*printf(αhr = %s, min = %snα, hr, min);*/
 		baArr[i] = 60*atoi(hr) + atoi(min) + T;
 	}
 
 }
 
 int solvethis(int testcasenum)
 {
 	int i = 0;
 	int j = 0, ad, aa, bd, ba;
 	int newA = 0, newB = 0, surplus = 0;
 	int numswitches = 0;
 
 	DEB();
 	/* get T */
 	T = getMeT();
 	/* now get and set NA and NB  */
 	getNaNb();
 
 	DEB();
 	/* now read all the engines (trains at NA) */
 	readmoreinput(NA, file, Engines);
 	/* set sEng */
 	for (j = 0; j < NA; j++)
 	{
 		sEng[j] = Engines[j];
 	}
 	/* now read all the queries (trains at NB) */
 	readmoreinput(NB, file, Queries);
 	/* set qText */
 	for (j = 0; j < NB; j++)
 	{
 		qText[j] = Queries[j];
 	}
 	/* convert to timings */
 	convertToTimedNumbers();
 
 	DEB();
 	/* sort all arrs and deps independantly */
 	bubbleSort(NA, abDep);
 	bubbleSort(NA, abArr);
 	bubbleSort(NB, baDep);
 	bubbleSort(NB, baArr);
 	DEB();
 
 /*	puts(αNA, abDepα);
 	printLines(NA, abDep);
 	puts(αNA, abArrα);
 	printLines(NA, abArr);
 	puts(αNB, baDepα);
 	printLines(NB, baDep);
 	puts(αNB, baArrα);
 	printLines(NB, baArr);
 */
 	/* merge all arrs and deps on each station independantly */
 	/* abstract the trains */
 	for(i = 0; i < NA+NB+1; i++)
 		ta[i] = tb[i] = 0;
 	for(i = 0, ad = 0, ba = 0; i < NA+NB; i++)
 	{
 		/*printf(α comparing %ld with %ldnα, baArr[ba], abDep[ad]);*/
 		/* always save arrivals before departures, coz arrs reduce the number of new trains */
 		if(baArr[ba]<=abDep[ad])
 		{
 			ta[i] = -1;
 			ba++;
 		}
 		else
 		{
 			ta[i] = 1;
 			ad++;
 		}
 	}
 /*	puts(αNA+NB, taα);
 	printLines(NA+NB, ta);
 	DEB();*/
 	for(i = 0, bd = 0, aa = 0; i < NA+NB; i++)
 	{
 		/*printf(α comparing %ld with %ldnα, abArr[aa], baDep[bd]);*/
 		if(abArr[aa]<=baDep[bd])
 		{
 			tb[i] = -1;
 			aa++;
 		}
 		else
 		{
 			tb[i] = 1;
 			bd++;
 		}
 	}
 /*	puts(αNA+NB, tbα);
 	printLines(NA+NB, tb);
 	DEB();*/
 	/* find trains to be started from A */
 	for(i = 0, newA = 0, surplus = 0; i < NA+NB; i++)
 	{
 		surplus += ta[i];
 		if(surplus > 0)
 		{
 			newA++;
 			surplus = 0; /* basically, we never want any surplus trains ;) */
 		}
 	}
 
 	/* find trains to be started from B */
 	for(i = 0, newB = 0, surplus = 0; i < NA+NB; i++)
 	{
 		surplus += tb[i];
 		if(surplus > 0)
 		{
 			newB++;
 			surplus = 0; /* basically, we never want any surplus trains ;) */
 		}
 	}
 
 	/* print the output for the program */
 	printf(αCase #%d: %d %dnα, testcasenum+1, newA, newB);
 
 	return (NA+NB+2);
 }
 
 int main(int argc, char *argv[])
 {
 	int N = 0;
 	int Q = 0;
 	int i = 0/*current testcase*/, j = 0/* current search engine or query */;
 	int currentTestcaseStart = 2;
 	int t = 0;
 
 	if(argc < 2)
 		return 0;
 
 	/* open a text file for reading */
 	file = fopen(argv[1], αrα); 
 	if(file==NULL) 
 	{
 		/*printf(αError: can't open file.nα);*/
 		return 1;
 	}
 
 	N = OpenAndReadN();
 
 	if(N == 0)
 		return 0;
 
 	for(i = 0; i < N; i++)
 	{
 		avoidedSEngines = 0;
 		for(t = 0; t < 202; t++)
 			abDep[t] = abArr[t] = baDep[t] = baArr[t] = 9999;
 
 		for(t = 0; t < 404; t++)
 			ta[t] = tb[t] = 0; 
 
 		currentTestcaseStart += solvethis(i);
 	}
 
 	fclose(file);
 	return 0;
 }"
9491,2008,32013,ViniciusCabessa,24480,1,a.c,gcj/2008/32013/ViniciusCabessa/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX (1<<10)
 
 int v[MAX];
 
 char nome[MAX][MAX];
 
 int s, q;
 int cas;
 
 char buff[MAX];
 
 int acha()
 {
 	int i;
 
 	for (i=0; i<s; i++)
 	{
 		if (!strcmp(nome[i], buff))
 			return i;
 	}
 	return -1;
 }
 
 char foi[MAX];
 
 
 int main()
 {
 	int casos, resp;
 	int i, j;
 	int cont;
 
 	gets(buff);
 
 	sscanf(buff, α%dα,&casos);
 
 	for (cas=0; cas<casos; cas++)
 	{
 		gets(buff);
 		sscanf(buff, α%dα, &s);
 		for (i=0; i<s; i++)
 			gets(nome[i]);
 		gets(buff);
 		sscanf(buff, α%dα, &q);
 
 		for (i=0; i<q; i++)
 		{
 			gets(buff);
 			v[i] = acha();
 		}
 
 		for (i=0; i<s; i++)
 			foi[i] = 0;
 
 		cont = 0;
 		resp = 0;
 
 		for (i=0; i<q; i++)
 		{
 			if (!foi[v[i]])
 			{
 				cont++;
 				if (cont == s)
 				{
 					resp++;
 					for (j=0; j<q; j++)
 						foi[j] = 0;
 					cont = 1;
 				}
 				foi[v[i]] = 1;
 			}
 		}
 
 
 		printf(αCase #%d: %dnα, cas+1, resp);
 	}
 
 	return 0;
 }"
9493,2008,32013,ViniciusCabessa,24481,1,b.c,gcj/2008/32013/ViniciusCabessa/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX 128
 
 int na, nb;
 
 typedef struct
 {
 	int x, y;
 	int ori;
 }tipo;
 
 tipo va[MAX], vb[MAX];
 tipo v[MAX+MAX];
 int r[2];
 
 int fc(const void *e1, const void *e2)
 {
 	tipo *p1, *p2;
 
 	p1 = (tipo*)e1;
 	p2 = (tipo*)e2;
 
 	return p1->x - p2->x;
 }
 
 int tem[2][MAX];
 int q[2];
 
 int testa(tipo a)
 {
 	int min, qual;
 
 	int i;
 
 	if (q[a.ori] == 0)
 		return 0;
 	min = tem[a.ori][0];
 	qual = 0;
 
 	for (i=1; i<q[a.ori]; i++)
 	{
 		if (tem[a.ori][i] < min)
 		{
 			min = tem[a.ori][i];
 			qual = i;
 		}
 	}
 
 	if (min <= a.x)
 	{
 		tem[a.ori][qual]=tem[a.ori][q[a.ori]-1];
 		q[a.ori]--;
 		return 1;
 	}
 	return 0;
 }
 
 int main()
 {
 	int cas, casos, a, b, i, t;
 
 	scanf(α%dα,&casos);
 
 	for (cas=1; cas<=casos; cas++)
 	{
 
 		printf(αCase #%d: α,cas);
 		scanf(α%dα,&t);
 
 		scanf(α%d %dα,&na, &nb);
 
 		for (i=0; i<na; i++)
 		{
 			scanf(α%d:%dα, &a, &b);
 			va[i].x = 60*a + b;
 			scanf(α%d:%dα, &a, &b);
 			va[i].y = 60*a + b;
 			va[i].ori = 0;
 		}
 
 		for (i=0; i<nb; i++)
 		{
 			scanf(α%d:%dα, &a, &b);
 			vb[i].x = 60*a + b;
 			scanf(α%d:%dα, &a, &b);
 			vb[i].y = 60*a + b;
 			vb[i].ori = 1;
 		}
 
 		r[0] = r[1] = 0;
 
 		for (i=0; i<na; i++)
 		{
 			v[i] = va[i];
 		}
 
 		for (i=0; i<nb; i++)
 		{
 			v[i+na] = vb[i];
 		}
 
 		qsort(v, na+nb, sizeof(v[0]), fc);
 
 		q[0] = q[1] = 0;
 
 		for (i=0; i<na+nb; i++)
 		{
 			if (!testa(v[i]))
 			{
 				r[v[i].ori]++;
 			}
 /*			printf(α%d %dnα, i, v[i].ori);
 */			tem[(v[i].ori+1)%2][q[(v[i].ori+1)%2]] = v[i].y+t;
 			q[(v[i].ori+1)%2]++;
 		}
 		printf(α%d %dnα,r[0], r[1]);
 
 	}
 	return 0;
 }"
9519,2008,32013,tarunrs,24480,1,1.c,gcj/2008/32013/tarunrs/24480/1/extracted/1.c,"#include <stdio.h>
 #include<string.h>
 
 int num_cases, num_se,num_q,firstOcc[2000],chosenSE=-1,max=0;
 char name[2000][100],query[2000][100];
 
 calcFirst()
 {
 	int i,j,flag=0;
 	for(i=1;i<=num_se;i++)
 	{
 		flag=0;
 		for(j=max+1;j<=num_q;j++)
 		{
 		if(strcmp(name[i],query[j])==0 && i!=chosenSE)
 			{
 			firstOcc[i]=j;
 			flag=1;
 			break;
 			}
 		}
 		if(i!=chosenSE && flag==0)
 			firstOcc[i]=num_q+1;
 		printf(α%dtα,firstOcc[i]);
 	}
 	printf(αnα);
 }
 
 calcMax()
 	{
 		int i;
 		for(i=1;i<=num_se;i++)
 			{
 			if(firstOcc[i]>max && i!=chosenSE)
 				{
 				max=firstOcc[i];
 				chosenSE=i;
 				//printf(αCSE : %dnα,chosenSE);
 				}
 			}
 	}
 
 int main()
 	{
 		int i,j,casen;
 		FILE* rf;
 		FILE* wf;
 		rf=fopen (αinα,αrα);
 		wf=fopen (αoutα,αwα);
 
 		fscanf(rf,α%dnα,&num_cases);
 		printf(α%dnα,num_cases);
 		
 		//iterate thru the cases
 		
 		for(i=1;i<=num_cases;i++)
 			{
 			max=0;chosenSE=-1;
 			// num of search engines
 			fscanf(rf,α%dnα,&num_se);
 			printf(α%dnα,num_se);
 			// read names of SEs
 			for(j=1;j<=num_se;j++)
 				{
 				fgets (name[j],100,rf);
 				//printf(α%snα,name[j]);
 				}
 			// num of queries
 			fscanf(rf,α%dnα,&num_q);
 			printf(α%dnα,num_q);
 			for(j=1;j<=num_q;j++)
 				{
 				fgets (query[j],100,rf);
 				//printf(α%snα,query[j]);
 				}
 			for(j=1;j<=num_se;j++)
 				{
 				firstOcc[i]=num_q+1;
 				}
 			casen=-1;
 			do
 //for(j=0;j<4;j++)
 			{
 			calcFirst();
 			calcMax();
 			casen++;
 			}
 			while (max<=num_q);
 
 			printf(αcase %d : %dnα,i,casen);
 			fprintf (wf,αCase #%d: %dnα,i,casen);
 			}
 		
 	}"
9521,2008,32013,tarunrs,24481,1,2.c,gcj/2008/32013/tarunrs/24481/1/extracted/2.c,"#include <stdio.h>
 #include<string.h>
 
 int t[500][4],na,nb,tt,num_cases;
 
 int check()
 	{
 	int i;
 	for(i=1;i<=(na+nb);i++)
 		{
 		if (t[i][4]==0)
 			return i;
 		}
 	return -1;
 	}
 sort()
 	{
 	int i,j,temp;
 	for(i=1;i<(na+nb);i++)
 		for(j=i+1;j<=(na+nb);j++)
 			{
 			if(t[i][1]>t[j][1])
 				swap (t[i],t[j]);
 			}
 	for(i=1;i<=(na+nb);i++)
 		{
 			printf(α%dt%dt%dnα,t[i][1],t[i][2],t[i][3]);
 		}
 	}
 swap (int a[4], int b[4])
 	{
 	int i,temp[4];
 	for(i=1;i<=4;i++)
 		{
 		temp[i]=a[i];
 		a[i]=b[i];
 		b[i]=temp[i];
 		}
 	}
 
 update (int pos)
 	{
 	int i;
 	int *temp;
 	t[pos][4]=1;
 	temp=t[pos];
 	for(i=pos+1;i<=(na+nb);i++)
 		{
 			if((temp[2]+tt)<=t[i][1] && t[i][3]!=temp[3] && t[i][4]==0)
 				{
 				t[i][4]=1;
 				temp=t[i];
 				}
 		}
 	}
 
 int main()
 	{
 		int i,j,casena,casenb,pos=0;
 		int dhr,dmin,shr,smin;
 		FILE* rf;
 		FILE* wf;
 		rf=fopen (αinα,αrα);
 		wf=fopen (αoutα,αwα);
 
 		fscanf(rf,α%dnα,&num_cases);
 		printf(α%dnα,num_cases);
 		
 		//iterate thru the cases
 		
 		for(i=1;i<=num_cases;i++)
 			{
 			
 
 			fscanf(rf,α%dnα,&tt);
 			printf(α%dnα,tt);
 			fscanf(rf,α%d %dnα,&na,&nb);
 			printf(α%dn%dnα,na,nb);
 			//turn around time = tt
 			for(j=1;j<=na;j++)
 				{
 				fscanf(rf,α%d:%d %d:%dnα,&shr,&smin,&dhr,&dmin);
 				t[j][1]=(shr*60)+smin;
 				t[j][2]=(dhr*60)+dmin;
 				t[j][3]=1;
 				t[j][4]=0;
 				printf(α%dt%dnα,t[j][1],t[j][2]);
 				}
 			for(j=na+1;j<=(nb+na);j++)
 				{
 				fscanf(rf,α%d:%d %d:%dnα,&shr,&smin,&dhr,&dmin);
 				t[j][1]=(shr*60)+smin;
 				t[j][2]=(dhr*60)+dmin;
 				t[j][3]=2;
 				t[j][4]=0;
 				printf(α%dt%dnα,t[j][1],t[j][2]);
 				}
 			// array contains the time table of both the stations
 			sort();
 			pos=1;
 			casena=0;
 			casenb=0;
 
 			while (pos!=-1)
 				{
 				pos=check();				
 				if(t[pos][3]==1 && t[pos][4]==0)
 					{
 					casena++;
 					printf(αA %d tα,t[pos][1]);
 					}
 				else if (t[pos][3]==2 && t[pos][4]==0)
 					{
 					casenb++;
 					printf(αB %d tα,t[pos][1]);
 					}
 
 				update(pos);
 				
 				}
 			
 
 //			if (na==0) casena=0;if (nb==0) casenb=0;
 
 			printf(αcase %d : %dt %dnα,i,casena,casenb);
 			fprintf (wf,αCase #%d: %d %dnα,i,casena,casenb);
 			}
 		
 	}"
9539,2008,32013,nsn,24480,1,universe.c,gcj/2008/32013/nsn/24480/1/extracted/universe.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<iostream>
 #include<string>
 #include <map>
 
 
 using namespace std;
 
 #define T 1
 #define F 0
 
 
 char SENames[101][101], queries[1000][101];
 
 int searchEngineSwitch(string *Query,int iNumQuery,int iNumEngines,map<string,int> mSE)
 {
 	int nswitch=0;	
 	//string *SearchEngineSeq =  new string[iNumQuery];
 	int iQueryIndex,iSEInd,i;
 	
 	map<string, int>::iterator it;
 	// init to -1
 	
 
 	// for each query
 	int full=0;
 	for(iQueryIndex=0;iQueryIndex<iNumQuery;iQueryIndex++)
 	{
 		//iSEInd = 0;
 		//for each search engine
 		for(it=mSE.begin();it!=mSE.end();it++)
 		{
 			if( (Query[iQueryIndex] == it->first) && (it->second==-1) )
 			{
 				it->second = iQueryIndex;
 				full++;
 			}
 			if(full==iNumEngines)
 			{
 				full=0;
 				break;
 			}
 		
 			
 		}
 
 		if(full==0)
 		{
 			// find max
 			/*map<string,int>::iterator itm;
 			it=mSE.begin();
 			int max= it->second;
 			itm = it;
 			it++;
 			for(;it!=mSE.end();it++)
 			{
 				if(max<it->second)
 				{
 					max = it->second;
 					itm = it;
 				}
 			}*/
 
 		// update search engine sequence
 			//SearchEngineSeq[seq++] = itm->first;
 
 		//update query index iterator
 			iQueryIndex--;
 			cout<<iQueryIndex<<endl;
 
 			nswitch++;
 
 		// reinit search engine window to -1
 			for(it=mSE.begin();it!=mSE.end();it++)
 				mSE[it->first] = -1;
 		}
 		
 	}
 
 	//delete[] SearchEngineSeq;
 	return nswitch;
 
 }		
 
 
 
 		
 
 int main(int argc,char **argv)
 {
 	
 	FILE *fpIp,*fpOp;
 	
 	int n=1,num,numSE,numQ,nswitch;
 	int i,j,k;
 	char sename[101],str[101],genStr[3];
 	string temp;
 	//string *query;
 
 	fpIp = fopen(αinput.txtα,αrα);
 	fpOp = fopen(αoutput.txtα,αwα);
 
 	fscanf(fpIp,α%dα,&num);
 	while(n<=num)
 	{
 		map<string,int> mSE;	
 		fscanf(fpIp,α%dα,&numSE);
 		fgets( genStr, 2, fpIp );		
 		i=0;
 		while(i<numSE)
 		{
 			fgets( SENames[i], 100, fpIp );			
 			//temp.string(SENames[i]);
 			mSE.insert(std::pair<string,int>(SENames[i],-1));
 	
 			i++;
 		}
 		
 		fscanf(fpIp,α%dα,&numQ);
 		fgets( genStr, 2, fpIp );
 		j=0;
 		string *query = new string[numQ];
 
 		while(j<numQ)
 		{
 			fgets( queries[j], 100, fpIp );
 			//temp.string(queries[i]);
 			query[j] = queries[j];
 			j++;
 			
 
 		}
 
 		nswitch = searchEngineSwitch(query,numQ,numSE,mSE);
 		fprintf(fpOp,α%s%d%s %dnα,αCase #α,n,α:α,nswitch);
 		n++;
 		delete[] query;
 	}
 
 }"
9567,2008,32013,Manoharan,24480,1,saveuniverse.c,gcj/2008/32013/Manoharan/24480/1/extracted/saveuniverse.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 int N = 0,S = 0,Q = 0;
 char Queries[1010][110];
 char Servers[110][110] ;
 int ServerWeightage[110];
 int LightestWeighingServer = -1;
 int LightestWeight = -1;
 int NumSwitches = -1;
 int numberoftestcases = 0;
 int pos = 0;
 char readline[200];
 int numberofchars = 0;
 
 int zeroarrays()
 {
   int i;
   for(i=0;i<105;i++)
   {
      Servers[i][0] = '0';
      Queries[i][0] = '0';
   }
   return 0;
 }
 
 int zeroserverweightage()
 {
     int i = 0;
     for(i=0;i<110;i++)
 	ServerWeightage[i] = -1;
     return 0;
 
 }
 
 int findpos(char *servername)
 {
    int i = 0;
    for(i=0;i<S;i++)
    {
 	if(0 == strcmp(servername,Servers[i]))
 	    return i;
    }
 }
 
 int findzeroserver()
 {
 	int i = 0;
 	
 	for(i=0;i<S;i++)
 	{
 		if(-1 == ServerWeightage[i])
 			return i;
 	}
 	return -1;
 }
 
 int readinline()
 {
   char c;
   numberofchars = 0;
 /*  while(c=getchar()!='n')
   {
      readline[numberofchars++] = c;
   }
      readline[numberofchars]= '0';*/
    gets(readline);
 } 
 
 
 main()
 {
 	int i,j;
 	int ServerNumber = 0;	
 	readinline();
 	N = atoi(readline);	
 	for(numberoftestcases=0;numberoftestcases<N;numberoftestcases++)
 	{
 	   NumSwitches = -1;		
 	   LightestWeighingServer = -1;
 	   LightestWeight = -1;
 	   pos = 0;
 	   zeroarrays();
 	   
 	   readinline();
 	   S = atoi(readline);
            if (S == 0)
            {
                 printf(αCase #%d: %dnα,numberoftestcases+1,0);
                 continue;
            }
 
 	   for(i=0;i<S;i++)
 	   {
 		readinline();
 		strcpy(Servers[i],readline);
                 /*    fgets(Servers[i],105,stdin); */
            }
 	   
 	   readinline();
 	   Q = atoi(readline);
 	   if (Q == 0)
 	   {
 		printf(αCase #%d: %dnα,numberoftestcases+1,0);
 		continue;
 	   }
 	   for(i=0;i<Q;i++)
 	   {
 		readinline();
                 strcpy(Queries[i],readline);
 
 	       /*fgets(Queries[i],105,stdin);*/
 	  }	    
 	   /* now do the task */
 switched:   zeroserverweightage();
 	   for(i=pos;i<Q;i++) 
 	   {
 		ServerNumber = findpos(Queries[i]);
 		if(-1 == ServerWeightage[ServerNumber])
 		{
 		    if(LightestWeight < i)
 		    {
 			LightestWeighingServer = ServerNumber;
 			LightestWeight = i;
 		    }			 
 		    ServerWeightage[ServerNumber] = i;
 		}
 	   }		    
 	   ServerNumber = findzeroserver();			
 	   if(-1 != ServerNumber)		   	
 	   {
 /*		printf(αGoing with %s servernα,Servers[ServerNumber]);
 */		NumSwitches++;
 		printf(αCase #%d: %dnα,numberoftestcases+1,NumSwitches);		
 	   }
 	   else
 	   {
 		/* now choosing the lease server */
 		 /*printf(αtest case number = %dnα,numberoftestcases);
 		 printf(αThe least weighing server is %dnα,
 			LightestWeighingServer);*/
 /*	 printf(αGoing with %s servernα,Servers[LightestWeighingServer]);	
 */		pos = LightestWeight;
 		NumSwitches++;
 		goto switched;
 	   }
 	}
 }"
9585,2008,32013,n22n,24481,1,B.c,gcj/2008/32013/n22n/24481/1/extracted/B.c,"#include <stdio.h>
 
 int compute(int atrips_d[], int atrips_a[], int na,
 	    int btrips_d[], int btrips_a[], int nb, int t);
 
 int main()
 {
   int n;
   int h, m;
   int resa, resb;
   int t, na, nb;
   int atrips_d[100], atrips_a[100], btrips_d[100], btrips_a[100];
   int i, j;
 
   scanf(α%dnα, &n);
   for (i = 0; i < n; i++) {
     scanf(α%dnα, &t);
     scanf(α%d %dnα, &na, &nb);
     // printf(α%d, %d, %dnα, t, na, nb); // d
     for (j = 0; j < na; j++) {
       scanf(α%d:%d α, &h, &m);
       atrips_d[j] = h*60 + m;
       scanf(α%d:%dnα, &h, &m);
       atrips_a[j] = h*60 + m;
     }
     for (j = 0; j < nb; j++) {
       scanf(α%d:%d α, &h, &m);
       btrips_d[j] = h*60 + m;
       scanf(α%d:%dnα, &h, &m);
       btrips_a[j] = h*60 + m;
     }
 
     resa = compute(atrips_d, atrips_a, na, btrips_d, btrips_a, nb, t);
     resb = compute(btrips_d, btrips_a, nb, atrips_d, atrips_a, na, t);
     printf(αCase #%d: %d %dnα, i+1, resa, resb);
   }
 }
 
 int compute(int atrips_d[], int atrips_a[], int na,
 	    int btrips_d[], int btrips_a[], int nb, int t)
 {
   int i, j, res;
   int tmp;
 
   for (i = 0; i < na - 1; i++) {
     for (j = 1; j < na - i; j++) {
       if (atrips_d[j-1] > atrips_d[j]) {
 	tmp = atrips_d[j-1];
 	atrips_d[j-1] = atrips_d[j];
 	atrips_d[j] = tmp;
 	tmp = atrips_a[j-1];
 	atrips_a[j-1] = atrips_a[j];
 	atrips_a[j] = tmp;
       }
     }
   }
   for (i = 0; i < nb - 1; i++) {
     for (j = 1; j < nb - i; j++) {
       if (btrips_a[j-1] > btrips_a[j]) {
 	tmp = btrips_a[j-1];
 	btrips_a[j-1] = btrips_a[j];
 	btrips_a[j] = tmp;
 	tmp = btrips_d[j-1];
 	btrips_d[j-1] = btrips_d[j];
 	btrips_d[j] = tmp;
       }
     }
   }
 
   i = 0;
   j = 0;
   res = na;
   while (i < na && j < nb) {
     if (btrips_a[j] - atrips_d[i] <= -t) {
       i++;
       j++;
       res--;
     } else {
       i++;
     }
   }
 
   /*for(i = 0 ; i < na; i++)
     printf(α%d, %dnα, atrips_d[i], atrips_a[i]);
   for(i = 0 ; i < nb; i++)
   printf(α%d, %dnα, btrips_d[i], btrips_a[i]);*/
 
   return res;
 }"
9871,2008,32013,sao3,24480,1,A.c,gcj/2008/32013/sao3/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 char se[100][101];
 char now[101];
 int canuse[100];
 FILE *fin, *fout;
 
 void readstring(char *str){
 	int i;
 	for(i = 0; fscanf(fin, α%cα, &str[i]), str[i] != 'n'; i++);
 	str[i] = 0;
 }
 
 int main(){
 	int n, x;
 	int s, q;
 	int i, j;
 	int ans, ava;
 	
 	fin = fopen(αA-small.inα, αrα);
 	fout = fopen(αA-small.outα, αwα);
 	fscanf(fin, α%dα, &n);
 	x = n;
 	while(n-- > 0){
 		fscanf(fin, α%dα, &s);
 		fscanf(fin, α%cα, &now[100]);
 		memset(canuse, 0, sizeof(canuse));
 		ans = 0;
 		ava = s;
 		for(i = 0; i < s; i++){
 			readstring(se[i]);
 		}
 		fscanf(fin, α%dα, &q);
 		fscanf(fin, α%cα, &now[100]);
 		
 		for(i = 0; i < q; i++){
 			readstring(now);
 			for(j = 0; j < s && strcmp(now, se[j]) != 0; j++);
 			if(canuse[j] != 1){
 				canuse[j] = 1;
 				if(--ava == 0){
 					memset(canuse, 0, sizeof(canuse));
 					ans++;
 					canuse[j] = 1;
 					ava = s - 1;
 				}
 			}
 		}
 		fprintf(fout, αCase #%d: %dnα, x - n, ans);
 	}
 	return 0;
 }"
9873,2008,32013,sao3,24481,1,B.c,gcj/2008/32013/sao3/24481/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int ansa, ansb;
 
 typedef struct{
 	int dep;
 	int arr;
 	int sta;
 }time; 
 time train[201];
 int u[201];
 
 void readtime(int *a){
 	char ch;
 	*a = 0;
 	scanf(α%cα, &ch);
 	*a += (ch - '0') * 600;
 	scanf(α%cα, &ch);
 	*a += (ch - '0') * 60;
 	scanf(α%cα, &ch);
 	scanf(α%cα, &ch);
 	*a += (ch - '0') * 10;
 	scanf(α%cα, &ch);
 	*a += (ch - '0');
 	scanf(α%cα, &ch);
 }
 
 int cmp(const void *a, const void *b){
 	return ((const time *)a)->dep - ((const time *)b)->dep;
 }
 
 void go(){
 	int i, j;
 	int t, na, nb;
 	char ch;
 	ansa = ansb = 0;
 	scanf(α%d%d%d%cα, &t, &na, &nb, &ch);
 	for(i = 0; i < na + nb; i++){
 		readtime(&(train[i].dep));
 		readtime(&(train[i].arr));
 		train[i].arr += t;
 		train[i].sta = i < na ? 0 : 1;
 	}
 	memset(u, 0, sizeof(u));
 	qsort(train, na + nb, sizeof(time), cmp);
 	for(i = 0; i < na + nb; i++){
 		if(u[i] == 0){
 			if(train[i].sta == 0)
 				ansa++;
 			else
 				ansb++;
 		}
 		for(j = 0; j < na + nb &&
 				(train[i].arr > train[j].dep || train[i].sta == train[j].sta || u[j] == 1);
 				j++);
 		u[j] = 1;
 	}
 }
 
 int main(){
 	int i, cs;
 	freopen(αB.inα, αrα, stdin);
 	freopen(αB.outα, αwα, stdout);
 	scanf(α%dα, &cs);
 	for(i = 1; i <= cs; i++){
 		go();
 		printf(αCase #%d: %d %dnα, i, ansa, ansb);
 	}
 	return 0;
 }"
9931,2008,32013,Kalenda,24480,1,search.c,gcj/2008/32013/Kalenda/24480/1/extracted/search.c,"#include <stdio.h>
 #include <string.h>
 
 int openInFile();
 int openOutFile();
 int readFile(char* ln);
 int sendOutputBuffer(char* msg);
 int flushOutputBuffer();
 int closeFile(FILE* fpt);
 int initialize();
 int finalize();
 int performTask();
 int handleData();
 
 char outputBuffer[100];
 
 FILE* input;
 FILE* output;
 
 
 
 char searchEngine[100][100];
 
 
 int numEngine;
 int numQuery;
 
 int readEngine();
 int readQuery();
 
 
 
 int main()
 {
 	strcpy(outputBuffer,αα);
     if (!initialize()){
 		system(αPauseα);
 		return 0;
     }
 
     performTask();
 
 	finalize();
     system(αPauseα);
     return 0;
 }
 
 
 int performTask()
 {
     char in[512];
   	int dataSize;
   	int i;
 
 	char txt[20];
 	readFile(in);
 	dataSize = atoi(in);
 	
 	for (i=0;i<dataSize; i++){ //loop for test case
 		sprintf (txt, αCase #%d: α,i+1);
 	    sendOutputBuffer(txt);
  		handleData();
 	}
 	return 1;
 }
 
 int handleData()
 {
     char in[512];
 	char* tpoint;
   	int point[6];
   	int i;
 
 	readEngine();
 	readQuery();
 
 	return 1;
 }
 
 
 int readEngine()
 {
 	int i =0;
     char in[512];
 	readFile(in);
 	numEngine = atoi(in);
 	
 
 	for (i=0;i<numEngine; i++){ //loop for engine
 		readFile(searchEngine[i]);
 	}
 	
 	return 1;
 }
 
 int readQuery()
 {
 	int i =0, y =0;
     char in[512];
 	int numQuery = 0;
 	int engineLeft = numEngine;
 	int numSwitch = 0;
 	char searcher[100][100];
 	char txt[20];
 	
 	
 	readFile(in);
 	numQuery = atoi(in);
 
 	memcpy (searcher,searchEngine,100*numEngine);
 	for (i=0;i<numQuery; i++){ //loop for query
 		readFile(in);
 		for (y=0;y<numEngine;y++){
 			if (!strcmp(in,searcher[y])){
                 if (engineLeft==1){
 	     	 		memcpy (searcher,searchEngine,100*numEngine);
 					numSwitch++;
 					engineLeft = numEngine;
 				}
 				engineLeft--;
 				strcpy(searcher[y],αα);
 				break;
 			}
 		}
 	}
 
 	sprintf (txt, α%dnα,numSwitch);
 	sendOutputBuffer(txt);
 	flushOutputBuffer();
 
 	return 1;
 }
 
 
 
 
 int initialize()
 {
     return openInFile() && openOutFile();
 }
 
 int finalize()
 {
     closeFile(input);
     closeFile(output);
 }
 
 int openInFile()
 {
      FILE* fpt = NULL;
      char name[80];
      fpt = NULL;
      printf(αPlease enter the name of the input file (80 character max): α);
      scanf(α%sα,name);
      input = fopen(name,αrα);
      if (input == NULL){
         printf(αError open FILEnα);
         return 0;
      }
      return 1;
 }
 
 int openOutFile()
 {
      char name[80];
      printf(αPlease enter the name of the output file (80 character max): α);
      scanf(α%sα,name);
      output = fopen(name,αwα);
      if (output == NULL){
         printf(αError creating FILEnα);
         return 0;
      }
      return 1;
 }
 
 int readFile(char* ln)
 {
 	  int temp;
       fgets(ln,80,input);
       temp =strlen(ln)-1;
 	  if(ln[temp]==10)
 	  	ln[temp]=0;
       return 1;
 }
 
 int sendOutputBuffer(char* msg)
 {
     strcat(outputBuffer,msg);
     return 1;
 }
 
 
 int flushOutputBuffer()
 {
     fputs(outputBuffer,output);
     strcpy(outputBuffer,αα);
     return 1;
 }
 
 int closeFile(FILE* fpt)
 {
     if (fpt!=NULL){
         fclose(fpt);
         return 1;
     }
     return 0;
 }"
9933,2008,32013,Kalenda,24481,1,train.c,gcj/2008/32013/Kalenda/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 
 int openInFile();
 int openOutFile();
 int readFile(char* ln);
 int sendOutputBuffer(char* msg);
 int flushOutputBuffer();
 int closeFile(FILE* fpt);
 int initialize();
 int finalize();
 int performTask();
 int handleData();
 
 char outputBuffer[100];
 
 FILE* input;
 FILE* output;
 
 
 
 int Atrip[100][2];
 int Btrip[100][2];
 
 int numA, numB, turn;
 
 int readSchedule();
 int findMin();
 
 
 
 int main()
 {
 	strcpy(outputBuffer,αα);
     if (!initialize()){
 		system(αPauseα);
 		return 0;
     }
 
     performTask();
 
 	finalize();
     system(αPauseα);
     return 0;
 }
 
 
 int performTask()
 {
     char in[512];
   	int dataSize;
   	int i;
 
 	char txt[20];
 	readFile(in);
 	dataSize = atoi(in);
 	
 	for (i=0;i<dataSize; i++){ //loop for test case
 		sprintf (txt, αCase #%d: α,i+1);
 	    sendOutputBuffer(txt);
  		handleData();
 	}
 	return 1;
 }
 
 int handleData()
 {
     char in[512];
 	char* tpoint;
   	int point[6];
   	int i;
   	
 	readFile(in);
 	turn = atoi(in);
 
 	readSchedule();
 	findMin();
 
 	return 1;
 }
 
 int readSchedule()
 {
     char* input;
     char in[512];
     int i;
     
    	readFile(in);
    	
    	input = strtok(in,α α);
    	numA = atoi(input);
 	numB = atoi(strtok(NULL,α α));
 	
 	for (i=0;i<numA;i++){
 	   	readFile(in);
 	   	input = strtok(in,α: α);
 	   	Atrip[i][0]=atoi(input)*60;
 	   	Atrip[i][0]+=atoi(strtok(NULL,α: α));
 	   	Atrip[i][1]=atoi(strtok(NULL,α: α))*60;
 		Atrip[i][1]+=atoi(strtok(NULL,α: α));
 	}
 	
 	for (i=0;i<numB;i++){
 	   	readFile(in);
 	   	input = strtok(in,α: α);
 	   	Btrip[i][0]=atoi(input)*60;
 	   	Btrip[i][0]+=atoi(strtok(NULL,α: α));
 	   	Btrip[i][1]=atoi(strtok(NULL,α: α))*60;
 		Btrip[i][1]+=atoi(strtok(NULL,α: α));
 	}
 
 	return 1;
 }
 
 int findMin()
 {
 	int i, y, aTotal=0, bTotal=0;
 	int found=0;
 	int loc = -1;
 	char txt[20];
 
 	for (i=0;i<numA;i++){
 		for(y=0;y<numB;y++){
 			if ((Btrip[y][1]+turn)<=Atrip[i][0]){
 				//Btrip[y][1]=1500;
 				if (loc==-1 || Btrip[loc][1]<Btrip[y][1])
 					loc = y;
 				found = 1;
 			}
 		}
 		if (!found){
 			aTotal++;
 		}
 		else{
 			Btrip[loc][1]=2400;
 			loc = -1;
 			found = 0;
 		}
 	}
 
 	for (i=0;i<numB;i++){
 		for(y=0;y<numA;y++){
 			if ((Atrip[y][1]+turn)<=Btrip[i][0]){
 				//Btrip[y][1]=1500;
 				if (loc==-1 || Atrip[loc][1]<Atrip[y][1])
 					loc = y;
 				found = 1;
 			}
 		}
 		if (!found){
 			bTotal++;
 		}
 		else{
 			Atrip[loc][1]=2400;
 			loc = -1;
 			found = 0;
 		}
 	}
 
 	sprintf (txt, α%d %dnα,aTotal, bTotal);
 	
 	sendOutputBuffer(txt);
 	flushOutputBuffer();
 	
 	return 1;
 }
 
 
 
 
 int initialize()
 {
     return openInFile() && openOutFile();
 }
 
 int finalize()
 {
     closeFile(input);
     closeFile(output);
 }
 
 int openInFile()
 {
      FILE* fpt = NULL;
      char name[80];
      fpt = NULL;
      printf(αPlease enter the name of the input file (80 character max): α);
      scanf(α%sα,name);
      input = fopen(name,αrα);
      if (input == NULL){
         printf(αError open FILEnα);
         return 0;
      }
      return 1;
 }
 
 int openOutFile()
 {
      char name[80];
      printf(αPlease enter the name of the output file (80 character max): α);
      scanf(α%sα,name);
      output = fopen(name,αwα);
      if (output == NULL){
         printf(αError creating FILEnα);
         return 0;
      }
      return 1;
 }
 
 int readFile(char* ln)
 {
 	  int temp;
       fgets(ln,80,input);
       temp =strlen(ln)-1;
 	  if(ln[temp]==10)
 	  	ln[temp]=0;
       return 1;
 }
 
 int sendOutputBuffer(char* msg)
 {
     strcat(outputBuffer,msg);
     return 1;
 }
 
 
 int flushOutputBuffer()
 {
     fputs(outputBuffer,output);
     strcpy(outputBuffer,αα);
     return 1;
 }
 
 int closeFile(FILE* fpt)
 {
     if (fpt!=NULL){
         fclose(fpt);
         return 1;
     }
     return 0;
 }"
9954,2008,32013,Ghost,24480,1,FILES_new.C,gcj/2008/32013/Ghost/24480/1/extracted/FILES_new.C,"#include<stdio.h>
 main()
 {
 
   FILE* fp;
   FILE* fp1;
   int i,n,s,q,num=1,j,k,swi,a,flag;
   char* str;
  /* char **sengine;*/
   char *query[1000];
   char temp[100][100];
   clrscr();
   fp=fopen(αlarge.inα,αrα);
 
   fp1=fopen(αout.txtα,αwα);
 
   str = (char*) malloc (1024);
 
   fgets(str,1024,fp);
 
   n=atoi(str);
 
 
 
 while(num<=n)
 
 {
 
   fgets(str,1024,fp);
   s=atoi(str);
 
   for(i=0;i<s;i++)
   fgets(str,1024,fp);
 
 
   fgets(str,1024,fp);
   q=atoi(str);
 
 
   for(i=0;i<q;i++)
    {
       fgets(str,1024,fp);
       query[i]=(char *)malloc((strlen(str)+1));
       strcpy(query[i],str);
     }
 
   i=0;swi=0;
   L: k=0;
 
   for(;i<q;i++)
    {
 
        flag=1;
        for(j=0;j<k;j++)
          {
             if(!strcmp(query[i],temp[j]))
                {
 
                  flag=0;
                  break;
                 }
             flag=1;
           }
        if(flag==1&&k<s-1)
          {
             k++;
             strcpy(temp[j],query[i]);
 
           }
        else if(flag==0) continue;
 
        else
             {
                swi++;
                goto L;
              }
    }
 
   fprintf(fp1, αCase #%d: %d nα,num,swi);
   num++;
 
 
 for(i=0;i<q;i++)
 free(query[i]);
 
 
  }
 
   fclose(fp1);
   fclose(fp);
   getch();
 }
 "
9966,2008,32013,piyush,24480,1,universe.c,gcj/2008/32013/piyush/24480/1/extracted/universe.c,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 #define SIZE 1000
 int main()
 {  
    int testcase,output[SIZE]; 
    char server[SIZE][SIZE];
    char query[SIZE][SIZE];
    FILE *fp;
    fp=fopen(αoutput.txtα,αwα);
    int server_size,query_size,index,i,j,no_switch,m,k,max,l;
    int a[SIZE];
    scanf(α%dα,&testcase);
    fflush(stdin);
    for(l=0;l<testcase;l++)
    {
     scanf(α%dα,&server_size);
     fflush(stdin);
     for(m=0;m<server_size;m++)
     {
      gets(server[m]);
                        //       fflush(stdin);
     }                          
     scanf(α%dα,&query_size);
     fflush(stdin);
     for(m=0;m<query_size;m++)
     gets(query[m]);
     j=0;
     
     no_switch=-1;
     while(j<query_size)
     {
       for(i=0;i<server_size;i++)
       {
          index=i;
          for(k=j;k<query_size;k++)
          {
             if(strcmp(server[index],query[k])==0)
             {
                   printf(αIndex for %s=%dnα,server[index],k);
                   break;
             }      
          }
 
          a[index]=k;
       }
       max=a[0];
       for(m=1;m<server_size;m++)
       {
          if(max < a[m])
             max=a[m];
       }
       printf(αmax=%dnα,max);  
       j=max;
       no_switch++;
     }                    
     if(no_switch == -1)
        no_switch=0;             
     output[l]=no_switch;
   }
   for(k=0;k<testcase;k++)
   {
   fprintf(fp,αCase #%d: %dnα,k+1,output[k]);
   }
   fclose(fp);
   getch();                          
 }"
9987,2008,32013,Infy,24480,1,test.c,gcj/2008/32013/Infy/24480/1/extracted/test.c,"/*
 ** test.c
 ** 
 ** Made by (Vasanth Kumar)
 ** Login   <vasanth@portegia>
 ** 
 ** Started on  Thu Jul 17 17:18:32 2008 Vasanth Kumar
 ** Last update Thu Jul 17 18:48:53 2008 Vasanth Kumar
 */
 
 #include <stdio.h>
 #include <string.h>
 
 int main()
 {
     int N;
     scanf(α%dα, &N);
 
     int S, Q, i, j;
     char engineList[100][110];
     int ticks[100];
     int tickCount;
     char query[110];
 
     int caseCount = 1;
     int nSwitches, lastTick;
 
     while(N--){
 	nSwitches = 0;
 
 	scanf(α%dnα, &S);
 	for(i=0; i<S; ++i){
 	    //input the strings into an array. Read as lines, not
 	    //strings.
 	    
 	    gets(engineList[i]);
 
 	    //debug
 	    //printf(α%snα, engineList[i]);
 
 	    ticks[i] = 0;
 	}
 	tickCount = 0;
 
 	scanf(α%dnα, &Q);
 	for(i=0; i<Q; ++i){
 	    //keep ticking off the engines in the list, until
 	    //everything is exhausted. Then, at this point, a switch
 	    //is necessary. Increment the count for the switch and
 	    //then reset the array ticks.
 
 	    gets(query);
 	    for(j=0; j<S; ++j){
 		if(ticks[j] != 1 && strcmp(query, engineList[j]) == 0){
 		    ticks[j] = 1;
 		    ++tickCount;
 		    lastTick = j;
 		    break;
 		}
 	    }
 	    
 	    if(tickCount == S){
 		++nSwitches;
 		for(j=0; j<S; ++j){
 		    ticks[j] = 0;
 		}
 		tickCount = 1;
 		ticks[lastTick] = 1;
 	    }
 	}
 	
 	//print the number of switches necessary. formatted as 
 	//Case #%d: %dn
 	printf(αCase #%d: %dnα, caseCount, nSwitches);
 	++caseCount;
     }
     return 0;
 }"
9989,2008,32013,Infy,24481,1,test.c,gcj/2008/32013/Infy/24481/1/extracted/test.c,"/*
 ** test.c
 ** 
 ** Made by (Vasanth Kumar)
 ** Login   <vasanth@portegia>
 ** 
 ** Started on  Thu Jul 17 23:45:53 2008 Vasanth Kumar
 ** Last update Fri Jul 18 00:50:27 2008 Vasanth Kumar
 */
 
 #include <stdio.h>
 
 struct node{
     int dep;
     int aux;
 };
 
 int comp(const void *a, const void *b)
 {
 //    return ((struct node *)a)->dep - ((struct node *)b)->dep;
     int A = ((struct node *)a)->dep;
     int B = ((struct node *)b)->dep;
     if(A != B){
 	return A - B;
     }else if(((struct node *)a)->aux == 1){
 	return -1;
     }else if(((struct node *)b)->aux == 1){
 	return 1;
     }else{
 	return 0;
     }
 }
 
 
 int main()
 {
     int N, T, caseCount, i;
     scanf(α%dα, &N);
 
     struct node depA[200], depB[200];
     int NA, NB, hours, mins, countA, countB, bufA, bufB;
 
     for(caseCount=1; caseCount<=N; ++caseCount){
 	//scan the turnaround time
 	scanf(α%dα, &T);
 
 	//scan the value of NA and NB
 	scanf(α%d %dα, &NA, &NB);
 
 	//scan the arrival and departure time values
 	for(i=0; i<NA; ++i){
 	    scanf(α%d:%dα, &hours, &mins);
 	    depA[i].dep = 60*hours + mins;
 	    depA[i].aux = 0;
 
 	    scanf(α%d:%dα, &hours, &mins);
 	    depB[i].dep = 60*hours + mins + T;
 	    depB[i].aux = 1;
 	}
 
 	for(i=0; i<NB; ++i){
 	    scanf(α%d:%dα, &hours, &mins);
 	    depB[i+NA].dep = 60*hours + mins;
 	    depB[i+NA].aux = 0;
 
 	    scanf(α%d:%dα, &hours, &mins);
 	    depA[i+NA].dep = 60*hours + mins + T;
 	    depA[i+NA].aux = 1;
 	}
 
 	//debug
 //	printf(αDone reading...nα);
 	    
 	//sort the arrays dep and aux, based on dep
 	qsort(depA, NA+NB, sizeof(struct node), comp);
 	qsort(depB, NA+NB, sizeof(struct node), comp);
 
 
 	//debug
 //	printf(αDone sorting...nα);
 
 	countA = countB = bufA = bufB = 0;
 	//process
 	for(i=0; i<(NA+NB); ++i){
 	    if(depA[i].aux == 0 && bufA == 0){
 		++countA;
 	    }else if(depA[i].aux == 0){
 		--bufA;
 	    }else{
 		++bufA;
 	    }
 
 	    if(depB[i].aux == 0 && bufB == 0){
 		++countB;
 	    }else if(depB[i].aux == 0){
 		--bufB;
 	    }else{
 		++bufB;
 	    }
 	}
 
 	//print
 	printf(αCase #%d: %d %dnα, caseCount, countA, countB);
     }
     
     return 0;
 }"
10194,2008,32013,iizs,24480,1,A.c.txt,gcj/2008/32013/iizs/24480/1/extracted/A.c.txt,"#include <stdio.h>
 
 
 #define SEPARATOR           ' '
 #define LINEBUF_SIZE        (1024 * 1024)
 
 static char *EngineNames[256];
 static char Visited[256];
 static unsigned char    Queries[1000];
 
 unsigned char hash(char *str) {
     unsigned char c = 0;
     int i;
     int l;
 
     l = strlen( str );
     for ( i=0; i<l; ++i ) {
         c += str[i];
     }
     return c;
 }
 
 unsigned int insert(char *str) {
     unsigned char   k;
     k = hash( str );
     while ( EngineNames[k] != NULL ) {
         ++k;
 
         if ( k == 0 ) k = 1;
     }
 
     EngineNames[k] = strdup( str );
 
     return k;
 }
 
 unsigned char lookup(char *str) {
     int k;
     k = hash( str );
     while ( EngineNames[k] != NULL ) {
         if ( strcmp( str, EngineNames[k] ) == 0 ) return k;
         ++k;
     }
 
     return 0;
 }
 
 int solve( int S, int Q ) {
     int     i;
     int     UV = 0;
     int     change = 0;
 
     memset( Visited, 0, 256 * sizeof(char));
     for ( i=0; i<Q; ++i ){
         if ( Visited[ Queries[i] ] == 0 ) {
             Visited[ Queries[i] ] = 1;
             ++UV;
         }
 
         if ( UV == S ) {
             ++change;
             UV = 1;
             memset( Visited, 0, 256 * sizeof(char));
             Visited[ Queries[i] ] = 1;
         }
     }
 
     return change;
 }
 
 int main(int argc, char **argv) {
     FILE    *f;
     char    linebuf[LINEBUF_SIZE];
     int     totalnum = 0;
     int     casenum = 1;
     int     i;
     int     S;
     int     Q;
     //unsigned char k;
 
     if ( argc < 2 ) {
         printf( αUsage: universe inputfilenα );
         return 1;
     }
 
     f = fopen( argv[1], αrα );
     if ( fgets( linebuf, LINEBUF_SIZE, f ) == NULL ) {
         printf( αError: invalid input filenα );
         return 1;
     };
 
     totalnum = atoi( linebuf ) + 1;
     while ( fgets( linebuf, LINEBUF_SIZE, f ) != NULL && casenum < totalnum ) {
         memset( EngineNames, 0, 256 * sizeof(char *));
         memset( Queries, 0, 1000 * sizeof(unsigned char));
 
         S = atoi( linebuf );
         for ( i=0; i<S; ++i ) {
             fgets( linebuf, LINEBUF_SIZE, f );
             insert( linebuf );
         }
 
         /*
         for ( i=0; i<256 ; ++i ) {
             if ( EngineNames[i] != NULL ) {
                 printf ( α%d %s nα, i, EngineNames[i] );
             }
         }
         */
 
         fgets( linebuf, LINEBUF_SIZE, f );
         Q = atoi( linebuf );
         for ( i=0; i<Q; ++i ) {
             fgets( linebuf, LINEBUF_SIZE, f );
             Queries[i] = lookup( linebuf );
             //printf ( α%dnα, Queries[i] );
         }
 
         printf( αCase #%d: %dnα, casenum, solve( S, Q ) );
         ++casenum;
 
         for ( i=0; i<256 ; ++i ) {
             if ( EngineNames[i] != NULL ) {
                 free( EngineNames[i] );
             }
         }
     }
 
     fclose( f );
 
     return 0;
 }"
10196,2008,32013,iizs,24481,1,B.c.txt,gcj/2008/32013/iizs/24481/1/extracted/B.c.txt,"#include <stdio.h>
 #include <stdlib.h>
 
 #define SEPARATOR           ' '
 #define LINEBUF_SIZE        (1024 * 1024)
 
 int encode(int hour, int min, char AB, char DA) {
     short time;
     int ret;
     char *p = (char *) &ret;
 
     time = min + hour * 60;
     memcpy( p + 2, &time, sizeof(short) );
     p[0] = AB;
     p[1] = DA;
 
     return ret;
 }
 
 int decode(int code, int *hour, int *min, char *AB, char *DA) {
     char *p;
     short time;
 
     p = (char *) &code;
     memcpy( &time, p + 2, sizeof(short) );
     *hour = time / 60;
     *min = time % 60;
     *AB = p[0];
     *DA = p[1];
     return 0;
 }
 
 int comp(const void *a, const void *b ) {
     return *((int *) a) - *((int *)b);
 }
 
 int main(int argc, char **argv) {
     FILE    *f;
     char    linebuf[LINEBUF_SIZE];
     int     totalnum = 0;
     int     casenum = 1;
     int     table[400];
     int     NA, NB;
     int     T;
     int     i;
     int     j;
     int     TA, TB;
     int     TA_min, TB_min;
     int     H1, M1, H2, M2;
     char    DA, AB;
 
     if ( argc < 2 ) {
         printf( αUsage: train inputfilenα );
         return 1;
     }
 
     f = fopen( argv[1], αrα );
     if ( fgets( linebuf, LINEBUF_SIZE, f ) == NULL ) {
         printf( αError: invalid input filenα );
         return 1;
     };
 
     totalnum = atoi( linebuf ) + 1;
     while ( fgets( linebuf, LINEBUF_SIZE, f ) != NULL && casenum < totalnum ) {
         T = atoi( linebuf );
 
         fgets( linebuf, LINEBUF_SIZE, f );
         sscanf( linebuf, α%d %dα, &NA, &NB );
 
         j = 0;
         for ( i=0; i<NA; ++i ){
             fgets( linebuf, LINEBUF_SIZE, f );
             sscanf( linebuf, α%d:%d %d:%dα, &H1, &M1, &H2, &M2 );
 
             table[j++] = encode( H1, M1, 'A', 'D' );
             table[j++] = encode( H2, M2 + T, 'B', 'A' );
         }
         for ( i=0; i<NB; ++i ){
             fgets( linebuf, LINEBUF_SIZE, f );
             sscanf( linebuf, α%d:%d %d:%dα, &H1, &M1, &H2, &M2 );
 
             table[j++] = encode( H1, M1, 'B', 'D' );
             table[j++] = encode( H2, M2 + T, 'A', 'A' );
         }
 
         TA = 0;
         TB = 0;
         TA_min = 0;
         TB_min = 0;
 
         qsort( table, j, sizeof(int), &comp );
 
         for ( i=0; i < j; ++i ) {
             decode( table[i], &H1, &M1, &AB, &DA );
             if ( AB == 'A' ) {
                 if ( DA == 'D' ) --TA;
                 else ++TA;
             } else {
                 if ( DA == 'D' ) --TB;
                 else ++TB;
             }
 
             if ( TA_min > TA ) TA_min = TA;
             if ( TB_min > TB ) TB_min = TB;
             //printf ( α%c %c %d:%d => TA: %d, TB: %dnα, DA, AB, H1, M1, TA, TB );
         }
         /*
         if ( convert( source, target, aliennum, answer ) < 0 ) {
             return 2;
         }
         */
         printf( αCase #%d: %d %dnα, casenum, -TA_min, -TB_min );
         ++casenum;
     }
     fclose( f );
 
     return 0;
 }"
10217,2008,32013,caratos,24481,1,Main.c,gcj/2008/32013/caratos/24481/1/extracted/Main.c,"#include <stdio.h>
 #include <string.h>
 
 #define fori(a,b) for(a=0; a<b; a++ )
 
 int getVal( char *ptr ) {
 	int h = (*ptr - '0')*10 + (*(ptr+1)-'0');
 	return h*60 + ((*(ptr+3)-'0')*10 + (*(ptr+4)-'0'));
 }
 int main() {
 	int i,T,N,inst,NA,NB,valA,valB;
 	int linA[1560];
 	int linB[1560];
 	char h1[8], h2[8];
 
 	scanf(α%dα,&N);
 	for( inst=1; inst<=N; inst++ ) {
 		scanf(α%d %d %dα,&T, &NA, &NB);
 		fori( i, 1560 ) linA[i]=linB[i]=0;
 		while( NA-- ) {
 			scanf(α%s %sα,h1,h2);
 			linA[ getVal(h1) ]++;
 			linB[ getVal(h2) + T ]--;
 		}
 		while( NB-- ) {
 			scanf(α%s %sα,h1,h2);
 			linB[ getVal(h1) ]++;
 			linA[ getVal(h2) + T]--;
 		}
 		valA = valB = 0;
 		for( i=1559; i>-1; i-- ) {
 			if( linA[i] > 0 ) break;
 		}
 		while( i>-1 ) {
 			if( linA[i]>0 ) valA+=linA[i];
 			else if( linA[i]<0 ) valA+=linA[i];
 			if( valA<0 ) valA=0;
 			i--;
 		}
 		for( i=1559; i>-1; i-- ) {
 			if( linB[i] > 0 ) break;
 		}
 		while( i>-1 ) {
 			if( linB[i]>0 ) valB+=linB[i];
 			else if( linB[i]<0 ) valB+=linB[i];
 			if( valB<0 ) valB=0;
 			i--;
 		}
 		printf(αCase #%d: %d %dnα,inst,valA,valB);
 	}
 	return 0;
 }"
10233,2008,32013,samsat,24480,1,universe.c,gcj/2008/32013/samsat/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <string.h>
 
 void main()
 {
 	int nocases;
 	int noengines;
 	int noqueries;
 
 	char engines[100][100];
 
 	int queryfound[100];
 
 	char query[100];
 
 	int count = 0;
 
 
 
 	scanf(α%dα,&nocases);
 	while(count < nocases)
 	{
 		++count;
 
 		int noswitches = 0;
 		int countfound = 0;
 
 		int i=0;
 		scanf(α%dα,&noengines);
 		getchar();
 		while(i<noengines)
 		{
 			int j=0;
 			char c = getchar();
 			while(!(c =='n' || c==EOF))
 			{
 				engines[i][j] = c;
 				c = getchar();
 				++j;
 			}
 			engines[i][j] ='0';
 			queryfound[i] = 0;
 			++i;
 		}
 ;
 		i=0;
 		scanf(α%dα,&noqueries);
 		getchar();
 		while(i<noqueries)
 		{
 			int k=0;
 			char c = getchar();
 			while(!(c =='n' || c==EOF))
 			{
 				query[k] = c;
 				c = getchar();
 				++k;
 			}
 			query[k] ='0';
 
 			int j=0;
 			for(;j<noengines;++j)
 			{
 				if(strcmp(query,engines[j])==0)
 				{
 					if(queryfound[j]==0)
 					{
 						queryfound[j] = 1;
 						++countfound;
 					}
 					break;
 				}
 			}
 			if(countfound == noengines)
 			{
 				++noswitches;
 				k=0;
 				for(;k<noengines;++k)
 				{
 					queryfound[k] =0;
 				}
 				queryfound[j] = 1;
 				countfound = 1;
 			}
 			++i;
 		}
 
 		printf(αCase #%d: %dnα,count,noswitches);
 	}
 
 }"
10235,2008,32013,samsat,24481,1,train1.c,gcj/2008/32013/samsat/24481/1/extracted/train1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 
 struct train{
 	int inmidchain;
 	int arrmin;
 	int depmin;
 } traina[100],trainb[100];
 
 void sortindex(int arrindx[], struct train trains[],char ad,int notrains)
 {
 	int i;
 	for(i=0;i<notrains;++i)
 	{
 		arrindx[i] = i;
 	}
 	for(i=0;i<notrains;++i)
 	{
 		for(int j=0;j<notrains;++j)
 		{
 			int bless = 0;
 			if(ad =='a')
 			{
 				if(trains[arrindx[j]].arrmin < trains[arrindx[i]].arrmin)
 					bless = 1;
 			}
 			else
 			{
 				if(trains[arrindx[j]].depmin < trains[arrindx[i]].depmin)
 					bless = 1;
 			}
 			if(bless==1)
 			{
 				int temp;
 				temp = arrindx[i];
 				arrindx[i] = arrindx[j];
 				arrindx[j] = temp;
 			}
 		}
 	}
 }
 
 int main()
 {
 
 	int sortedaarr[100],sortedadep[100],sortedbarr[100],sortedbdep[100];
 
 	int nocases,turnaround;
 	int count = 0;
 	int notrainsa,notrainsb;
 
 	char arrival[6], departure[6];
 
 	scanf(α%dα,&nocases);
 
 	while(count < nocases)
 	{
 		++count;
 		int trainsfroma =0;
 		int trainsfromb =0;
 
 		scanf(α%dα,&turnaround);
 
 		scanf(α%dα,&notrainsa);
 		scanf(α%dα,&notrainsb);
 
 		int i=0;
 		while(i<notrainsa)
 		{
 			scanf(α%sα,departure);
 			scanf(α%sα,arrival);
 
 			int hr = (arrival[0]-'0')*10 + (arrival[1]-'0');
 			traina[i].arrmin = hr*60 + (arrival[3]-'0')*10 + (arrival[4]-'0');
 
 			hr = (departure[0]-'0')*10 + (departure[1]-'0');
 			traina[i].depmin = hr*60 + (departure[3]-'0')*10 + (departure[4]-'0');
 
 			traina[i].inmidchain =0;
 
 			++i;
 		}
 		i=0;
 		while(i<notrainsb)
 		{
 			scanf(α%s %sα,departure,arrival);
 
 			int hr = (arrival[0]-'0')*10 + (arrival[1]-'0');
 			trainb[i].arrmin = hr*60 + (arrival[3]-'0')*10 + (arrival[4]-'0');
 
 			hr = (departure[0]-'0')*10 + (departure[1]-'0');
 			trainb[i].depmin = hr*60 + (departure[3]-'0')*10 + (departure[4]-'0');
 
 			trainb[i].inmidchain =0;
 
 			++i;
 		}
 
 		sortindex(sortedaarr,traina,'a',notrainsa);
 	    sortindex(sortedadep,traina,'d',notrainsa);
 
 	    sortindex(sortedbarr,trainb,'a',notrainsb);
 	    sortindex(sortedbdep,trainb,'d',notrainsb);
 
 		for(i=0;i<notrainsa;++i)
 		{
 			for(int j=0;j<notrainsb;++j)
 			{
 				if((trainb[sortedbdep[j]].inmidchain == 0) &&
 					((traina[sortedaarr[i]].arrmin+turnaround) <= trainb[sortedbdep[j]].depmin))
 				{
 					trainb[sortedbdep[j]].inmidchain = 1;
 					break;
 				}
 			}
 		}
 
 		for(i=0;i<notrainsb;++i)
 		{
 			for(int j=0;j<notrainsa;++j)
 			{
 				if((traina[sortedadep[j]].inmidchain == 0) &&
 					((trainb[sortedbarr[i]].arrmin+turnaround) <= traina[sortedadep[j]].depmin))
 				{
 					traina[sortedadep[j]].inmidchain = 1;
 					break;
 				}
 			}
 		}
 
 		for(i=0;i<notrainsa;++i)
 		{
 			if(traina[i].inmidchain == 0) ++trainsfroma;
 		}
 		for(i=0;i<notrainsb;++i)
 		{
 			if(trainb[i].inmidchain == 0) ++trainsfromb;
 		}
 
 		printf(αCase #%d: %d %dnα,count,trainsfroma,trainsfromb);
 	}
 
 	return 0;
 }"
10279,2008,32013,sahu.ashish,24481,1,TRAIN.C,gcj/2008/32013/sahu.ashish/24481/1/extracted/TRAIN.C,"#include<stdio.h>
 
 #define SUCCESS 1
 #define FAILURE 0
 
 #define MIN_LIMIT_N 1
 #define MAX_LIMIT_N 100
 
 
 #define MIN_LIMIT_NA 0
 #define MAX_LIMIT_NA 100
 
 #define MIN_LIMIT_NB 0
 #define MAX_LIMIT_NB 100
 
 int rtt = 0;
 
 typedef struct train_t_{
   int start_time;
   int start_station;
   struct train_t_ *next;
 }train_t;
 typedef struct schedule_t_{
   int start_time;
   int end_time;
   int start_station;
   struct schedule_t_ *next;
 }schedule_t;
 
 schedule_t * alloc_schedule(){
   schedule_t *new = NULL;
 
   new = (schedule_t *)malloc(sizeof(schedule_t));
 
   if(new == NULL){
     printf(αMemory allocation for schedule failednα);
     exit(0);
   }
   memset((void*)new,0,sizeof(schedule_t));
   return new;
 }
 
 void insert_schedule(schedule_t *head, schedule_t *new_elem){
   schedule_t *prev=NULL, *next=NULL;
 
   prev = head;
   next = head->next;
 
   while((next!=NULL) && (next->start_time < new_elem->start_time)){
 	  if((next->start_time == new_elem->start_time) && ((new_elem->end_time - new_elem->start_time)<= (next->end_time - next->start_time))){
 		  break;
 	  }
     prev = next;
     next = prev->next;
   }
   new_elem->next = prev->next;
   prev->next = new_elem;
 }
 
 void free_schedule(schedule_t *head_schedule){
   schedule_t *next_schedule = head_schedule->next,*tmp = NULL;
 
   while(next_schedule){
     tmp = next_schedule;
     next_schedule = next_schedule->next;
     free(tmp);
   }
 }
 
 train_t * alloc_train(){
   train_t *new = NULL;
 
   new = (train_t *)malloc(sizeof(train_t));
 
   if(new == NULL){
     printf(αMemory allocation for train failednα);
     exit(0);
   }
   memset((void*)new,0,sizeof(train_t));
   return new;
 }
 
 void insert_train(train_t *head, train_t *new_elem){
   train_t *prev=NULL, *next=NULL;
 
   prev = head;
   next = head->next;
 
   while((next!=NULL) && (next->start_time < new_elem->start_time)){
 
     prev = next;
     next = prev->next;
   }
   new_elem->next = prev->next;
   prev->next = new_elem;
 }
 
 void free_train(train_t *head_train){
   train_t *next_train = head_train->next,*tmp = NULL;
 
   while(next_train){
     tmp = next_train;
     next_train = next_train->next;
     free(tmp);
   }
 }
 
 train_t * find_and_remove_train(train_t *head_train, schedule_t *schedule){
 	  train_t *prev=NULL, *next=NULL;
 
   prev = head_train;
   next = head_train->next;
 
   while(next!=NULL){
 
 	  if((next->start_time <= schedule->start_time) && (next->start_station == schedule->start_station)){
 		  prev->next = next->next;
 		  next->next = NULL;
 		  return next;
 	  }
     prev = next;
     next = prev->next;
   }
   return NULL;
 }
 
 void parse_input_file(FILE *input, schedule_t *head_schedule);
 
 int main (int argc, char *argv[])
 {
  
   int num_entries = 0, count = 1;
   int ret_val = 0;
   FILE *input = NULL, *output = NULL;
   schedule_t head_schedule, *next_schedule = NULL;
   train_t head_train, *train_elem = NULL;
   int num_train_a = 0, num_train_b = 0;
 
   if(argc != 3){
     printf(αUsage: ./a.out <input_file_name> <output_file_name> nα);
     return 1;
   }
 
   input = fopen(argv[1], αrα);
   if(input == NULL){
     printf(αError opening input file: %snα, argv[1]);
   }
 
   output = fopen(argv[2], αwα);
   if(output == NULL){
     printf(αError opening input file: %snα, argv[2]);
   }
 
 
   ret_val = fscanf(input,α%dα,&num_entries);
 
   if(ret_val == EOF){
     printf(αThe input file was empty!!nα);
     exit(0);
   }
 
   printf(αNumber of entries: %dnα,num_entries);
 
   if((num_entries < MIN_LIMIT_N) || (num_entries>MAX_LIMIT_N)){
     printf(αInvalid number of input entries!!nα);
     exit(0);
   }
 
   while(num_entries){
     memset((void *)&head_schedule,0,sizeof(schedule_t));
     memset((void *)&head_train,0,sizeof(train_t));
     rtt = 0;
     num_train_a = 0;
     num_train_b = 0;
 
     parse_input_file(input, &head_schedule);
 
     next_schedule = head_schedule.next;
 
     while(next_schedule){
       printf(α%d:%d:%dnα,next_schedule->start_time,next_schedule->end_time,next_schedule->start_station);
 
 
       train_elem = find_and_remove_train(&head_train, next_schedule);
       if(train_elem == NULL){
 	      printf(αNo train foundnα);
 	train_elem = alloc_train();
 	if(next_schedule->start_station == 1){
 	  num_train_a++;
 	}
 	else{
 	  num_train_b++;
 	}
       }else{
 	      printf(αTrain found: start_time %d, start_station %dnα,train_elem->start_time, train_elem->start_station);
       }
 
       train_elem->start_time = next_schedule->end_time + rtt;
       if(next_schedule->start_station == 1){
 	train_elem->start_station = 2;
       }
       else{
         train_elem->start_station = 1;
       }
 
       
       insert_train(&head_train, train_elem);
       
       next_schedule = next_schedule->next;
     }
  
     fprintf(output,αCase #%d: %d %dnα,count,num_train_a,num_train_b);
 
     count++;
     free_schedule(&head_schedule);
     free_train(&head_train);
     
     num_entries--;
   }
   fclose(output);
   fclose(input);
   
   return 0;
 }
 
 void parse_input_file(FILE *input, schedule_t *head_schedule)
 {
   int ret_val = 0;
   int na = 0, nb = 0;
   int start_hr=-1,start_min = -1, end_hr = -1, end_min = -1;
   int start_time=0,end_time=0;
   schedule_t *new_elem = NULL;
   
   ret_val = fscanf(input,α%dα,&rtt);
   if(ret_val == EOF){
     printf(αInvalid input file!!nα);
     exit(0);
   }
 
   printf(αThe rtt is %dnα,rtt);
   
   if((rtt<0) || (rtt>60)){
     printf(αInvalid round trip timenα);
     exit(0);
   }
   
   ret_val = fscanf(input,α%d%dα,&na,&nb);
   if(ret_val == EOF){
     printf(αInvalid input file!!nα);
     exit(0);
   }
 
   if((na<MIN_LIMIT_NA || na>MAX_LIMIT_NA) || (nb<MIN_LIMIT_NB || nb>MAX_LIMIT_NB)){
     printf(αInvalid round trip timenα);
     exit(0);
   }
 
   printf(αNA: %d, NB: %dnα,na,nb);
   
   while(na){
     ret_val = fscanf(input,α%d:%d%d:%dα,&start_hr,&start_min,&end_hr,&end_min);
 
     if(ret_val == EOF){
       printf(αInvalid input file!!nα);
       exit(0);
     }
 
     printf(αStation A: start hr: %d, start min: %d, end_hr: %d, end_min: %dnα,start_hr,start_min,end_hr,end_min);
     
     if((start_hr<0) || (start_hr>23) || (end_hr <0) || (end_hr > 23) || 
         (start_min<0) || (start_min > 59) || (end_min<0) || (end_min > 59)){
       printf(αInvalid time!!nα);
       exit(0);
     }
     
     start_time = (start_hr * 60) + start_min;
     end_time = (end_hr * 60) + end_min;
     
     printf(αStart time in min: %d, end_time in mins: %dnα,start_time, end_time);
     if(start_time > end_time){
       printf(αInvalid input time: start time > end time!!nα);
       exit(0);
     }
 
     new_elem = alloc_schedule();
 
     new_elem->start_time = start_time;
     new_elem->end_time = end_time;
     new_elem->start_station = 1;
 
     insert_schedule(head_schedule, new_elem);
     
     na--;
   }
 
   while(nb){
 
     ret_val = fscanf(input,α%d:%d%d:%dα,&start_hr,&start_min,&end_hr,&end_min);
 
     if(ret_val == EOF){
       printf(αInvalid input file!!nα);
       exit(0);
     }
 
     printf(αStation B: start hr: %d, start min: %d, end_hr: %d, end_min: %dnα,start_hr,start_min,end_hr,end_min);
 
     if((start_hr<0) || (start_hr>23) || (end_hr <0) || (end_hr > 23) || 
         (start_min<0) || (start_min > 59) || (end_min<0) || (end_min > 59)){
       printf(αInvalid time!!nα);
       exit(0);
     }
     
     start_time = (start_hr * 60) + start_min;
     end_time = (end_hr * 60) + end_min;
     
     printf(αStart time in min: %d, end_time in mins: %dnα,start_time, end_time);
     if(start_time > end_time){
       printf(αInvalid input time: start time > end time!!nα);
       exit(0);
     }
 
     new_elem = alloc_schedule();
 
     new_elem->start_time = start_time;
     new_elem->end_time = end_time;
     new_elem->start_station = 2;
 
     insert_schedule(head_schedule, new_elem);
     nb--;
   }
 }"
10293,2008,32013,Ashmer,24480,1,a.c,gcj/2008/32013/Ashmer/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define aDEBUG
 
 char search[100][128];
 int snum[100];
 
 int main (int argc , char * argv[])
 {
     int n , i , c , j , k;
     int min , zero , count;
     int engine , query;
     char str[128];
     if (argc == 1)
 	freopen(α./input.inα,αrα , stdin);
     else
 	freopen(argv[1] , αrα , stdin);
     scanf (α%dα , &n);
     for (c = 0 ; c < n ; c ++)
     {
 	count = 0;
 	scanf (α%dα , &engine);
 	gets(str );
 	zero = engine;
 	for (i = 0 ; i < engine ; i++)
 	{
 	    gets(search[i]);
 	}
 	scanf (α%dα , &query);
 	gets(str);
 	for (i = 0 ; i < engine ; i++)
 	    snum[ i ] = 0;
 	for (i = 0 ; i < query ; i++)
 	{
 	    gets(str);
 	    for (j = engine - 1 ; j > 0 ; j --)
 		if (strcmp(search[j] , str) == 0)
 		    break;
 		if ( snum[j] == 0 )
 		{
 		    zero --;
 		    if (zero == 0)
 		    {
 			count ++;
 			zero = engine - 1;
 			for (k = 0 ; k < engine ; k++)
 			    snum[ k ] = 0;
 		    }
 		}
 		snum[ j ] += 1;
 	}
 	printf (αCase #%d: %dnα , c + 1 , count);
     }
     return 0;
 }"
10295,2008,32013,Ashmer,24481,1,b.c,gcj/2008/32013/Ashmer/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define aDEBUG
 
 int Astart[100] , Aend[100];
 int Bstart[100] , Bend[100];
 int t;
 int na , nb;
 
 void _quicksort(int * data,int left,int right)
 {
     int i,j,temp;
     i=left;
     j=right;
     temp=data[left];
     if(left>right)
 	return;
     while(i!=j)
     {
 	while(data[j]>=temp && j>i)
 	    j--;
 	if(j>i)
 	    data[i++]=data[j];
 	while(data[i]<=temp && j>i)
 	    i++;
 	if(j>i)
 	    data[j--]=data[i];
     }
     data[i]=temp;
     _quicksort(data,left,i-1);
     _quicksort(data,i+1,right);
 }
 
 int QuickSort(int * data , int count)
 {
     _quicksort(data , 0 , -- count);
     return 0;
 
 }
 
 int a(void)
 {
     int i , j;
     int start =0;
     int re = na;
     for (i = 0 ; i< na ; i ++ )
 	for (j = start ; j< nb ; j ++ )
 	    if (Astart[i] >= Bend[j])
 	    {
 		start  = j + 1;
 		re -- ;
 		break;
 	    }
 	    return re;
 }
 
 int b(void)
 {
     int i , j;
     int start = 0;
     int re = nb;
     for (i = 0 ; i< nb ; i ++ )
 	for (j = start ; j< na ; j ++ )
 	    if (Bstart[i] >= Aend[j])
 	    {
 		start  = j + 1;
 		re -- ;
 		break;
 	    }
 	    return re;
 }
 
 int deal(int order)
 {
     int i ;
     int hh , mm;
     char str[128];
     scanf (α%dα , &t);
     scanf (α%d%dα , &na , &nb);
 
     for (i = 0 ; i < na ; i++)
     {
 	scanf (α%d:%dα , &hh , &mm);
 	Astart[i] = hh*60 + mm;
 	scanf (α%d:%dα , &hh , &mm);
 	Aend[i] = hh*60 + mm + t;
     }
     QuickSort(Astart , na);
     QuickSort(Aend , na);
     for (i = 0 ; i < nb ; i++)
     {
 	scanf (α%d:%dα , &hh , &mm);
 	Bstart[i] = hh*60 + mm;
 	scanf (α%d:%dα , &hh , &mm);
 	Bend[i] = hh*60 + mm + t;
     }
     QuickSort(Bstart , nb);
     QuickSort(Bend , nb);
     printf (αCase #%d: %d %dnα , order , a() , b());
     return 0;
 }
 
 
 int main (int argc , char * argv[])
 {
     int n , c;
     FILE * fp;
     if (argc == 1)
 	fp = freopen (α./input.inα,αrα , stdin);
     else
 	fp = freopen (argv[1] , αrα , stdin);
     if (fp == NULL)
 	exit(1);
     scanf (α%dα , &n);
     for (c = 0 ; c < n ; c ++)
     {
 	#ifdef DEBUG
 	printf (αChecknα);
 	#endif
 	deal(c + 1);
     }
     return 0;
 }"
10307,2008,32013,xkcd,24481,1,train.c,gcj/2008/32013/xkcd/24481/1/extracted/train.c,"#include<stdio.h>
 #include<stdlib.h>
 #includeαtrain.hα
 
 int main(){
 
   int ncases;
   int tTime;
   int AtoB;
   int BtoA;
   int i,k;
   scanf(α%dα,&ncases);
   for(i=0;i<ncases;i++){
     scanf(α%d %d %dα,&tTime,&AtoB,&BtoA);
     int numA=0,numB=0;
 
     Train **allTrains = (Train **)malloc((AtoB+BtoA)*sizeof(Train*));
     for(k=0;k<AtoB;k++){
       int hourD,minuteD,hourA,minuteA;
       Train *temp=(Train*)malloc(sizeof(Train));
       scanf(α%d:%d %d:%dα,&hourD,&minuteD,&hourA, &minuteA);
       temp->departTime = 60*hourD+minuteD;
       temp->arriveTime = 60*hourA+minuteA;
       temp->accountedFor=FALSE;
       temp->Atrain =TRUE;
       
       allTrains[k]=temp;
     }
     for(k=AtoB;k<BtoA+AtoB;k++){
       int hourD,minuteD,hourA,minuteA;
       Train *temp=(Train*)malloc(sizeof(Train));
       scanf(α%d:%d %d:%dα,&hourD,&minuteD,&hourA, &minuteA);
       temp->departTime = 60*hourD+minuteD;
       temp->arriveTime = 60*hourA+minuteA;
       temp->accountedFor=FALSE;
       temp->Atrain=FALSE;
       allTrains[k]=temp;
     }
     while(!AllAccountedFor(allTrains,AtoB,BtoA)){
       Train *tempMin = FindOverallMin(allTrains, AtoB,BtoA);
       
       if(tempMin->Atrain==TRUE)
 	numA++;
       else
 	numB++;
       
       while(GetNextTrain(allTrains,&tempMin,AtoB,BtoA,tTime)==1);
       
     } 
     printf(αCase #%d: %d %dnα,i+1,numA,numB);
   }
   return 0;
 }
   
   
 int GetNextTrain(Train **allTrains,Train **prevMin,int AtoB, int BtoA,int timeWait){
   int i;
   Train *tempMin = *prevMin;
 
   for(i=0;i<AtoB+BtoA;i++){
     if((*prevMin)->Atrain!=allTrains[i]->Atrain && allTrains[i]->accountedFor==FALSE){
       if(tempMin==*prevMin){
 	if(tempMin->arriveTime+timeWait<=allTrains[i]->departTime)
 	  tempMin = allTrains[i];
       }
       else{
 	if(allTrains[i]->departTime>=((*prevMin)->arriveTime+timeWait)){
 	  if(allTrains[i]->departTime<tempMin->departTime)
 	    tempMin=allTrains[i];
 	  else if(allTrains[i]->departTime==tempMin->departTime){
 	    if(allTrains[i]->arriveTime<tempMin->arriveTime)
 	      tempMin=allTrains[i];
 	  }
 	}
       }
     }
   }
   
   if(tempMin!=*prevMin){
     tempMin->accountedFor=TRUE;
     *prevMin=tempMin;
     return 1;
   }
   else
     return -1;
 }
 
 Train *FindOverallMin(Train **allTrains, int AtoB, int BtoA){
   int k;
   int minTime;
   minTime = 23*60 + 59;
   Train *minTrain = allTrains[0];
 
   for (k=0;k<AtoB+BtoA;k++){
     if(allTrains[k]->departTime<minTime && allTrains[k]->accountedFor==FALSE){
       minTime = allTrains[k]->departTime;
       minTrain = allTrains[k];
     }
     else if(allTrains[k]->departTime==minTime && allTrains[k]->arriveTime<minTrain->arriveTime && allTrains[k]->accountedFor==FALSE){
       minTrain=allTrains[k];
     }
   }
   
   minTrain->accountedFor=TRUE;
   return minTrain;
 }
   
 BOOLEAN AllAccountedFor(Train ** allTrains,int AtoB,int BtoA){
   int k;
   for(k=0;k<AtoB+BtoA;k++)
     if(allTrains[k]->accountedFor==FALSE)
       return FALSE;
   
   return TRUE;
 }"
10348,2008,32013,RuiJia,24480,1,savingUniverse.c,gcj/2008/32013/RuiJia/24480/1/extracted/savingUniverse.c,"#include <stdio.h>
 #include <string.h> 
 
 #define MAX_LINE 260 
 
 
 int main()
 {
     int caseCount=0;
     int engineCount=0;
     int queryCount=0; 
     int ci,j,k,p; 
     int* queryNameCode;    
     int* flag; int x,tempMint,currentX,currentY; 
     int* resultTemp;
     char line[MAX_LINE]; 
     FILE* fp;FILE* fout;
     char* engineName;
     
     fp = fopen(αinput.inα,αrα);
     fout = fopen(αoutput.outα,αwα);
     fgets(line,MAX_LINE,fp);
     caseCount = atoi(line); 
     //printf(αcaseCount %dα,caseCount); 
     for(ci=0;ci<caseCount;ci++)
     {
         fgets(line,MAX_LINE,fp);                       
         engineCount=atoi(line);//get engine count
         engineName = (char*)malloc(sizeof(char)*engineCount*MAX_LINE);
         for(j=0;j<engineCount;j++) //handle engine name
         {
             fgets(line,MAX_LINE,fp);
             strcpy(engineName+j*MAX_LINE,line); 
             //printf(α  %sα,engineName+j*MAX_LINE);
         }
         fgets(line,MAX_LINE,fp);
         queryCount=atoi(line);//get query count
         //  printf(αqueryCount %dnα,queryCount);
         
         if(queryCount<engineCount||engineCount==1||queryCount==0)
         {
             //printf(αcase #%d : %dnα,ci+1,0);
             sprintf(line,αCase #%d: %dnα,ci+1,0);
             fputs(line,fout);
             continue;
         }
         if(queryCount!=0)
             queryNameCode =(int*)malloc(sizeof(int)*queryCount);
         for(j=0;j<queryCount;j++)
         {
             fgets(line,MAX_LINE,fp); 
            // printf(αl    %sα,line);
             for(x =0;x<engineCount;x++)
             {
                 if(strcmp(line,engineName+x*MAX_LINE)==0)
                     queryNameCode[j] = x;    
             }
                                
         }
         //record query name 
          
         //for(j=0;j<queryCount;j++)
            // printf(αqueryNumber %dnα,queryNameCode[j]);
             
         if(queryCount!=0)
             resultTemp = (int*)malloc(sizeof(int)*queryCount*queryCount);
         for(j=0;j<queryCount*queryCount;j++)
             resultTemp[j]=0;
         
             
         flag = (int*)malloc(sizeof(int)*engineCount);
         for(j=0;j<engineCount;j++) flag[j]=0;
          
         for(j=engineCount-1;j<queryCount;j++){
              currentX=0;currentY=j;
              for(;currentX<queryCount&&currentY<queryCount;currentX++,currentY++)
              {
                  for(k=0;k<engineCount;k++) flag[k]=0;                                                                 
                  for(k=currentX;k<=currentY;k++) flag[queryNameCode[k]] = 1;
                  for(k=0;k<engineCount;k++){if(flag[k]==0) break;} 
                  if(k==engineCount)
                  {
                     //printf(αcurrentX %dnα,currentX);
                     //printf(αcurrentY %dnα,currentY);
                     tempMint = resultTemp[currentX*queryCount+currentX]+resultTemp[currentX*queryCount+queryCount+currentY]+1;
                     //printf(αfirst min %dnα,tempMint);
                     for(p=currentX+1;p<currentY;p++)
                     {
                        if(resultTemp[currentX*queryCount+p]+resultTemp[p*queryCount+queryCount+currentY]+1 < tempMint)
                        {
                            tempMint = resultTemp[currentX*queryCount+p]+resultTemp[p*queryCount+queryCount+currentY]+1 ;
                            //if(j==queryCount-1) printf(αposition %dnα,p);
                        }
                     } 
                     resultTemp[currentX*queryCount+currentY] = tempMint;
                  } 
                  
                  else resultTemp[currentX*queryCount+currentY]=0; 
              }
         } 
         //printf(αcase #%d : %dnα,ci+1,resultTemp[queryCount-1]);
         sprintf(line,αCase #%d: %dnα,ci+1,resultTemp[queryCount-1]);
         fputs(line,fout);
         free(queryNameCode);
         free(flag);
         free(resultTemp);
         free(engineName);
     } 
     fclose(fp);
     fclose(fout);
     //getchar();
     return 0; 
      
 }"
10437,2008,32013,zhangjc,24481,1,train.c,gcj/2008/32013/zhangjc/24481/1/extracted/train.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 struct time1
 {
 	int depart;
 	int arriv;
 }Node;
 
 int Cmpdep(const void *a,const void *b)
 {
 
 	return (*(struct time1 *)a).depart > (*(struct time1 *)b).depart?1:-1;
 
 }
 
 int Cmparr(const void *a,const void *b)
 
 {
 
 	return (*(struct time1 *)a).arriv > (*(struct time1 *)b).arriv?1:-1;
 
 }
 
 
 
 
 struct time1 natime[100],nbtime[100];
 
 int n,na,nb,t,dept[100],arr[100],tempa,tempb;
 	FILE *fp,*out;
 
 void input()
 {
 
         int j,t1,t2;
 		char a;
 
 		fscanf(fp,α%dα,&t);
 
 		fscanf(fp,α%d%dα,&na,&nb);
         tempa=na;
 		tempb=nb;
         fgetc(fp);
 		for(j=0;j<na;j++)
 		{
 			t1=(((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0'))*60;
 			a=fgetc(fp);
 		
 			t2=((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0');
            
 			natime[j].depart=t1+t2;
 
 			a=fgetc(fp);
 			t1=(((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0'))*60;
 				a=fgetc(fp);
 			
 			t2=((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0');
 			natime[j].arriv=t1+t2;
 				a=fgetc(fp);
 		}
 
 
 		for(j=0;j<nb;j++)
 		{
 			t1=(((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0'))*60;
 			a=fgetc(fp);
 		
 			t2=((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0');
            
 			nbtime[j].depart=t1+t2;
 
 				a=fgetc(fp);
 			t1=(((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0'))*60;
 			a=fgetc(fp);
 		
 			t2=((a=fgetc(fp))-'0')*10+((a=fgetc(fp))-'0');
 			nbtime[j].arriv=t1+t2;
 				a=fgetc(fp);
 		}
 }
 
 
 
 void proce()
 {
 	int pa=0,pb=0;
 
 	qsort(nbtime,nb,sizeof(Node),Cmpdep);
 	qsort(natime,na,sizeof(Node),Cmparr);
 
 	for(;pa<na&&pb<nb;)
 	{
 		if(nbtime[pb].depart-t>=natime[pa].arriv)
 		{
 			pb++;
 		    pa++;
 			tempb--;
 		}
 		else 
 
               pb++;
 	}
 
 	qsort(nbtime,nb,sizeof(Node),Cmparr);
 	qsort(natime,na,sizeof(Node),Cmpdep);
 	pa=0;pb=0;	
     for(;pa<na&&pb<nb;)
 	{
 		if(natime[pa].depart-t>=nbtime[pb].arriv)
 		{
 			pb++;
 		    pa++;
 			tempa--;
 		}
 		else 
 
               pa++;
 	}
 }
 
 
 
 
 
 
 
 int main()
 {
 
 	int i;
 
 	fp=fopen(αsmall.inα,αrα);
     out=fopen(αout.outα,αwα);
 	fscanf(fp,α%dα,&n);
 	for(i=0;i<n;i++)
 	{
 		input();
 
 		proce();
 		dept[i]=tempa;
 		arr[i]=tempb;
 	}
 
 		for(i=0;i<n;i++)
 	{
 		fprintf(out,αCase #%d: %d %dnα,i+1,dept[i],arr[i]);
 	}
     fclose(fp);
 	return 0;
 
 }"
10671,2008,32013,Appleway,24480,1,SavingTheUniverse.c,gcj/2008/32013/Appleway/24480/1/extracted/SavingTheUniverse.c,"#include <stdio.h>
 struct engine{
     int rank;
     char name[200];
 };
 typedef struct engine engline;
 struct query{
     char name[200];
 };
 typedef struct query query;
 void init_eng(engline *Ename, int E){
     int i;
     for(i = 0 ; i < E ; i++)
 	Ename[i].rank = 99999;
 }
 
 int self_search(query Qone, engline *Ename, int E){
     int i = -1;
     for(i = 0 ; i < E ; i++)
 	if( strcmp(Qone.name, Ename[i].name) == 0)
 	    return i;
 }
 
 
 int count(engline *Ename, query *Qname, int E, int Q){
     int loc_ptr = 0;
     int ANS = 0;
     int i, j, val;
     int laster;
     while(loc_ptr < Q){
 	init_eng(Ename, E);
 	for( i = loc_ptr ; i < Q ; i++){
 	    val = self_search(Qname[i], Ename, E);
 	    if(val >= 0)
 		if(Ename[val].rank == 99999)
 		    Ename[val].rank = i;
 	}
 //	for(i = 0 ; i < E ; i++ )
 //	    printf(α=== %s %d === nα, Ename[i].name, Ename[i].rank);	
 	for( j = 0, laster = 0 ; j < E ; j++){
 	    if(Ename[j].rank > Ename[laster].rank)
 		laster = j;
 	}
 	if(Ename[laster].rank <= Q)
 	    ANS++;
 	loc_ptr = Ename[laster].rank;
     }
     return ANS;
 }
 
 int main(void){
     int N, E, Q;
     engline Ename[100];
     query Qname[1005];
     int i, j;
 
     scanf(α%dnα, &N);
     for(i = 0 ; i < N ; i++){
 	printf(αCase #%d: α, i+1);
 	scanf(α%dnα, &E);
 
 //	printf(α%dnα, E);
 	for(j = 0  ; j < E ; j++){
 	    fgets(Ename[j].name, 200, stdin);
 //	    printf(α%sα, Ename[j].name);
 	}
 	scanf(α%dnα, &Q);
 	for(j = 0 ;  j < Q ; j++){
 	    fgets(Qname[j].name, 200, stdin);
 //	    printf(α%sα, Qname[j].name);
 	}
 //	printf(αa.........nα);
 	printf(α%dnα, count(Ename, Qname, E, Q));
     }
     
 
 
 
     return 0;
 }"
10673,2008,32013,valluri,24480,1,a.c,gcj/2008/32013/valluri/24480/1/extracted/a.c,"#include<stdio.h>
 #include<stdlib.h>
 struct str_engines
 {
 char name[100];
 int index;
 };
 
 //search engine data structure: each engine in S engines
 struct str_engines se[101];
 
 //N in problem
 char s_not[4];
 //S in problem
 char s_nose[4];
 //Q in problem
 char s_nostrs[20];
 //  N  ,   S   ,   Q
 int not,nose,nostrs;
 
 char strname[100];
 char temp[100];
 
 int arr[1001];
 
 int seekpos=0,flag = 0;
 
 void gotillnextline(FILE *fp)
 {
 char c;
 do
 {
 c = fgetc(fp);
 }while(c=='n'||c=='0'||c=='r');
 fseek(fp,-1,SEEK_CUR);
 }
 int getindexofengine(char *s)
 {
  int i,n,j;
   for(i=1;i<=nose;i++)
   {
     n = strcmp(s,se[i].name);
 //    printf(αstrlen1=%d(%s)nα,strlen(s),s);
     if(!n)
   	break;
 
   }
 
   return i;
 }
 
 int getpos(int i)
 {
 int j;
  if(i>9)
  	j=2;
  else if(i<=9)
  	j =1;
  return j;
  	
 }
 void copy(char *res,char *src)
 {
   int len = 0,i;
   len = strlen(src);
 
   for(i=0;((i<=(len-1))&&(src[i]!='r')&&(src[i]!='n'));i++)
   {
     res[i] = src[i];
   }
      res[i] = '0';
 }
 int main()
 {
 
 FILE *fp,*fw;
 int i,j,count =0,k,len=0,m;
 int swneeded = 0,t;
 
 for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of test cases
 fp = fopen(αblarge.txtα,αrα);
 fw = fopen(αlarge_out.txtα,αwα);
 
 fgets(s_not,3,fp);
 gotillnextline(fp);
 not = atoi(s_not);
 //printf(αno of test cases= %d nα,not);
 
 for(k = 1;k<=not;k++)
 {
     for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of search engines
 fgets(s_nose,5,fp);
 nose = atoi(s_nose);
 //printf(αno of search engines = %d nα,nose);
 gotillnextline(fp);
 
 //to read all engine names 1 by 1
 //printf(αSearch engines are as below:nα);
 for(i=1;i<=nose;i++)
  {
    se[i].index = i;
    fgets(temp,100,fp);
    gotillnextline(fp);
 //  printf(αstring got %snα,temp);
    copy(se[i].name,temp);
    //printf(α%d: %snα,i,se[i].name);
  }
 
 
 //to read search strings names 1 by 1
 fgets(s_nostrs,5,fp);
 gotillnextline(fp);
 nostrs = atoi(s_nostrs);
 //printf(αno of search strings are %d nα,nostrs);
 
  
 //printf(αsearch strings are as below:nα);
  for(i=1;i<=nostrs;i++)
  {
  //reading string name
          fgets(temp,100,fp);
         gotillnextline(fp);
          copy(strname,temp);
         //printf(α%d: %s nα,i,strname);
          for(m=1;m<=100;m++)
          temp[m]='0';
 		 
          j = getindexofengine(strname);
 	  if(arr[j]==0)
 	  {
 	    count++;
 	    arr[j]=1;
 	//    printf(αcount is incremented:%dnα,count);
 	  }
 	  if(count ==  nose)
           {
             for(m=1;m<=1000;m++)
             arr[m]=0;
 	     arr[j]=1;
             swneeded++;
             count = 1;
 	     j =0;
            // printf(αSWITCHEDnα);
           }        
          
  }
 
  fprintf(fw,αCase #%d: %dnα,k,swneeded);
  
   swneeded = 0;
   count = 0;
 
 }
 
 fclose(fp);
 fclose(fw);
 	return 0;
 }"
10701,2008,32013,failer,24481,1,train.c,gcj/2008/32013/failer/24481/1/extracted/train.c,"#include <stdio.h>
 
 enum {
 	MAXN = 100,
 	MAXVALUE = 99999
 };
 
 int astart[MAXN],  aend[MAXN];
 int bstart[MAXN],  bend[MAXN];
 int aqueuearr[MAXN],  bqueuearr[MAXN];
 int *aqueue, *bqueue;
 int aqlen, bqlen;
 
 void inqueue(int * queue, int value, int *plen)
 {
 	int idx, k;
 	int len = *plen;
 	for (idx=0; idx<len; idx++)
 	{
 		if (value < queue[idx])
 			break;
 	}
 	for (k=len;k>idx;k--)
 		queue[k]= queue[k-1];
 	queue[idx]=value;
 	(*plen)++;
 }
 
 void outqueue(int **pqueue, int *plen)
 {
 	(*pqueue) ++;
 	(*plen)--;
 }
 
 void quickSort(int* start, int *end,int startPos, int endPos,int t) 
 { 
     int i,j; 
     int ch, chend; 
     ch=start[startPos];
 	chend = end[startPos];
     i=startPos; 
     j=endPos; 
     if(t==0) 
     {
         while(i<j) 
         { 
             while(start[j]>=ch && i<j)--j; 
             start[i]=start[j];
 			end[i]=end[j];
             while(start[i]<=ch && i<j)++i; 
             start[j]=start[i];
 			end[j]=end[i]; 
         } 
         start[i]=ch; 
 		end[i]=chend; 
         if(i-1>startPos) quickSort(start, end,startPos,i-1,t); 
         if(endPos>i+1) quickSort(start, end,i+1,endPos,t); 
     } 
     else 
     { 
         while(i<j) 
         { 
             while(start[j]<=ch&&i<j) --j; 
             start[i]=start[j];
 			end[i]=end[j];
             while(start[i]>=ch&&i<j) ++i; 
             start[j]=start[i];
 			end[j]=end[i]; 
         } 
         start[i]=ch; 
 		end[i]=chend; 
         if(i-1>startPos) quickSort(start, end,startPos,i-1,t); 
         if(endPos>i+1) quickSort(start, end,i+1,endPos,t); 
     } 
 } 
 
 
 
 void main()
 {
 	int n, i, k;
 	int turnaround;
 	int na, nb;
 	int hour,minute;
 	int atrain, btrain;
 	int aready, bready;
 	int apos, bpos;
 	int now;
 	int turntime;
 	int atime, btime;
 
 	FILE *inf, *outf;
 
 	//aqueue[0] = bqueue[0] = MAXVALUE;
 
 	inf = fopen(αtrain_in.txtα,αrα);
 	outf = fopen(αtrain_out.txtα,αwα);
 
 	fscanf(inf,α%dα, &n);
 	for (i=0; i<n; i++)
 	{
 		fscanf(inf,α%dα,&turnaround);
 		fscanf(inf,α%d%dα, &na, &nb);
 		for (k=0;k<na;k++)
 		{
 			fscanf(inf,α%d:%dα,&hour,&minute);
 			astart[k] = hour * 60 + minute;
 			fscanf(inf,α%d:%dα,&hour,&minute);
 			aend[k] = hour * 60 + minute + turnaround;
 		}
 		for (k=0;k<nb;k++)
 		{
 			fscanf(inf,α%d:%dα,&hour,&minute);
 			bstart[k] = hour * 60 + minute;
 			fscanf(inf,α%d:%dα,&hour,&minute);
 			bend[k] = hour * 60 + minute + turnaround;
 		}
 		quickSort(astart, aend, 0, na-1,0);
 		quickSort(bstart, bend, 0, nb-1,0);
 		atrain = btrain = 0;
 		aready = bready = 0;
 		apos = bpos = 0;
 		bqueue = bqueuearr;
 		aqueue = aqueuearr;
 		aqlen = bqlen = 0;
 		now = 0;
 
 		for (;(apos<na) || (bpos<nb);)
 		{
 			//жϷnow
 			if (apos<na)
 				atime = astart[apos];
 			else
 				atime = 9999;
 			if (bpos<nb)
 				btime = bstart[bpos];
 			else
 				btime = 9999;
 			if (atime < btime)
 			{//a start
 				now = atime;
 				//outqueue, ready
 				if (aqlen >0)
 				{
 					turntime = *aqueue;
 					if (turntime<=now)
 					{
 						aready++;
 						outqueue(&aqueue,&aqlen);
 					}
 				}
 
 				//atrain, inqueue, pos
 				if (aready>0)
 				{
 					aready--;
 				} else {
 					atrain++;
 				}
 				inqueue(bqueue, aend[apos], &bqlen);
 				apos++;
 			} else {//if (atime < btime)
 				//bstart
 				now = btime;
 				//outqueue, ready
 				if (bqlen >0)
 				{
 					turntime = *bqueue;
 					if (turntime<=now)
 					{
 						bready++;
 						outqueue(&bqueue,&bqlen);
 					}
 				}
 				//atrain, inqueue, pos
 				if (bready>0)
 				{
 					bready--;
 				} else {
 					btrain++;
 				}
 				inqueue(aqueue, bend[bpos], &aqlen);
 				bpos++;
 			}//if (atime < btime)
 		}//for (;(apos<na) || (bpos<nb);)
 		fprintf(outf, αCase #%d: %d %dnα, i+1, atrain, btrain);
 	}//for (i=0; i<n; i++)
 	
 	fclose(inf);
 	fclose(outf);
 }"
10740,2008,32013,BeerCode,24480,1,sol.c,gcj/2008/32013/BeerCode/24480/1/extracted/sol.c,"/*
  * Programmer : Kookiat Suetrong (kookiatsuetrong@gmail.com)
  * Compiler   : Visual C++ / ISO C++ / ANSI C
  * Date       : 2008/07/17
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <ctype.h>
 
 #define MAX_S		(100)
 #define MAX_Q		(1000)
 #define MAX_STRING	(100)
 
 char s[MAX_S][MAX_STRING + 1];
 char q[MAX_Q][MAX_STRING + 1];
 int ns;
 int nq;
 
 void process()
 {
 	int i;
 	int j;
 	int curEngine = -1;
 	int can[MAX_Q][MAX_S];
 	int minSwitch = 0;
 
 	for (i = 0; i < nq; i++)
 	{
 		for (j = 0; j < ns; j++)
 		{
 			int cmp = strcmp(q[i], s[j]);
 			if (0 == cmp)
 			{
 				can[i][j] = 0;
 			}
 			else
 			{
 				can[i][j] = 1;
 			}
 		}
 	}
 
 /*
 printf(αnα);
 for (i = 0; i < nq; i++)
 {
 	printf(α%dtα, i);
 	for (j = 0; j < ns; j++)
 	{
 		printf(α%dtα, can[i][j]);
 	}
 	printf(αnα);
 }
 */
 	
 
 
 	i = 0;
 	while (i < nq)
 	{
 		int bestEngine = 0;
 		int score[MAX_S];
 		memset(score, 0, sizeof(int) * MAX_S);
 		
 		for (j = 0; j < ns; j++)
 		{
 			if (j != curEngine)
 			{
 				int k = 0;
 				while (i + k < nq &&
 					can[i + k][j])
 				{
 					k++;
 				}
 				score[j] = k;
 				if (score[bestEngine] < score[j])
 				{
 					bestEngine = j;
 				}
 			}
 		}
 
 		curEngine = bestEngine;
 
 		if (i + score[bestEngine] >= nq)
 		{
 //printf(αEngine %d at %d score = %dnα, bestEngine, i, score[bestEngine]);
 			break;
 		}
 		else
 		{
 //printf(αEngine %d at %d score = %dnα, bestEngine, i, score[bestEngine]);
 			i += score[bestEngine];
 			minSwitch++;
 		}
 	}
 
 //printf(αnMinSwitch = %dnα, minSwitch);
 	printf(α%dnα, minSwitch);
 }
 
 //int main(void)
 int main(int argc, char ** argv)
 {
 	int n;
 	int i;
 	FILE *f = fopen(argv[1], αrα);
 	if (!f)
 		return 0;
 
 	fscanf(f, α%dnα, &n);
 	for (i = 0; i < n; i++)
 	{
 		int j;
 
 		// read data for this case
 		fscanf(f, α%dnα, &ns);
 		for (j = 0; j < ns; j++)
 		{
 			fgets(s[j], MAX_STRING, f);
 		}
 
 		fscanf(f, α%dnα, &nq);
 		for (j = 0; j < nq; j++)
 		{
 			fgets(q[j], MAX_STRING, f);
 		}
 
 		// output the result of this case
 		printf(αCase #%d: α, i + 1);
 
 		// solve the test case
 		process();
 	}
 
 	fclose(f);
 
 	return 0;
 }"
10742,2008,32013,BeerCode,24481,1,prog.c,gcj/2008/32013/BeerCode/24481/1/extracted/prog.c,"/*
  * Programmer : Kookiat Suetrong (kookiatsuetrong@gmail.com)
  * Compiler   : Visual C++ / ISO C++ / ANSI C
  * Date       : 2008/07/17
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <ctype.h>
 
 
 #define MAX_MINUTE	(25*60)
 
 #define MAX_T		(61)
 #define MAX_NA		(101)
 #define MAX_NB		(101)
 
 
 void minute2clock(int minute, int * h, int * m)
 {
 	*h = minute / 60;
 	*m = minute % 60;
 }
 
 int clock2minute(int h, int m)
 {
 	return h * 60 + m;
 }
 
 typedef struct _sched {
 	int start, stop;
 } sched;
 
 int T;
 int NA;
 int NB;
 sched SA[MAX_NA];
 sched SB[MAX_NB];
 
 int sort_function(void *a, void *b)
 {
 	sched *x = (sched*)a;
 	sched *y = (sched*)b;
 	if (x->start < y->start) return -1;
 	if (x->start > y->start) return 1;
 
 	if (x->stop < y->stop) return -1;
 	if (x->stop > y->stop) return 1;
 
 	// equal
 	return 0;
 }
 
 typedef struct _TRAIN
 {
 	char startPlatform; // 'A' or 'B'
 	char currentPlatform; // 'A' or 'B' or
 	int status[MAX_MINUTE]; // 0 = available
 } TRAIN;
 
 int nTrain = 0;
 TRAIN aTrain[MAX_NA + MAX_NB];
 
 void startAtPlatformA(int a)
 {
 	int found = -1;
 	int i;
 
 	for (i = 0; i < nTrain; i++)
 	{
 		if (0 == aTrain[i].status[SA[a].start] &&
 			'A' == aTrain[i].currentPlatform)
 		{
 			found = i;
 			break;
 		}
 	}
 	
 	if (-1 == found)
 	{
 		// create a new train
 		found = nTrain;
 		aTrain[nTrain].startPlatform = 'A';
 		for (i = 0; i < MAX_MINUTE; i++)
 		{
 			aTrain[nTrain].status[i] = 0; // available
 		}
 		nTrain++;
 	}
 	
 	aTrain[found].currentPlatform = 'B';
 	for (i = SA[a].start; i < SA[a].stop; i++)
 	{
 		aTrain[found].status[i] = 1; // A->B
 	}
 }
 
 void startAtPlatformB(int b)
 {
 	int found = -1;
 	int i;
 
 	for (i = 0; i < nTrain; i++)
 	{
 		if (0 == aTrain[i].status[SB[b].start] &&
 			'B' == aTrain[i].currentPlatform)
 		{
 			found = i;
 			break;
 		}
 	}
 
 	if (-1 == found)
 	{
 		// create a new train
 		found = nTrain;
 		aTrain[nTrain].startPlatform = 'B';
 		for (i = 0; i < MAX_MINUTE; i++)
 		{
 			aTrain[nTrain].status[i] = 0; // available
 		}
 		nTrain++;
 	}
 
 	aTrain[found].currentPlatform = 'A';
 	for (i = SB[b].start; i < SB[b].stop; i++)
 	{
 		aTrain[found].status[i] = -1; // A<-B
 	}
 
 }
 
 void process()
 {
 	int a, b;
 	int nA, nB;
 	int i;
 	
 	// sort
 	qsort(SA, NA, sizeof(sched), sort_function);
 	qsort(SB, NB, sizeof(sched), sort_function);
 
 	// init
 	nTrain = 0;
 	a = 0;
 	b = 0;
 
 	while (a < NA || b < NB)
 	{
 		if (SA[a].start == SB[b].start)
 		{
 			// start both A,B
 			startAtPlatformA(a);
 			startAtPlatformB(b);
 			a++;
 			b++;
 		}
 		else if (SA[a].start < SB[b].start)
 		{
 			// start at A
 			startAtPlatformA(a);
 			a++;
 		}
 		else
 		{
 			// start at B
 			startAtPlatformB(b);
 			b++;
 		}
 	}
 
 	nA = nB = 0;
 	for (i = 0; i < nTrain; i++)
 	{
 		if ('A' == aTrain[i].startPlatform)
 			nA++;
 		if ('B' == aTrain[i].startPlatform)
 			nB++;
 	}
 
 	printf(α%d %dnα, nA, nB);
 }
 
 int main(int argc, char ** argv)
 {
 	int n;
 	int i;
 	FILE * f = fopen(argv[1], αrα);
 
 	if (!f) return -1;
 
 	fscanf(f, α%dnα, &n);
 	for (i = 0; i < n; i++)
 	{
 		int h0, h1, m0, m1;
 		int j;
 
 		// read data for this case
 		fscanf(f, α%dnα, &T);
 		fscanf(f, α%d %dnα, &NA, &NB);
 
 		for (j = 0; j < NA; j++)
 		{
 			fscanf(f, α%d:%d %d:%dnα, &h0, &m0, &h1, &m1);
 			SA[j].start = clock2minute(h0, m0);
 			SA[j].stop = clock2minute(h1, m1);
 			SA[j].stop += T;
 		}
 		SA[j].start = clock2minute(25, 0);
 
 		for (j = 0; j < NB; j++)
 		{
 			fscanf(f, α%d:%d %d:%dnα, &h0, &m0, &h1, &m1);
 			SB[j].start = clock2minute(h0, m0);
 			SB[j].stop = clock2minute(h1, m1);
 			SB[j].stop += T;
 		}
 		SB[j].start = clock2minute(25, 0);
 
 		// output the result of this case
 		printf(αCase #%d: α, i + 1);
 
 		// solve the test case
 		process();
 
 	}
 
 	fclose(f);
 
 	return 0;
 }"
11046,2008,32013,tory,24480,1,univ.c,gcj/2008/32013/tory/24480/1/extracted/univ.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 struct problem_input_record
 {
     int engine_no;
     char engines[100][256];
     int query_no;
     char queries[1000][256];
     
     int switch_no;
 };
 
 
 /* lookup the engine which matches the given query */
 int
 find_engine(struct problem_input_record *record, int query_idx)
 {
     int engine_idx;
 
     for (engine_idx=0; engine_idx < record->engine_no; engine_idx++)
     {
 	if (!strcmp(record->engines[engine_idx], record->queries[query_idx]))
 	    return engine_idx;
     }
 
     return -1;
 }
 
 int
 get_an_answer(struct problem_input_record *record)
 {
     int query_idx, engine_idx;
     int engine_seen[100];
     int remain_engines;
 
     memset(engine_seen, 0, sizeof(engine_seen));
     remain_engines = record->engine_no;
 
     for (query_idx=0; query_idx < record->query_no; query_idx++)
     {
 	engine_idx = find_engine(record, query_idx);
 
 // printf(αidx=%d, remains=%dnα, engine_idx, remain_engines);
 
 	/* no such engine. - great. continue */
 	if (engine_idx < 0) continue;
 
 	if (engine_seen[engine_idx] == 0) 
 	{
 	    /* new found */
 	    engine_seen[engine_idx] = 1;
 	    remain_engines--;
 	}
 
 	if (remain_engines == 0)
 	{
 	    /* no more engine left - we have to switch */
 	    record->switch_no++;
 
 	    memset(engine_seen, 0, sizeof(engine_seen));
 	    remain_engines = record->engine_no;
 
 	    /* The last one is a new starting position */
 	    engine_seen[engine_idx] = 1;
 	    remain_engines--;
 	}
     }
 
     return 0;
 }
 
 int
 read_a_record(FILE *fp, struct problem_input_record *record)
 {
     char buf[256];
     int nread;
     int i;
     char *p;
 
     /* read engines */
     if (fgets(buf, 256, fp) == NULL) return -1;
     nread = sscanf(buf, α%dα, &record->engine_no);
     if (nread != 1) return -1;
 
 //    printf(α%d: enginesnα, record->engine_no);
 
     for (i=0; i<record->engine_no; i++)
     {
 	p = fgets(record->engines[i], 256, fp);
 	if (p == NULL) return -1;
 
 	p = strchr(record->engines[i], 'n');
 	if (p != NULL) *p = '0';
 //    printf(α[%s]nα, record->engines[i]);
     }
     
     /* read queries */
     if (fgets(buf, 256, fp) == NULL) return -1;
     nread = sscanf(buf, α%dα, &record->query_no);
     if (nread != 1) return -1;
 
 //    printf(α%d: queriesnα, record->query_no);
 
     for (i=0; i<record->query_no; i++)
     {
 	p = fgets(record->queries[i], 256, fp);
 	if (p == NULL) return -1;
 
 	p = strchr(record->queries[i], 'n');
 	if (p != NULL) *p = '0';
 //    printf(α[%s]nα, record->queries[i]);
     }
     
     return 0;
 }
 
 int
 solve_the_problem(char *filename)
 {
     FILE *fp;
     int i, n;
     struct problem_input_record *record;
 
     record = malloc(sizeof(struct problem_input_record));
 
     fp = fopen(filename, αrα);
     if (fp == NULL) return -1;
 
     fscanf(fp, α%dnα, &n);
 
     for (i=0; i<n; i++)
     {
 	memset(record, 0, sizeof(struct problem_input_record));
 
 	if (read_a_record(fp, record) != 0)
 	{
 	    printf(αfailed to parse an input filenα);
 	    fclose(fp);
 	    return -2;
 	}
 
 	get_an_answer(record);
 
 	printf(αCase #%d: %dnα, i+1, record->switch_no);
     }
 
     fclose(fp);
 
     return 0;
 }
 
 
 int
 main(int argc, char *argv[])
 {
     int ret;
 
     /* load an input file */
     ret = solve_the_problem(argv[1]);
     if (ret != 0)
     {
 	printf(αsomthing wrong [%s].nα, argv[1]);
 	return -1;
     }
 
     return 0;
 }"
11049,2008,32013,tory,24481,1,train.c,gcj/2008/32013/tory/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 struct trtime
 {
     int hour;
     int min;
 };
 
 struct problem_input_record
 {
     struct trtime turnaround;
 
     int tableA_no;
     struct trtime tableA_departure[100];
     struct trtime tableA_arrival[100];
 
     int tableB_no;
     struct trtime tableB_departure[100];
     struct trtime tableB_arrival[100];
 
     int trainA;
     int trainB;
 };
 
 
 void
 trtime_add(struct trtime A, struct trtime B, struct trtime *C)
 {
     C->hour = A.hour + B.hour;
     C->min  = A.min  + B.min;
 
     if (C->min > 60)
     {
 	C->hour++;
 	C->min -= 60;
     }
 }
 
 /*
  * if A > B, return 1
  * if A < B, return -1
  * if A = B, return 0
  */
 int
 trtime_cmp(struct trtime A, struct trtime B)
 {
     if (A.hour > B.hour) return 1;
     else if (A.hour < B.hour) return -1;
     else if (A.min > B.min) return 1;
     else if (A.min < B.min) return -1;
 
     return 0;
 }
 
 int 
 compare_trtime(const void *paramA, const void *paramB)
 {
     struct trtime *pA = (struct trtime *)paramA;
     struct trtime *pB = (struct trtime *)paramB;
 
     return trtime_cmp(*pA, *pB);
 }
 
 /* get the number of trains that should be started */
 int
 find_trains(struct trtime arrtable[], struct trtime deptable[], int arrcnt, int depcnt,
 	struct trtime turnaround)
 {
     struct trtime rdytable[100];
     int i;
     int rdyidx;
     int train;
 
     if (arrcnt == 0) return depcnt;
 
     for (i=0; i < arrcnt; i++)
     {
 	trtime_add(arrtable[i], turnaround, &rdytable[i]);
     }
 
     /* first sort each table */
     qsort(rdytable, arrcnt, sizeof(struct trtime), compare_trtime);
     qsort(deptable, depcnt, sizeof(struct trtime), compare_trtime);
 
     /* get the number of trains departed newly */
 
     train  = 0;
     rdyidx = 0;
     for (i = 0; i < depcnt; i++)
     {
 //	printf(α=> %02d:%02d %02d:%02dnα,
 //		rdytable[rdyidx].hour,
 //		rdytable[rdyidx].min,
 //		deptable[i].hour,
 //		deptable[i].min
 //	      );
 
 	if (rdyidx == arrcnt
 		|| trtime_cmp(rdytable[rdyidx], deptable[i]) == 1)
 	{
 	    /* no train is ready yet. - start new one */
 	    train++;
 	}
 	else
 	{
 	    rdyidx++;
 	}
     }
 
     return train;
 }
 
 
 int
 get_an_answer(struct problem_input_record *record)
 {
     /* first find the number of trains from A */
     record->trainA =  find_trains(record->tableB_arrival, record->tableA_departure,
 	    record->tableB_no, record->tableA_no,
 	    record->turnaround);
 
     /* second find the number of trains from B */
     record->trainB =  find_trains(record->tableA_arrival, record->tableB_departure,
 	    record->tableA_no, record->tableB_no,
 	    record->turnaround);
 
     return 0;
 }
 
 
 int
 read_a_record(FILE *fp, struct problem_input_record *record)
 {
     char buf[256];
     int nread;
     int i;
     char *p;
 
     /* read turnaround time */
     nread = fscanf(fp, α%dα, &record->turnaround.min);
     if (nread != 1) return -1;
 
 //    printf(α%d: turnaroundnα, record->turnaround.min);
 
     nread = fscanf(fp, α%d %dα, &record->tableA_no, &record->tableB_no);
     if (nread != 2) return -1;
 
     /* read timetable A */
 //    printf(αTable Anα);
     for (i=0; i<record->tableA_no; i++)
     {
 	nread = fscanf(fp, α%02d:%02d %02d:%02dnα,
 		&record->tableA_departure[i].hour,
 		&record->tableA_departure[i].min,
 		&record->tableA_arrival[i].hour,
 		&record->tableA_arrival[i].min);
 
 	if (nread != 4) return -1;
 
 //	printf(α%02d:%02d %02d:%02dnα,
 //		record->tableA_departure[i].hour,
 //		record->tableA_departure[i].min,
 //		record->tableA_arrival[i].hour,
 //		record->tableA_arrival[i].min);
     }
     
     /* read timetable B */
 //    printf(αTable Bnα);
     for (i=0; i<record->tableB_no; i++)
     {
 	nread = fscanf(fp, α%02d:%02d %02d:%02dnα,
 		&record->tableB_departure[i].hour,
 		&record->tableB_departure[i].min,
 		&record->tableB_arrival[i].hour,
 		&record->tableB_arrival[i].min);
 
 	if (nread != 4) return -1;
 
 //	printf(α%02d:%02d %02d:%02dnα,
 //		record->tableB_departure[i].hour,
 //		record->tableB_departure[i].min,
 //		record->tableB_arrival[i].hour,
 //		record->tableB_arrival[i].min);
     }
     
     return 0;
 }
 
 int
 solve_the_problem(char *filename)
 {
     FILE *fp;
     int i, n;
     struct problem_input_record *record;
 
     record = malloc(sizeof(struct problem_input_record));
 
     fp = fopen(filename, αrα);
     if (fp == NULL) return -1;
 
     fscanf(fp, α%dnα, &n);
 
     for (i=0; i<n; i++)
     {
 	memset(record, 0, sizeof(struct problem_input_record));
 
 	if (read_a_record(fp, record) != 0)
 	{
 	    printf(αfailed to parse an input filenα);
 	    fclose(fp);
 	    return -2;
 	}
 
 	get_an_answer(record);
 
 	printf(αCase #%d: %d %dnα, i+1, record->trainA, record->trainB);
     }
 
     fclose(fp);
 
     return 0;
 }
 
 
 int
 main(int argc, char *argv[])
 {
     int ret;
 
     /* load an input file */
     ret = solve_the_problem(argv[1]);
     if (ret != 0)
     {
 	printf(αsomthing wrong [%s].nα, argv[1]);
 	return -1;
     }
 
     return 0;
 }"
11180,2008,32013,brunabxs,24480,1,A2.c,gcj/2008/32013/brunabxs/24480/1/extracted/A2.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <math.h>
 
 typedef struct _SEARCHENGINE
 {
 	int casos;
 	char nome[128];
 	int distancia, query;
 }SEARCHENGINE;
 
 SEARCHENGINE searchEngines[128];
 char queries[1024][128];
 
 int compara (const void * a, const void * b)
 {
 	SEARCHENGINE se1 = *(SEARCHENGINE*) a;
 	SEARCHENGINE se2 = *(SEARCHENGINE*) b;
 	
   return (se1.casos - se2.casos);
 }
 
 int main (void)
 {
 	int i, j, k, n, s, q, maiorDistancia, query, teste;
 	int numSwitches=0;
 
 	scanf(α%dα,&n);
 	for (teste=0; teste<n; teste++)
 	{
 		numSwitches=0;
 		scanf(α%dα,&s);
 		getchar();
 		// LEITURA DAS SEARCH ENGINES
 		for (j=0; j<s; j++)
 		{
 			gets(searchEngines[j].nome);
 			searchEngines[j].casos = 0;
 			searchEngines[j].distancia = 0;
 			searchEngines[j].query = 0;
 		}
 		scanf(α%dα,&q);
 		getchar();
 		// LEITURA DAS QUERIES
 		for (j=0; j<q; j++)
 		{
 			gets(queries[j]);
 			for (k=0; k<s; k++)
 			{
 				if (!strcmp(queries[j],searchEngines[k].nome))
 				{
 					searchEngines[k].casos++;
 					break;
 				}
 			}
 			
 		}
 		// ORDENANDO O VETOR DE SEARCH ENGINES
 		qsort(searchEngines,s,sizeof(SEARCHENGINE),compara);
 		j=0;
 		maiorDistancia=0;
 		query=0;
 		while(j<q)
 		{
 			for (i=0; i<s; i++)
 			{
 				j=query;	
 				while (strcmp(searchEngines[i].nome,queries[j]) && j<q)
 				{
 					j++;
 				}
 				searchEngines[i].query=j;
 				searchEngines[i].distancia = j;
 			}
 			maiorDistancia = searchEngines[0].distancia;
 			query = searchEngines[0].query;
 			for (i=0; i<s; i++)
 			{
 				if (maiorDistancia < searchEngines[i].distancia)
 				{
 					maiorDistancia = searchEngines[i].distancia;
 					query = searchEngines[i].query;			
 				}
 			}
 			numSwitches++;
 			j = query;
 		}	
 		numSwitches--;
 		
 		if (numSwitches<0)
 		{
 			numSwitches=0;
 		}
 		
 		
 		
 		
 		printf(αCase #%d: %dnα,teste+1,numSwitches);
 		
 	}
 
 	return 0;
 }"
11339,2008,32013,mart0258,24480,1,a.c,gcj/2008/32013/mart0258/24480/1/extracted/a.c,"#include <stdio.h>
 
 char buf[512];
 
 char names[200][200];
 int query[2000];
 
 int N;
 int S;
 int Q; 
 
 /* pos = first entry that needs to be checked by a new engine. */
 int solve(int pos)
 {
 	int ret=0;
 	int i;
 	int j;
 	int best=pos; 
 	int bi;
 
 	for (i=0; i<S; i++)
 	{
 		for (j=pos; j<Q; j++)
 		{
 			if (query[j]==i)
 				break;
 		}
 		if (j==Q) 
 			return 0;
 
 		if (j>best)
 		{
 			best=j;
 			bi=i;
 		}
 	}
 
 	ret = solve(best)+1;
 
 	return ret;
 }
 
 int main (void)
 {
 	int i,j,k;
 	fgets(buf, 512, stdin);
 	sscanf(buf, α%dα, &N);
 
 	for (i=1; i<=N; i++)
 	{
 		fgets(buf, 512, stdin);
 		sscanf(buf, α%dα, &S);
 
 		for (j=0; j<S; j++)
 		{
 			fgets(names[j], 512, stdin);
 		}
 
 		fgets(buf, 512, stdin);
 		sscanf(buf, α%dα, &Q);
 
 		for (j=0; j<Q; j++)
 		{
 			fgets(buf, 512, stdin);
 			for (k=0; k<S; k++)
 			{
 				if (strcmp(buf, names[k])==0)
 				{
 					query[j]=k;
 					break;
 				}
 			}
 		}
 
 		/* Solve. */
 		j = solve(0);
 
 		printf (αCase #%d: %dnα, i, j);
 
 	}
 }"
11341,2008,32013,mart0258,24481,1,b.c,gcj/2008/32013/mart0258/24481/1/extracted/b.c,"/* Just a quick note:
    Even though this is a C program, it is not C89-compliant due to the α//α comments. 
    You need to use a C-compiler that supports this comment type - either a C99 program or one
    that uses it as an extension. 
    */
 
 #include <stdio.h>
 
 int N;
 
 int T;
 int NA, NB;
 
 int sa[300]; /* Start at a */
 int aa[300]; /* Arrived from a. */
 
 int sb[300]; /* start at b */
 int ab[300]; /* Arrived from b */
 
 int sol1, sol2; 
 
 void solve(void)
 {
 	int sap=0, aap=0, sbp=0, abp=0; /* Positions in the list. */
 	int tca=0, tcb=0;
 	int t=0;
 
 	sol1=0; sol2=0;
 
 	while (sap < NA || sbp < NB)
 	{
 		/* Check earliest outbound */
 		if (sap<NA && (sbp==NB || sa[sap] < sb[sbp]))
 		{
 			/* SA is earlier. */
 			/* Check for incoming. */
 			while (abp<NB && ab[abp]<=sa[sap])
 			{
 				//printf (αExisting train: %d (%d)nα, ab[abp],abp);
 				abp++;
 				tca++;
 			}
 			if (tca==0)
 			{
 				//printf (αNew train at A-%d (%d/%d)nα, sb[sap], sap, NA);
 				sol1++;
 			} else
 			{
 				tca--;
 			}
 			sap++;
 		} else
 		{
 			/* SB earlier. */
 			/* SA is earlier. */
 			/* Check for incoming. */
 			while (aap<NA && aa[aap]<=sb[sbp])
 			{
 				//printf (αExisting train: %d (%d)nα, aa[aap],aap);
 				aap++;
 				tcb++;
 			}
 			if (tcb==0)
 			{
 				//printf (αNew train at B-%d (%d/%d)nα, sb[sbp], sbp, NB);
 				sol2++;
 			} else
 			{
 				tcb--;
 			}
 			sbp++;
 		}
 			//printf (α%d/%d (%d), %d/%d (%d)nα, sap, NA, sa[sap], sbp, NB, sb[sbp]);
 	}
 
 }
 
 int main (void)
 {
 	int t;
 	int ta, tb, tc, td;
 	int val; 
 	int i,j;
 	int swp;
 	scanf(α%dα, &N);
 
 	for (t=1; t<=N; t++)
 	{
 		scanf (α%dα, &T);
 		scanf (α%d %dα, &NA, &NB);
 
 		
 		for (i=0; i<NA; i++)
 		{
 			scanf (α%d:%d %d:%dα, &ta, &tb, &tc, &td);
 			val=ta*60+tb;
 			sa[i]=val;
 
 			val=tc*60+td+T;
 			aa[i]=val;
 			//printf (αTrain A-%d: %d -> %dnα, i, sa[i], aa[i]);
 		}
 
 		for (i=0; i<NB; i++)
 		{
 			scanf (α%d:%d %d:%dα, &ta, &tb, &tc, &td);
 			val=ta*60+tb;
 			sb[i]=val;
 
 			val=tc*60+td+T;
 			ab[i]=val;
 			//printf (αTrain B-%d: %d -> %dnα, i, sb[i], ab[i]);
 		}
 
 		/* Bubble sort */
 		for (i=NA-1; i>0; i--)
 		{
 			for (j=0; j<i; j++)
 			{
 				if (sa[j]>sa[j+1])
 				{
 					swp=sa[j+1];
 					sa[j+1]=sa[j];
 					sa[j]=swp;
 				}
 			}
 		}
 		for (i=NA-1; i>0; i--)
 		{
 			for (j=0; j<i; j++)
 			{
 				if (aa[j]>aa[j+1])
 				{
 					swp=aa[j+1];
 					aa[j+1]=aa[j];
 					aa[j]=swp;
 				}
 			}
 		}
 
 		for (i=NB-1; i>0; i--)
 		{
 			for (j=0; j<i; j++)
 			{
 				if (sb[j]>sb[j+1])
 				{
 					swp=sb[j+1];
 					sb[j+1]=sb[j];
 					sb[j]=swp;
 				}
 			}
 		}
 		for (i=NB-1; i>0; i--)
 		{
 			for (j=0; j<i; j++)
 			{
 				if (ab[j]>ab[j+1])
 				{
 					swp=ab[j+1];
 					ab[j+1]=ab[j];
 					ab[j]=swp;
 				}
 			}
 		}
 
 		solve();
 
 		printf (αCase #%d: %d %dnα, t, sol1, sol2);
 
 	}
 }"
11345,2008,32013,pacoswitch,24480,1,su.c,gcj/2008/32013/pacoswitch/24480/1/extracted/su.c,"#include <stdio.h>
 #include <string.h>
 #define MAX 101
 #define TAM 102
 
 char browser[MAX][TAM];
 
 int binsearch(char x[], int n)
 {
    int valor, low, high, mid;
    low = 0;
    high = n - 1;
    while (low <= high) 
    {
       mid = (low+high)/2;
       if ((valor = strcmp(x, browser[mid])) < 0)
          high = mid - 1;
       else if (valor > 0)
          low = mid + 1;
       else /* found match */
          return mid;
    }
    return -1; /* no match */
 }
 
 void shellsort(int n)
 {
    int gap, i, j;
    char temp[TAM];
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && strcmp(browser[j], browser[j+gap]) > 0; j-=gap) 
          {
             strcpy(temp, browser[j]);
             strcpy(browser[j], browser[j+gap]);
             strcpy(browser[j+gap], temp);
          }
    return;
 }
 
 int main()
 {
     int i, j, k, casos, s, q, cont, suma, indice, flags[MAX];
     char query[TAM];
     scanf(α%dnα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &s);/*numero de browsers*/
         for(i = 0; i < s; i++){
             for(j = 0; (browser[i][j] = getchar()) != 'n'; j++);
             browser[i][j] = '0';
         }
         shellsort(s);
 /*        for(i = 0; i < s; i++)
             printf(α%s'nα, browser[i]);*/
         suma = cont = 0;
         for(i = 0; i < s; i++)
             flags[i] = 0;
         scanf(α%dnα, &q);/*numero de consultas*/
         for(i = 0; i < q; i++){
             for(j = 0; (query[j] = getchar()) != 'n' && query[j] != EOF; j++);
             query[j] = '0';
             indice = binsearch(query, s);
             if(indice != -1){
                 if(flags[indice] == 0){
                     flags[indice] = 1;
                     suma++;
                 }
                 if(suma == s){
                     for(j = 0; j < s; j++)
                         flags[j] = 0;
                     flags[indice] = 1;
                     cont++;
                     suma = 1;
                 }
             }
 /*            for(j = 0; j < s; j++)
                 printf(α%d α, flags[j]);
             printf(αn%3d suma = %3d indice = %3d %s'nnα, i+1, suma, indice, query);*/
         }
         printf(αCase #%d: %dnα, k, cont);
     }
     return 0;
 }"
11347,2008,32013,pacoswitch,24481,1,tt.c,gcj/2008/32013/pacoswitch/24481/1/extracted/tt.c,"#include <stdio.h>
 #define MAX 102
 #define SALE 0
 #define LLEGA 1
 
 int empalma(int llega[], int sale[], int n, int m, int tiempo)
 {
     int i, j, cont = 0;
     for(i = j = 0; i < n && j < m; j++){
         if(sale[j] >= (llega[i]+tiempo))
             i++;
         else
             cont++;
     }
     if(j < m){
         cont += (m-j);
     }
     return cont;
 }
 
 void shellsort(int v[], int n)
 {
    int gap, i, j, temp;
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) 
          {
             temp = v[j];
             v[j] = v[j+gap];
             v[j+gap] = temp;
          }
    return;
 }
 
 void imprime(int m[2][MAX], int n)
 {
     int i;
     printf(α%dnα, n);
     for(i = 0; i < n; i++)
         printf(α%d %dnα, m[SALE][i], m[LLEGA][i]);
     return;
 }
 
 int hmilitar(int horas, int minutos)
 {
     return (horas * 60) + minutos;
 }
 
 int main()
 {
     int a, b, c, d, i, k, salena, salenb, tiempo, casos, na, nb, ab[2][MAX], ba[2][MAX];
     scanf(α%dα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &tiempo);
         scanf(α%d%dnα, &na, &nb);
         for(i = 0; i < na; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ab[SALE][i] = hmilitar(a, b);
             ab[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ab[SALE][i], ab[LLEGA][i]);*/
         }
         for(i = 0; i < nb; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ba[SALE][i] = hmilitar(a, b);
             ba[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ba[SALE][i], ba[LLEGA][i]);*/
         }
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[SALE], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[LLEGA], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salena = empalma(ba[LLEGA], ab[SALE], nb, na, tiempo);
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[LLEGA], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[SALE], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salenb = empalma(ab[LLEGA], ba[SALE], na, nb, tiempo);
         printf(αCase #%d: %d %dnα, k, salena, salenb);
     }
     return 0;
 }"
11502,2008,32013,Lele,24480,1,search.c,gcj/2008/32013/Lele/24480/1/extracted/search.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #define HASH_PRIME 5003
 
 typedef struct node *link;
 struct node {
     int w;
     link next;
 };
 
 char engines[100][100];
 link hash_table[HASH_PRIME];
 int queries[1000];
 int full[100];
 
 /*Universal hash function */
 int hash(char *key)
 {
     int h, a=31415, b=27183;
     for (h=0; *key!='0'; key++, a=a*b%(HASH_PRIME-1))
 	h = (a*h + *key) % HASH_PRIME;
     return h;
 }
 
 int hash_find(char *word)
 {
     int i = hash(word);
     link p;
     for(p=hash_table[i]; p!=NULL; p=p->next)
 	if(strcmp(word, engines[p->w]) == 0)
 	    return p->w;
     return -1;
 }
 
 link hash_insert(link p, int w)
 {
     link new = malloc(sizeof(link));
     new->w = w;
     new->next = p;
     return new;
 }
 
 /*Inserts search engine number in the hash_table */
 void add(int x)
 {
     int i = hash(engines[x]);
     hash_table[i] = hash_insert(hash_table[i], x);
 }
 
 void cleanup()
 {
     int i;
     for(i=0; i<HASH_PRIME; i++){
 	free(hash_table[i]);
 	hash_table[i] = NULL;
     }	
 }
 
 /*Calculates minimum number of switches */
 int solve(int Nengines, int Nqueries)
 {
     int i, switches=0, sum=0, j, sENG = -1;
     for(i=0; i<Nengines; i++)
 	full[i] = -1;
 
     for(i=0; i<Nqueries; i++){
 	/*printf(α%snα, engines[queries[i]]);*/
 	if(full[queries[i]] == -1){
 	    full[queries[i]] = 1;
 	    sum++;
 	}
 
 	if(sum == Nengines){
 	    sENG = queries[i];
 	    switches++;
 	    sum = 0;
 	    for(j=0; j<Nengines; j++)
 		full[j] = -1;
 	    i--;
 	    /*printf(αateh aqui com o %snα, engines[sENG]);*/
 	}
     }
 	
 
     return switches;
 }
 
 int main()
 {
     int n, tests = 1, eng, i, j, k, q;
     char c, query[100];
 
     scanf(α%dα, &n);
 
     while(n>0){
 	/*Prepare hash_table */
 	cleanup();
 
 	/*Get Search Engines */
 	scanf(α%dα, &eng);
 	getchar();
 	for(i=0; i<eng; i++){
 	    c = getc(stdin);
 	    j=0;
 	    while(c!='n'){
 		engines[i][j++] = c;
 		c = getc(stdin);
 	    }
 	    engines[i][j] = '0';
 	    add(i);
 	}
 
 	/*Get Queries */
 	scanf(α%dα, &q);
 	getchar();
 	for(i=0, k=0; i<q; i++){
 	    c = getc(stdin);
 	    j=0;
 	    while(c!='n'){
 		query[j++] = c;
 		c = getc(stdin);
 	    }
 	    query[j] = '0';
 
 	    queries[k] = hash_find(query);
 	    if(k==0 || queries[k-1] != queries[k])
 		k++;			    
 	}
 	
 	/*Solve & print answer */
 	printf(αCase #%d: %dnα, tests++, solve(eng, k));
 	n--;
     }
 
     return 0;
 }"
11555,2008,32013,chc,24480,1,a1.c,gcj/2008/32013/chc/24480/1/extracted/a1.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 char engine[100][80];
 char query[1000][80];
 int m[100];
 
 solve(int s, int q)
 {
   int i, j, k;
   int n=s;
   int sh=0;
 
 /*
   for (i=0; i<s; i++) {
     printf(α%snα, engine[i]);
   }
 */
   for (k=0; k<100; k++)
     m[k]=0;
 
   for (i=0; i<q; i++) {
     // printf(α%snα, query[i]);
     for (j=0; j<s; j++) {
       if (m[j]==1)
         continue;
       if (!strcmp(query[i], engine[j])) {
         n--;
         if (n<=0) {
           sh++;
           for (k=0; k<100; k++)
             m[k]=0;
           // bzero(&m,s*sizeof(int));
           n=s-1;
         }
         m[j]=1;
       }
     }
   }
   return(sh);
 }
 
 main(int argc, char *argv[])
 {
   char *fname;
   char buf[1024], data[80];
   FILE *fp;
   int i, num, line, j, s, q;
 
   if (argc<2)
     fname = αA-small.inα;
   else
     fname = argv[1];
 
   fp = fopen(fname, αrα);
   if (!fp) {
     fprintf(stderr, αunable to open %snα, fname);
     exit(-1);
   }
   
   fgets(buf, sizeof(buf), fp);
   num = atoi(buf);
 
   for (i=0; i<num; i++) {
     printf(αCase #%d: α,i+1);
 
     fgets(buf, sizeof(buf), fp);
     s= atoi(buf);
     for (j=0; j<s; j++) {
       fgets(data, sizeof(data), fp);
       data[strlen(data)-1]='0';
       strcpy(engine[j],data);
     }
 
     fgets(buf, sizeof(buf), fp);
     q= atoi(buf);
     for (j=0; j<q; j++) {
       fgets(data, sizeof(data), fp);
       data[strlen(data)-1]='0';
       strcpy(query[j],data);
     }
     if (q==0)
       printf(α0α, solve(s, q));
     else
       printf(α%dα, solve(s, q));
     printf(αnα,i+1);
   }
 
   fclose(fp);
 }"
11557,2008,32013,chc,24481,1,q3.c,gcj/2008/32013/chc/24481/1/extracted/q3.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <time.h>
 
 #define STATION_A 1
 #define STATION_B 2
 #define USED 9999999
 
 struct {
 //  int start;
   int pos;
   int arr_t;
 } train[1000];
 
 
 typedef struct {
   int station; 
   int dep_t; 
   int arr_t; 
   int id; 
   int train_id; 
 } M;
 
 M line[200];
 
 int my_cmp(const void *c, const void *d) {
   M *a=c, *b=d;
 
   return(a->dep_t - b->dep_t);
 }
 
 int solve(int a, int b)
 {
   int i,j ;
   int n=0, f=0;
   int train_a=0;
   int train_b=0;
 
   qsort(line, a+b, sizeof(M), my_cmp);
 
   for (i=0; i<a+b; i++) {
     int station = line[i].station;
     // printf(α%d %d %d %dnα, line[i].dep_t, line[i].station, line[i].id, line[i].train_id);
 
     f=0;
     for (j=0; j<n; j++) {
       if (train[j].pos == station && train[j].arr_t <= line[i].dep_t) {
 // printf(αold train %d station=%d time=%dnα, j, train[j].pos, train[j].arr_t);
         train[j].pos = (station==STATION_A)?STATION_B:STATION_A;
         train[j].arr_t = line[i].arr_t;
 // printf(αnew train %d station=%d time=%dnα, j, train[j].pos, train[j].arr_t);
         f=1;
         break;
       }
     }
     if (f==0) {
       train[n].pos = (station==STATION_A)?STATION_B:STATION_A;
       train[n].arr_t = line[i].arr_t;
       n++;
       if (station == STATION_A)
         train_a++;
       else
         train_b++;
     }
   }
   printf(α%d %dα, train_a, train_b);
 }
 
 main(int argc, char *argv[])
 {
   char *fname;
   char buf[1024], data[80];
   FILE *fp;
   int i, num, j, t, a, b;
   int h,m,h2,m2;
 
   if (argc<2)
     fname = αA-small.inα;
   else
     fname = argv[1];
 
   fp = fopen(fname, αrα);
   if (!fp) {
     fprintf(stderr, αunable to open %snα, fname);
     exit(-1);
   }
 
   fgets(buf, sizeof(buf), fp);
   num = atoi(buf);
 
   for (i=0; i<num; i++) {
     printf(αCase #%d: α,i+1);
 
     fgets(buf, sizeof(buf), fp);
     t= atoi(buf);
     fscanf(fp,α%d %dnα, &a, &b);
 
     for (j=0; j<a; j++) {
       fscanf(fp,α%d:%d %d:%dnα, &h, &m, &h2, &m2);
       line[j].station = STATION_A;
       line[j].id = j;
       line[j].dep_t = h*60+m;
       line[j].arr_t = h2*60+m2 + t;
     }
     for (j=0; j<b; j++) {
       fscanf(fp,α%d:%d %d:%dnα, &h, &m, &h2, &m2);
 
       line[a+j].station = STATION_B;
       line[a+j].id = a+j;
       line[a+j].dep_t = h*60+m;
       line[a+j].arr_t = h2*60+m2 + t;
     }
     solve(a, b);
     printf(αnα,i+1);
   }
 
   fclose(fp);
 }"
11599,2008,32013,praveenkjvs,24480,1,savingTheUniverse.c,gcj/2008/32013/praveenkjvs/24480/1/extracted/savingTheUniverse.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 //#define debug 1
 
 //function definitions
 int readNoOfcases(void);
 int readCase(void);
 int processCase(void);
 int updateDB(const char*);
 void resetDB(void);
 void showResults(void);
 
 //global Variables
 int iflag = 0;
 int iNoOfCases = 0;
 int iNoOfSearchEngines = 0;
 int iNoOfQueries = 0;
 int iDBSEN[100];
 int iResults[20];
 int iCurrentCase;
 char cSEN[100][100];
 char cQueries[1000][100];
 char cGlobalTemp[100];
 FILE *ptrInputFile = NULL;
 
 
 
 int main(void){
      
      int iFunc_readNoOfcases = 0;
      int iFunc_readCase = 0;
      int iTemp = 0;
      
      //open file to read input
      ptrInputFile = fopen(αA-large.inα, αrα);
      if(ptrInputFile == NULL){
         printf(αn Error Opening Input File. Existing.α);
         getchar();
         return(1);
      }
      
      iFunc_readNoOfcases = readNoOfcases();
      #ifdef debug
      if(iFunc_readNoOfcases != 0)
                  printf(αnError Reading File. Error in function: readNoOfcases()nα);
      #endif
      
      
      //loop for each case
      for (iTemp = 1; iTemp <= iNoOfCases; iTemp++)
      {
          printf(αncurrent case = %dα, iTemp);
          if (iTemp == iNoOfCases) iflag = 1;
          iCurrentCase = iTemp - 1;
          iFunc_readCase = readCase();
      }
      
      fclose(ptrInputFile);
      
      //displaying results
      showResults();
      
      getchar();
      return 0;
 }
      
      
 int readNoOfcases(){
     
     char *cReturnCode;
     
     //reading no of cases
     cReturnCode = fgets(cGlobalTemp, 100, ptrInputFile);
     //check for char *cReturnCode; == NULL for error in reading
     cGlobalTemp[strlen(cGlobalTemp)-1] = '0';   
     iNoOfCases = atoi(cGlobalTemp);
     
     
     #ifdef debug
     printf(αiNoOfCases = %dα,iNoOfCases);
     #endif
     
     return 0;
     
 }
 
 int readCase(void){
     
     int iTemp = 0;
     int iReturn = 0;
     char *cReturnCode;
     
     //reading no of search Engines
     cReturnCode = fgets(cGlobalTemp, 100, ptrInputFile);
     cGlobalTemp[strlen(cGlobalTemp)-1] = '0';
     //check for char *cReturnCode; == NULL for error in reading
     iNoOfSearchEngines = atoi(cGlobalTemp);
     
     
     #ifdef debug
     printf(αniNoOfSearchEngines = %dα,iNoOfSearchEngines);
     #endif
         
     
     for (iTemp = 1; iTemp <= iNoOfSearchEngines; iTemp++)
     {
         cReturnCode = fgets(cGlobalTemp, 100, ptrInputFile);
         cGlobalTemp[strlen(cGlobalTemp)-1] = '0';
         //check for char *cReturnCode; == NULL for error in reading
         
         strcpy(cSEN[iTemp-1], cGlobalTemp);
         iDBSEN[iTemp - 1] = 0;
         
         #ifdef debug
         printf(αnSearch Engine = %sα, cSEN[iTemp-1]);
         #endif
     }
     
     //getting number of queries
     cReturnCode = fgets(cGlobalTemp, 100, ptrInputFile);
     cGlobalTemp[strlen(cGlobalTemp)-1] = '0';
     //check for char *cReturnCode; == NULL for error in reading
     iNoOfQueries = atoi(cGlobalTemp);
     
     
     #ifdef debug
     printf(αniNoOfQueries = %dα,iNoOfQueries);
     #endif
     
     // reading the query queue
     
     for (iTemp = 1; iTemp <= iNoOfQueries; iTemp++)
     {
         /*if ((iflag == 1) && (iTemp == iNoOfQueries))
         {
            fscanf(ptrInputFile, α%sα, cGlobalTemp);
            
            #ifdef debug
            printf(αn******************nα);
            printf(αQuery = %sα, cGlobalTemp);
            printf(αn******************nα);
            #endif
            
            strcpy(cQueries[iTemp-1], cGlobalTemp);
            continue;
         }
         */
         cReturnCode = fgets(cGlobalTemp, 100, ptrInputFile);
         cGlobalTemp[strlen(cGlobalTemp)-1] = '0';
         //check for char *cReturnCode; == NULL for error in reading
         
         strcpy(cQueries[iTemp-1], cGlobalTemp);
         
         #ifdef debug
         printf(αnQuery = %sα, cQueries[iTemp-1]);
         #endif
         
         
     }
     
     
     iReturn = processCase();
     iResults[iCurrentCase] = iReturn;
     
     #ifdef debug
     printf(αn iNoOfSwitches = %dα, iReturn);
     getchar();  
     #endif 
     
     return 0;
 }
 
 int processCase(void){
     
     int iTemp = 0;
     int iRemain = 0;
     int iNoOfSwitches = -1;
     char cCSEN[100];
     char cCQ[100];
     int iReturnUpdateDB;
     
     iRemain = iNoOfSearchEngines;
     
     
     for (iTemp = 1; iTemp <= iNoOfQueries; iTemp++)
     {
         
         strcpy(cCQ, cQueries[iTemp-1]);
         iReturnUpdateDB = updateDB(cCQ);
         
         if (iReturnUpdateDB == 1)
         {
            iRemain--;
            if (iRemain == 0)
            {
               iNoOfSwitches++;
               iTemp--;
               iRemain = iNoOfSearchEngines;
               resetDB();
            }
         }
         if (iReturnUpdateDB == -1)
         {
            printf(αn Fatal Error in function updateDB(). Existing.α);
            getchar();
            exit(0);
         }
     }
     
     return (iNoOfSwitches+1);
  
 }
 
 int updateDB(const char *SEN)
 {
     
     int iTemp = 0;
     int iCompare = 0;
     int iEarlierValue = -1;
     
     for (iTemp = 1; iTemp <= iNoOfSearchEngines; iTemp++)
     {
         iCompare = strcmp(SEN, cSEN[iTemp-1]);
         
         #ifdef debug
         //printf(αn SEN = %sn cSEN = %sα,SEN,cSEN[iTemp-1]);
         //printf(αiCompare = %dα, iCompare);
         #endif
         
         if (iCompare == 0)
         {
            iEarlierValue = iDBSEN[iTemp-1];
            
            if (iEarlierValue == 0)
            {
               iDBSEN[iTemp-1] = 1;
               return 1;
            }
            else
                return 0;
         }
     }
     
     return -1;
 }
 
 void resetDB(void){
      
      int iTemp = 0;
      
      for (iTemp = 1; iTemp <= iNoOfSearchEngines; iTemp++)
      {
          iDBSEN[iTemp-1] = 0;
      }
 }
 
 void showResults(void){
      
      int iTemp = 0;
      
      FILE *ptrOutputFile;
      
      ptrOutputFile = fopen(αoutput.txtα, αwα);
      
      for (iTemp = 1; iTemp <= iNoOfCases; iTemp++)
      {
          if (iTemp == iNoOfCases)
             fprintf(ptrOutputFile, αCase #%d: %dα, iTemp, iResults[iTemp-1]);
          else
              fprintf(ptrOutputFile, αCase #%d: %dnα, iTemp, iResults[iTemp-1]);
      }
      fclose(ptrOutputFile);
 }"
11614,2008,32013,Rugved,24481,1,B.c,gcj/2008/32013/Rugved/24481/1/extracted/B.c,"#include<stdio.h>
 
 #define MAX 100
 
 
 void PrintArray(int a[], int cnt)
 {
 	int i;
 	
 	printf(αnα);
 	for(i=0;i<cnt;i++)
 		printf(α%d  α, a[i]);
 	printf(αnα);
 }
 
 void Sort(int a[], int cnt)
 {
 	int i,j,t;
 	
 	for(i=0;i<cnt;i++)
 	{
 		for(j=i+1;j<cnt;j++)
 		{
 			if(a[j] < a[i])
 			{
 				t = a[j];
 				a[j] = a[i];
 				a[i] = t;
 			}
 		}
 	}
 //	PrintArray(a,cnt);
 }
 
 void Solve(FILE *fp, int caseNum)
 {
 	int T, NA, NB, A_cnt=0, B_cnt=0;
 	int A_DT[MAX], A_AT[MAX], B_DT[MAX], B_AT[MAX];
 	int A_ptr=0, B_ptr=0;
 	int i, num, time;
 	char ch;
 	
 	fscanf(fp, α%dα, &T);
 	fscanf(fp, α%dα, &NA);
 	fscanf(fp, α%dα, &NB);
 	
 //	printf(αnT=%d,NA=%d,NB=%dnα, T,NA,NB);
 	
 	for(i=0;i<NA;i++)
 	{
 		fscanf(fp, α%dα, &num);
 		time = num * 60;
 		fscanf(fp, α%cα, &ch);		// ignore ':'
 		fscanf(fp, α%dα, &num);
 		A_DT[i] = time + num;		// store time in minutes
 		
 		fscanf(fp, α%cα, &ch);		// ignore ' '
 		fscanf(fp, α%dα, &num);
 		time = num * 60;
 		fscanf(fp, α%cα, &ch);		// ignore ':'
 		fscanf(fp, α%dα, &num);
 		B_AT[i] = time + num + T;		// store time in minutes
 	}
 
 	for(i=0;i<NB;i++)
 	{
 		fscanf(fp, α%dα, &num);
 		time = num * 60;
 		fscanf(fp, α%cα, &ch);		// ignore ':'
 		fscanf(fp, α%dα, &num);
 		B_DT[i] = time + num;		// store time in minutes
 		
 		fscanf(fp, α%cα, &ch);		// ignore ' '
 		fscanf(fp, α%dα, &num);
 		time = num * 60;
 		fscanf(fp, α%cα, &ch);		// ignore ':'
 		fscanf(fp, α%dα, &num);
 		A_AT[i] = time + num + T;		// store time in minutes
 	}
 	
 //	PrintArray(A_DT, NA);
 //	PrintArray(A_AT, NB);
 //	PrintArray(B_DT, NB);
 //	PrintArray(B_AT, NA);
 	
 	Sort(A_DT, NA);
 	Sort(A_AT, NB);
 	Sort(B_DT, NB);
 	Sort(B_AT, NA);
 	
 	for(i=0;i<NA;i++)
 	{
 		if(A_ptr < NB && A_AT[A_ptr] <= A_DT[i])
 			A_ptr++;
 		else
 			A_cnt++;
 	}
 
 	for(i=0;i<NB;i++)
 	{
 		if(B_ptr < NA && B_AT[B_ptr] <= B_DT[i])
 			B_ptr++;
 		else
 			B_cnt++;
 	}
 	
 	printf(αCase #%d: %d %dnα, caseNum, A_cnt, B_cnt);
 }
 
 int main(int argc, char* argv[])
 {
 	int i,n;
 	FILE *fp;
 
 	if(argc <= 1)
 	{
 		printf(αUsage: a.out <input_file>nα);
 		return 0;
 	}
 	
 	fp = fopen(argv[1], αrα);
 
 	fscanf(fp, α%dα, &n);
 //	printf(αnn = %dnα,n);
 	
 	for(i=0;i<n;i++)
 		Solve(fp, i+1);
 
 	return 0;
 }"
11726,2008,32013,srini,24481,1,main.c,gcj/2008/32013/srini/24481/1/extracted/main.c,"#include <stdio.h>
 #include <conio.h>
 
 void getinput(int **arr,int **dep,int trips);
 int stringtoint(char *buff);
 int power(int i,int j);
 void quicksort(int a, int b,int *A);
 int calctrain(int *arr,int *dep,int trip1,int trip2);
 
 //static variables
 static int no_of_cases = 0;
 static int turn_around_time = 0;
 
 static FILE * fp;
 
 static int * arr_A;
 static int * arr_B;
 static int * dep_A;
 static int * dep_B;
 
 static int trains_at_A=0;
 static int trains_at_B=0;
 
 
 int main()
 {
 	int tripA,tripB;
 	int len;
 	int case_id;
     char * buff = (char *) malloc(64 * sizeof(char));
 
 	FILE * fp_out = fopen(αD:\Suman\Google CodeJAM\Qualifying Round\Train\output.txtα,αw+α);
 
 	buff[0] = '0';
 
 	fp = fopen(αD:\Suman\Google CodeJAM\Qualifying Round\Train\input.txtα,αr+α);
 
 	if(fp == NULL)
 	{
 		printf(αError opening the input filenα);
 		getch();
 		return 0;
 	}
 	
 	if(fgets(buff,64,fp))
 	{
 		int len1 = strlen(buff);
 		buff[len1-1]='0';
 		 no_of_cases = stringtoint(buff);
 	}
 	
 
 
 	for(case_id=0;case_id<no_of_cases;case_id++)
 	{
 		//read the turn around time
 		if(fgets(buff,64,fp))
 		{
 			int len1 = strlen(buff);
 			buff[len1-1]='0';
 			turn_around_time = stringtoint(buff);
 		}
 		// now read the number of lines for A and B
 		if(fgets(buff,64,fp))
 		{
 			int i=0,j=0;
 			char tmp[15];
 			while(buff[i] != ' ')
 			{
 				tmp[j] = buff[i];
 				i++;j++;
 			}
 			tmp[j]='0';
 			tripA = stringtoint(tmp);
 			i++;
 			j=0;
 			
 			while((buff[i] != ' ') && (buff[i] != '0'))
 			{
 				tmp[j] = buff[i];
 				i++;j++;
 			}
 			tmp[j-1]='0';
 			tripB = stringtoint(tmp);
 		
 		}
 
 		// now read the input from the file ---Station A details
 		getinput(&arr_A,&dep_A,tripA);
 		getinput(&arr_B,&dep_B,tripB);
 		// sort all the arrays
 		quicksort(0, tripA-1,arr_A);
 		quicksort(0, tripA-1,dep_A);
 		quicksort(0, tripB-1,arr_B);
 		quicksort(0, tripB-1,dep_B);
 		//
 		trains_at_A = calctrain(arr_A,dep_B,tripA,tripB);
 		trains_at_B = calctrain(arr_B,dep_A,tripB,tripA);
 		//write output
 		if(fp_out)
 		{
 			fprintf(fp_out,αCase #%d: %d %dnα,case_id+1,trains_at_A,trains_at_B);
 			fflush(fp_out);
 		}
 
 	}
 
 		
 	fclose(fp);
 	fclose(fp_out);
 
 	getch();
 	return 0;
 }
 
 //
 int calctrain(int *arr,int *dep,int trip1,int trip2)
 {
 	int i,j=0,k;
 	int val;
 	int trains=0;
 
 	if((trip1 != 0) && (trip2 != 0))
 	{
 		for(i=0;i<trip1;i++)
 		{
 			val = arr[i] - turn_around_time;
 
 			while((dep[j]<val)&&(j<trip2))
 			{
 				trains++;
 				if(j<trip2)
 				{
 					j++;
 					break;
 				}
 			}
 		}
 	}
 	return (trip1 - trains);
     
 }
 
 
 
 
 
 // reads the input from the FILE
 void getinput(int **arr,int **dep,int trips)
 {
 	int i,j;
 	int time_hr,time_min;
 	char *buff = (char *) malloc(16*sizeof(char));
 	char *tbuff;
 	char tmp[4];
     buff[0] = '0';
 	
 	tbuff = buff;
 
 
 	*arr = (int *) malloc(trips*sizeof(int));
 	*dep = (int *) malloc(trips*sizeof(int));
 
 	for(i=0;i<trips;i++)
 	{
 		buff =tbuff;
 		fgets(buff,16,fp);
 		
             tmp[0]=buff[0];
 			tmp[1]=buff[1];
 			tmp[2]='0';
 			
 			arr[0][i]=60*(stringtoint(tmp));
 			buff =buff+3;
 
 			tmp[0]=buff[0];
 			tmp[1]=buff[1];
 			tmp[2]='0';
 			
 			arr[0][i]=arr[0][i] + stringtoint(tmp);
 			buff =buff+3;
 
 			tmp[0]=buff[0];
 			tmp[1]=buff[1];
 			tmp[2]='0';
 
 			dep[0][i]=60*(stringtoint(tmp));
 			buff =buff+3;
 
 			tmp[0]=buff[0];
 			tmp[1]=buff[1];
 			tmp[2]='0';
 			
 			dep[0][i]=dep[0][i] + stringtoint(tmp);
 		
 	}
 
 }
 
 
 
 
 
 
 // converts string to int
 int stringtoint(char *buff)
 {
 	int i=0;
 	int val=0;
 	int size;
 	char ch;
 
 	size = strlen(buff);
 	//size = size -2;
 	i = size;
 
 
 	while(i>0)
 	{
 		ch = buff[i-1];
 		val =val + (((int) ch) - 48) * power(10, size-i) ;
 		//val = val - 48;
 
 		i--;
 	}
 
 	return val;
 }
 // power function
 int power(int i,int j)
 {
 	int t,val=1;
 	for(t=1;t<=j;t++)
 		val = val * i;
 
 	return val;
 }
 //QuickSort function
 void quicksort(int a, int b,int *A)
 { 
 	int rtidx=0,ltidx=0,k=a,l=0,pivot; 
 	int leftarr[1000],rtarr[1000];  
 	pivot=A[a]; 
 
 	if(a==b)
 		return; 
 	
 	while(k<b)
 	{
 		++k;
 		if(A[k]<A[a])
 		{
 			leftarr[ltidx]=A[k];
 			ltidx++;
 		}
 		else
 		{
 			rtarr[rtidx]=A[k];
 			rtidx++;
 		}
 	}
 
 	k=a;
 	
 	for(l=0;l<ltidx;++l)
 		A[k++]=leftarr[l];
 	A[k++]=pivot;
 	
 	for(l=0;l<rtidx;++l)
 		A[k++]=rtarr[l];
 
 	if(ltidx>0)
 		quicksort(a,a+ltidx-1,A);
 	
 	if(rtidx>0)
 		quicksort(b-rtidx+1,b,A);
 
 }"
11748,2008,32013,paritosh1010,24480,1,q1.c,gcj/2008/32013/paritosh1010/24480/1/extracted/q1.c,"#include<stdio.h>
 #include<string.h>
 #include<conio.h>
 
 
 
 //Code Jam 08 Problem 1;
 
 #define MAX 200
 void init_marked(char *got, int s);
 
 int main()
 {
 
 	
 	
 	char list[MAX][MAX], query[MAX];
 	int queries[2000];
 		int k,n,s,i,j,q;
 	
 	char got[MAX];
 	int no_marked,switchctr;
 
 	scanf(α%dα, &n);
 	
 	
 
 	for(k=0;k<n;k++)
 	{
 		scanf(α%dα, &s);
 		
       //Input search engines
 		for(i=0;i<s;i++)
 		
 		{
 			scanf(α %[^n]α, list[i]);
 			
 			
 		}
 
 		scanf(α%dα, &q);
 
 		for(i=0;i<q;i++)
 		{
 			scanf(α %[^n]α, query);
 		//input, analyse query values
 			for(j=0;j<s;j++)
 			{
 				if(strcmp(query, list[j]) == 0)
 				{
 					queries[i] = j;
 					break;
 				}
 			}
 		}
 
 		init_marked(got, s);
 		
 		
 
 		no_marked = 0;
 		switchctr = 0;
 		
 		
 
 		for(i=0;i<q;)
 		{
 			if(got[queries[i]] == '0')
 			{
 				got[queries[i]] = 'x';
 				no_marked++;
 			}
 
 			if(no_marked == s)
 			{
 				no_marked = 0;
 				switchctr++;
 				init_marked(got, s);
 			}
 			else
 				i++;
 		}
 
 
 
 		printf(αCase #%d: %dnα, k+1, switchctr);
 	}
 
 	return 0;
 }
 
 void init_marked(char *got, int s)
 {
 	int i;
 	for(i=0;i<s;i++)
 	{
 		got[i] = '0';
 	}
 }"
11846,2008,32013,swami1985,24480,1,search.c,gcj/2008/32013/swami1985/24480/1/extracted/search.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int doCase(FILE* fin)
 {
 int S=0;
 	fscanf(fin,α%dnα,&S);
 	//printf(α%dα,S);
 	char eng[S][100];
 	char temp;
 	for(int i=0;i<S;i++) 
 	{
 		fgets(eng[i],100,fin);
 		//printf(α%sα,eng[i]);
 	}
 	
 	
 	
 	int Q;
 	
 	fscanf(fin,α%dnα,&Q);
 	printf(αn%dα,Q);
 	char query[Q][100];
 	
 	for(int i=0;i<Q;i++) 
 	{
 		fgets(query[i],100,fin);
 		//printf(α%sα,query[i]);
 	}
 	
 	
 	
 	//all queries read
 	
 	
 	int flag[S];int curr=-1;
 	for(int i=0;i<S;i++) flag[i]=0;
 	int no_sw=0;
 	for(int i=0;i<Q;i++) //for each q
 	{
 	 // setFlag(query[i],eng,flag);//set flag corres to q[i]
 	  int cureng=-1;
 	  	for(int j=0;j<S;j++)
 	  	{
 	  		if(strcmp(eng[j],query[i])==0) 
 	  		{ flag[j]=1;cureng=j; break;}
 	  	}
 	  	
 	  	int cnt=0;
 	  	for(int j=0;j<S;j++)
 	  	{
 	  		if(flag[j]==0){curr=j; cnt++;}
 	  	}
 	  	if(cnt==0) //found pick
 	  	{
 	  	//check for each possible curr and choose one with max i.
 	  	//int i2max=0,curmax=0;
 	  	 //for(int k=0;k<S;k++)
 	  	 //{
 	  	 //if(flag[k]==0) {curr=k;
 		  //int i2=i;
 		  
 	  	 //while(i<Q && strcmp(query[i],eng[curr])!=0 ) {i++;}
 	  	
 	  	 //if(i2>i2max){ i2max=i2;curmax=curr;}
 	  	  
 	  	 //}
 	  	 //curr=curmax;
 	  	 //i=i2max;
 	  	 //if(i==Q) break;
 	  	 no_sw++;
 	  	 for(int j=0;j<S;j++) flag[j]=0;
 	  	 flag[cureng]=1;
 	  	//set flaG of deppest engine
 	  	
 	  	
 	  	
 	  	
 	  	
 	  	
 	  	}
 	  	
 	  	
 	  		 
 
 
 	  }
 	  
 	
 	
 	
 	
 	return no_sw;
 }
 	
 	
 
 
 int main()
 {
 FILE *fin,*fout;
 int N;
 fin=fopen(αA-large.inα,αrwα);
 fout=fopen(αoutputα,αwα);
 fscanf(fin,α%dnα,&N);
 //printf(α%dα,N);
 for(int i=0;i<N;i++) fprintf(fout,αCase #%d: %dnα,i+1,doCase(fin));
 fclose(fin);
 fclose(fout);
 return 0;
 }"
11910,2008,32013,Eduardopa,24480,1,Search.c,gcj/2008/32013/Eduardopa/24480/1/extracted/Search.c,"#include <stdio.h>
 #include <math.h>
 #include <string.h>
 
 #define BUFF_SIZE 200
 
 typedef struct SEARCH_ENGINE
 {
 	char name[BUFF_SIZE];
 	unsigned char used;
 }SEARCH_ENGINE;
 
 void zeroEngines (SEARCH_ENGINE * sEngines, int qtdEngines)
 {
 	int i;
 	for (i=0;i<qtdEngines;i++)
 		sEngines[i].used = 0;
 }
 
 SEARCH_ENGINE * findEngine (SEARCH_ENGINE * sEngines, int qtdEngines, char * name)
 {
 	int i;
 
 	for (i=0;i<qtdEngines; i++)
 		if (strcmp (sEngines[i].name, name) == 0)
 			return &sEngines[i];
 	return NULL;
 }
 void saveUniverse (SEARCH_ENGINE * sEngines, int qtdEngines, char queries[1000][BUFF_SIZE], int qtdQueries, int * output)
 {
 	int i;
 	int j;
 	SEARCH_ENGINE * aux;
 
 	*output = 0;
 	for (i=0;i<qtdQueries;i++)
 	{
 		aux = findEngine(sEngines, qtdEngines, queries[i]);
 		if (aux->used == 0)
 		{
 			aux->used = 1;
 			for (j=0;j<qtdEngines;j++)
 				if (sEngines[j].used == 0)
 					break;
 			if (j == qtdEngines)
 			{
 				*output += 1;
 				zeroEngines(sEngines,qtdEngines);
 			}
 			aux->used = 1;
 		}
 	}
 }
 
 void main (void)
 {
 	FILE * inputFile;
 	FILE * outputFile;
 	int paramCount;
 	int i;
 	int j;
 	SEARCH_ENGINE sEngines[100];
 	int qtdEngines;
 	char queries[1000][BUFF_SIZE];
 	int qtdQueries;
 	int output;
 
 	inputFile = fopen (αinput.txtα, αrtα);
 	if (inputFile == NULL)
 	{
 		puts (αFile not foundα);
 		return;
 	}
 	outputFile = fopen (αoutput.txtα, αwtα);
 	if (outputFile == NULL)
 	{
 		puts (αError creating fileα);
 		return;
 	}
 	fscanf (inputFile,α%dα,&paramCount);
 
 	for (i=0;i<paramCount;i++)
 	{
 		fscanf (inputFile, α%dnα,&qtdEngines);
 		for (j=0;j<qtdEngines;j++)
 		{
 			fgets (sEngines[j].name,BUFF_SIZE,inputFile);
 			if (strlen(sEngines[j].name) >= 1 && (sEngines[j].name[strlen(sEngines[j].name) - 1] == 10 || sEngines[j].name[strlen(sEngines[j].name) - 1] == 13))
 				sEngines[j].name[strlen(sEngines[j].name) - 1] = 0;
 		}
 		fscanf (inputFile, α%dnα,&qtdQueries);
 		for (j=0;j<qtdQueries;j++)
 		{
 			fgets (queries[j],BUFF_SIZE,inputFile);
 			if (strlen(queries[j]) >= 1 && (queries[j][strlen(queries[j]) - 1] == 10 || queries[j][strlen(queries[j]) - 1] == 13))
 				queries[j][strlen(queries[j]) - 1] = 0;
 		}
 
 		zeroEngines(sEngines, qtdEngines);
 		saveUniverse(sEngines, qtdEngines, queries, qtdQueries, &output);
 		fprintf (outputFile, αCase #%d: %dnα,i+1, output);
 	}
 
 	fclose (inputFile);
 	fclose (outputFile);
 }"
11912,2008,32013,Eduardopa,24481,1,Train.c,gcj/2008/32013/Eduardopa/24481/1/extracted/Train.c,"#include <stdio.h>
 #include <math.h>
 #include <string.h>
 
 #define BUFF_SIZE 200
 
 typedef struct TRAIN_TT
 {
 	int departure;
 	int freeTime;
 	unsigned char newTrain;
 }TRAIN_TT;
 
 void initTrains (TRAIN_TT * trains, int qtdTrains)
 {
 	int i;
 
 	for (i=0;i<qtdTrains;i++)
 		trains[i].newTrain = 1;
 }
 
 int compDepart (TRAIN_TT * first, TRAIN_TT * second)
 {
 	if (first->departure < second->departure)
 		return -1;
 	if (first->departure > second->departure)
 		return 1;
 	return 0;
 
 }
 
 int compFreeTime (TRAIN_TT * first, TRAIN_TT * second)
 {
 	if (first->freeTime < second->freeTime)
 		return -1;
 	if (first->freeTime > second->freeTime)
 		return 1;
 	return 0;
 
 }
 
 void bSort (TRAIN_TT * vet, int tamVet, int (*comp)(void *, void *))
 {
 	int i;
 	int j;
 	TRAIN_TT aux;
 
 	for (i=0;i<tamVet;i++)
 	{
 		for (j=i+1;j<tamVet;j++)
 		{
 			if (comp(&vet[i],&vet[j]) == 1) // j  maior
 			{
 				aux = vet[i];
 				vet[i] = vet[j];
 				vet[j] = aux;
 			}
 		}
 	}
 }
 
 void Trains(TRAIN_TT * trainsA, int qtdTrainsA, TRAIN_TT * trainsB, int qtdTrainsB, int * iniTrainsA, int * iniTrainsB)
 {
 	int i;
 	int j;
 
 	initTrains (trainsA,qtdTrainsA);
 	initTrains (trainsB,qtdTrainsB);
 	*iniTrainsA = 0;
 	*iniTrainsB = 0;
 
 	bSort (trainsA,qtdTrainsA,compDepart);
 	bSort (trainsB,qtdTrainsB,compFreeTime);
 
 	j=0;
 	for (i=0;i<qtdTrainsB;i++)
 	{
 		for (;j<qtdTrainsA;j++)
 		{
 			if (trainsB[i].freeTime <= trainsA[j].departure)
 			{
 				trainsA[j].newTrain = 0;
 				j++;
 				break;
 			}
 		}
 	}
 
 	bSort (trainsA,qtdTrainsA,compFreeTime);
 	bSort (trainsB,qtdTrainsB,compDepart);
 
 	j=0;
 	for (i=0;i<qtdTrainsA;i++)
 	{
 		for (;j<qtdTrainsB;j++)
 		{
 			if (trainsA[i].freeTime <= trainsB[j].departure)
 			{
 				trainsB[j].newTrain = 0;
 				j++;
 				break;
 			}
 		}
 	}
 
 	for (i=0;i<qtdTrainsA;i++)
 		*iniTrainsA += trainsA[i].newTrain;
 
 	for (i=0;i<qtdTrainsB;i++)
 		*iniTrainsB += trainsB[i].newTrain;
 
 }
 
 void main (void)
 {
 	FILE * inputFile;
 	FILE * outputFile;
 	int paramCount;
 	int i;
 	int j;
 	TRAIN_TT trainsA[BUFF_SIZE];
 	int qtdTrainsA;
 	int qtdTrainsB;
 	int auxHour;
 	int auxMin;
 	TRAIN_TT trainsB[BUFF_SIZE];
 	int turnTime;
 	int iniTrainsA;
 	int iniTrainsB;
 
 	inputFile = fopen (αinput.txtα, αrtα);
 	if (inputFile == NULL)
 	{
 		puts (αFile not foundα);
 		return;
 	}
 	outputFile = fopen (αoutput.txtα, αwtα);
 	if (outputFile == NULL)
 	{
 		puts (αError creating fileα);
 		return;
 	}
 	fscanf (inputFile,α%dα,&paramCount);
 
 	for (i=0;i<paramCount;i++)
 	{
 		fscanf (inputFile, α%dα, &turnTime);
 		fscanf (inputFile, α%d %dα,&qtdTrainsA, &qtdTrainsB);
 		for (j=0;j<qtdTrainsA;j++)
 		{
 			fscanf (inputFile, α%d:%dα, &auxHour, &auxMin);
 			trainsA[j].departure = auxHour * 60 + auxMin;
 			fscanf (inputFile, α%d:%dα, &auxHour, &auxMin);
 			trainsA[j].freeTime = auxHour * 60 + auxMin + turnTime;
 		}
 		for (j=0;j<qtdTrainsB;j++)
 		{
 			fscanf (inputFile, α%d:%dα, &auxHour, &auxMin);
 			trainsB[j].departure = auxHour * 60 + auxMin;
 			fscanf (inputFile, α%d:%dα, &auxHour, &auxMin);
 			trainsB[j].freeTime = auxHour * 60 + auxMin + turnTime;
 		}
 		Trains(trainsA, qtdTrainsA, trainsB, qtdTrainsB, &iniTrainsA, &iniTrainsB);
 		fprintf (outputFile, αCase #%d: %d %dnα,i+1, iniTrainsA, iniTrainsB);
 	}
 
 	fclose (inputFile);
 	fclose (outputFile);
 }"
11920,2008,32013,orb1t.ua,24480,1,main.c,gcj/2008/32013/orb1t.ua/24480/1/extracted/main.c,"// Excuse for an ugly looking code :)))
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
 
 #define SEnameMax 100
 
 char SEnames[100][SEnameMax];
 char Queries[1000][SEnameMax];
 
 int SeCanExecuteQueries[100];
 
 int N = 0;
 int S = 0;
 int Q = 0;
 
 int QryStrt = 0;
 
 int CanExecute ( int SEidx )
 {
     int res = 0;
 
     int i = 0;
     for ( i = QryStrt; i < Q; i++ )
     {
         if ( strcmp ( SEnames[SEidx], Queries[i] ) != 0 )
         {
             res++;
         }
         else
         {
             break;
         }
     }
 
     return res;
 }
 
 void select ( int SEidx )
 {
     QryStrt = QryStrt + SeCanExecuteQueries[SEidx];
 }
 
 int main(int argc, char * argv[])
 {
     if ( argc < 1 )
     {
         printf ( αError: please specify name of an input set filenα );
     }
 
     FILE *fin;
     FILE *fout;
 
     fin=fopen (argv[1],αrα);
     if (fin==NULL)
     {
         puts (αError reading input fileα);
         exit(EXIT_FAILURE);
     }
 
     int j = 0;
     char tmp[100];
 
     fout = fopen (αset.outα,αwα);
 
 
     fgets(tmp, 100, fin);
     N = atoi(tmp);
 
     for ( j = 0; j < N; j++)
     {
         QryStrt = 0;
         memset(SEnames, 0, sizeof(SEnames) );
         memset(Queries, 0, sizeof(Queries) );
         memset(SeCanExecuteQueries, 0, sizeof(SeCanExecuteQueries) );
 
         fgets(tmp, 100, fin);
         S = atoi(tmp);
 
         int i = 0;
 
         for ( i = 0; i < S; i++ )
         {
             fgets(SEnames[i], SEnameMax, fin);
         }
 
         fgets(tmp, 100, fin);
         Q = atoi(tmp);
 
         for ( i = 0; i < Q; i++ )
         {
             fgets(Queries[i], SEnameMax, fin);
         }
 
         for ( i = 0; i < S; i++ );
         {
                 SeCanExecuteQueries[i] = 0;
         }
 
         int cnt = -1;
         if ( Q == 0 )
         {
             cnt = 0;
         }
 
         while ( QryStrt < Q )
         {
             for ( i = 0; i < S; i++ )
             {
                 SeCanExecuteQueries[i] = CanExecute(i);
             }
 
             int k = 0;
             for ( i = 1; i < S; i++ )
             {
                 if ( SeCanExecuteQueries[k] < SeCanExecuteQueries[i] )
                 {
                     k = i;
                 }
             }
 
             select(k);
             cnt++;
         }
 
         sprintf(tmp, αCase #%i: %inα, j + 1, cnt );
         fputs(tmp, fout);
     }
 
     fclose ( fin );
     fclose ( fout );
 
     return 0;
 }"
12023,2008,32013,joliveirinha,24480,1,a.c,gcj/2008/32013/joliveirinha/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAXS 101
 #define MAXQ 1002
 #define MAXSTR 1000
 
 int n, s, q;
 int data[MAXS][MAXQ];
 char engines[MAXS][MAXSTR];
 char querys[MAXQ][MAXSTR];
 
 int solve(int a, int b) {
 	int tmp = strcmp(engines[a], querys[b]);
 	int i, min=q, result;
 
 	if (b==q)
 		return 0;
 
 	if (data[a][b] != -1)
 		return data[a][b];
 
 	if (tmp==0) {
 		for (i=0;i<s;i++)
 			if (i!=a) {
 				tmp = 1+solve(i, b+1);
 				if (tmp < min)
 					min = tmp;
 			}
 
 		result = min;
 	} else 
 		result = solve(a, b+1);
 
 	return data[a][b] = result;
 }
 
 int main(void) {
 	int i, j;
 
 	scanf(α%dα, &n);
 	for (i=0;i<n;i++) {
 		memset(data, -1,sizeof(data));
 
 		scanf(α%dnα, &s);
 		for (j=0;j<s;j++) 
 			fgets(engines[j], sizeof(engines[j]), stdin);
 
 		scanf(α%dnα, &q);
 		for (j=0;j<q;j++)
 			fgets(querys[j], sizeof(querys[j]), stdin);
 	
 		if (q==0) {
 			printf(αCase #%d: %dnα, i+1, 0);
 			continue;
 		}
 
 		int min = q, t;
 		for (j=0;j<s;j++) {
 			t = solve(j, 0);
 			if (t<min)
 				min = t;
 		}
 	
 		printf(αCase #%d: %dnα, i+1, min);
 	}
 
 	return 0;
 }"
12025,2008,32013,joliveirinha,24481,1,b.c,gcj/2008/32013/joliveirinha/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX 205
 
 typedef struct _route {
 	int station;
 	int h1, m1, h2,m2;
 } route;
 
 typedef struct _train {
 	int station;
 	int h, m;
 } train;
 
 route timetable[MAX];
 train trains[MAX];
 int n, na, nb, t, conta;
 
 int cmp(const void *a, const void *b) {
 	route *a2 = (route *) a;
 	route *b2 = (route *) b;
 
 	if (a2->h1 == b2->h1)
 		return a2->m1 - b2->m1;
 	else return a2->h1 - b2->h1;
 }
 
 int checktime(int a, int b) {
 
 	int t = timetable[a].h1 - trains[b].h;
 	int t2 = timetable[a].m1 - trains[b].m;
 
 	//printf(α%d:%d %d:%dnα, timetable[a].h1, timetable[a].m1, trains[b].h, trains[b].m);
 
 	if (t>0 || (t==0 && t2>=0))
 		return 1;
 	else return 0;
 }
 
 int main(void) {
 	int i, j, a, b, c, d;
 	int contat[2], conta;
 
 	scanf(α%dα, &n);
 
 	for (i=0;i<n;i++) {
 		scanf(α%d%d%dα, &t, &na, &nb);
 		for (j=0;j<na+nb;j++) {
 			scanf(α%d:%d %d:%dα, &timetable[j].h1, &timetable[j].m1, &timetable[j].h2, &timetable[j].m2);
 			
 			if (j>=na)
 				timetable[j].station = 1;
 			else timetable[j].station = 0;
 		}
 	
 
 		qsort(timetable, na+nb, sizeof(route), cmp);
 
 		conta = contat[0] = contat[1] = 0;
 		for (j=0;j<na+nb;j++) {
 			int flag = 0;
 			int k, use;
 
 			for (k=0;k<conta;k++) 
 				if (timetable[j].station == trains[k].station && checktime(j, k)) {
 					use = k;
 					flag = 1;
 					break;
 				}
 
 			if (!flag) { 
 				use = conta;
 				conta++;
 				contat[timetable[j].station]++;
 			}
 
 			trains[use].station = !timetable[j].station;
 			trains[use].m = (timetable[j].m2 + t)%60;
 			trains[use].h = timetable[j].h2 + (timetable[j].m2+t>=60?1:0); 
 		}
 
 		printf(αCase #%d: %d %dnα, i+1, contat[0], contat[1]);
 	}
 
 	return 0;
 }"
12027,2008,32013,Kasti,24481,1,code_2.c,gcj/2008/32013/Kasti/24481/1/extracted/code_2.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 
 typedef struct _Station
 {
   struct _Station * Next;
   int AvailTime;
 } TStation;
 
 typedef struct _ListTrain
 {
   struct _ListTrain * Next;
   int Salida;
   int Llegada;
   int Station;
 } TListTrain;
  
 
 TListTrain * ListTrain = NULL;
 TStation * StationA = NULL;
 TStation * StationB = NULL;
 
 
 void AddExit(int Salida, int Llegada, int Station)
 {
   TListTrain * ptr, * ptrtmp;
   ptr = calloc(1, sizeof(TListTrain));
   if (ptr != NULL)
   {
     ptr->Llegada = Llegada;
     ptr->Salida = Salida;
     ptr->Station = Station;
     if (ListTrain == NULL)
     {
       ListTrain = ptr;
     }
     else
     {
       if (Salida < ListTrain->Salida)
       {
         ptr->Next = ListTrain;
         ListTrain = ptr;
       }
       else
       {
         ptrtmp = ListTrain;
         while ((ptrtmp->Next != NULL) && (ptrtmp->Next->Salida < Salida))
         {
           ptrtmp = ptrtmp->Next;
         }
         ptr->Next = ptrtmp->Next;
         ptrtmp->Next = ptr;
       }
     }
   }
 }
 
 
 void AddTrain(TStation ** Station, int AvailTime)
 {
   TStation * ptr, * ptrtmp;
   ptr = calloc(1, sizeof(TStation));
   if (ptr != NULL)
   {
     ptr->AvailTime = AvailTime;
     if (*Station == NULL)
     {
       *Station = ptr;
     }
     else
     {
       if (AvailTime < (*Station)->AvailTime)
       {
         ptr->Next = *Station;
         *Station = ptr;
       }
       else
       {
         ptrtmp = *Station;
         while ((ptrtmp->Next != NULL) && (ptrtmp->Next->AvailTime < AvailTime))
         {
           ptrtmp = ptrtmp->Next;
         }
         ptr->Next = ptrtmp->Next;
         ptrtmp->Next = ptr;
       }
     }
   }
 }
 
 
 void main()
 {
   FILE * f;
 //  f = fopen(αc:\data\B-small-attempt0.inα, αrα);
   f = fopen(αc:\data\B-large.inα, αrα);
 //  f = fopen(αc:\data\data2.txtα, αrα);
   if (f != NULL)
   {
     int N;
     int n;
     fscanf(f, α%dnα, &N);
     for (n=0; n<N; n++)
     {
       int T, NA, NB, i;
       int NTrainsA = 0, NTrainsB = 0;
       TListTrain * ptrtrain;
       fscanf(f, α%dnα, &T);
       fscanf(f, α%d %dnα, &NA, &NB);
       for (i=0; i<NA; i++)
       {
         int hour0, hour1, min0, min1;
         fscanf(f, α%02d:%02d %02d:%02dnα, &hour0, &min0, &hour1, &min1);
         AddExit(hour0*60+min0, hour1*60+min1, 'A');
       }
       for (i=0; i<NB; i++)
       {
         int hour0, hour1, min0, min1;
         fscanf(f, α%02d:%02d %02d:%02dnα, &hour0, &min0, &hour1, &min1);
         AddExit(hour0*60+min0, hour1*60+min1, 'B');
       }
       ptrtrain = ListTrain;
       while (ptrtrain != NULL)
       {
         ListTrain = ListTrain->Next;
         if (ptrtrain->Station == 'A')
         {
           AddTrain(&StationB, ptrtrain->Llegada + T);
           if (StationA == NULL)
           {
             NTrainsA++;
           }
           else
           {
             if (StationA->AvailTime > ptrtrain->Salida)
             {
               NTrainsA++;
             }
             else
             {
               if (StationA != NULL)
               {
                 TStation * ptr  = StationA;
                 StationA = StationA->Next;
                 free(ptr);
               }
             }
           }
         }
         else
         {
           AddTrain(&StationA, ptrtrain->Llegada + T);
           if (StationB == NULL)
           {
             NTrainsB++;
           }
           else
           {
             if (StationB->AvailTime > ptrtrain->Salida)
             {
               NTrainsB++;
             }
             else
             {
               if (StationB != NULL)
               {
                 TStation * ptr  = StationB;
                 StationB = StationB->Next;
                 free(ptr);
               }
             }
           }
         }
         free(ptrtrain);
         ptrtrain = ListTrain;
       }
       printf(αCase #%d: %d %dnα, n+1, NTrainsA, NTrainsB);
       {
         TStation * ptr;
         while (StationA != NULL)
         {
           ptr = StationA;
           StationA = StationA->Next;
           free(ptr);
         }
         while (StationB != NULL)
         {
           ptr = StationB;
           StationB = StationB->Next;
           free(ptr);
         }
       }
     }
     fclose(f);
   }
 }"
12069,2008,32013,slayer1000,24480,1,STU.c,gcj/2008/32013/slayer1000/24480/1/extracted/STU.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_ENGINE	100
 #define MAX_QUERIE	1000
 
 
 int processing(int S, int Q);
 
 
 char Search_engine[MAX_ENGINE][100];
 char Querie[MAX_QUERIE][100];
 
 int main(void)
 {
 	int n, i, j;
 	FILE* in;
 	FILE* out;
 	int S, Q;
 	char string[100];
 	char ch;
 	int t;
 
 	in = fopen(αA-large.inα, αrα);
 	out = fopen(αoutα, αwtα);
 
 	fscanf(in, α%dα, &n);
 
 	for(i=0; i < n; i++)
 	{
 		fscanf(in, α%dα, &S);
 		fgetc(in);
 		for(j=0; j < S; j++)
 		{
 			memset(&string, '0', sizeof(char)*100);
 			t = 0;
 			while((ch=fgetc(in))!='n')
 			{
 				string[t++] = ch;
 			}
 			strncpy(Search_engine[j], string, 100);
 		}
 		fscanf(in, α%dα, &Q);
 		fgetc(in);
 		for(j=0; j < Q; j++)
 		{
 			memset(&string, '0', sizeof(char)*100);
 			t = 0;
 			while((ch=fgetc(in))!='n' && ch !=EOF)
 			{
 				string[t++] = ch;
 			}
 			strncpy(Querie[j], string, 100);
 		}
 		//fprintf(stdout, αCase #%d: %dnα, i+1, processing(S, Q));
 		fprintf(out, αCase #%d: %dnα, i+1, processing(S, Q));
 	}
 
 	return 0;
 }
 
 int processing(int S, int Q)
 {
 	int* check;
 	int i, j;
 	int ok;
 	int out;
 	int f;
 
 	check = (int *)calloc(sizeof(int), S);
 
 	out = 0;
 	ok = 0;
  	for(i=0; i < Q; i++)
 	{
 		for(j=0; j < S; j++)
 		{
 			if(!strncmp(Querie[i], Search_engine[j],100))
 			{
 				check[j] = 1;
 				f = j;
 				break;
 			}
 		}
 		for(j=0; j < S; j++)
 		{
 			if(check[j]==0)
 			{
 				ok = 1;
 				break;
 			}
 		}
 		if(ok==0)
 		{
 			for(j=0; j < S; j++)
 				check[j] = 0;
 			out ++;
 			check[f] = 1;
 		}
 		else 
 			ok = 0;
 	}
 
 	return out;
 }"
12071,2008,32013,slayer1000,24481,1,TT.c,gcj/2008/32013/slayer1000/24481/1/extracted/TT.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX	100
 
 struct time_table
 {
 	short s_hour;
 	short s_min;
 	short e_hour;
 	short e_min;
 	char station;
 	short go;
 	short num;	
 } AtoB[MAX], BtoA[MAX];
 
 void processing(int NA, int NB, int T);
 void check_all(int num, char station, int size);
 void output(int A, int B);
 void sort_e(struct time_table* x, int n);
 void sort_s(struct time_table* x, int n);
 struct time_table* mearge_table(struct time_table*, int NA, int NB);
 void re(struct time_table* arr, int hour, int min, int size, char station);
 void re2(struct time_table* arr, int hour, int min, int size, char station);
 
 FILE* out;
 struct time_table* end;
 struct time_table* start;
 int T;
 
 int main(void)
 {
 	FILE* in;
 
 	int n;	
 	int NA, NB;
 	int i, j;
 	char ch;
 
 	in = fopen(αB-large.inα,αrα);
 	out = fopen(αoutα, αwtα);
 
 
 	fscanf(in, α%dα, &n);
 	for(i=0; i < n; i++)
 	{
 		fscanf(in, α%d %d %dα, &T, &NA, &NB);
 		for(j=0; j < NA; j++)
 		{
 			fscanf(in, α%d%c%dα, &AtoB[j].s_hour, &ch, &AtoB[j].s_min);
 			fscanf(in, α%d%c%dα, &AtoB[j].e_hour, &ch, &AtoB[j].e_min);
 			AtoB[j].go = 0;
 			AtoB[j].station = 'A';
 			AtoB[j].num = j;
 		}
 		for(j=0; j < NB; j++)
 		{
 			fscanf(in, α%d%c%dα, &BtoA[j].s_hour, &ch, &BtoA[j].s_min);
 			fscanf(in, α%d%c%dα, &BtoA[j].e_hour, &ch, &BtoA[j].e_min);
 			BtoA[j].go = 0;
 			BtoA[j].station = 'B';
 			BtoA[j].num = j;
 		}
 		processing(NA, NB, T);
 	}
 
 	return 0;
 }
 
 void processing(int NA, int NB, int T)
 {
 	int i;
 	int hour, min;
 	int n_A = 0;
 	int n_B = 0;
 
 	end = mearge_table(end, NA, NB);
 	start = mearge_table(start, NA, NB);
 	sort_e(end, NA+NB);
 	sort_s(start, NA+NB);
 
 	for(i=0; i < NA+NB; i++)
 	{
 		if(end[i].go==1) continue;
 
 		hour = end[i].e_hour;
 		min = end[i].e_min + T;
 		if(min >= 60)
 		{
 			hour++;
 			min -= 60;
 		}
 		check_all(end[i].num, end[i].station, NA+NB);
 
 		re(start, hour, min, NA+NB, end[i].station);
 
 		if(end[i].station=='A') n_A++;
 		else n_B++;
 	}
 
 	output(n_A, n_B);
 }
 
 void re(struct time_table* arr, int hour, int min, int size, char station)
 {
 	int i;
 	
 	for(i=0; i < size; i++)
 	{
 		if( (arr[i].s_hour > hour || ( (arr[i].s_hour==hour) && (arr[i].s_min >=min) )) && arr[i].go==0
 			&& arr[i].station!=station)
 		{
 			check_all(arr[i].num, arr[i].station, size);
 			hour = arr[i].e_hour;
 			min = arr[i].e_min + T;
 			if(min >=60)
 			{
 				hour++;
 				min -= 60;
 			}
 			if(station=='A') re(start, hour, min, size, 'B');
 			else re(start, hour, min, size, 'A');
 			break;
 		}
 	}
 }
 
 void re2(struct time_table* arr, int hour, int min, int size, char station)
 {
 	int i;
 	
 	for(i=0; i < size; i++)
 	{
 		if((arr[i].e_hour > hour || ( (arr[i].e_hour==hour) && (arr[i].e_min >=min) )) && arr[i].go==0
 			&& arr[i].station!=station)
 		{
 			check_all(arr[i].num, arr[i].station, size);
 			if(station=='A') re(start, arr[i].s_hour, arr[i].s_min, size, 'B');
 			else re(start, arr[i].s_hour, arr[i].s_min, size, 'A');
 			break;
 		}
 	}
 }
 
 void check_all(int num, char station, int size)
 {
 	int i;
 	for(i=0; i < size; i++)
 	{
 		if(end[i].num==num && end[i].station==station)
 		{
 			end[i].go = 1;
 			break;
 		}
 	}
 	for(i=0; i < size; i++)
 	{
 		if(start[i].num==num && start[i].station==station)
 		{
 			start[i].go = 1;
 			break;
 		}
 	}
 }
 
 struct time_table* mearge_table(struct time_table* All, int NA, int NB)
 {	
 	All = (struct time_table *) calloc(sizeof(struct time_table), NA+NB);
 
 	memcpy(All, &AtoB, sizeof(struct time_table) * NA);
 	memcpy(All+NA, &BtoA, sizeof(struct time_table) * NB);
 
 	return All;
 }
 
 void sort_e(struct time_table* x, int n)
 {
 	int i, j;
 	struct time_table temp;
 
 	for(i=0; i < n; i++)
 	{
 		for(j=i; j < n; j++)
 		{
 			if(x[i].e_hour > x[j].e_hour || (x[i].e_hour==x[j].e_hour) && (x[i].e_min > x[j].e_min))
 			{
 				memcpy(&temp, &x[i], sizeof(struct time_table));
 				memcpy(&x[i], &x[j], sizeof(struct time_table));
 				memcpy(&x[j], &temp, sizeof(struct time_table));
 			}
 		}
 	}
 }
 
 void sort_s(struct time_table* x, int n)
 {
 	int i, j;
 	struct time_table temp;
 
 	for(i=0; i < n; i++)
 	{
 		for(j=i; j < n; j++)
 		{
 			if(x[i].s_hour > x[j].s_hour || (x[i].s_hour==x[j].s_hour) && (x[i].s_min > x[j].s_min))
 			{
 				memcpy(&temp, &x[i], sizeof(struct time_table));
 				memcpy(&x[i], &x[j], sizeof(struct time_table));
 				memcpy(&x[j], &temp, sizeof(struct time_table));
 			}
 		}
 	}
 }
 
 void output(int A, int B)
 {
 	static int n = 1;
 
 	fprintf(out, αCase #%d: %d %dnα, n, A, B);
 	n++;
 }"
12198,2008,32013,vind,24481,1,train3.c,gcj/2008/32013/vind/24481/1/extracted/train3.c,"#include <stdio.h>
 #include <stdlib.h>
 
 
 
 struct train{
        int arr;
        int dep;
        int marker;
        };
 
 typedef struct train train;
 train train1[5],temp;
 
 
 int main(){
     int i,j,k,l,i1,op1=0,op2=0,test,test1=0,ta=0,t1=0,t2=0;
     FILE *fp;
     fp=fopen(αinput.inα,αrα);
     fscanf(fp,α%dnα,&test1);
     test1=test1+1;
     for(test=1;test<test1;test++){
     fscanf(fp,α%dnα,&ta);
     fscanf(fp,α%dnα,&t1);
     fscanf(fp,α%dnα,&t2);
       
      for(i1=0;i1<t1;i1++){
     fscanf(fp,α%d:%d    %d:%dnα,&i,&j,&k,&l);
   //  printf(α%d:%dα,i,j);
     train1[i1].arr=(i*60+j);
     train1[i1].dep=(k*60+l+ta);
     train1[i1].marker=1;
     }
 for(i1=t1;i1<(t1+t2);i1++){
     fscanf(fp,α%d:%d    %d:%dnα,&i,&j,&k,&l);
    // printf(α%d:%dα,i,j);
     train1[i1].arr=(i*60+j);
     train1[i1].dep=(k*60+l+ta);
        train1[i1].marker=2;
 }
     //for(i1=0;i1<(t1+t2);i1++)
     //printf(α%d------------->%d  %d nα, train1[i1].arr,train1[i1].dep,train1[i1].marker);
     //printf(αnnnα);
 
 j=0;
 
  
 
      for(i = 0; i < (t1+t2-1); i++)
      {
           for ( j=i+1;j<(t1+t2);j++)
           {
                if ((train1[i].arr > train1[j].arr))  //comparing brands
                {
                      temp = train1[ i ];    //swapping entire struct
                      train1[i] =train1[j];
                      train1[j] = temp;
                }
           }
      }
 
 
 
 /*
 
 for(i1=0;i1<5;i1++)
     printf(α%d------------->%d  %d nα, train1[i1].arr,train1[i1].dep,train1[i1].marker);
     
   */  
     
     
     
 for(i=0;i<(t1+t2-1);i++)
 {
  for(j=i+1;j<(t1+t2);j++){
      if((train1[i].dep > train1[j].arr)||(train1[j].arr==9999))
      continue;
      else         
      {//printf(αn %d:%dα, train1[i].dep,train1[j].arr);
      if(train1[i].marker==train1[j].marker)
           continue;
        else{          train1[j].arr   =9999;         
       if(train1[i].marker==1)         
          { op2=op2-1;}//printf(αn inininelse  i=%d,j=%d,%dα,i,j,op1);}
        else
           {op1=op1-1;}//printf(αn ininin else i=%d,j=%d,%dα,i,j,op2);}
                 break;  }
      if(train1[i].marker==1)
      {op1=op1+1;} //printf(αi=%d,j=%d,%dα,i,j,op1);}
       else
       {op2=op2+1;}//printf(αi=%d,j=%d,%dα,i,j,op2);}             
                   
                   
                   }
      
      }
                 
                 
                 
                 
                 
                 
                 
                 
                 }    
     
     
     
     
   
     
     
     
     printf(αCase #%d: %d %dnα,test,t1+op1,t2+op2);
     
     
     
     ta=0,t1=0,t2=0,op1=0;op2=0;
 }
 
 }"
12229,2008,32013,schultz,24479,1,a.c,gcj/2008/32013/schultz/24479/1/extracted/a.c,"#include<stdio.h>
 #include<math.h>
 
 typedef unsigned nat;
 typedef unsigned bool;
 typedef double real;
 
 #define false 0
 #define true 1
 
 real pi;
 
 typedef struct {
 	real x, y;
 } vec;
 
 typedef struct {
 	vec c;
 	real r;
 } circ;
 
 inline real sq(real x) {
 	return x*x;
 }
 
 inline vec vec_dist(vec u, vec v) {
 	return (vec) {v.x-u.x, v.y-u.y};
 }
 
 inline real vec_norm_2(vec v) {
 	return sq(v.x) + sq(v.y);
 }
 
 inline real vec_norm(vec v) {
 	return sqrt(vec_norm_2(v));
 }
 
 bool vec_circ_in(vec v, circ c) {
 	return vec_norm_2(vec_dist(c.c, v)) <= sq(c.r);
 }
 
 real relative_angle(vec u, vec v) {
 	real a;
 	vec d;
 
 	d = vec_dist(u, v);
 	a = acos(d.x/vec_norm(d));
 	if (d.y < 0)
 		a = 2*pi - a;
 	return a;
 }
 
 inline real relative_angle2(vec u, vec a, vec b) {
 	return fabs(relative_angle(u, b) - relative_angle(u, a));
 }
 
 real chord_area(circ c, vec u, vec v) {
 	real a, sec, tri;
 
 	a = relative_angle2(c.c, u, v);
 	sec = a*sq(c.r)/2;
 	tri = sq(c.r)*sin(a)/2;
 	return sec-tri;
 }
 
 vec circ_hline_inter(circ c, real y) {
 	real rx, ry;
 
 	ry = y-c.c.y;
 	rx = sqrt(sq(c.r) - sq(ry));
 	return (vec) {c.c.x+rx, y};
 }
 
 vec circ_vline_inter(circ c, real x) {
 	real rx, ry;
 
 	rx = x-c.c.x;
 	ry = sqrt(sq(c.r)-sq(rx));
 	return (vec) {x, c.c.y+ry};
 }
 
 inline real vec_tri_area(vec u) {
 	return fabs(u.x*u.y/2);
 }
 
 real inter_area_cs_case2(circ c, real s) {
 	vec u, v;
 
 	u = circ_hline_inter(c, s);
 	v = circ_vline_inter(c, s);
 
 	return sq(s) - vec_tri_area(vec_dist(u, v)) + chord_area(c, u, v);
 }
 
 real inter_area_cs_case0(circ c, real s) {
 	vec u, v;
 	real tri, cho;
 
 	u = circ_hline_inter(c, 0);
 	v = circ_vline_inter(c, 0);
 
 	tri = vec_tri_area(vec_dist(u, v));
 	cho = chord_area(c, u, v);
 
 	return tri + cho;
 }
 
 real inter_area_cs_case1(circ c, real s) {
 	vec u, v;
 
 	u = circ_vline_inter(c, 0);
 	v = circ_vline_inter(c, s);
 
 	return (u.y + v.y)*s/2 + chord_area(c, u, v);
 }
 
 real inter_area_cs(circ c, real s) {
 	bool ia, ib;
 	real t;
 
 	if (!vec_circ_in((vec) {0, 0}, c))
 		return 0;
 
 	if (vec_circ_in((vec) {s, s}, c))
 		return sq(s);
 
 	ia = vec_circ_in((vec) {s, 0}, c);
 	ib = vec_circ_in((vec) {0, s}, c);
 
 	if (ia && ib)
 		return inter_area_cs_case2(c, s);
 	if (!ia && !ib)
 		return inter_area_cs_case0(c, s);
 	
 	if (ib) {
 		t = c.c.x;
 		c.c.x = c.c.y;
 		c.c.y = t;
 	}
 
 	return inter_area_cs_case1(c, s);
 }
 
 #if DEBUGING
 int main() {
 	circ c;
 	real s;
 
 	pi = acos(-1);
 
 	while (scanf(α ( %lf , %lf ) %lf ~ %lfα, &c.c.x, &c.c.y, &c.r, &s) == 4) {
 		printf(α%.12lfnα, inter_area_cs(c, s));
 	}
 
 	return 0;
 }
 #else
 
 int main() {
 	nat tc, ix, iy, cs;
 	real f, R, t, r, g, ta, aa, ar, x, y, s;
 	circ c;
 
 	pi = acos(-1);
 	
 	scanf(α%uα, &tc);
 	for (cs = 0; cs != tc; ++cs) {
 		scanf(α%lf%lf%lf%lf%lfα, &f, &R, &t, &r, &g);
 		ta = pi*sq(R)/4;
 		R-= t;
 
 		aa = 0;
 		for (ix = 0;; ++ix) {
 			x = r + (g+2*r)*ix;
 			if (x >= R)
 				break;
 			for (iy = 0;; ++iy) {
 				y = r + (g+2*r)*iy;
 				if (y >= R)
 					break;
 				c.c = (vec) {-x-f, -y-f};
 				c.r = R-f;
 				s = g-2*f;
 				if (c.r > 0 && s > 0) {
 					ar = inter_area_cs(c, s);
 					aa+= ar;
 				}
 			}
 		}
 
 		printf(αCase #%u: %.12lfnα, cs+1, 1.0-aa/ta);
 	}
 
 	return 0;
 }
 
 #endif"
12231,2008,32013,schultz,24481,1,a.c,gcj/2008/32013/schultz/24481/1/extracted/a.c,"#include<stdio.h>
 
 typedef unsigned nat;
 typedef unsigned char nat8;
 typedef unsigned short nat16;
 
 typedef enum {departure, arrival} kind_t;
 typedef nat8 term_t;
 typedef nat16 time_t;
 
 typedef struct {
 	kind_t kind;
 	term_t term;
 	time_t time;
 } event;
 
 #define E_SIZE 512
 
 event E[E_SIZE];
 
 int ecmp(const void* pa, const void* pb) {
 	const event *a = pa, *b = pb;
 
 	if (a->time < b->time)
 		return -1;
 	if (a->time > b->time)
 		return 1;
 	if (a->kind == arrival)
 		return b->kind == departure ? -1 : 0;
 	return b->kind == departure ? 0 : 1;
 }
 
 int main() {
 	nat tc, cs, tt, na, nb, evs, i, dh, dm, d, ah, am, a, t[2], c[2], term;
 
 	scanf(α%uα, &tc);
 	for (cs = 0; cs != tc; ++cs) {
 		scanf(α%u%u%uα, &tt, &na, &nb);
 		evs = 0;
 		for (i = 0; i != na; ++i) {
 			scanf(α%u:%u%u:%uα, &dh, &dm, &ah, &am);
 			d = 60*dh + dm;
 			a = 60*ah + am;
 			E[evs++] = (event) {
 				.kind = departure,
 				.term = 0,
 				.time = d
 			};
 			E[evs++] = (event) {
 				.kind = arrival,
 				.term = 1,
 				.time = a+tt
 			};
 		}
 		for (i = 0; i != nb; ++i) {
 			scanf(α%u:%u%u:%uα, &dh, &dm, &ah, &am);
 			d = 60*dh + dm;
 			a = 60*ah + am;
 			E[evs++] = (event) {
 				.kind = departure,
 				.term = 1,
 				.time = d
 			};
 			E[evs++] = (event) {
 				.kind = arrival,
 				.term = 0,
 				.time = a+tt
 			};
 		}
 
 		qsort(E, evs, sizeof(event), ecmp);
 
 		t[0] = t[1] = 0;
 		c[0] = c[1] = 0;
 		for (i = 0; i != evs; ++i) {
 			if (E[i].kind == arrival)
 				++t[E[i].term];
 			else {
 				term = E[i].term;
 				if (t[term] == 0) {
 					++t[term];
 					++c[term];
 				}
 				--t[term];
 			}
 		}
 
 		printf(αCase #%u: %u %unα, cs+1, c[0], c[1]);
 	}
 
 	return 0;
 }"
12298,2008,32013,DQUADROS,24480,1,QR_A.c,gcj/2008/32013/DQUADROS/24480/1/extracted/QR_A.c,"//
 //	Google CodeJam - Qualification Round, Problem A
 //	DQuadros
 //
 //	Tested with Microsoft Visual C++ v6
 //	(but should run with other compilers with 32bit ints!)
 //
 
 // If the following define is uncommented:
 // - Uses test files instead of standard input/output
 // - Enables debug printfs
 //#define TEST
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 // Search Engines
 #define MAX_ENGINES 100
 int nS;
 char Engines [MAX_ENGINES][101];
 int order[MAX_ENGINES];
 
 // Insert a search engine
 // (good old insertion sort)
 void InsertEngine (char *name)
 {
     int i;
 
     strcpy (Engines[nS], name);
     for (i = nS; i > 0; i--)
         if (strcmp (Engines[order[i-1]], name) <= 0)
             break;
     if (i < nS)
         memmove (order+i+1, order+i, (nS-i)*sizeof(int));
     order[i] = nS;
 }
 
 // Find a search engine
 // (good old binary search)
 int FindEngine (char * name)
 {
     int first, last, mid, dif;
 
     first = 0;
     last = nS-1;
     while (last >= first)
     {
         mid = (last+first)/2;
         dif = strcmp (Engines[order[mid]], name);
         if (dif == 0)
             return mid;
         else if (dif < 0)
             first = mid + 1;
         else
             last = mid - 1;
     }
     return -1;  // not found
 }
 
 
 #ifdef TEST
 void DumpEngines (void)
 {
     int i;
 
     for (i = 0; i < nS; i++)
         printf (α[%s]nα, Engines[order[i]]);
 }
 #endif
 
 
 void main (void)
 {
 	int iCase, nCases;
     int S, Q, nQ;
 	char name[101];
     char used [MAX_ENGINES];
     int se, unused;
     int nSwitches;
 
 #ifdef TEST
 	freopen(αtest.inα,αrα,stdin);
 	freopen(αtest.outα,αwα,stdout);
 #endif
 
 	scanf (α%dα, &nCases);
 	for (iCase = 1; iCase <= nCases; iCase++)
 	{
         // Read the search engines names
         scanf (α%dnα, &S);
         for (nS = 0; nS < S; nS++)
         {
     		gets (name);
             InsertEngine (name);
         }
 
 #ifdef TEST
         DumpEngines ();
 #endif
 
         // Process the queries
         nSwitches = 0;
         unused = nS;
         memset (used, ' ', MAX_ENGINES);
         scanf (α%dnα, &Q);
         for (nQ = 0; nQ < Q; nQ++)
         {
     		gets (name);
             se = FindEngine (name);
 #ifdef TEST
             printf (α[%s] = %dnα, name, se);
 #endif
             if (se != -1)
             {
                 if (used[se] == ' ')
                 {
                     if (unused == 1)
                     {
                         // must switch
     #ifdef TEST
                         printf (α--- SWITCH ---nα, name, se);
     #endif
                         nSwitches++;
                         unused = nS;
                         memset (used, ' ', MAX_ENGINES);
                     }
                     used[se] = '*';
                     unused--;
                 }
             }
         }
 
 
 		printf (αCase #%d: %dnα, iCase, nSwitches);
 	}
 
 }"
12300,2008,32013,DQUADROS,24481,1,QR_B.c,gcj/2008/32013/DQUADROS/24481/1/extracted/QR_B.c,"//
 //	Google CodeJam - Qualification Round, Problem B
 //	DQuadros
 //
 //	Tested with Microsoft Visual C++ v6
 //	(but should run with other compilers with 32bit ints!)
 //
 
 // If the following define is uncommented:
 // - Uses test files instead of standard input/output
 // - Enables debug printfs
 //#define TEST
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_TRIPS   100
 
 #define TRAIN_READY     1
 #define TRAIN_DEPARTURE 2
 
 // Each array record departures and ready trains,
 // ordered by time and type
 int StationA [2*MAX_TRIPS];
 int StationB [2*MAX_TRIPS];
 int nSA, nSB;
 
 // Convert HH:MM in tenths of minutes
 int EncodeTime (char *s)
 {
     return (s[0]-'0')*10*600 + (s[1]-'0')*600 +
            (s[3]-'0')*100 + (s[4]-'0')*10;
 }
 
 // Register an event at the station
 // (good old insertion sort, again)
 void Register (int *tabEvt, int nEvt, int event)
 {
     int i;
 
     for (i = nEvt; i > 0; i--)
         if (tabEvt[i-1] <= event)
             break;
     if (i < nEvt)
         memmove (tabEvt+i+1, tabEvt+i, (nEvt-i)*sizeof(int));
     tabEvt[i] = event;
 }
 
 // Finds how many trains we need
 int Trains (int *Station, int nEvt)
 {
     int i, need, cur;
 
     for (i = need = cur = 0; i < nEvt; i++)
     {
         if ((Station[i] % 10) == TRAIN_READY)
             cur++;
         else if (cur == 0)
             need++;
         else
             cur--;
     }
     return need;
 }
 
 void main (void)
 {
 	int iCase, nCases;
     int t, nA, nB;
     int i;
     char depart[6], arrive[6];
 
 #ifdef TEST
 	freopen(αtest.inα,αrα,stdin);
 	freopen(αtest.outα,αwα,stdout);
 #endif
 
 	scanf (α%dα, &nCases);
 	for (iCase = 1; iCase <= nCases; iCase++)
 	{
         scanf (α%dα, &t);
         t *= 10;
         scanf (α%d %dα, &nA, &nB);
         nSA = nSB = 0;
         for (i = 0; i < nA; i++)
         {
             scanf (α%s %sα, depart, arrive);
             Register (StationA, nSA, EncodeTime(depart)+TRAIN_DEPARTURE);
             nSA++;
             Register (StationB, nSB, EncodeTime(arrive)+t+TRAIN_READY);
             nSB++;
         }
         for (i = 0; i < nB; i++)
         {
             scanf (α%s %sα, depart, arrive);
             Register (StationB, nSB, EncodeTime(depart)+TRAIN_DEPARTURE);
             nSB++;
             Register (StationA, nSA, EncodeTime(arrive)+t+TRAIN_READY);
             nSA++;
         }
 
 #ifdef TEST
         printf (αStation Anα);
         for (i = 0; i < nSA; i++)
             printf (α%02d:%02d %cnα, StationA[i]/600, (StationA[i]%600)/10,
             (StationA[i]%10) == TRAIN_DEPARTURE ? '>' : '<');
         printf (αStation Bnα);
         for (i = 0; i < nSB; i++)
             printf (α%02d:%02d %cnα, StationB[i]/600, (StationB[i]%600)/10,
             (StationB[i]%10) == TRAIN_DEPARTURE ? '>' : '<');
 #endif
 
 		printf (αCase #%d: %d %dnα, iCase, Trains (StationA, nSA), 
                 Trains (StationB, nSB));
 	}
 
 }"
12332,2008,32013,Sherman,24479,1,fly_swatter.c,gcj/2008/32013/Sherman/24479/1/extracted/fly_swatter.c,"// 
 // File:   egg_drop.cpp
 // Author: rsalmeidafl
 //
 // Created on 26 de Junho de 2008, 22:52
 //
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <assert.h>
 
 double tuffArea(double R, double y, double a, double b) {
     
     assert(a >= b);
     assert(a <= R);
     assert(b <= R);
     
     double R2 = R*R;
     double theta = acos(b/R);
     double phi = acos(a/R);
     
     assert (theta >= phi);
     
     double area = (R2/2)*(theta - phi) - (R2/4)*(sin(2*theta) - sin(2*phi)) - (a - b)*y;
     //assert(area >= 0);
     return area;
 }
 
 int main(int argc, char** argv) {
     
     int num_of_instances;
     int current_instance = 0;
         
     scanf(α%dα, &num_of_instances);
     
     while (current_instance++ < num_of_instances) {
         double f, R, t, r, g, R2;
         scanf(α%lf %lf %lf %lf %lfα, &f, &R, &t, &r, &g);
         
         t += f;
         R -= t;
         g -= 2*f;
         r += f;
         
         R2 = R*R;
                 
         
         /* Compute αstandard gap effective areaα */
         double noHitArea = 0.0;
         
         if (g > 0 && R > 0) {
 
             double delta = 2*r + g;
             double bottom = r;
             double right = r;                    
             
             double stdarea = g*g;
             
             /* For each row */        
             while (bottom < R) {
                 right = r;
                 
                 /* Are there any? */
                 double top = bottom + g;
                 double left = right + g;
                 if (R > top) {
                     int number_of_standard_gaps = 1 + floor((sqrt(R*R - top*top) - (right + g))/delta);
                     noHitArea += number_of_standard_gaps*stdarea;
                     right += delta*number_of_standard_gaps;
                 }
                 
                 /* Tuff gaps */
                 
                 while(bottom*bottom + right*right < R2) {
 
                     int toprightin = (bottom + g)*(bottom + g) + right*right <= R2;
                     int bottomleftin = bottom*bottom + (right + g)*(right + g) <= R2;
                     assert((bottom + g)*(bottom + g) + (right + g)*(right + g) > R2);                   
                     
                     double a, b, y, rect;
                     
                     /* First case: both corners out */
                     if (!toprightin && !bottomleftin) {
                         b = right;
                         a = sqrt(R2 - bottom*bottom);
                         assert(a >= b);
                         y = bottom;
                         rect = 0;
                     }
                     else if (toprightin && !bottomleftin) {
                         b = sqrt(R2 - (bottom + g)*(bottom + g));
                         a = sqrt(R2 - bottom*bottom);
                         assert(b >= right);
                         assert(a >= b);
                         y = bottom;
                         rect = (b - right)*g;
                     }
                     else if (!toprightin && bottomleftin) {
                         b = right;
                         a = right + g;
                         y = sqrt(R2 - a*a);
                         assert(y >= bottom);
                         rect = (y - bottom)*g;
                     }
                     else if (toprightin && bottomleftin) {
                         b = sqrt(R2 - (bottom + g)*(bottom + g));
                         a = right + g;
                         y = sqrt(R2 - a*a);
                         assert (a >= b);
                         assert(b >= right);
                         assert(y >= bottom);
                         rect = (a - b)*(y - bottom) + (b - right)*g;
                     }
                     
                     assert(rect >= 0);
                     noHitArea += rect;
                     noHitArea += tuffArea(R, y, a, b);
                     
                     right += delta;                    
                 }
 
                 bottom += delta;
             }
         }
         
         double totalArea = 3.141592653589793238462643*(R+t)*(R+t)/4;
         double probability = 1 - (noHitArea / totalArea);
         
         printf(αCase #%d: %.6fnα, current_instance, probability);
     }    
     
     return (EXIT_SUCCESS);
 }"
12344,2008,32013,Lispad,24480,1,Unit1.c,gcj/2008/32013/Lispad/24480/1/extracted/Unit1.c,"//---------------------------------------------------------------------------
 
 #include <stdio.h>
 #include <string.h>
 
 
 //---------------------------------------------------------------------------
 
 int n, s, q;
 char se[102][102];
 
 char query[101];
 int main(int argc, char* argv[])
 {
 	FILE *fi, *fo;
 	int i, j, k, f, u, ans;
 	fi=fopen (argv[1], αrα);
 	fscanf(fi, α%dα , &n);
 
 	fo=fopen (argv[2], αwα);
 	for (i = 0; i <n; i++)
 	{
 		ans=0;
 		u=0;
 		fscanf(fi, α%dnα , &s);
 		for (j = 0; j <s; j++) 
 		{
 			fgets((char *)&se[j], 100, fi);
 			se[j][101]=0;
 		}
 
 		fscanf(fi, α%dnα , &q);
 		for (j = 0; j <q; j++) 
 		{
 			fgets((char *)&query, 100, fi);
 			for (k = 0; k <s; k++) 
 			{
 				f=-1;
 				if (strcmp(query, se[k])==0) 
 				{
 					f=k;
 					break;
 				}
 			}
 			if (f>-1)
 			{
 				if (se[f][101]==0) 
 					u++;
 				se[f][101]=1;
 				
 				if (u==s) 
 				{
 					for (k = 0; k <s; k++) 
 						se[k][101]=0;
 					se[f][101]=1;
 					ans++;
 					u=1;
 
 				}
 			}
 		}		
 		fprintf(fo, αCase #%d: %dnα, i+1, ans);
 	}
 	fclose(fi);
 	fclose(fo);
 	return 0;
 
 }
 //---------------------------------------------------------------------------"
12346,2008,32013,Lispad,24479,1,Unit1.c,gcj/2008/32013/Lispad/24479/1/extracted/Unit1.c,"//---------------------------------------------------------------------------
 
 #include <stdio.h>
 #include <math.h>
 
 #define PI  3.1415926535897932385
 double	 e=0.00000001;
 
 //---------------------------------------------------------------------------
 
 int inside(double x, double y, double R)
 {
 	return (x*x+y*y<R*R);
 }
 double penta (double xs, double ys, double xe, double ye, double R)
 {
 	double xn, yn, A, B, C, al;
 	xn=sqrt(R*R-ye*ye);
 	yn=sqrt(R*R-xe*xe);
 
 
 	A=ye-yn;
 	B=xe-xn;
 	C=sqrt(A*A+B*B);
 	al=acos(1-C*C/2/R/R);
 	return (xn-xs)*(ye-ys)+(xe-xn)*(yn-ys)+(A*B/2)+(R*R*al/2-R*R*sin(al)/2);
 }
 double kvadr1 (double xs, double ys, double xe, double ye, double R)
 {
 	double yns, yne, A, B, C, al;
 	yns=sqrt(R*R-xs*xs);
 	yne=sqrt(R*R-xe*xe);
 
 
 	A=yns-yne;
 	B=xe-xs;
 	C=sqrt(A*A+B*B);
 
 	al=acos(1-C*C/2/R/R);
 
 	return (yne-ys)*(xe-xs)+(A*B/2)+(R*R*al/2-R*R*sin(al)/2);
 
 }
 double kvadr2 (double xs, double ys, double xe, double ye, double R)
 {
 
 	double xns, xne, A, B, C, al;
 	xns=sqrt(R*R-ys*ys);
 	xne=sqrt(R*R-ye*ye);
 
 
 	A=xns-xne;
 	B=ye-ys;
 	C=sqrt(A*A+B*B);
 
 	al=acos(1-C*C/2/R/R);
 
 	return (xne-xs)*(ye-ys)+(A*B/2)+(R*R*al/2-R*R*sin(al)/2);
 }
 
 double triag (double xs, double ys, double xe, double ye, double R)
 {
 	double xn, yn, A, B, C, al;
 	xn=sqrt(R*R-ys*ys);
 	yn=sqrt(R*R-xs*xs);
 
 	A=yn-ys;
 	B=xn-xs;
 	C=sqrt(A*A+B*B);
 
 	al=acos(1-C*C/2/R/R);
 	return (A*B/2)+(R*R*al/2-R*R*sin(al)/2);
 }
 
 int main(int argc, char* argv[])
 {
 	FILE *fi, *fo;
 	int i, j;
 	int n;
 	double f, R, t, r, g;
 	double xs, ys, xe, ye;
 	double S, Sf;
 	double ans;
 
 	float ff, fR, ft, fr, fg;
 
 	int c1, c2, c3, c4;
 	double s1, s2, s3, s4;
 
 	fi=fopen (argv[1], αrα);
 	fo=fopen (argv[2], αwα);
 
 	fscanf(fi, α%dα , &n);
 
 	for (i = 0; i <n; i++)
 	{
 		S=0;
 		c1=0;
 		c2=0;
 		c3=0;
 		c4=0;
 
 		s1=0;
 		s2=0;
 		s3=0;
 		s4=0;
 
 		fscanf(fi,α%f %f %f %f %fα, &ff, &fR, &ft, &fr, &fg);
 		f=ff;
 		R=fR;
 		t=ft;
 		r=fr;
 		g=fg;
 		if (2*f-g>-e)
 		{
 			fprintf(fo, αCase #%d: %.6fnα, i+1,1.0);
 			continue;
 		}
 		Sf=R*R*PI/4;
 		xs=r;
 		R-=t;
 		while (xs<R)
 		{
 			xe=xs+g;
 			ys=r;
 			while (inside(xs+f, ys-f, R-f))
 			{
 				ye=ys+g;
 
 				if (inside((xs+f), (ys+f), R-f)&&inside((xe-f), (ys+f), R-f)&&inside((xs+f), (ye-f), R-f)&&inside((xe-f), (ye-f), R-f))
 				{
 					S+=((xe-f)-(xs+f))*((ye-f)-(ys+f));
 					s1+=((xe-f)-(xs+f))*((ye-f)-(ys+f));
 					c1++;
 				}
 				else
 				if (inside((xs+f), (ys+f), R-f)&&inside((xe-f), (ys+f), R-f)&&inside((xs+f), (ye-f), R-f)&&!inside((xe-f), (ye-f), R-f))
 				{
 					S+=penta((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 					s2+=penta((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 					c2++;
 				}
 				else
 				if (inside((xs+f), (ys+f), R-f)&&inside((xe-f), (ys+f), R-f)&&!inside((xs+f), (ye-f), R-f)&&!inside((xe-f), (ye-f), R-f))
 				{
 					S+=kvadr1((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 					s3+=kvadr1((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 
 					c3++;
 				}
 				else
 				if (inside((xs+f), (ys+f), R-f)&&!inside((xe-f), (ys+f), R-f)&&inside((xs+f), (ye-f), R-f)&&!inside((xe-f), (ye-f), R-f))
 				{
 					S+=kvadr2((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 					s3+=kvadr2((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 
 					c3++;
 				}
 				else
 				if (inside((xs+f), (ys+f), R-f)&&!inside((xe-f), (ys+f), R-f)&&!inside((xs+f), (ye-f), R-f)&&!inside((xe-f), (ye-f), R-f))
 				{
 					S+=triag((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 					s4+=triag((xs+f), (ys+f), (xe-f), (ye-f), R-f);
 
 					c4++;
 
 				}
 
 				//
 				ys=ye+2*r;
 			}
 			xs=xe+2*r;
 		}
 
 			ans=1.0-1.0*S/Sf; //(int)(1000000*S/Sf)/1000000;
 			fprintf(fo, αCase #%d: %.6fnα, i+1, (float)ans);
 
 //			fprintf(fo, αCase #%d: %.6f nFull: %.6f nDyrka: %.6fnc1=%dnc2=%dnc3=%dnc4=%dnns1=%fns2=%fns3=%fns4=%fnn===================nα, i+1,1.0-S/Sf, Sf, S, c1, c2, c3, c4, s1, s2, s3, s4);
 	}
 
 
 	fclose(fi);
 	fclose(fo);
 	return 0;
 
 }
 //---------------------------------------------------------------------------"
12348,2008,32013,Lispad,24481,1,Unit1.c,gcj/2008/32013/Lispad/24481/1/extracted/Unit1.c,"//---------------------------------------------------------------------------
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 //---------------------------------------------------------------------------
 
 
 static int comp(const void *p1, const void *p2)
 {
 	return ((int *)p1)[0]-((int *)p2)[0];
 }
 
 
 int main(int argc, char* argv[])
 {
 	FILE *fi, *fo;
 	int i, j, h, m;
 	int n, na, nb, t, f, k;
 	int tt[202][3];
 	int tr[202][2];
 	int tc[2];
 
 	fi=fopen (argv[1], αrα);
 	fo=fopen (argv[2], αwα);
 
 	fscanf(fi, α%dα , &n);
 
 	for (i = 0; i <n; i++)
 	{
 		tc[0]=0;
 		tc[1]=0;
 		fscanf(fi,α%dn%d %dnα, &t, &na, &nb);
 		for(j=0; j<na+nb; j++)
 		{
 			fscanf(fi,α%d:%dα, &h, &m);
 			tt[j][0]=h*60+m;
 			fscanf(fi,α%d:%dα, &h, &m);
 			tt[j][1]=h*60+m;
 			tt[j][2]=(j<na?0:1);
 		}
 		qsort(tt[0], na+nb, sizeof(int*)*3, comp);
 		if (na+nb==0)
 		{
 			fprintf(fo, αCase #%d: 0 0nα, i);
 			continue;
 		}
 
 		tr[tc[0]+tc[1]][0]=tt[0][1];
 		tr[tc[0]+tc[1]][1]=1-tt[0][2];
 		
 		tc[tt[0][2]]++;
 
 		for (j=1; j < na+nb; j++)
 		{
 			f=-1;
 			for (k = 0; k < tc[0]+tc[1]; k++) 
 			{
 				if ((tr[k][0]+t<=tt[j][0])&&(tr[k][1]==tt[j][2])) 
 				{
 					f=k;
 					break;
 				}		
 			}
 
 			if (f>-1) 
 			{
 				tr[f][0]=tt[j][1];
 				tr[f][1]=1-tt[j][2];
 			
 			}
 			else
 			{
 				tr[tc[0]+tc[1]][0]=tt[j][1];
 				tr[tc[0]+tc[1]][1]=1-tt[j][2];
 				tc[tt[j][2]]++;
 			}
 		}
 
 		fprintf(fo, αCase #%d: %d %dnα, i+1,tc[0],tc[1]);
 	}
 
 
 	fclose(fi);
 	fclose(fo);
 	return 0;
 
 }
 //---------------------------------------------------------------------------"
12377,2008,32013,wagh.utkarsh,24480,1,SavingUniverse.c,gcj/2008/32013/wagh.utkarsh/24480/1/extracted/SavingUniverse.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #define S 100
 #define Q 1000
 
 int clear (int *arr) {
 	int iter;
 	for (iter = 0; iter < S; iter ++)
 		arr[iter] = 0;
 	return 0;
 }
 
 int get_match (char Server_List[][512], int Number_Of_Servers, char Query[]) {
 	int iter;
 	for (iter = 0; iter < Number_Of_Servers; iter ++) {
 		if (! strcmp (Server_List[iter], Query))
 			return iter;
 	}
 	return -1;
 }
 int findOptimal (char Server_List[][512], char Query_List[][512], int NS, int NQ, int index, char Current_Server[]) {
 	int val, check [S], count = 0, iter;
 	clear (check);
 	for (iter = index; iter < NQ; iter ++) {
 		val = get_match (Server_List, NS, Query_List[iter]);
 		if (check[val] == 0 && count < NS - 1) {
 			check [val] = 1; count ++;
 		}
 	}
 	for (iter = 0; iter < NS; iter ++) 
 		if (check[iter] == 0) {
 			strcpy (Current_Server, Server_List[iter]);
 			return iter;
 		}
 }
 int find_switch (char Server_List[][512], char Query_List[][512], 
 			int Number_Of_Servers, int Number_Of_Queries)  {
 	int query, switch_count = 0;
 	char Current_Server [512];
 	findOptimal (Server_List, Query_List, Number_Of_Servers, Number_Of_Queries, query, Current_Server);
 //	printf (αCurrent Server: %s nα, Current_Server);
   	for ( query = 0; query < Number_Of_Queries; query ++) {
 		if ( !strcmp (Query_List[query], Current_Server)) {
 			switch_count ++;
 			findOptimal (Server_List, Query_List, Number_Of_Servers, Number_Of_Queries, 
 									query, Current_Server);
 // 			printf (αCurrent Server: %sα, Current_Server);
 		}
 	}
 	return switch_count;
 }
 
 int SaveUniverse (char *filename) {
 	FILE *fpIn, *fpOut;
 	char Server_List[S][512], Query_List[Q][512];
 	int Number_Of_Inputs, Number_Of_Servers, Number_Of_Queries, iter, server, query;
 	fpIn = fopen (filename, αrα); fpOut = fopen (αOutputα, αwα);
 	fscanf (fpIn, α%dα, &Number_Of_Inputs);
 	for (iter = 0; iter < Number_Of_Inputs; iter ++) {
 		fscanf (fpIn, α%dnα, &Number_Of_Servers);
 		for (server = 0; server < Number_Of_Servers; server ++) {
 			fgets (Server_List [server], 512, fpIn);
 		}
 		fscanf (fpIn, α%dnα, &Number_Of_Queries);
 		for (query = 0; query < Number_Of_Queries; query ++) {
 			fgets (Query_List [query], 512, fpIn);
 		}
 		// implementing optimal scheduling
 		fprintf (fpOut, αCase #%d: %dnα,iter + 1, find_switch (Server_List, Query_List, 
 								Number_Of_Servers, Number_Of_Queries));
 	}
 	return 0;
 }
 int main (int argc, char *argv[]) {
 	if (argc != 2) {
 		printf (αInvalid arguments .... n usage SavingUniverse <Input File>nα);
 		exit (1);
 	}
 	else SaveUniverse (argv[1]);
 	return 0;
 }"
12379,2008,32013,wagh.utkarsh,24481,1,train.c,gcj/2008/32013/wagh.utkarsh/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
 #define NA 100
 #define NB 100
 #define T 60
 
 typedef struct journey {
 	int arrival, departure;
 }journeyStruct;
 
 int find_closest (journeyStruct station, journeyStruct dest[], int no, int *check,int turnaround) {
 	int iter, prevval = INT_MAX, returnval = -1, diff;
 	for (iter = 0; iter < no; iter ++) {
 		diff = station.arrival - dest[iter].departure;
 		// printf (αhere %d %d %d %dnα,station.arrival, dest[iter].departure, diff, check[iter]);
 		if (diff >= turnaround && check [iter] == 0) {			
 			if (diff < prevval) {
 				prevval = diff;
 				returnval = iter;				
 			}
 		}
 	}
 	return returnval;
 }
 
 int clear_arr (int *arr) {
 	int iter;
 	for (iter = 0; iter < NA; iter ++)
 		arr[iter] = 0;
 	return 0;
 }
 
 int get_trains (journeyStruct stationf[], journeyStruct stations[], int nf, int ns, int turnaround) {
 	int iterf, iters, val = 0;
 	int  count = 0, check [NA];
 	bzero ((void *) check, sizeof(int) * NA);
 	for (iterf = 0; iterf < nf; iterf ++) {
 		val = find_closest (stationf[iterf], stations, ns, check, turnaround);
 		if (val == -1) 
 			count ++;
 		else check[val] = 1;
 		// printf (αval : %dnα, val);
 	}
 	return count; 
 }
 
 int train_schedule (char *filename) {
 	journeyStruct journeyA[NA], journeyB[NB];
 	FILE *fpIn, *fpOut = fopen (αOutputα, αwα);
 	int Number_Of_Inputs, iter, turnaround, na, nb, loop, h1, h2, m1, m2;
 	fpIn = fopen (filename, αrα);
 	if (!fpIn || !fpOut) 
 		printf (αUnable to Open file.nα), exit(1);
 	fscanf (fpIn, α%dα, &Number_Of_Inputs);
 	for (iter = 0; iter < Number_Of_Inputs; iter ++) {
 		fscanf (fpIn, α%d %d %dα, &turnaround, &na, &nb);
 		for (loop = 0; loop < na; loop ++) {
 			fscanf (fpIn, α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			journeyA[loop].arrival = h1 * 60 + m1;	journeyA[loop].departure = h2 * 60 + m2;			
 		}
 		for (loop = 0; loop < nb; loop ++) {
 			fscanf (fpIn, α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			journeyB[loop].arrival = h1 * 60 + m1;	journeyB[loop].departure = h2 * 60 + m2;
 		}
 		fprintf (fpOut, αCase #%d: %d %dnα, iter + 1, get_trains (journeyA, journeyB, na, nb, turnaround),
 								get_trains (journeyB, journeyA, nb, na, turnaround));
 	}
 	return 0;
 }
 
 int main (int argc, char *argv[]) {
 	if (argc != 2) {
 		printf (αInvalid Arguments .... n Usage Train <Input File>α);
 		exit (1);
 	}
 	train_schedule (argv[1]);
 }"
12387,2008,32013,rompel,24480,1,stu.c,gcj/2008/32013/rompel/24480/1/extracted/stu.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
 
   scanf(α%dnα, &N);
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 #define MAXENG 100
 #define MAXQUERY 1000
 
 char name[MAXENG][110];
 
 void do_one_case(int cnum)
 {
   int S, Q;
   int i, j;
   char qbuf[110];
   int query[MAXQUERY];
   char avail[MAXENG];
   int navail, nswitch;
 
   scanf(α%dnα, &S);
 
   for(i=0; i<S; i++)
       gets(name[i]);
 
   scanf(α%dnα, &Q);
   // fprintf(stderr, αS=%d, Q=%dnα, S, Q);
 
   for(i=0; i<Q; i++)
     {
       gets(qbuf);
       for(j=0; j<S && strcmp(qbuf, name[j]); j++)
           ;
       assert(j<S);
       query[i] = j;
     }
 
   for(i=0; i<S; i++)
       avail[i] = 1;
   navail = S;
   nswitch = 0;
 
   for(i=Q-1; i>=0; i--)
     {
       if(avail[query[i]])
         {
           avail[query[i]] = 0;
           navail--;
           if(navail==0)
             {
               nswitch++;
               // fprintf(stderr, α$$%d: %snα, nswitch, name[query[i]]);
               for(j=0; j<S; j++)
                   avail[j] = 1;
               avail[query[i]] = 0;
               navail = S-1;
             }
         }
     }
 
   printf(αCase #%d: %dnα, cnum, nswitch);
 }"
12389,2008,32013,rompel,24479,1,fs.c,gcj/2008/32013/rompel/24479/1/extracted/fs.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
 
   scanf(α%dnα, &N);
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 void do_one_case(int cnum)
 {
   int i, j;
   double f, R0, t, r0, g0;
   double miss, R, g, r, s;
 
   assert(5==scanf(α%lf %lf %lf %lf %lfnα, &f, &R0, &t, &r0, &g0));
 
   R = R0 - t - f;
   g = g0 - 2.0*f;
   r = r0 + f;
   miss = 0.0;
 
   if(R<=0.0 || g<=0.0)
       goto done;
       
   // norm everything to interior radius 1
   R0 /= R;
   g /= R;
   r /= R;
   s = g + 2*r;
 
   //fprintf(stderr, αR0=%g, g=%g, s=%gnα, R0, g, s);
 
   for(i=0; i<1010 && i*s<=1.0; i++)
     {
       double ylow, yhigh;
       double xlow, xhigh;
 
       ylow = i*s + r;
       xhigh = sqrt(1.0 - ylow*ylow);
       yhigh = ylow + g;
       if(yhigh < 1.0)
           xlow = sqrt(1.0 - yhigh*yhigh);
       else
         {
           xlow = 0.0;
           yhigh = 1.0;
         }
 
       j = (int) floor(xlow/s);
       miss += j * g*g;
       for(; j<1010 && j*s<xhigh; j++)
         {
           double a, b, c, d, A;
           a = b = j*s + r;
           c = d = a + g;
           //fprintf(stderr, αi=%d j=%d a=%g b=%g c=%g d=%gnα, i, j, a, b, c, d);
           if(a>xhigh)
             {
               A = 0.0;
               goto addarea;
             }
           if(d<xlow)
             {
               A = g*g;
               goto addarea;
             }
           if(b<xlow)
               b = xlow;
           else if(b>xhigh)
               b = xhigh;
           if(c>xhigh)
               c = xhigh;
           else if(c<xlow)
               c = xlow;
           //fprintf(stderr, αi=%d j=%d a=%g b=%g c=%g d=%gnα, i, j, a, b, c, d);
           assert(a<=b && b<=c && c<=d);
           A = (b-a)*(yhigh-ylow);
           A += .5*(c*sqrt(1.0-c*c) + asin(c) - b*sqrt(1.0-b*b) - asin(b));
           A -= (c-b)*ylow;
 addarea:
           //fprintf(stderr, αi=%d j=%d A=%g (g^2=%g)nα, i, j, A, g*g);
           miss += A;
         }
       assert(j<1005);
     }
   assert(i<1005);
 
   miss *= 4.0/M_PI;     // adjust for size of quadrant
   miss /= R0*R0;        // adjust for outer radius
 
 done:
   printf(αCase #%d: %.9fnα, cnum, 1.0-miss);
 }"
12391,2008,32013,rompel,24481,1,tt.c,gcj/2008/32013/rompel/24481/1/extracted/tt.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
 
   scanf(α%dnα, &N);
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 #define MAXTRIP 100
 #define MAXTRAIN 200
 
 void do_one_case(int cnum)
 {
   int i, j, k;
   int T, N[2];
   int hh1, mm1, hh2, mm2;
   struct {
       int start;
       int end; } trip[2][MAXTRIP];
   int event[MAXTRAIN];
 
   scanf(α%dnα, &T);
   scanf(α%d %dnα, &N[0], &N[1]);
 
   for(i=0; i<2; i++)
       for(j=0; j<N[i]; j++)
         {
           assert(4==scanf(α%d:%d %d:%dnα, &hh1, &mm1, &hh2, &mm2));
           trip[i][j].start = 60*hh1 + mm1;
           trip[i][j].end = 60*hh2 + mm2;
         }
 
   printf(αCase #%d:α, cnum);
   for(i=0; i<2; i++)
     {
       int n, m, t;
 
       for(j=0; j<N[i]; j++)
           event[j] = 2*trip[i][j].start + 1;
       for(j=0; j<N[1-i]; j++)
           event[j + N[i]] = 2*(trip[1-i][j].end + T);
 
       for(j=1; j<N[0]+N[1]; j++)
         {
           t = event[j];
           for(k=j; k>0 && event[k-1]>t; k--)
               event[k] = event[k-1];
           event[k] = t;
         }
 
       n = m = 0;
       for(j=0; j<N[0]+N[1]; j++)
         {
           if(event[j]&1)
             {
               if(++n > m)
                   m = n;
             }
           else
               --n;
         }
       printf(α %dα, m);
     }
   printf(αnα);
 }"
12418,2008,32013,raghuram1988,24481,1,train.c,gcj/2008/32013/raghuram1988/24481/1/extracted/train.c,"#include<stdio.h>
 #include<stdlib.h>
 struct time
 {
 	int dep;
 	int arr;
 	int mark;
 };
 void sortbydeptime(struct time *A[],int noA)
 {
 	int i,j;
 	for(i=0;i<noA;i++)
 	{
 		for(j=i+1;j<noA;j++)
 		{
 			if(A[i]->dep>A[j]->dep)
 			{
 				A[i]->arr=A[i]->arr+A[j]->arr;
 				A[j]->arr=A[i]->arr-A[j]->arr;
 				A[i]->arr=A[i]->arr-A[j]->arr;
 				A[i]->mark=A[i]->mark+A[j]->mark;
 				A[j]->mark=A[i]->mark-A[j]->mark;
 				A[i]->mark=A[i]->mark-A[j]->mark;
 				A[i]->dep=A[i]->dep+A[j]->dep;
 				A[j]->dep=A[i]->dep-A[j]->dep;
 				A[i]->dep=A[i]->dep-A[j]->dep;
 			}
 		}
 	}
 }
 void setmarkzero(struct time *A[],struct time *B[],int noA,int noB)
 {
 		int j;
 		for(j=0;j<noA;j++)
 		{
 			
 			A[j]->mark=0;
 		}
 		for(j=0;j<noB;j++)
 		{
 			
 			B[j]->mark=0;
 		}
 }
 void mintrain(struct time *A[],struct time *B[],int noA,int noB,int caseno)
 {
 	int i,j;
 	int solA=0,solB=0;
 	for(i=0;i<noA;i++)
 	{
 		for(j=0;j<noB;j++)
 		{
 			if((A[i]->dep>=B[j]->arr) && (B[j]->mark==0))
 			{
 				A[i]->mark=1;
 				B[j]->mark=1;
 				break;
 			}
 		}
 	}
 	for(i=0;i<noA;i++)
 	{
 		if(A[i]->mark==0)
 		{
 			solA++;
 		}
 	}
 	setmarkzero(A,B,noA,noB);
 	for(i=0;i<noB;i++)
 	{
 		for(j=0;j<noA;j++)
 		{
 			if((B[i]->dep>=A[j]->arr) && (A[j]->mark==0))
 			{
 				B[i]->mark=1;
 				A[j]->mark=1;
 				break;
 			}	
 		}
 	}
 	for(i=0;i<noB;i++)
 	{
 		if(B[i]->mark==0)
 		{
 			solB++;
 		}
 	}
 	printf(αCase #%d: %d %dnα,caseno+1,solA,solB);
 }
 int main()
 {
 	int turnaroundtime;
 	int noofcases,noA,noB,i,hr,min;
 	struct time *A[120],*B[120];
 	scanf(α%dα,&noofcases);
 	for(i=0;i<noofcases;i++)
 	{
 		scanf(α%dα,&turnaroundtime);
 		scanf(α%dα,&noA);
 		scanf(α%dα,&noB);
 		int j,k;
 		for(j=0;j<noA;j++)
 		{
 			A[j]=(struct time *)malloc(sizeof(struct time));
 			scanf(α%d:%dα,&hr,&min);
 			A[j]->dep=hr*60+min;
 			scanf(α%d:%dα,&hr,&min);
 			A[j]->arr=hr*60+min+turnaroundtime;
 		}
 		for(j=0;j<noB;j++)
 		{
 			B[j]=(struct time *)malloc(sizeof(struct time));
 			scanf(α%d:%dα,&hr,&min);
 			B[j]->dep=hr*60+min;
 			scanf(α%d:%dα,&hr,&min);
 			B[j]->arr=hr*60+min+turnaroundtime;			
 		}
 	setmarkzero(A,B,noA,noB);
 	sortbydeptime(A,noA);
 	sortbydeptime(B,noB);
 	mintrain(A,B,noA,noB,i);
 	}
 	return 0;
 }"
12463,2008,32013,maver1ck,24480,1,sav_univ.c,gcj/2008/32013/maver1ck/24480/1/extracted/sav_univ.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct input
 {
     int ncases;
     int nsearch_engines;
     char search_engines[100][101];
     int se_occ[100];
     int se_dis[100];
     int nqueries;
     char queries[1000][101];
 }inp;
     
 #define SE_LEN 101    
 
 
 int get_se_index(char *str)
 {
     int loop = 0;
     for (loop =0; loop < inp.nsearch_engines;loop++)
     {
         if(!strcmp(str,inp.search_engines[loop]))
 		return loop;
     }
     return -1;
 }
 
 char * read_input(FILE *fptr)
 {
     int se_cnt = 0, q_cnt = 0;
     char *tmp_sptr = NULL,  /* Temp string ptr - Used to populate the search engines & querry array */ 
 	 ch;
     fscanf(fptr,α%dnα,&inp.nsearch_engines);
 #ifdef __DEBUG__
     printf(αNo of search Engines = %dnα,inp.nsearch_engines);
 #endif //__DEBUG__
 //    search_engines = (char *) malloc(inp.nsearch_engines*SE_LEN);   
     
     while(se_cnt < inp.nsearch_engines)
     {
 	 tmp_sptr = inp.search_engines[se_cnt];
          while((ch = fgetc(fptr)) != 'n' && ch != EOF)
          {
             *tmp_sptr = ch;
             tmp_sptr++;
 	 }
 	 if(ch == EOF)
 	 {
 		 printf(αIncomplete Input Filenα);
 		 exit(0);
 	 }
          *tmp_sptr = '0';
 /* Initialize distance and occurance to 0 */
         inp.se_occ[se_cnt] = 0;
         inp.se_dis[se_cnt] = 0;
         se_cnt++; 
     }
 #ifdef __DEBUG__
 
     for(se_cnt = 0 ; se_cnt < inp.nsearch_engines; se_cnt++)
     {
         printf(α%snα,inp.search_engines[se_cnt]);
     }    
 
 #endif //__DEBUG__    
     
     fscanf(fptr,α%dnα,&inp.nqueries);
 #ifdef __DEBUG__
     printf(αNo of queries = %dnα,inp.nqueries);
 #endif //__DEBUG__
 
 
     while(q_cnt < inp.nqueries)
     {
         tmp_sptr = inp.queries[q_cnt];
 	while((ch = fgetc(fptr)) != 'n' && ch != EOF)
 	{
 		*tmp_sptr = ch;
 		tmp_sptr++;
 	}
 	if(ch == EOF)
         {
 	    printf(αIncomplete Input Filenα);
 	    exit(0);
         }
 	*tmp_sptr = '0';
         q_cnt++;
     }
 
 
 #ifdef __DEBUG__
 
     for(q_cnt = 0 ; q_cnt < inp.nqueries ;q_cnt++)
     {
         printf(α%snα,inp.queries[q_cnt]);
     }
 
 #endif //__DEBUG__    
 
 
    return;
 } 
 
 
 void process_input(int case_cnt)
 {
     int index = -1, q_cnt =0, tmp_cnt = 0;
     int sel_se_num = 0;
     int switches=0;
 
 
 /* Calculate the occurance and distance for each SE in the queries */
     for(q_cnt = 0; q_cnt < inp.nqueries; q_cnt++)
     {
          if((index = get_se_index(inp.queries[q_cnt]) ) != -1)
          {
 	     inp.se_occ[index]++;
 	     if(inp.se_dis[index] == 0)
 		inp.se_dis[index] = q_cnt+1;                    
          }
     } 
 
 #ifdef __DEBUG__
     for(q_cnt = 0; q_cnt < inp.nsearch_engines; q_cnt++)
         printf(αOcc = %d , Dist = %dnα, inp.se_occ[q_cnt],inp.se_dis[q_cnt]);
 #endif //__DEBUG__
 
 /* Select the first SE based on dist and occ */
     for(index =0; index < inp.nsearch_engines;index++)
     {
         if(inp.se_occ[index] == 0) 
         {
             sel_se_num = index;
             break;
         }
         if(inp.se_dis[index] > inp.se_dis[sel_se_num])
 	    sel_se_num = index;
     }
 
 #ifdef __DEBUG__
 printf(αSelect SE = %snα,inp.search_engines[sel_se_num]);
 #endif
 
 /* Process individual queries & switch if same SE is hit */
     for(q_cnt = 0; q_cnt < inp.nqueries; q_cnt++)
     {
 	if(!(strcmp(inp.queries[q_cnt],inp.search_engines[sel_se_num])))
         {
 	/* Hit the same search Engine - Switch */
 	    switches++;
 	/* update the distaces */
             for(tmp_cnt = 0 ;tmp_cnt < inp.nsearch_engines; tmp_cnt++)
             {
                 inp.se_dis[tmp_cnt] = 0;
             }
             for(tmp_cnt = q_cnt; tmp_cnt < inp.nqueries; tmp_cnt++)
 	    {
 		    if((index = get_se_index(inp.queries[tmp_cnt]) ) != -1)
 		    {
 			    if(inp.se_dis[index] == 0)
 				    inp.se_dis[index] = tmp_cnt+1;                    
 		    }
             }
 
 #ifdef __DEBUG__
 	    for(tmp_cnt = 0; tmp_cnt < inp.nsearch_engines; tmp_cnt++)
 		    printf(α Occ = %d , Dist = %dnα, inp.se_occ[tmp_cnt],inp.se_dis[tmp_cnt]);
 #endif //__DEBUG__
  
 /*Select the next Search engine based on occurance and distance */
 	    sel_se_num = 0;
 	    for(index =0; index < inp.nsearch_engines;index++)
 	    {
 		    if(inp.se_occ[index] == 0)
 		    {
 			    sel_se_num = index;
 			    break;
 		    }
 		    if(inp.se_dis[index] > inp.se_dis[sel_se_num])
 			    sel_se_num = index;
 	    }
 
 #ifdef __DEBUG__
 	printf(αSwitch : Processing query = %s, Select SE = %snα,inp.queries[q_cnt],inp.search_engines[sel_se_num]);
 #endif
 
         }
 	/* End of Switching logic */
 
         inp.se_occ[get_se_index(inp.queries[q_cnt])]--;
         
     }        
 
 /* Done with processing the queries print the output*/
     printf(αCase #%d: %dnα,case_cnt,switches);
     return;
 }
   
 
 
 int main(int argc, char *argv[])
 {
 
     FILE *ifptr = NULL;
     int case_cnt = 0;
 
     if(argc < 2)
     {
         printf (α Please enter the input file namen Usage ./sav_univ <input_file>nα);
         exit(0);
     }
 /* Open the input file */
     if((ifptr = fopen(argv[1],αrα)) == NULL)
     {
         perror(αInput file not foundnα);
         exit(0);
     }
 
 /* Read the num of cases */
     fscanf(ifptr,α%dnα,&inp.ncases);
     
 #ifdef __DEBUG__
     printf(αNo of cases = %dnα,inp.ncases);
 #endif /* __DEBUG__ */
 
     while(case_cnt++ < inp.ncases)
     {
          read_input(ifptr);
          process_input(case_cnt);
 /*         write_output(case_cnt);
   */
     }
  
     fclose(ifptr);
     
     return 0;
 }"
12568,2008,32013,xregis,24481,1,train.c,gcj/2008/32013/xregis/24481/1/extracted/train.c,"/*
  * Macete:
  * comea com init_a e init_b iguais a 0
  * se available_x fica menor que zero
  * seta init_x pra init_x + 1
  * seta available_x pra 0
  */
 
 #include <stdio.h>
 #include <string.h>
 
 
 #define LEAVES_A 4
 #define ARRIVES_B 2
 #define LEAVES_B 3
 #define ARRIVES_A 1
 
 struct event 
 {
 	int time;
 	int ocurrence;
 };
 typedef struct event event_type;
 
 int hour_minute_to_int(int hour, int minute);
 void sortbytime(event_type event[], int size);
 void print_events(event_type event[], int size);
 
 int main(void)
 {
 	int caseCounter, naCounter, nbCounter, eventCounter, totalEvents;
 	int n; //test cases
 	int turn_around; //turn around time
 	int na; //number of departures from a
 	int nb; //number of departures from b
 	
 	int hour; //the hour of an event
 	int minute; //the minute of an event
 	
 	int available_a, available_b;
 	int init_a, init_b;
 	event_type event[500]; //to handle large_dataset...
 	
 	
 	//time to get started
 	scanf(α%dα, &n); //reads number of cases
 	for(caseCounter = 0; caseCounter < n; caseCounter++)
 	{
 		available_a = available_b = 0;
 		init_a = init_b = 0;
 		//get params for case
 		scanf(α%dα, &turn_around); //gets turn_around
 		scanf(α%d %dα, &na, &nb);
 		//printf(αTurn Around: %d, NA: %d, NB: %dnα, turn_around, na, nb);
 		//fill events vector:
 		eventCounter = 0;
 		for(naCounter = 0; naCounter < na && !feof(stdin); naCounter++)
 		{
 			//two events for each line
 			scanf(α%d:%dα, &hour, &minute);
 			//printf(α%d:%d -> %dnα, hour, minute, hour_minute_to_int(hour, minute));
 			event[eventCounter].time = hour_minute_to_int(hour, minute);
 			event[eventCounter].ocurrence = LEAVES_A;
 			eventCounter++;
 			scanf(α%d:%dα, &hour, &minute);
 			//printf(α%d:%d -> %dnα, hour, minute, hour_minute_to_int(hour, minute));
 			event[eventCounter].time = hour_minute_to_int(hour, minute + turn_around);
 			event[eventCounter].ocurrence = ARRIVES_B;
 			eventCounter++;
 		}
 		//eventCounter--;
 		for(nbCounter = 0; nbCounter < nb && !feof(stdin); nbCounter++)
 		{
 			//two events for each line (again)
 			scanf(α%d:%dα, &hour, &minute);
 			//printf(α%d:%d -> %dnα, hour, minute, hour_minute_to_int(hour, minute));
 			event[eventCounter].time = hour_minute_to_int(hour, minute);
 			event[eventCounter].ocurrence = LEAVES_B;
 			eventCounter++;
 			scanf(α%d:%dα, &hour, &minute);
 			//printf(α%d:%d -> %dnα, hour, minute, hour_minute_to_int(hour, minute));
 			event[eventCounter].time = hour_minute_to_int(hour, minute + turn_around);
 			event[eventCounter].ocurrence = ARRIVES_A;
 			eventCounter++;
 		}
 		//eventCounter--;
 		
 		//sorts events vector based on field time:
 		//print_events(event,eventCounter);
 		sortbytime(event, eventCounter);
 		
 		
 			
 		//processes events:
 		totalEvents = eventCounter;
 		for(eventCounter = 0; eventCounter < totalEvents; eventCounter++) 
 		{
 			switch(event[eventCounter].ocurrence)
 			{
 			case LEAVES_A:
 				available_a -= 1;
 				if(available_a < 0)
 				{
 				//nao pode ser um sai e um chega... 
 				//os eventos αchegaα devem ser processados antes...	
 					init_a += 1;
 					available_a = 0;
 				}
 				break;
 			case LEAVES_B:
 				available_b -= 1;
 				if(available_b < 0)
 				{
 					init_b += 1;
 					available_b = 0;
 				}
 				break;
 			case ARRIVES_A:
 				available_a += 1;
 				break;
 			case ARRIVES_B:
 				available_b += 1;
 				break;
 			}
 		}
 		// display output line:
 		printf(αCase #%d: %d %dnα, caseCounter+1, init_a, init_b);
 	}
 	return 0;
 }
 
 int hour_minute_to_int(int hour, int minute)
 {
 	while(minute > 60)
 	{
 		minute -= 60;
 		hour += 1;
 	}
 	return 100*hour + minute;
 }
 
 void sortbytime(event_type event[], int size)
 {
 	//vetor pequeno: bubblesort
 	int i, j;
 	int auxtime, auxocur;
 	for(i = size - 1; i > 0 - 1; i--)
 	{
 		for(j = 0; j < i; j++)
 		{
 			if(event[j].time > event[j+1].time || (event[j].time == event[j+1].time && event[j].ocurrence > event[j+1].ocurrence))
 			{
 				auxtime = event[j].time;
 				auxocur = event[j].ocurrence;
 				event[j].time = event[j+1].time;
 				event[j].ocurrence = event[j+1].ocurrence;
 				event[j+1].time = auxtime;
 				event[j+1].ocurrence = auxocur;
 			}
 		}
 	} //fim do bubblesort
 	//agora ordenar pelo αchegaα
 	for(i = 0; i < size; i++)
 	return;
 }
 void print_events(event_type event[], int size)
 {
 	int i;
 	for(i = 0; i < size; i++)
 	{
 		printf(αHora: %4d, Tipo: %dnα, event[i].time, event[i].ocurrence);
 	}
 }"
12666,2008,32013,rkroy,24480,1,GOOGQN.C,gcj/2008/32013/rkroy/24480/1/extracted/GOOGQN.C,"#include<stdio.h>
 #include<malloc.h>
 #include<stdlib.h>
 #include<string.h>
 #define MAX 1000
 #define MAXSIZE 100
 
 struct s_engine
 {
        char *name;
        int occur;
        int found;
 
 }search_engine[MAXSIZE];
 
 
 
 int find_max(int dista[],int num)
 {
 
   int max,m,i;
    max=dista[0];
   m=0;
   for(i=0;i<num;i++)
   {
     if(max<dista[i])
      {
       max=dista[i];
       m=i;
      }
   }
   return m;
 }
 
 
 
 //**************************** MAIN*************************************
 main()
 {
 
    int f,i=0,j,ff,dist,k;
 
 
    int no_of_switch=0,no_of_engine,no_of_query,no_of_inputs,call,num=1,flag;
    char *query_string[MAX],buf[MAXSIZE];
    int distance[MAXSIZE];
    FILE *fp ,*fp1;
  
  if(( fp=fopen(αc:\test5.inα,αrα))==NULL)
  {
       printf(αcant opn fileα);
       system(αpauseα);
       return 1;
 }     
 if(( fp1=fopen(αc:\test.outα,αwα))==NULL)
  {
       printf(αcant opn fileα);
       return 1;
 }     
 
 //printf(αn Enter the number of search engines : α);
 while(fgets(buf,100,fp))
 {
                         //gets(buf);
                         sscanf(buf,α%dα,&no_of_inputs);
 while((no_of_inputs--)!=0)
 {
                           i=0;
                         dist=0;
                          flag=0;    
                          fgets(buf,100,fp);
                          sscanf(buf,α%dα,&no_of_engine);
 //table initialization
                       while( i < no_of_engine )
                       {
 	                   search_engine[i].name=(char *)malloc(MAXSIZE*sizeof(char));
 	                   fgets(search_engine[i].name,100,fp);
 	//printf(α%dα,i);
 	                   search_engine[i].found=0;
 	                   i++;
                      }
 
 //printf(αn Enter the number of query strings nα);
 //gets(buf);
              fgets(buf,100,fp);
              sscanf(buf,α%dα,&no_of_query);
 
 
 //printf(αn Start entering the query stringsα);
 
              for(i=0;i<no_of_query;i++)
              {
              query_string[i]=(char*)malloc(MAXSIZE*sizeof(char));
              fgets(query_string[i],100,fp);
              }
 
 
              no_of_switch=0;
              i=0;
              flag=0;
 while(i!= no_of_query)
 {
              ff=0;
              flag=0;
              while(ff!=no_of_engine)
              {
               dist=0;
 	                 for(j=i;j<no_of_query;j++)
 	                 {
                       if(strcmpi(search_engine[ff].name,query_string[j]) ) //table[ff]!=string[j])
 		              {
 			           dist++;
 		               }
                        else
 	                   {
 		                search_engine[ff].occur=j;
                         search_engine[ff].found=1;
 		                break;
 	                    }
                     }
 
 	                if(dist==no_of_query || search_engine[ff].found==0)
 	                {
 		            flag=1;
 		            break;
 	                }
 	                else
 	                {
 		            distance[ff]=dist;
 		            ++ff;
 	                }
                 }//end of while
 	         if( flag)
 		         break;
 
        call=find_max(distance,no_of_engine);
        i=search_engine[call].occur  ;
        for(k=0;k<no_of_engine;k++)
        {
 		search_engine[k].found=0;
 		search_engine[k].occur=0;
        }
        no_of_switch++;
 }
 fprintf(fp1,αCase #%d: %dnα ,num, no_of_switch);
 num++;
 }
 }
 system(αpauseα);
 return 0;
 }"
12752,2008,32013,vitaminC,24480,1,search_switch.c,gcj/2008/32013/vitaminC/24480/1/extracted/search_switch.c,"#include <stdio.h>
 #include <string.h>
 
 #define CLR_NL(str) 
 	do { 
 		int n; 
 		if ( str && (n=strlen(str)) && str[n-1] == 'n' ) 
 			str[n-1] = '0'; 
 	} while(0)
 
 #define LINE_SZ 200
 #define NAME_SZ 101
 #define S_MAX 100
 #define Q_MAX 1000
 
 FILE *inf; 
 
 void getline(char *line)
 {
 	line[0] = '0';
 	fgets(line, LINE_SZ, inf);
 	CLR_NL(line);
 	if(!line[0])
 	{
 		printf(αInput file invalidnα);
 		exit(1);
 	}
 
 }
 
 int index_of(char *name, int S, char s_name[][NAME_SZ])
 {
 	int i;
 	for(i = 0; i < S; i++)
 		if(strcmp(name, s_name[i]) == 0)
 			return i;
 	return -1;
 }
 
 int get_max(int *arr, int num, int *max_indx)
 {
 	int i, max = arr[0];
        	*max_indx = 0;
 	for(i = 1; i < num; i++)
 		if(arr[i] > max)
 		{
 			max = arr[i];
 			*max_indx = i;
 		}
 	return max;
 }
 
 int getswno(int S, char s_name[][NAME_SZ], int Q, char q_name[][NAME_SZ])
 {
 	/* range is upto (not including) which index of query a search engine entry can service
 	 * without needing to switch */
 	int *range;
 	int i, lim = Q, j;
 	int swno = 0, max_range, start = 0, max_indx;
 
 
 	range = (int *)malloc(S * sizeof(int));
 
 
 	for(;; swno++)
 	{
 		/* initialize range */
 		for(i = 0; i < S; i++)
 			range[i] = lim;
 
 		for(i = start; i < Q; i++)
 		{
 			if((j = index_of(q_name[i], S, s_name)) >= 0)
 				if(range[j] == lim)
 					range[j] = i;
 		}
 		max_range = get_max(range, S, &max_indx);
 		/***************************************************/
 		/*
 		printf(αfrom q indx %d to %d, use %snα, start, max_range-1, s_name[max_indx]);
 		*/
 
 		if(max_range == lim) /* unique search engine exists which can cover all */
 			break;
 
 		start = max_range;
 	}
 
 	if(range)
 		free(range);
 	return swno;
 }
 
 int main(int argc, char *argv[])
 {
 
 	int N; /* num of tst cases */
 	int i;
 	char line[LINE_SZ];
 
 	if(argc != 2)
 	{
 		printf(αGive 1st arg = input file namenα);
 		exit(1);
 	}
 
 	inf = fopen(argv[1], αrα);
 	if(!inf)
 	{
 		printf(αCould not open input filenα);
 		exit(1);
 	}
 
 	getline(line);
 	sscanf(line, α%dα, &N);
 
 	for(i = 0; i < N; i++)
 	{
 		int S; /* max 100 */
 		char s_name[S_MAX][NAME_SZ];
 		int j;
 		int Q; /* max 1000 */
 		char q_name[Q_MAX][NAME_SZ];
 
 		getline(line);
 		sscanf(line, α%dα, &S);
 
 		for(j = 0; j < S; j++)
 		{
 			getline(s_name[j]);	
 		}
 
 		getline(line);
 		sscanf(line, α%dα, &Q);
 
 		for(j = 0; j < Q; j++)
 		{
 			getline(q_name[j]);	
 		}
 
 		/* output */
 		printf(αCase #%d: %dnα, i+1, getswno(S, s_name, Q, q_name));
 	}
 	return 0;
 }"
12754,2008,32013,vitaminC,24481,1,trains.c,gcj/2008/32013/vitaminC/24481/1/extracted/trains.c,"#include <stdio.h>
 #include <string.h>
 
 #define CLR_NL(str) 
 	do { 
 		int n; 
 		if ( str && (n=strlen(str)) && str[n-1] == 'n' ) 
 			str[n-1] = '0'; 
 	} while(0)
 
 #define LINE_SZ 200
 #define OUTF_NAME αoutput.txtα
 #define SORT_ARR  0
 #define SORT_DEP  1
 
 /* time table entry */
 typedef struct _ttentry
 {
 	int start_HH, start_MM; /* departure time */
 	int end_HH, end_MM; /* arrival time */
 	int start_mins, end_mins; /* converted to minutes */
 	char sent_back; /* marked 1 when train used for next journey */
 } ttentry;
 
 /* wrapper list for time table entry */
 typedef struct _ttent_list
 {
 	struct _ttent_list *next;
 	ttentry *ent;
 
 } ttent_list;
 
 FILE *inf, *outf; 
 int debug = 0;
 
 void getline(char *line)
 {
 	line[0] = '0';
 	fgets(line, LINE_SZ, inf);
 	CLR_NL(line);
 	if(!line[0])
 	{
 		printf(αInput file invalidnα);
 		exit(1);
 	}
 
 }
 
 void free_list(ttentry **list, int num)
 {
 	int i;
 
 	for(i = 0; i < num; i++)
 		if(list[i])
 			free(list[i]);
 	free(list);
 }
 
 /* return departure or arrival time(in minutes) value depending on mode */
 int get_time(ttentry *ent, char mode)
 {
 	if(mode == SORT_DEP)
 		return ent->start_mins;
 	else
 		return ent->end_mins;
 }
 
 void swap_entry(ttentry **arr, int i, int j)
 {
 	ttentry *temp;
 	temp = arr[i];
 	arr[i] = arr[j];
 	arr[j] = temp;
 }
 
 int partition_list(ttentry **list, int left, int right, int piv_index, char mode)
 {
 	int store_index, i ;
 	ttentry *piv = list[piv_index];
 	swap_entry(list, piv_index, right);
 
 	for(i = left, store_index = left; i < right; i++)
 		if(get_time(list[i], mode) <= get_time(piv, mode) )
 			swap_entry(list, i, store_index++);
 	swap_entry(list, store_index, right);
 
 	return store_index;
 }
 
 void qsort_list(ttentry **list, int left, int right, char mode)
 {
 	int pivot_index = left, new_piv_index;
 
 	if(left >= right)
 		return;
 
 	new_piv_index = partition_list(list, left, right, pivot_index, mode);
 	qsort_list(list, left, new_piv_index - 1, mode);
 	qsort_list(list, new_piv_index + 1, right, mode);
 
 }
 
 /* get a train that has arrived before the time given 
  * and which has not been sent back*/
 ttentry *prev_train_ent(ttentry **list, int num, int time)
 {
 	int i;
 
 	if(num <= 0 || time < 0 || !list)
 		return NULL;
 
 	for(i = 0; i < num; i++)
 	{
 		if(list[i]->end_mins <= time && !list[i]->sent_back)
 			return list[i];
 	}
 
 	return NULL;
 }
 
 int main(int argc, char *argv[])
 {
 
 	int N; /* num of tst cases */
 	int i;
 	char line[LINE_SZ];
 	ttentry *ent;
 	ttent_list *entlist;
 
 	if(argc != 2)
 	{
 		printf(αGive 1st arg = input file namenα);
 		exit(1);
 	}
 
 	inf = fopen(argv[1], αrα);
 	if(!inf)
 	{
 		printf(αCould not open input filenα);
 		exit(1);
 	}
 
 	outf = fopen(OUTF_NAME, αwα);
 	if(!outf)
 	{
 		printf(αCould not open output file for writingnα);
 		exit(1);
 	}
 
 	getline(line);
 	sscanf(line, α%dα, &N);
 
 	for(i = 0; i < N; i++)
 	{
 		int T, NA, NB, j, a_start, b_start;
 	        ttentry **a_dep_list, **b_dep_list;	
 		
 		a_dep_list = b_dep_list = NULL;
 
 		getline(line);
 		sscanf(line, α%dα, &T);
 
 		getline(line);
 		sscanf(line, α%d %dα, &NA, &NB);
 
 		if(NA > 0)
 			a_dep_list = (ttentry **)calloc(NA , sizeof(ttentry *)); /* using array */
 		for(j = 0; j < NA; j++)
 		{
 			getline(line);
 			ent = (ttentry *)calloc(1, sizeof(ttentry));
 			sscanf(line, α%d:%d %d:%dα, &ent->start_HH, &ent->start_MM, &ent->end_HH, &ent->end_MM);
 			ent->start_mins = ent->start_HH * 60 + ent->start_MM;
 			ent->end_mins = ent->end_HH * 60 + ent->end_MM;
 			a_dep_list[j] = ent;
 			
 		}
 
 		if(NB > 0)
 			b_dep_list = (ttentry **)calloc(NB , sizeof(ttentry *)); /* using array */
 		for(j = 0; j < NB; j++)
 		{
 			getline(line);
 			ent = (ttentry *)calloc(1, sizeof(ttentry));	
 			sscanf(line, α%d:%d %d:%dα, &ent->start_HH, &ent->start_MM, &ent->end_HH, &ent->end_MM);
 			ent->start_mins = ent->start_HH * 60 + ent->start_MM;
 			ent->end_mins = ent->end_HH * 60 + ent->end_MM;
 			b_dep_list[j] = ent;	
 		}
 
 
 		/******For A */
 		/* sort the lists according to time */
 		qsort_list(a_dep_list, 0, NA-1, SORT_DEP);
 		qsort_list(b_dep_list, 0, NB-1, SORT_ARR); /* B's departure is A's arrival */
 		
 		if(debug)
 			printf(αfrom A to B:nα); /************************/
 		for(j = 0, a_start = 0; j < NA; j++)
 		{
 			ttentry *prev_ent;
 
 			ent = a_dep_list[j];
 			prev_ent = prev_train_ent(b_dep_list, NB, ent->start_mins - T);
 			if(prev_ent) /* train found that can be sent back , no start needed */
 				prev_ent->sent_back = 1;
 			else
 				a_start++;  /* new train has to start from A */
 
 			/***************************/
 			if(debug)
 			   if(prev_ent)
 				printf(α	sending back : %d:%d(B) -> %d:%d(A) as %d:%d(A) -> %d:%d(B)nα, prev_ent->start_HH, prev_ent->start_MM, prev_ent->end_HH, prev_ent->end_MM, ent->start_HH, ent->start_MM, ent->end_HH, ent->end_MM);
 			   else
 				printf(α	new start at A : %d:%d(A) -> %d:%d(B)nα, ent->start_HH, ent->start_MM, ent->end_HH, ent->end_MM);
 		}
 
 		if(debug)
 			printf(αfrom B to A:nα); /************************/
 		/******For B */
 		/* sort the lists according to time */
 		qsort_list(b_dep_list, 0, NB-1, SORT_DEP);
 		qsort_list(a_dep_list, 0, NA-1, SORT_ARR); /* A's departure is B's arrival */
 		
 		for(j = 0, b_start = 0; j < NB; j++)
 		{
 			ttentry *prev_ent;
 
 			ent = b_dep_list[j];
 			prev_ent = prev_train_ent(a_dep_list, NA, ent->start_mins - T);
 			if(prev_ent) /* train found that can be sent back , no start needed */
 				prev_ent->sent_back = 1;
 			else
 				b_start++;  /* new train has to start from B */
 
 			/***************************/
 			if(debug)
 			  if(prev_ent)
 				printf(α	sending back : %d:%d(A) -> %d:%d(B) as %d:%d(B) -> %d:%d(A)nα, prev_ent->start_HH, prev_ent->start_MM, prev_ent->end_HH, prev_ent->end_MM, ent->start_HH, ent->start_MM, ent->end_HH, ent->end_MM);
 			  else
 				printf(α	new start at B : %d:%d(B) -> %d:%d(A)nα, ent->start_HH, ent->start_MM, ent->end_HH, ent->end_MM);
 		}
 
 		/* output */
 		fprintf(outf, αCase #%d: %d %dnα, i+1, a_start, b_start);
 		printf(αCase #%d: %d %dnα, i+1, a_start, b_start);
 
 
 		/* free memory */
 		if(a_dep_list)
 			free_list(a_dep_list, NA);
 		if(b_dep_list)
 			free_list(b_dep_list, NB);
 	}
 	return 0;
 }"
13005,2008,32013,Bowman,24480,1,test_save.c,gcj/2008/32013/Bowman/24480/1/extracted/test_save.c,"#include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <pwd.h>
 #include <string.h>
 #include <errno.h>
 #include <stdlib.h>
 
 #include <crypt.h>
 #include <unistd.h>
 #include <dirent.h>
 
 #define MAX_NAME_LEN	100
 typedef struct tag_db
 {
     char		dbname[MAX_NAME_LEN];
     int			count;
 
 }TAG_DB;
 
 static TAG_DB sql_db[100];
 static char	target[1000][MAX_NAME_LEN];
 
 static int	sql_n = 0;
 static int	target_n = 0;
 static int	switch_n = 0;
 
 
 void show_arrays()
 {
 	int i;
 	
 	printf(α%dnα, sql_n);
 	for(i = 0; i < sql_n; i++)
 	{
 		printf(α%snα, sql_db[i].dbname);
 	}
 
 	printf(α%dnα, target_n);
 	for(i = 0; i < target_n; i++)
 	{
 		printf(α%snα, target[i]);
 	}
 }
 
 void clear_count()
 {
 	int i;
 
 	for(i = 0; i < sql_n; i++)
 	{
 		sql_db[i].count = 0;
 	}
 }
 
 char * ltrimstr(char *buf)
 {
 
 	int	len;
 	int	i;
 	char *	p;
 
 	len = strlen(buf);
 	if (len <= 0)	return buf;
 
 	p = buf;
 	for (i = 0; i < len; i++)
 	{
 		if (buf[i] == ' ' || buf[i] == 't')
 			p = buf + i;
 		else
 			break;
 	}
 
 	return p;
 
 }
 
 /************************************************************************
  * 
  ************************************************************************/
 char * rtrimstr(char *buf)
 {
 
 	int	len;
 	int	i;
 
 	len = strlen(buf);
 	if (len <= 0)	return buf;
 
 	for (i = len - 1; i >= 0; i--)
 	{
 		if (buf[i] == ' ' || buf[i] == 'r' || buf[i] == 'n')
 		{
 			buf[i] = '0';
 		}
 		else	break;
 	}
 
 	return buf;
 
 }
 char *readline(FILE *fp, char *line, int len)
 {
 	char *start;
 
 	if(fgets(line, len, fp) == NULL)
 	{
 		printf(αfgets errornα);
 		return NULL;
 	}
 	
 	start = ltrimstr(line);
 	rtrimstr(start);
 
 	return start;
 }
 
 int found_name(const char *name, int temp_db)
 {
 	int i;
 
 	for(i = 0; i < sql_n; i++)
 	{
 		if(!strcmp(name, sql_db[i].dbname))
 		{
 			if(sql_db[i].count == 0)
 			{
 				sql_db[i].count++;
 				temp_db--;
 			}
 			break;
 			
 		}
 	}
 	
 //	printf(αtemp_db = %d, %snα, temp_db, name);
 	if(temp_db == 0)
 	{
 		printf(α%d: %snα, switch_n, name);
 		switch_n++;
 		temp_db = sql_n - 1;
 		clear_count();
 		sql_db[i].count = 1;
 	}
 
 	return temp_db;
 }
 
 
 void count_switch_n()
 {
 	int temp_db = sql_n;
 	int	i;
 
 	/* 
 	 * find each target with dbname, until only one dbname left 
 	 * or on target left
 	 */
 	
 	for(i = 0; i < target_n; i++)
 	{
 		temp_db = found_name(target[i], temp_db);
 		
 		
 	}
 
 	for(i = 0; i < sql_n; i++)
 	{
 		if(sql_db[i].count == 0)
 		{
 			printf(α%d: %snα, switch_n, sql_db[i].dbname);
 			break;
 		}
 	}
 	
 
 }
 
 
 int main()
 {
  	FILE            *fp_r, *fp_w;
 	char            line[MAX_NAME_LEN];
 	int				i, j, lines = 0;
 	char			*start;
 	int				cases = 0;
 
 
 	fp_r = fopen(α./inputα, αrα);
 	fp_w = fopen(α./outputα, αw+α);
 	if(!fp_r || !fp_w)
 	{
 		printf(αopen file errornα);
 		return 1;
 	}
 
 	start = readline(fp_r, line, sizeof(line));
 	cases = strtoul(start, NULL, 0);
 
 
 	for(i = 0; i < cases; i++)
 //	for(i = 0; i < 1; i++)
 	{
 		start = readline(fp_r, line, sizeof(line));
 		sql_n = strtoul(start, NULL, 0);
 		for(j = 0; j < sql_n; j++)
 		{
 			start = readline(fp_r, line, sizeof(line));
 			strcpy(sql_db[j].dbname, start);
 			sql_db[j].count = 0;			
 
 		}
 
 		start = readline(fp_r, line, sizeof(line));
 		target_n = strtoul(start, NULL, 0);
 		for(j = 0; j < target_n; j++)
 		{
 			start = readline(fp_r, line, sizeof(line));
 			strcpy(target[j], start);
 
 		}
 
 		switch_n = 0;
 		printf(αCase #%d:nα, i + 1);
 //		show_arrays();
 //		printf(α========================nα);
 		count_switch_n();
 		fprintf(fp_w, αCase #%d: %dnα, i + 1, switch_n);	
 		
 
 	}
 
 
 	fclose(fp_r);
 	fclose(fp_w);
 	return 0;
 }"
13007,2008,32013,Bowman,24481,1,test_train.c,gcj/2008/32013/Bowman/24481/1/extracted/test_train.c,"#include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <pwd.h>
 #include <string.h>
 #include <errno.h>
 #include <stdlib.h>
 
 #include <crypt.h>
 #include <unistd.h>
 #include <dirent.h>
 
 #define MAX_NAME_LEN	100
 #define A_STATION	1
 #define B_STATION	2
 typedef struct tag_trip
 {
     char		start[6];
     char		arriv[6];
 	int			train;		//0 : no train 
 	int			direct;	// A -> B= 0; B -> A = 1;
 
 }TAG_TRIP;
 
 typedef struct tag_train
 {
     char		valid_time[6];
 	int			local;		//A = 0; B = 1;
 
 }TAG_TRAIN;
 
 
 static TAG_TRIP tripAB[100];
 static TAG_TRIP tripBA[100];
 static TAG_TRAIN trains[200];
 
 static int	tr = 0;
 static int	NA = 0;
 static int	NB = 0;
 static int	A_start = 0;
 static int	B_start = 0;
 
 void init_data()
 {
 	bzero(tripAB, sizeof(tripAB));
 	bzero(tripBA, sizeof(tripBA));
 	bzero(trains, sizeof(trains));
 	A_start = 0;
 	B_start = 0;
 }
 
 void show_train(TAG_TRAIN *train)
 {
 	printf(αnew train info: α);
 	printf(αA_start = %d, B_start = %d; α, A_start, B_start);
 	printf(α%s at %snα, train->valid_time,
 			(train->local == A_STATION) ? αAα : αBα);
 }
 
 void show_arrays()
 {
 	int i;
 	
 	printf(α%d %dnα, NA, NB);
 	for(i = 0; i < NA; i++)
 	{
 		printf(α%s %snα, tripAB[i].start, tripAB[i].arriv);
 	}
 
 	for(i = 0; i < NB; i++)
 	{
 		printf(α%s %snα, tripBA[i].start, tripBA[i].arriv);
 	}
 }
 
 char * ltrimstr(char *buf)
 {
 
 	int	len;
 	int	i;
 	char *	p;
 
 	len = strlen(buf);
 	if (len <= 0)	return buf;
 
 	p = buf;
 	for (i = 0; i < len; i++)
 	{
 		if (buf[i] == ' ' || buf[i] == 't')
 			p = buf + i;
 		else
 			break;
 	}
 
 	return p;
 
 }
 
 /************************************************************************
  * 
  ************************************************************************/
 char * rtrimstr(char *buf)
 {
 
 	int	len;
 	int	i;
 
 	len = strlen(buf);
 	if (len <= 0)	return buf;
 
 	for (i = len - 1; i >= 0; i--)
 	{
 		if (buf[i] == ' ' || buf[i] == 'r' || buf[i] == 'n')
 		{
 			buf[i] = '0';
 		}
 		else	break;
 	}
 
 	return buf;
 
 }
 char *readline(FILE *fp, char *line, int len)
 {
 	char *start;
 
 	if(fgets(line, len, fp) == NULL)
 	{
 		printf(αfgets errornα);
 		return NULL;
 	}
 	
 	start = ltrimstr(line);
 	rtrimstr(start);
 
 	return start;
 }
 
 TAG_TRIP *find_notrain(TAG_TRIP *trip, int len)
 {
 	int i;
 
 	for(i = 0; i < len; i++)
 	{
 		if(trip[i].train == 0)
 		{
 			return &trip[i];
 		}
 	}
 
 	return NULL;
 }
 
 TAG_TRIP *find_earliest()
 {
 	int i, j;
 	TAG_TRIP	*earliest;
 
 	if(NA != 0)
 	{
 		earliest = find_notrain(&tripAB[0], NA);
 		if(earliest == NULL)
 		{
 			earliest = find_notrain(&tripBA[0], NB);
 		}
 	
 
 	}
 	else
 	{
 		if(NB != 0)
 		{
 			earliest = find_notrain(&tripBA[0], NB);
 		}
 		else
 		{
 			return NULL;
 		}
 	}
 
 	if(earliest == NULL)
 	{
 		printf(αearliest == NULLnα);
 		return NULL;
 	}
 
 	/* find out earliest trip between A and B */
 	for(i = 0; i < NA; i++)
 	{
 		if(tripAB[i].train == 0)
 		{
 			if(strcmp(tripAB[i].start, earliest->start) < 0)
 			{
 				earliest = &tripAB[i];
 			}
 			
 			if(strcmp(tripAB[i].start, earliest->start) == 0)
 			{
 				if(strcmp(tripAB[i].arriv, earliest->arriv) < 0)
 				{
 					earliest = &tripAB[i];
 				}
 			}
 		}
 	}
 
 	for(i = 0; i < NB; i++)
 	{
 		if(tripBA[i].train == 0)
 		{
 //			printf(α%s ? %snα, tripBA[i].start, earliest->start);
 			if(strcmp(tripBA[i].start, earliest->start) < 0)
 			{
 				earliest = &tripBA[i];
 			}
 			
 			if(strcmp(tripBA[i].start, earliest->start) == 0)
 			{
 				if(strcmp(tripBA[i].arriv, earliest->arriv) < 0)
 				{
 					earliest = &tripBA[i];
 				}
 			}
 		}
 
 	}
 
 	return earliest;
 }
 
 TAG_TRAIN *check_train(int station, const char *time)
 {
 	int i;
 	
 	for(i = 0; i < A_start + B_start; i++)	
 	{
 //		printf(αtrains[%d].local = %d, %dnα, i, trains[i].local, station);
 		if(trains[i].local == station)
 		{
 //			printf(α%s ? %snα, trains[i].valid_time, time);
 			if(strcmp(trains[i].valid_time, time) <= 0)
 			{
 				return &trains[i];
 			}
 		}
 	}
 
 	return NULL;
 }
 
 void count_valid_time(char *result, const char *time)
 {
 	char	time1[6];
 	char	*start;
 	int		h, m;
 
 	strcpy(time1, time);
 
 	start = strtok(time1, α:α);
 	h = strtoul(start, NULL, 10);
 
 	start = strtok(NULL, α:α);
 	m = strtoul(start, NULL, 10);
 
 	if(m + tr >= 60)
 	{
 		h++;
 		m = m + tr - 60;
 	}
 	else
 	{
 		m = m + tr;
 	}
 
 	sprintf(result, α%.2d:%.2dα, h, m);
 }
 
 void count_trains_n()
 {
 	TAG_TRIP *trip;
 	TAG_TRAIN *train;
 	int	i;
 
 	for(i = 0; i < NA + NB; i++)
 	{
 		trip = find_earliest();
 		if(!(trip->direct))
 		{
 			printf(αA -> B: α);
 			printf(α%s -> %snα, trip->start, trip->arriv);
 			if((train = check_train(A_STATION, trip->start)) != NULL)
 			{
 				/* exist train */
 				train->local = B_STATION;	
 				count_valid_time(train->valid_time, trip->arriv);
 				printf(αexist train: %s at %snα, train->valid_time,
 						(train->local == A_STATION) ? αAα : αBα);
 			}
 			else
 			{
 				/* new train */
 				train = &trains[A_start + B_start];
 				A_start++;
 				train->local = B_STATION;
 				count_valid_time(train->valid_time, trip->arriv);
 				show_train(train);
 			}
 		}
 		else
 		{
 			printf(αB -> A: α);
 			printf(α%s -> %snα, trip->start, trip->arriv);
 			if((train = check_train(B_STATION, trip->start)) != NULL)
 			{
 				/* exist train */
 				train->local = A_STATION;	
 				count_valid_time(train->valid_time, trip->arriv);
 				printf(αexist train: %s at %snα, train->valid_time,
 						(train->local == A_STATION) ? αAα : αBα);
 	
 			}
 			else
 			{
 				/* new train */
 				train = &trains[A_start + B_start];
 				B_start++;
 				train->local = A_STATION;
 				count_valid_time(train->valid_time, trip->arriv);
 				show_train(train);
 			}
 		}
 
 		
 
 		trip->train = 1;
 
 	}
 
 
 }
 int main()
 {
  	FILE            *fp_r, *fp_w;
 	char            line[MAX_NAME_LEN];
 	int				i, j, lines = 0;
 	char			*start;
 	int				cases = 0;
 
 
 	fp_r = fopen(α./inputα, αrα);
 	fp_w = fopen(α./outputα, αw+α);
 	if(!fp_r || !fp_w)
 	{
 		printf(αopen file errornα);
 		return 1;
 	}
 
 	start = readline(fp_r, line, sizeof(line));
 	cases = strtoul(start, NULL, 0);
 
 
 	for(i = 0; i < cases; i++)
 //	for(i = 0; i < 1; i++)
 	{
 		char *p;
 
 		init_data();
 		start = readline(fp_r, line, sizeof(line));
 		tr = strtoul(start, NULL, 0);
 		
 		start = readline(fp_r, line, sizeof(line));
 		p = strtok(start, α α);
 		NA = strtoul(p, NULL, 0);
 		p = strtok(NULL, α α);
 		NB = strtoul(p, NULL, 0);
 		for(j = 0; j < NA; j++)
 		{
 			start = readline(fp_r, line, sizeof(line));
 			p = strtok(start, α α);			
 			strcpy(tripAB[j].start, p);
 
 			p = strtok(NULL, α α);			
 			strcpy(tripAB[j].arriv, p);
 			tripAB[j].train = 0;
 			tripAB[j].direct = 0;
 
 		}
 
 		for(j = 0; j < NB; j++)
 		{
 			start = readline(fp_r, line, sizeof(line));
 			p= strtok(start, α α);			
 			strcpy(tripBA[j].start, p);
 
 			p = strtok(NULL, α α);			
 			strcpy(tripBA[j].arriv, p);
 
 			tripBA[j].train = 0;
 			tripBA[j].direct = 1;
 		}
 
 		printf(αCase #%d:nα, i + 1);
 		printf(αturnaround : %dnα, tr);
 		show_arrays();
 		printf(α========================nα);
 		count_trains_n();
 		fprintf(fp_w, αCase #%d: %d %dnα, i + 1, A_start, B_start);	
 		
 
 	}
 
 
 	fclose(fp_r);
 	fclose(fp_w);
 	return 0;
 }"
13023,2008,32013,fcoelho,24480,1,save_universe.c,gcj/2008/32013/fcoelho/24480/1/extracted/save_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 struct avanco{
 	int avanco;
 	int buscador;
 };
 
 int comp(const void *p1, const void *p2)
 {
 	struct avanco *a = (struct avanco*)p1;
 	struct avanco *b = (struct avanco*)p2;
 	
 	return b->avanco - a->avanco;	
 }
 
 int main(int argc, char *argv[])
 {
 	int N, S, Q;
 	int caso, i, j;
 	int trocas;
 	int max=0, total = 0;
 	struct avanco avanco[100];
 	char buscador[100][101];
 	char busca[1000][101];
 	char linha[256];
 	FILE *arq;
 	
 	arq = fopen(αA-small.inα,αrα);
 	if (!arq)
 	{
 		perror(αDEU ERRO!!α);
 		exit(1);
 	}
 
 	/*quantidade de casos de teste*/
 	fgets(linha, 255, arq);
 	sscanf(linha, α%iα, &N);
 	
 	for (caso=1 ; caso<=N ; caso++)
 	{
 		/*número de buscadores*/
 		fgets(linha, 255, arq);
 		sscanf(linha, α%iα, &S);
 		for (i=0 ; i<S ; i++)
 		{
 			/*pega o nome do buscador*/
 			fgets(buscador[i], 101, arq);
 			/*zera os avanços*/
 			avanco[i].avanco = 0;
 			avanco[i].buscador = i;
 		}
 		/*número de buscas*/
 		fgets(linha, 255, arq);
 		sscanf(linha, α%iα, &Q);
 		for (i=0 ; i<Q ; i++)
 		{
 			/*pega a busca*/
 			fgets(busca[i], 101, arq);
 		}
 		/*parte hardcore da coisa*/
 		trocas = total = max = 0;
 		while (total < Q)
 		{
 			/*testa cada buscador pra saber o quanto ele αvai pra frenteα*/
 			/*parte do último ponto em que chegou*/
 			for (i=0 ; i<S ; i++)
 			{
 				j = max;			
 				while ( j<Q && (strcmp(buscador[i], busca[j]) != 0))
 					j++;
 				avanco[i].avanco = j;
 			}
 			
 			/*ordena decrescente -> primeiro é o que andou mais*/
 			qsort(avanco, S, sizeof(struct avanco), comp);
 			/*se ainda não chegou no final, tá na hora de fazer uma troca..*/
 			max = avanco[0].avanco;
 			if (max != Q)
 				trocas++;
 			total = max;
 		}
 		printf(αCase #%i: %inα, caso, trocas);
 	}
 	return 0;
 }"
13050,2008,32013,hiperx,24480,1,save_universe.c,gcj/2008/32013/hiperx/24480/1/extracted/save_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #define MAXn 200
 #define MAXc 200
 
 int foi[MAXn];
 char nome[MAXn][MAXc];
 int n,m;
 
 int procura(char *s){
   int meio, esq,dir, cmp;
 
   esq=0; dir=n-1;
   while(esq<=dir){
     meio=(esq+dir)/2;
     cmp=strcmp(s,nome[meio]);
 
     if(cmp==0) return meio;
     if(cmp<0) dir=meio-1;
     else esq=meio+1;
   }
 
   return -1;
 }
 
 int verify(){
   int i;
 
   for(i=0 ; i<n ; i++)
     if(foi[i]==0) return 0;
 
   return 1;
 }
 
 int main(){
   int nt,nt0;
   int i,j,k, cont;
   char query[MAXc];
 
   scanf(α %dα, &nt0);
   for(nt=1 ; nt<=nt0 ; nt++){
     cont=0;
 
     scanf(α %d%*cα, &n);
     for(i=0 ; i<n ; i++){
       gets(nome[i]);
       foi[i]=0;
     }
 
     qsort(nome,n,MAXc*sizeof(char),strcmp);
 
     scanf(α %d%*cα, &m);
     for(i=0 ; i<m ; i++){
       gets(query);
       k=procura(query);
 
       foi[k]=1;
       if(verify()){
 	for(j=0 ; j<n ; j++) foi[j]=0;
 	foi[k]=1;
 	cont++;
       }
 
     }
 
     printf(αCase #%d: %dnα, nt, cont);
   }
 
   return 0;
 }"
13052,2008,32013,hiperx,24481,1,train_time.c,gcj/2008/32013/hiperx/24481/1/extracted/train_time.c,"#include <stdio.h>
 #include <stdlib.h>
 #define MAX 200
 
 int t, na,nb;
 int tai[MAX],taf[MAX]; /*tempo de A inicial e final, em minutos*/
 int tbi[MAX],tbf[MAX]; /*tempo de B inicial e final, em minutos*/
 
 int cmp(const void *a, const void *b){
   return *(int *)a - *(int *)b;
 }
 
 int main(){
   int nt0,nt;
   int i,j, aux1,aux2, na2,nb2;
 
   scanf(α %dα, &nt0);
   for(nt=1 ; nt<=nt0 ; nt++){
     scanf(α %d %d %dα, &t, &na, &nb);
 
     /*le os tempos de A*/
     for(i=0 ; i<na ; i++){
       scanf(α %d:%dα, &aux1, &aux2);
       tai[i]=60*aux1+aux2;
 
       scanf(α %d:%dα, &aux1, &aux2);
       taf[i]=60*aux1+aux2;
     }
 
     /*le os tempos de B*/
     for(i=0 ; i<nb ; i++){
       scanf(α %d:%dα, &aux1, &aux2);
       tbi[i]=60*aux1+aux2;
 
       scanf(α %d:%dα, &aux1, &aux2);
       tbf[i]=60*aux1+aux2;
     }
 
     qsort(tai,na,sizeof(int),cmp);
     qsort(taf,na,sizeof(int),cmp);
 
     qsort(tbi,nb,sizeof(int),cmp);
     qsort(tbf,nb,sizeof(int),cmp);
 
     na2=na; nb2=nb;
     for(i=j=0 ; i<na && j<nb ; i++)
       if(tai[i]>=tbf[j]+t){ na2--; j++; }
 
     for(i=j=0 ; i<nb && j<na ; i++)
       if(tbi[i]>=taf[j]+t){ nb2--; j++; }
 
     printf(αCase #%d: %d %dnα, nt, na2,nb2);
   }
 
   return 0;
 }"
13194,2008,32013,wkrax,24480,1,main.c,gcj/2008/32013/wkrax/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include<ctype.h>
 
 
 #define MAXBUSCADORES 100
 #define MAXBUSQUEDAS  1000
 #define MAXCASOS      20
 
 
 int main(int argc, char *argv[])
 {
   FILE *infile;
   FILE *outfile;
 
   int i,j,k,l;
   
   int cantidadCasos;
   int cantidadMotores;
   int cantidadBusquedas;
   
   int mapabusquedas[MAXBUSQUEDAS];
   int cantidadBuscadoresDescartados;
   int esPosibleBuscador[MAXBUSCADORES];
   
   char motores[MAXBUSCADORES][100];
   char busquedas[MAXBUSQUEDAS][100];
   char tmp_cadena[100];
   
   int buscadorActual;
   int buscadoresPosibles;
   int cantidadCambios[MAXCASOS];
 
   if((infile = fopen(αc:\A-large.inα, αrα)) == NULL) {
     printf(αError Opening File.nα);
     exit(1);
   }
   
   fgets(tmp_cadena, 100, infile);
   cantidadCasos = atoi(tmp_cadena);
 
   for(i=0;i!=cantidadCasos;i++)
   {
 
      fgets(tmp_cadena, 100, infile);
      cantidadMotores = atoi(tmp_cadena);
 
      for(j=0;j!=cantidadMotores;j++)
     {
       fgets(motores[j],100,infile);
     }
     fgets(tmp_cadena, 100, infile);
     cantidadBusquedas = atoi(tmp_cadena);
 
    
     for(j=0;j!=cantidadBusquedas;j++) 
     {
       fgets(busquedas[j], 100, infile);
 
     }
     
     for(l=0;l!=cantidadMotores;l++)
     {
         esPosibleBuscador[l]=1;
     }
     buscadoresPosibles=cantidadMotores;
     cantidadCambios[i]=0;
     
     for(j=0;j!=cantidadBusquedas;j++)
     {
     
       for(k=0;k!=cantidadMotores;k++)
       {
           if(strcmp(motores[k],busquedas[j])==0 && esPosibleBuscador[k]==1)
           {
               esPosibleBuscador[k] = 0;
               buscadoresPosibles--;
           
               if(buscadoresPosibles==0)
               {
                   cantidadCambios[i]++;
                   for(l=0;l!=cantidadMotores;l++)
                   {
                       esPosibleBuscador[l]=1;
                   }
                   buscadoresPosibles=cantidadMotores-1;
               esPosibleBuscador[k] = 0;
               }
           }
       }
     }  
   }
 
 
   if((outfile = fopen(αc:\salida.inα, αwα)) == NULL) {
     printf(αError Creating File.nα);
     exit(1);
   }
   
   for(k=0;k!=cantidadCasos;k++)
   {
       fputs(αCase #α,outfile);
       fputs(itoa(k+1,tmp_cadena,10),outfile);
       fputs(α: α,outfile);
       fputs(itoa(cantidadCambios[k],tmp_cadena,10),outfile);     
       fputs(αnα,outfile);
 //      printf(itoa(cantidadCambios[k],tmp_cadena,10));
   }
 
   
      
   system(αPAUSEα);	
   fclose(infile);  /* Close the file */
   return 0;
 }"
13196,2008,32013,wkrax,24481,1,main.c,gcj/2008/32013/wkrax/24481/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 
 
 #define MAXVIAJES     100
 #define MAXBUSQUEDAS  1000
 #define MAXCASOS      100
 
 
 int main(int argc, char *argv[])
 {
   FILE *infile;
   FILE *outfile;
 
   int i,j,k,l,temp;
   
   int cantidadCasos;
   int viajesAB;
   int viajesBA;
   
   int horasPartidaAB;
   int minutosPartidaAB;
   int horasLlegadaAB;
   int minutosLlegadaAB;
   int horasPartidaBA;
   int minutosPartidaBA;
   int horasLlegadaBA;
   int minutosLlegadaBA;
   
   int  tiempoPartidaAB[MAXVIAJES];
   int  tiempoLlegadaAB[MAXVIAJES];
   int  tiempoPartidaBA[MAXVIAJES];
   int  tiempoLlegadaBA[MAXVIAJES];
 
   int  PAB[MAXVIAJES];
   int  LAB[MAXVIAJES];
   int  PBA[MAXVIAJES];
   int  LBA[MAXVIAJES];
   
   int tiempoRecarga;
      
 
   char tmp_cadena[100];
   char *tmp_cadena2;
   char *tmp_cadena3;
   
   int cantidadTrenesA[MAXCASOS];
   int cantidadTrenesB[MAXCASOS];
 
   if((infile = fopen(αc:\B-large.inα, αrα)) == NULL) {
     printf(αError Opening File.nα);
     exit(1);
   }
   
 
    fgets(tmp_cadena, 100, infile);
    cantidadCasos = atoi(tmp_cadena);
  
     for(i=0;i!=cantidadCasos;i++)
     {
       fgets(tmp_cadena, 100, infile);
       tiempoRecarga = atoi(tmp_cadena);
 
       fgets(tmp_cadena, 100, infile);
       tmp_cadena2=tmp_cadena;
 
       tmp_cadena3=strtok(tmp_cadena2, α α);
       viajesAB=atoi(tmp_cadena3);
       tmp_cadena3=strtok(NULL, α α);
       viajesBA=atoi(tmp_cadena3);
 
       
       for(j=0;j!=viajesAB;j++)
       {
           fgets(tmp_cadena, 100, infile);      
           tmp_cadena2=tmp_cadena;
 
 
           tmp_cadena3=strtok(tmp_cadena2, α:α);
           horasPartidaAB=atoi(tmp_cadena3);
 
           tmp_cadena3=strtok(NULL, α α);
           minutosPartidaAB=atoi(tmp_cadena3);
 
           tmp_cadena3=strtok(NULL, α:α);
           horasLlegadaAB=atoi(tmp_cadena3);          
 
           tmp_cadena3=strtok(NULL, α α);
           minutosLlegadaAB=atoi(tmp_cadena3);          
 
           tiempoPartidaAB[j]=(horasPartidaAB*60)+minutosPartidaAB;
           tiempoLlegadaAB[j]=(horasLlegadaAB*60)+minutosLlegadaAB;
       }
       for(j=0;j!=viajesBA;j++)
       {
           fgets(tmp_cadena, 100, infile);      
           tmp_cadena2=tmp_cadena;
 
 
           tmp_cadena3=strtok(tmp_cadena2, α:α);
           horasPartidaBA=atoi(tmp_cadena3);
 
           tmp_cadena3=strtok(NULL, α α);
           minutosPartidaBA=atoi(tmp_cadena3);
 
           tmp_cadena3=strtok(NULL, α:α);
           horasLlegadaBA=atoi(tmp_cadena3);          
 
           tmp_cadena3=strtok(NULL, α α);
           minutosLlegadaBA=atoi(tmp_cadena3);          
           
           tiempoPartidaBA[j]=(horasPartidaBA*60)+minutosPartidaBA;
           tiempoLlegadaBA[j]=(horasLlegadaBA*60)+minutosLlegadaBA;
       }
           
     
       
     for (j=1; j<viajesAB; j++)
          for(k=0 ; k<viajesAB - 1; k++)
               if (tiempoPartidaAB[k] > tiempoPartidaAB[k+1])
               {
                    temp = tiempoPartidaAB[k];
                    tiempoPartidaAB[k] = tiempoPartidaAB[k+1];
                    tiempoPartidaAB[k+1] = temp;
               }
 
     for (j=1; j<viajesAB; j++)
          for (k=0 ; k<viajesAB - 1; k++)
               if (tiempoLlegadaAB[k] > tiempoLlegadaAB[k+1])
               {
                    temp = tiempoLlegadaAB[k];
                    tiempoLlegadaAB[k] = tiempoLlegadaAB[k+1];
                    tiempoLlegadaAB[k+1] = temp;
               }
               
     for (j=1; j<viajesBA; j++)
          for (k=0 ; k<viajesBA - 1; k++)
               if (tiempoPartidaBA[k] >tiempoPartidaBA[k+1])
               {
                    temp = tiempoPartidaBA[k];
                    tiempoPartidaBA[k] = tiempoPartidaBA[k+1];
                    tiempoPartidaBA[k+1] = temp;
               }
 
     for (j=1; j<viajesBA; j++)
          for (k=0 ; k<viajesBA - 1; k++)
               if (tiempoLlegadaBA[k] > tiempoLlegadaBA[k+1])
               {
                    temp = tiempoLlegadaBA[k];
                    tiempoLlegadaBA[k] = tiempoLlegadaBA[k+1];
                    tiempoLlegadaBA[k+1] = temp;
               }
               
     for(k=0;k!=viajesAB;k++){
         PAB[k]=0;
         LAB[k]=0;}
     for(k=0;k!=viajesBA;k++){
         PBA[k]=0;
         LBA[k]=0;}
 
     cantidadTrenesA[i]=viajesAB;
     cantidadTrenesB[i]=viajesBA;
   
       for(j=viajesAB-1;j!=-1;j--)
       for(k=0;k!=viajesBA;k++)
         {
             if((tiempoLlegadaAB[j]+tiempoRecarga)<=tiempoPartidaBA[k] && PBA[k]==0 && LAB[j]==0)
             {
                 LAB[j]=1;
                 PBA[k]=1;
                 cantidadTrenesB[i]--;
             }
         }
               
       for(j=viajesBA-1;j!=-1;j--)
       for(k=0;k!=viajesAB;k++)
         {
             if((tiempoLlegadaBA[j]+tiempoRecarga)<=tiempoPartidaAB[k] && PAB[k]==0 && LBA[j]==0)
             {
                 LBA[j]=1;
                 PAB[k]=1;
                 cantidadTrenesA[i]--;
             }
         }
                             
     }
 //    viajesAB=atoi(tmp_cadena2);{
 //    printf(tmp_cadena2);
  /*   tmp_cadena2 = strtok (NULL, α α);
     viajesBA=atoi(tmp_cadena2);
     printf(tmp_cadena);*/
     
  /* {
 
      fgets(tmp_cadena, 100, infile);
      cantidadMotores = atoi(tmp_cadena);
 
      for(j=0;j!=cantidadMotores;j++)
     {
       fgets(motores[j],100,infile);
     }
     fgets(tmp_cadena, 100, infile);
     cantidadBusquedas = atoi(tmp_cadena);
 
    
     for(j=0;j!=cantidadBusquedas;j++) 
     {
       fgets(busquedas[j], 100, infile);
 
     }
     
     for(l=0;l!=cantidadMotores;l++)
     {
         esPosibleBuscador[l]=1;
     }
     buscadoresPosibles=cantidadMotores;
     cantidadCambios[i]=0;
     
     for(j=0;j!=cantidadBusquedas;j++)
     {
     
       for(k=0;k!=cantidadMotores;k++)
       {
           if(strcmp(motores[k],busquedas[j])==0 && esPosibleBuscador[k]==1)
           {
               esPosibleBuscador[k] = 0;
               buscadoresPosibles--;
           
               if(buscadoresPosibles==0)
               {
                   cantidadCambios[i]++;
                   for(l=0;l!=cantidadMotores;l++)
                   {
                       esPosibleBuscador[l]=1;
                   }
                   buscadoresPosibles=cantidadMotores-1;
               esPosibleBuscador[k] = 0;
               }
           }
       }
     }  
   }
 */
 
   if((outfile = fopen(αc:\salida.inα, αwα)) == NULL) {
     printf(αError Creating File.nα);
     exit(1);
   }
   
   for(k=0;k!=cantidadCasos;k++)
   {
       fputs(αCase #α,outfile);
       fputs(itoa(k+1,tmp_cadena,10),outfile);
       fputs(α: α,outfile);
       fputs(itoa(cantidadTrenesA[k],tmp_cadena,10),outfile);     
       fputs(α α,outfile);     
       fputs(itoa(cantidadTrenesB[k],tmp_cadena,10),outfile);     
       fputs(αnα,outfile);
 //      printf(itoa(cantidadCambios[k],tmp_cadena,10));
   }
 
   
      
   system(αPAUSEα);	
   fclose(infile);  /* Close the file */
   return 0;
 }"
13234,2008,32013,its.viky,24480,1,google.c,gcj/2008/32013/its.viky/24480/1/extracted/google.c,"#include<stdio.h>
 
 int n,s,q;
 char engine[100][100];
 char querry[1000][100];
 
 main(int argc, char *argv[])
 {
  int swt,use,count;
  int tcase,engno,qur;
  char ch;
  FILE *fr;
  char line[100];
  char cureng[100];
 
  fr = fopen(argv[1],αrα);
  readline(fr,line);
  n = strtoi(line);
  //printf(α%snα,line);
  //printf(αtest cases = %dnα,n);
  for(tcase=0;tcase<n;tcase++)
  {
   swt = 0;
   readline(fr,line);
   s = strtoi(line);
   //printf(αengines = %dnα,s);
   for(engno=0;engno<s;engno++)
   {
    readline(fr,line);
    strcpy(engine[engno],line);
   }//end copying eng names
   //printf(αengine names copied...nα);
   readline(fr,line);
   q = strtoi(line);
   //printf(αquerries = %dnα,q);
   for(qur = 0;qur<q; qur++)
   {
    readline(fr,line);
     strcpy(querry[qur],line);
   }//end copying querries
   //printf(αquerries copied...nα);
 /*  for(engno=0;engno<s;engno++)
   {
    for(qur=0,count=0;qur<q;qur++)
    {
     if(!strcmp(engine[engno],querry[qur]))  
      break;
     count++;
    }
     counteng[engno]=count;
   }//fill distances of each engine
   for(engno=0,use=0; engno<s; engno++)
   {
    //printf(α%d α,counteng[engno]);
    use = (counteng[engno]<counteng[use])?use:engno;
   }//find engine to be used
 */
   use = fillcount(0);
   //printf(αengine used = %snα,engine[use]);
   strcpy(cureng,engine[use]);
   for(swt=0,qur=0 ;qur<q;qur++)
   {
    while(!strcmp(cureng,querry[qur]))
    {
     swt++;
  //   printf(αswitching...nα);
     //use = (use<s)?use+1:0;
     use = fillcount(qur);
     strcpy(cureng,engine[use]);
    }//switch engine 
   }//end finding total switches
    
  printf(αCase #%d: %dnα,tcase+1,swt);
  }//end test cases 
   //printf(α%snα,line);
 }//end main
 
 int readline(FILE *f, char *l)
 {
  int i=0;
  int c;
  while((c=fgetc(f))!='n')
   if(c==-1)
    return 0;
   else
   l[i++]=c;
  l[i]='0';
 return i; 
 }
 
 int strtoi(char *l)
 {
  int num =0 ;
  char ch; 
  while(ch=*l++)
   if(isprint(ch))
    num = (num*10)+(ch - '0');
 return num;
 }
 
 int fillcount(int pos)
 {
  int use,engno,qur,count;
  int counteng[100]={0};
  for(engno=0;engno<s;engno++)
  {
   for(qur=pos,count=0;qur<q;qur++)
   {
    if(!strcmp(engine[engno],querry[qur]))  
     break;
    count++;
   }
    counteng[engno]=count;
  }//fill distances of each engine
  for(engno=0,use=0; engno<s; engno++)
  {
   //printf(α%d α,counteng[engno]);
   use = (counteng[engno]<counteng[use])?use:engno;
  }//find engine to be used
  return use;
 }"
13488,2008,32013,Isha,24480,1,a.c,gcj/2008/32013/Isha/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 	int main(){
 	int nr, te;
 
 	char ss[100][101], qs[1000][101];
 	int s, q, sn, qn, sc[100] = {0, };
 	char st[10], qt[10], tet[10];
 	int tt, swt;
 
 
 	//scanf(α%dα, &te);
 	gets(tet);
 	te = atoi(tet);
 
 	for ( nr = 0; nr < te; nr++ )
 	{
 		printf(αCase #%d: α, nr+1);
 
 		//scanf(α%dα, &sn);
 		gets(st);
 		sn = atoi(st);
 		for ( s = 0 ; s < sn ; s++ ) 
 		{
 			gets(ss[s]);		
 		}
 
 
 		//scanf(α%dα, &qn);
 		gets(qt);
 		qn = atoi(qt);
 		for ( q = 0 ; q < qn ; q++ )
 		{
 			gets(qs[q]);
 		}
 
 		tt = 0;
 		swt = 0;
 		memset(sc, 0, sizeof(sc));
 
 		for ( q = qn - 1 ; q >= 0 ; q-- )
 		{
 			for ( s = 0 ; s < sn ; s++ )
 			{
 				if ( strcmp(qs[q], ss[s]) == 0 ) {
 					if ( sc[s] == 0 ) {
 						sc[s] = 1;
 						tt++;
 						if ( tt == sn ) {
 							swt++;
 							memset(sc, 0, sizeof(sc));
 							sc[s] = 1;
 							tt = 1;
 						}
 					}
 					break;
 				}
 			}
 		}
 		
 		printf(α%dnα, swt);
 
 	}
 	return 0;
 }"
13491,2008,32013,Isha,24481,1,a.c,gcj/2008/32013/Isha/24481/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 static void scan_time(int * t)
 {
 	char instr[10], str[10];
 
 	scanf(α%sα, instr);
 	memset(str, 0, sizeof(str));
 	strncpy(str, instr, 2);
 	*t = atoi(str);
 	strncpy(str, instr+3, 2);
 	*t = (*t) * 60 + atoi(str);
 }
 
 int compare( const void *a, const void *b)
 {
 	return (*(int*)a) - (*(int*)b);
 }
 
 int main(){
 	int nr, te;
 
 	int ta;
 	int na, nb;
 
 	int at_dep[100], at_arr[100], bt_dep[100], bt_arr[100];
 	int aswa, aswb;
 
 	int i;
 
 	int ai = 0;
 	int bi = 0;
 
 	scanf(α%dα, &te);
 
 	for ( nr = 0; nr < te; nr++ )
 	{
 		printf(αCase #%d: α, nr+1);
 
 		aswa = 0;
 		aswb = 0;
 
 		scanf(α%dα, &ta);
 		scanf(α%d%dα, &na, &nb);		
 
 		for ( i = 0; i < na; i++ )
 		{
 			scan_time(&at_dep[i]);
 			scan_time(&at_arr[i]);
 		}
 		for ( i = 0; i < nb; i++ )
 		{
 			scan_time(&bt_dep[i]);
 			scan_time(&bt_arr[i]);
 		}
 		
 		qsort(at_dep, na, sizeof(int), compare);
 		qsort(at_arr, na, sizeof(int), compare);
 		qsort(bt_dep, nb, sizeof(int), compare);
 		qsort(bt_arr, nb, sizeof(int), compare);
 
 		ai = 0;
 		bi = 0;
 			
 		for ( i = 0; i < na; i++ )
 		{
 			if (bi >= nb) {
 				aswa += na - i;
 				break;
 			}
 
 			if (at_dep[i] < bt_arr[bi] + ta)
 				aswa++;
 			else 
 				bi++;
 		}
 
 		for ( i = 0; i < nb; i++ )
 		{
 			if (ai >= na) {
 				aswb += nb - i;
 				break;
 			}
 			
 			if (bt_dep[i] < at_arr[ai] + ta)
 				aswb++;
 			else 
 				ai++;
 		}			
 		
 		printf(α%d %dnα, aswa, aswb);
 
 	}
 	return 0;
 }"
13510,2008,32013,n00bee,24480,1,qt1.c,gcj/2008/32013/n00bee/24480/1/extracted/qt1.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX_NAME_SIZE		100
 
 #define MAX_SEARCH_ENGINES	100
 
 typedef struct
 {
 	char name[MAX_NAME_SIZE + 1];
 	int occurrence_count;
 } search_engine_statistics;
 
 int qs_comp(const void *c1, const void *c2)
 {
 	return strcmp(((search_engine_statistics *)c1)->name, ((search_engine_statistics *)c2)->name);
 }
 
 int read_search_engine_names(FILE *fp, search_engine_statistics *ses)
 {
 	int i, count;
 
 	fscanf(fp, α%dnα, &count);
 
 	for( i = 0; i < count; i++ )
 	{
 		fgets(ses[i].name, MAX_NAME_SIZE, fp);
 		ses[i].occurrence_count = 0;
 	}
 
 	qsort(ses, count, sizeof(search_engine_statistics), qs_comp);
 
 	return count;
 }
 
 int bs_comp(const void *c1, const void *c2)
 {
 	return strcmp(c1, ((search_engine_statistics *)c2)->name);
 }
 
 int count_switches(FILE *fp, search_engine_statistics *ses, int count)
 {
 	int i, j, switches;
 	int queries, max_available_search_engines;
 	search_engine_statistics *sr;
 	char query_string[MAX_NAME_SIZE + 1];
 
 	switches = 0;
 	max_available_search_engines = count;
 
 	fscanf(fp, α%dnα, &queries);
 
 	for( i = 0; i < queries; i++ )
 	{
 		fgets(query_string, MAX_NAME_SIZE, fp);
 
 		sr = bsearch(query_string, ses, count, sizeof(search_engine_statistics), bs_comp);
 
 		if( sr == NULL )
 		{
 			printf(αERROR: NO MATCHING SEARCH ENGINEnα);
 
 			exit(-1);
 		}
 
 		if( sr->occurrence_count == 0 )
 		{
 			sr->occurrence_count++;
 			max_available_search_engines--;
 
 			if( max_available_search_engines == 0 )
 			{
 				switches++;
 
 				for( j = 0; j < count; j++ )
 					ses[j].occurrence_count = 0;
 
 				sr->occurrence_count++;
 				max_available_search_engines = count - 1;
 			}
 		}
 	}
 
 	return switches;
 }
 
 int main(int argc, char *argv[])
 {
 	FILE *fp;
 	int i, max_trial;
 	int count, switches;
 	search_engine_statistics ses[MAX_SEARCH_ENGINES];
 
 	if( argc < 2 )
 	{
 		printf(α%s <filename>nα, argv[0]);
 
 		return -1;
 	}
 
 	fp = fopen(argv[1], αrα);
 
 	if( fp == NULL )
 	{
 		printf(αUnable to open file '%s'nα, argv[1]);
 
 		return -2;
 	}
 
 	fscanf(fp, α%dnα, &max_trial);
 
 	for( i = 0; i < max_trial; i++ )
 	{
 		count = read_search_engine_names(fp, ses);
 
 		switches = count_switches(fp, ses, count);
 
 		printf(αCase #%d: %dnα, i + 1, switches);
 	}
 
 	fclose(fp);
 
 	return 0;
 }"
13512,2008,32013,n00bee,24481,1,qt2.c,gcj/2008/32013/n00bee/24481/1/extracted/qt2.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX_TEMP_SZ	128
 
 #define MAX_T		60
 
 #define MAX_NA		100
 #define MAX_NB		100
 
 typedef enum
 {
 	STATION_A = 0,
 	STATION_B
 } station_type;
 
 typedef enum
 {
 	DEPARTURE = 0,
 	ARRIVAL
 } train_state;
 
 typedef struct
 {
 	int minute;
 	train_state state;
 } trains_at_station;
 
 int get_number(char ch)
 {
 	return ch - '0';
 }
 
 int convert_time_to_minute(char *str)
 {
 	int hour, min;
 	int value;
 
 	if( str[2] != ':' )
 		return -1;
 
 	hour = get_number(str[0]) * 10 + get_number(str[1]);
 	min = get_number(str[3]) * 10 + get_number(str[4]);
 
 	value = hour * 60 + min;
 
 	return value;
 }
 
 void translate_timeline(char *str, trains_at_station *ta, trains_at_station *tb, station_type st, int turn_around_time)
 {
 	int count, delta_t;
 	trains_at_station *t[2];
 
 	switch(st)
 	{
 		case STATION_A:
 			t[0] = ta;
 			t[1] = tb;
 			break;
 
 		case STATION_B:
 			t[0] = tb;
 			t[1] = ta;
 			break;
 	}
 
 	count = 0;
 	delta_t = 0;
 
 	while( (*str) && (count < 2) )
 	{
 		if( (*str >= '0') && (*str <= '9') )
 		{
 			t[count]->minute = convert_time_to_minute(str) + delta_t;
 			t[count]->state = count;
 
 			if( t[count]->minute < 0 )
 			{
 				printf(αERROR: INVALID INPUT FORMATnα);
 
 				exit(-1);
 			}
 
 			str += 5;
 			delta_t = turn_around_time;
 			count++;
 		}
 		else
 			str++;
 	}
 }
 
 int qs_comp(const void *c1, const void *c2)
 {
 	return (((trains_at_station *)c1)->minute - ((trains_at_station *)c2)->minute) * 2 + 
 		   (((trains_at_station *)c2)->state - ((trains_at_station *)c1)->state); // calcualte arrival first
 }
 
 void sort_timelines(trains_at_station *ta, trains_at_station *tb, int num)
 {
 	qsort(ta, num, sizeof(trains_at_station), qs_comp);
 	qsort(tb, num, sizeof(trains_at_station), qs_comp);
 }
 
 int count_number_of_trains_required(trains_at_station *t, int count)
 {
 	int i;
 	int starting_trains, remaining_trains;
 
 	remaining_trains = 0;
 	starting_trains = 0;
 
 	for( i = 0; i < count; i++ )
 	{
 		switch( t[i].state )
 		{
 			case DEPARTURE:
 				if( remaining_trains > 0 )
 					remaining_trains--;
 				else
 					starting_trains++;
 				break;
 
 			case ARRIVAL:
 				remaining_trains++;
 				break;
 		}
 	}
 
 	return starting_trains;
 }
 
 void read_timetable(FILE *fp, int *trains)
 {
 	int i;
 	int turn_around_time;
 	int num_a, num_b;
 	char temp[MAX_TEMP_SZ];
 	trains_at_station ta[MAX_NA + MAX_NB], tb[MAX_NA + MAX_NB];
 
 	fscanf(fp, α%dnα, &turn_around_time);
 	fscanf(fp, α%d %dnα, &num_a, &num_b);
 
 	memset(ta, 0, sizeof(ta));
 	memset(tb, 0, sizeof(tb));
 
 	for( i = 0; i < num_a + num_b; i++ )
 	{
 		fgets(temp, MAX_TEMP_SZ, fp);
 
 		translate_timeline(temp, &ta[i], &tb[i], (i < num_a) ? STATION_A : STATION_B, turn_around_time);
 	}
 
 	sort_timelines(ta, tb, num_a + num_b);
 
 	trains[0] = count_number_of_trains_required(ta, num_a + num_b);
 	trains[1] = count_number_of_trains_required(tb, num_a + num_b);
 }
 
 int main(int argc, char *argv[])
 {
 	FILE *fp;
 	int i, max_trial;
 	int trains[2];
 
 	if( argc < 2 )
 	{
 		printf(α%s <filename>nα, argv[0]);
 
 		return -1;
 	}
 
 	fp = fopen(argv[1], αrα);
 
 	if( fp == NULL )
 	{
 		printf(αUnable to open file '%s'nα, argv[1]);
 
 		return -2;
 	}
 
 	fscanf(fp, α%dnα, &max_trial);
 
 	for( i = 0; i < max_trial; i++ )
 	{
 		read_timetable(fp, trains);
 
 		printf(αCase #%d: %d %dnα, i + 1, trains[0], trains[1]);
 	}
 
 	fclose(fp);
 
 	return 0;
 }"
13578,2008,32013,Vikram1983,24480,1,universe_large.c,gcj/2008/32013/Vikram1983/24480/1/extracted/universe_large.c,"#include<stdio.h>
 #include<string.h>
 #include<malloc.h>
 
 int track_path(char server_name[100], char queries[1000][100], int no_queries, int start)
 {
    int ctr2 = 0;
    
    for(ctr2=start; ctr2<no_queries; ctr2++)
    {
       if(strcasecmp(server_name, queries[ctr2]) == 0)
       {
          break;
       }
    }
    return ctr2;
 }
 
 int best_path(char servers[100][100], char queries[1000][100], int no_servers, int no_queries, int start)
 {
    int best_path = 0;
    int ctr1 = 0;
    int path = 0;
    for(ctr1=0; ctr1<no_servers; ctr1++)
    {
       if(best_path < (path = track_path(servers[ctr1], queries, no_queries, start)))
       {
          best_path = path;
       }
    }
    return best_path;
 }
 
 int main(void)
 {
    char servers[100][100];
    char queries[1000][100];
    
    FILE *fp_in, *fp_out;
    int ctr1 = 0;
    int ctr2 = 0;
    int no_inputs = 0;
    int case_no = 0;
    int no_servers = 0;
    int no_queries = 0;
    int path = 0;
    int switches = 0;
    
    fp_in = fopen(αA-large.inα, αrα);
    if(fp_in == NULL)
       printf(αERRORα);
    
    fp_out = fopen(αA-large.outα, αwα);
    
    fscanf(fp_in, α%dnα, &no_inputs);
    
    while(1)
    {
       // Read till the end of file
       if(feof(fp_in))
          break;
       else
       {
          // Reading the no. of servers
          fscanf(fp_in, α%dnα, &no_servers);
          if(feof(fp_in))
             break;
          else
          {
             case_no++;
             // Storing the servers in the array
             for(ctr1=0; ctr1<no_servers; ctr1++)
                fgets(servers[ctr1], 100, fp_in);
 
             // Reading the no. of Queries
             fscanf(fp_in, α%dnα, &no_queries);
             
             // Storing the queries in the array
             for(ctr2=0; ctr2<no_queries; ctr2++)
                fgets(queries[ctr2], 100, fp_in);
             
             while(1)
             {
                path = best_path(servers, queries, no_servers, no_queries, path);
                
                if(path == no_queries)
                {
                   fprintf(fp_out, αCase #%d: %dnα, case_no, switches);
                   path = 0;
                   switches = 0;
                   break;
                }
                else
                {
                   switches++;
                }
             }
         }
       }
    }
    fclose(fp_out);
    fclose(fp_in);
    return 0;
 }"
13622,2008,32013,SillySen,24480,1,first.c,gcj/2008/32013/SillySen/24480/1/extracted/first.c,"#include <stdio.h>
 
 int 
 main ()
 {
   typedef struct enginfo
   {
     char searchengine[100];
     int used;
   }engineinfo;
 
   int noftestcases;
   int nofsearchengines;
   int nofsearchitems;
   char queryitems[100];
   int allsearchenginesused=1;
   int i=0, j=0, k=0;
   int sw[20];
   engineinfo testeinfo[100];
   scanf (α%dα, &noftestcases);
 
   for (i=0;i<noftestcases;i++)
     {
       sw[i] = 0;
       scanf (α%dα, &nofsearchengines);
       getchar ();
       for (j=0;j < nofsearchengines; j++)
 	{
 	  gets (testeinfo[j].searchengine);
 	  testeinfo[j].used=0;
 	}
       
       scanf (α%dα, &nofsearchitems);
       getchar ();
       for (j=0;j<nofsearchitems;j++)
 	{
 	  gets (queryitems);
 	  for (k=0;k<nofsearchengines; k++)
 	    {
 	      if (strcmp (testeinfo[k].searchengine, queryitems) == 0)
 		{
 		  testeinfo[k].used = 1;
 		}
 	    }
 
 	  allsearchenginesused = 1;
 	  for (k=0;k<nofsearchengines;k++)
 	    {
 	      if (testeinfo[k].used != 1)
 		{
 		  allsearchenginesused = 0;
 		  break;
 		}
 	    }
 	  
 	  if (allsearchenginesused == 1)
 	    {
 	      sw[i] = sw[i] + 1;
 	    
 	      for (k=0;k<nofsearchengines; k++)
 		{
 		  if (strcmp (testeinfo[k].searchengine, queryitems) != 0)
 		    {
 		      testeinfo[k].used = 0;
 		    }
 		}
 	    }
 	}
 
       for (j=0;j < nofsearchengines; j++)
 	{
 	  testeinfo[j].searchengine[0] = '0';
 	  testeinfo[j].used=0;
 	}
     }
 
   for (i=0;i<noftestcases;i++)
     {
       printf (αCase #%d: %dnα,i+1,sw[i]);
     }
   return 0;
 }"
13821,2008,32013,bageerath,24480,1,searchEngine.c,gcj/2008/32013/bageerath/24480/1/extracted/searchEngine.c,"#include <stdio.h>
 
 int 
 findMinSwitches( char sName[][103], int qMatches[], int s, int q )
 {
     int qIdx, sIdx, sMatch, othMinSw = 0;
     int switchCnt[100] = {0};
     
     for ( qIdx = q - 1; qIdx >= 0; qIdx--) {
         sMatch = qMatches[qIdx];
         othMinSw = q<<2;
         for ( sIdx = 0; sIdx < s; sIdx++ ) {
             if ( sIdx != sMatch && 
                  switchCnt[sIdx] < othMinSw ) {
                 othMinSw = switchCnt[sIdx];
             }
         }
         switchCnt[sMatch] = othMinSw + 1;
     }
     return othMinSw;
 }
 
 main()
 {
     char sName[100][103];
     char qStr[103];
     int  qMatches[1000];
     int n, s, q, c, sIdx, qIdx;
     int result;
 
     scanf(α%dα, &n);
     for ( c = 0; c < n; c++ ) {
         scanf(α%dα, &s);
         gets(qStr); // Skip new line
         for ( sIdx = 0; sIdx < s; sIdx++ ) {
             gets(sName[sIdx]);
         }
         scanf(α%dα, &q);
         gets(qStr); // Skip new line
         for ( qIdx = 0; qIdx < q; qIdx++ ) {
             gets(qStr);
             for ( sIdx = 0; sIdx < s; sIdx++ ) {
                 if ( strcmp(sName[sIdx], qStr) == 0 ) {
                     qMatches[qIdx] = sIdx;
                     break;
                 }
             }
         }
         result = findMinSwitches(sName, qMatches, s, q);
         printf(αCase #%d: %dnα, c+1, result);
     }
 }"
13833,2008,32013,Nelson,24480,1,A.c,gcj/2008/32013/Nelson/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 
 char sE[105][110];
 char query[1005][110];
 int flag[105][1005];
 int count;
 
 int main(){
 	int t,tk;
 	int s,q;
 	char temp[110];
 	int i, j, fine, last;
 	
 	scanf(α%dα,&tk);
 	for(t=1;t<=tk;t++){
 		scanf(α%dα,&s);
 		fgets(temp, 10, stdin);
 		for(i=0;i<s;i++){
 			fgets(sE[i], 105, stdin);
 			if(sE[i][strlen(sE[i])-1]=='n')sE[i][strlen(sE[i])-1]='0';
 		}
 		scanf(α%dα,&q);
 		fgets(temp, 10, stdin);
 		for(i=0;i<q;i++){
 			fgets(query[i], 105, stdin);
 			if(query[i][strlen(query[i])-1]=='n')query[i][strlen(query[i])-1]='0';
 			
 		}
 		
 		count = 0;
 		j=0;
 		for(i=0;i<s;i++){
 			if(strcmp(sE[i], query[j])==0) flag[i][j] = 1;
 			else flag[i][j] = 0;
 		}
 		for(j=1;j<q;j++){
 			fine = 0;
 			for(i=0;i<s;i++){
 				if(strcmp(sE[i], query[j])==0){ flag[i][j] = 1; last=i; }
 				else if(flag[i][j-1]==1) flag[i][j] = 1;
 				else { flag[i][j] = 0; fine = 1; }
 			}
 			if(fine==0){ 
 				count++; 
 				for(i=0;i<s;i++) flag[i][j] = 0;
 				flag[last][j] = 1;
 			}
 		}
 		
 		printf(αCase #%d: %dnα,t,count);
 	}
 
 	return 0;
 }"
13835,2008,32013,Nelson,24481,1,B.c,gcj/2008/32013/Nelson/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct {
 	int a,b;
 } Tschedule;
 
 int A[1500], B[1500];
 int nA, nB;
 
 Tschedule NA[105], NB[105];
 int sizeA, sizeB;
 int t,tk;
 int TR;
 int a,b,c,d;
 
 int comp(const void *a, const void *b){
 	Tschedule *m, *n;
 	m = (Tschedule*)a;
 	n = (Tschedule*)b;
 	
 	if(m->a < n->a)return -1;
 	else if(m->a > n->a)return 1;
 	else if(m->b <= n->b)return -1;
 	else return 1;
 }
 
 void simulate(void){
 	int i,j;
 	int x=0,y=0;
 	
 	nA = 0; nB=0;
 	
 	for(i= ((NA[0].a<NB[0].a)?(NA[0].a):(NB[0].a)) ; i<=1440; i++){
 		while(NA[x].a==i && x<sizeA){
 			if(A[i]==0){ A[i]=1; nA++; }
 			A[i]--; B[NA[x].b + TR]++;
 			x++;
 		}
 		
 		while(NB[y].a==i && y<sizeB){
 			if(B[i]==0){ B[i]=1; nB++; }
 			B[i]--; A[NB[y].b + TR]++;
 			y++;
 		}
 		
 		A[i+1] += A[i];
 		B[i+1] += B[i];
 		
 		if(x==sizeA && y==sizeB)break;
 	}
 }
 
 int main(){
 	int	i;
 	
 	scanf(α%dα,&tk);
 	for(t=1;t<=tk;t++){
 		scanf(α%dα,&TR);
 		scanf(α%d %dα,&sizeA, &sizeB);
 		for(i=0;i<sizeA;i++){
 			scanf(α%d:%d %d:%dα,&a,&b,&c,&d);
 			NA[i].a = (a*60) + b;
 			NA[i].b = (c*60) + d;
 		}
 		for(i=0;i<sizeB;i++){
 			scanf(α%d:%d %d:%dα,&a,&b,&c,&d);
 			NB[i].a = (a*60) + b;
 			NB[i].b = (c*60) + d;
 		}
 		for(i=0;i<=1440;i++){ A[i]=0; B[i]=0; }
 		qsort(NA, sizeA, sizeof(Tschedule), comp);
 		qsort(NB, sizeB, sizeof(Tschedule), comp);
 		simulate();
 		
 		printf(αCase #%d: %d %dnα,t, nA, nB);
 	}
 
 	return 0;
 }"
13845,2008,32013,lv50,24481,1,train.c,gcj/2008/32013/lv50/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct traintime
 {
 	int starttime;
 	int stoptime;
 	int sid;
 }trfroma[100],trfromb[100];
 
 int compare( const void *a , const void *b ) //order by stoptime
 { 
 	struct traintime *c = (struct traintime *)a; 
 	struct traintime *d = (struct traintime *)b; 
 	if(c->stoptime != d->stoptime ) return c->stoptime  - d->stoptime ; 
 	else return c->starttime  - d->starttime ; 
 } 
 
 
 int main()
 {
 	int cases;
 	int	na,nb;
 	int t;
 	int sa;
 	int i,k,j;
 	int flag;
 	int temp1,temp2,temp3,temp4,temptime,tempsub,tempid,tempflag;
 	int sub,counta,countb;
 
 	freopen(αB-small-attempt3.inα,αrα,stdin);
 	freopen(αout.txtα,αwα,stdout);
 	scanf(α%dα,&cases);
 
 	for(k=0;k<cases;k++)
 	{
 		scanf(α%dα,&t);
 		scanf(α%d %dα,&na,&nb);
 		for(i=0;i<na;i++)
 		{
 			scanf(α%d:%d %d:%dα,&temp1,&temp2,&temp3,&temp4 );
 			trfroma[i].starttime=temp1*60+temp2;
 			trfroma[i].stoptime =temp3*60+temp4;
 			trfroma[i].sid =1;
 		}
 		qsort(trfroma,na,sizeof(trfroma[0]),compare);//order trfroma by stoptime
 		for(i=0;i<nb;i++)
 		{
 			scanf(α%d:%d %d:%dα,&temp1,&temp2,&temp3 ,&temp4);
 			trfromb[i].starttime=temp1*60+temp2;
 			trfromb[i].stoptime =temp3*60+temp4;
 			trfromb[i].sid =2;
 		}
 		qsort(trfromb,nb,sizeof(trfromb[0]),compare);
 
 		flag=1;
 		while(flag)
 		{
 			flag=0;
 			for(i=0;i<na;i++) // to b
 			{
 				if(trfroma[i].sid==0)
 					continue;
 				tempflag=0;
 				temptime=trfroma[i].stoptime +t;
 //				printf(αtemptime %dnα,temptime);
 				sub=2000;
 				for(j=0;j<nb;j++)
 				{
 					if(trfromb[j].sid!=2)
 						continue;
 //					printf(αtrfromb[%d]:%dnα,j,trfromb[j].starttime ); 
 					if(temptime<=trfromb[j].starttime )
 					{
 						tempsub=trfromb[j].starttime-temptime ;
 						if(sub>tempsub)
 						{
 							tempid=j;
 							flag=1;
 							sa=2;
 							tempflag=1;
 							sub=tempsub;
 						}
 //						printf(α%d nα,j);
 					}
 					
 				}
 				for(j=0;j<na;j++)
 				{
 					if(trfroma[j].sid!=2)
 						continue;
 					if(temptime<=trfroma[j].starttime )
 					{
 						tempsub=trfroma[j].starttime -temptime;
 						if(sub>tempsub)
 						{
 							tempid=j;
 							sa=1;
 							flag=1;
 							tempflag=1;
 							sub=tempsub;
 						}
 					}
 				}
 				
 				if(tempflag==1)
 				{
 					switch(sa)
 					{
 					//delete trfroma[i] from trfroma[] and trfroma2[]
 					case 1:
 						trfroma[tempid].starttime =trfroma[i].starttime ;
 						trfroma[tempid].sid =trfroma[i].sid ;
 						trfroma[i].sid=0;
 						break;
 					case 2:
 						trfromb[tempid].starttime =trfroma[i].starttime ;
 						trfromb[tempid].sid=trfroma[i].sid;
 						trfroma[i].sid=0;
 						break;
 					}
 				}
 //				for(j=0;j<na;j++)
 //					printf(αtrfroma %d %d %dnα,trfroma[j].starttime ,trfroma[j].stoptime ,trfroma[j].sid );
 //				printf(αnα);
 //				for(j=0;j<nb;j++)
 //					printf(αtrfromb %d %d %dnα,trfromb[j].starttime,trfromb[j].stoptime ,trfromb[j].sid );
 //				printf(αnα);
 			}
 			for(i=0;i<nb;i++)
 			{
 				if(trfromb[i].sid==0)
 					continue;
 				tempflag=0;
 				temptime=trfromb[i].stoptime +t;
 				sub=2000;
 				for(j=0;j<na;j++)
 				{
 					if(trfroma[j].sid!=1)
 						continue;
 					if(temptime<=trfroma[j].starttime )
 					{
 						tempsub=trfroma[j].starttime-temptime ;
 						if(sub>tempsub)
 						{
 							tempid=j;
 							flag=1;
 							sa=1;
 							tempflag=1;
 							sub=tempsub;
 						}
 					}					
 				}
 				for(j=0;j<nb;j++)
 				{
 					if(trfromb[j].sid!=1)
 						continue;
 					if(temptime<=trfromb[j].starttime )
 					{
 						tempsub=trfromb[j].starttime -temptime;
 						if(sub>tempsub)
 						{
 							tempid=j;
 							flag=1;
 							sa=2;
 							tempflag=1;
 							sub=tempsub;
 						}
 					}
 				}
 				if(tempflag==1)
 				{
 					//delete trfroma[i] from trfroma[] and trfroma2[]
 					switch(sa)
 					{
 					case 1:
 						trfroma[tempid].starttime =trfromb[i].starttime ;
 						trfroma[tempid].sid=trfromb[i].sid;
 						trfromb[i].sid=0;
 						break;
 					case 2:
 						trfromb[tempid].starttime=trfromb[i].starttime ;
 						trfromb[tempid].sid =trfromb[i].sid ;
 						trfromb[i].sid =0;
 						break;
 					}
 				}
 			}
 		}
 		counta=0;
 		countb=0;
 		for(i=0;i<na;i++)
 		{
 			if(trfroma[i].sid==1)
 				counta++;
 			else if(trfroma[i].sid==2)
 				countb++;
 		}
 		for(i=0;i<nb;i++)
 		{
 			if(trfromb[i].sid==1)
 				counta++;
 			else if(trfromb[i].sid==2)
 				countb++;
 		}
 		printf(αCase #%d: %d %dnα,k+1,counta,countb);
 		
 	}
 	
 	return 0;
 }"
13856,2008,32013,veenviz,24480,1,a.c,gcj/2008/32013/veenviz/24480/1/extracted/a.c,"#include<stdio.h>
 #include<stdlib.h>
 struct str_engines
 {
 char name[100];
 int index;
 };
 
 //search engine data structure: each engine in S engines
 struct str_engines se[101];
 
 //N in problem
 char s_not[4];
 //S in problem
 char s_nose[4];
 //Q in problem
 char s_nostrs[20];
 //  N  ,   S   ,   Q
 int not,nose,nostrs;
 
 char strname[100];
 char temp[100];
 
 int arr[1001];
 
 int seekpos=0,flag = 0;
 
 void gotillnextline(FILE *fp)
 {
 char c;
 do
 {
 c = fgetc(fp);
 }while(c=='n'||c=='0'||c=='r');
 fseek(fp,-1,SEEK_CUR);
 }
 int getindexofengine(char *s)
 {
  int i,n,j;
   for(i=1;i<=nose;i++)
   {
     n = strcmp(s,se[i].name);
 //    printf(αstrlen1=%d(%s)nα,strlen(s),s);
     if(!n)
   	break;
 
   }
 
   return i;
 }
 
 int getpos(int i)
 {
 int j;
  if(i>9)
  	j=2;
  else if(i<=9)
  	j =1;
  return j;
  	
 }
 void copy(char *res,char *src)
 {
   int len = 0,i;
   len = strlen(src);
 
   for(i=0;((i<=(len-1))&&(src[i]!='r')&&(src[i]!='n'));i++)
   {
     res[i] = src[i];
   }
      res[i] = '0';
 }
 int main()
 {
 
 FILE *fp,*fw;
 int i,j,count =0,k,len=0,m;
 int swneeded = 0,t;
 
 for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of test cases
 fp = fopen(αlarge.txtα,αrα);
 fw = fopen(αlarge_out.txtα,αwα);
 
 fgets(s_not,3,fp);
 gotillnextline(fp);
 not = atoi(s_not);
 //printf(αno of test cases= %d nα,not);
 
 for(k = 1;k<=not;k++)
 {
     for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of search engines
 fgets(s_nose,5,fp);
 nose = atoi(s_nose);
 //printf(αno of search engines = %d nα,nose);
 gotillnextline(fp);
 
 //to read all engine names 1 by 1
 //printf(αSearch engines are as below:nα);
 for(i=1;i<=nose;i++)
  {
    se[i].index = i;
    fgets(temp,100,fp);
    gotillnextline(fp);
 //  printf(αstring got %snα,temp);
    copy(se[i].name,temp);
    //printf(α%d: %snα,i,se[i].name);
  }
 
 
 //to read search strings names 1 by 1
 fgets(s_nostrs,5,fp);
 gotillnextline(fp);
 nostrs = atoi(s_nostrs);
 //printf(αno of search strings are %d nα,nostrs);
 
  
 //printf(αsearch strings are as below:nα);
  for(i=1;i<=nostrs;i++)
  {
  //reading string name
          fgets(temp,100,fp);
         gotillnextline(fp);
          copy(strname,temp);
         //printf(α%d: %s nα,i,strname);
          for(m=1;m<=100;m++)
          temp[m]='0';
 		 
          j = getindexofengine(strname);
 	  if(arr[j]==0)
 	  {
 	    count++;
 	    arr[j]=1;
 	//    printf(αcount is incremented:%dnα,count);
 	  }
 	  if(count ==  nose)
           {
             for(m=1;m<=1000;m++)
             arr[m]=0;
 	     arr[j]=1;
             swneeded++;
             count = 1;
 	     j =0;
            // printf(αSWITCHEDnα);
           }        
          
  }
 
  fprintf(fw,αCase #%d: %dnα,k,swneeded);
  
   swneeded = 0;
   count = 0;
 
 }
 
 fclose(fp);
 fclose(fw);
 	return 0;
 }"
13895,2008,32013,PotatoChip,24480,1,StU.c,gcj/2008/32013/PotatoChip/24480/1/extracted/StU.c,"/*****************************************************/
 /* Date : 2008.07.17                                 */
 /* Author : HHJeon                                   */
 /* Description : Google Code Jam, Qualification Round, */
 /*               Saving the Universe                 */
 /*****************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define RET_OK 1
 #define RET_ERROR -1
 
 /*###################################################*/
 #define MAX_SEARCH_NAME_LEN 100
 
 int ProcStU(FILE *fpInFile, FILE *fpOutFile);
 int ComputeSwitchCount(char **pSEName, int nSECount, char **pQSeries, int nQSCount, int *pMinSwitch);
 int FreeMemory(char **pSEName, int nSECount, char **pQSeries, int nQSCount);
 /*###################################################*/
 
 int main(int argc, char* argv[])
 {
 	FILE *fpInFile, *fpOutFile;
 	char *sOutFileName = NULL;
 	int nOutFileNameSize = 0;
 	
 	/*+--------------------------------------------------*/
 	if(argc != 2)
 	{
 		if(NULL != strrchr(argv[0], '\'))
 		{
 			printf(αUsage %s input_filenα, strrchr(argv[0], '\') + 1);
 		}
 		else
 		{
 			printf(αUsage %s input_filenα, argv[0]);
 		}
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	nOutFileNameSize = strlen(argv[1]) + 5;
 	sOutFileName = (char *)malloc(sizeof(char) * nOutFileNameSize);
 	if(sOutFileName == NULL)
 	{
 		printf(αInsufficient memory availablenα);
 		return RET_ERROR;
 	}
 	memset(sOutFileName, 0, nOutFileNameSize);
 	sprintf(sOutFileName, α%s.outα, argv[1]);
 	/*---------------------------------------------------*/	
 
 	/*+--------------------------------------------------*/
 	fpInFile = (FILE *)fopen(argv[1], αrα);
 	if(fpInFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, argv[1]);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	fpOutFile = (FILE *)fopen(sOutFileName, αwα);
 	if(fpOutFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, sOutFileName);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*###################################################*/
 	if(RET_ERROR == ProcStU(fpInFile, fpOutFile))
 	{
 		printf(αError.nα);
 	}
 	/*###################################################*/
 
 	/*+--------------------------------------------------*/
 	fclose(fpOutFile);
 
 	fclose(fpInFile);
 
 	free(sOutFileName);
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int ProcStU(FILE *fpInFile, FILE *fpOutFile)
 {
 	int n = 0;
 	int i = 0, j = 0;
 	long nCount = 0;
 	int nSECount = 0;
 	int nQSCount = 0;
 	int nMinSwitch = 0;
 	char **pSEName = NULL;
 	char **pQSeries = NULL;
 	char ch;
 	
 	/*+--------------------------------------------------*/
 	if(EOF == fscanf(fpInFile, α%ldnα, &nCount))
 	{
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 	
 	/*+--------------------------------------------------*/
 	for(n = 0; n < nCount; n++)
 	{
 		nMinSwitch = 0;
 
 		fscanf(fpInFile, α%ldnα, &nSECount);
 		pSEName = (char**)malloc(sizeof(char*) * nSECount);
 		if(pSEName == NULL)
 		{
 			printf(αInsufficient memory availablenα);
 			FreeMemory(pSEName, nSECount, pQSeries, nQSCount);
 			return RET_ERROR;
 		}
 		for(i = 0; i < nSECount; i++)
 		{
 			pSEName[i] = (char*)malloc(sizeof(char) * (MAX_SEARCH_NAME_LEN + 1));
 			if(pSEName[i] == NULL)
 			{
 				printf(αInsufficient memory availablenα);
 				FreeMemory(pSEName, nSECount, pQSeries, nQSCount);
 				return RET_ERROR;
 			}
 			memset(pSEName[i], 0x00, sizeof(char) * (MAX_SEARCH_NAME_LEN + 1));
 			for(j = 0; j < MAX_SEARCH_NAME_LEN; j++)
 			{
 				ch = fgetc(fpInFile);
 				if((ch == 'n') || (ch == EOF))
 				{
 					break;
 				}
 				pSEName[i][j] = ch;
 			}
 		}
 
 		fscanf(fpInFile, α%ldnα, &nQSCount);
 		pQSeries = (char**)malloc(sizeof(char*) * nQSCount);
 		if(pQSeries == NULL)
 		{
 			printf(αInsufficient memory availablenα);
 			FreeMemory(pSEName, nSECount, pQSeries, nQSCount);
 			return RET_ERROR;
 		}
 		for(i = 0; i < nQSCount; i++)
 		{
 			pQSeries[i] = (char*)malloc(sizeof(char) * (MAX_SEARCH_NAME_LEN + 1));
 			if(pQSeries[i] == NULL)
 			{
 				printf(αInsufficient memory availablenα);
 				FreeMemory(pSEName, nSECount, pQSeries, nQSCount);
 				return RET_ERROR;
 			}
 			memset(pQSeries[i], 0x00, sizeof(char) * (MAX_SEARCH_NAME_LEN + 1));
 			for(j = 0; j < MAX_SEARCH_NAME_LEN; j++)
 			{
 				ch = fgetc(fpInFile);
 				if((ch == 'n') || (ch == EOF))
 				{
 					break;
 				}
 				pQSeries[i][j] = ch;
 			}
 		}
 
 		ComputeSwitchCount(pSEName, nSECount, pQSeries, nQSCount, &nMinSwitch);
 
 		fprintf(fpOutFile, αCase #%d: %dnα, n+1, nMinSwitch);
 
 		/*+--------------------------------------------------*/
 		FreeMemory(pSEName, nSECount, pQSeries, nQSCount);
 		/*---------------------------------------------------*/
 	}
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int ComputeSwitchCount(char **pSEName, int nSECount, char **pQSeries, int nQSCount, int *pMinSwitch)
 {
 	int i = 0, j = 0, k = 0;
 	int *pSENameCount = NULL;
 	int nSum = 0;
 
 	*pMinSwitch = 0;
 	pSENameCount = (int*)malloc(sizeof(int) * nSECount);
 	memset(pSENameCount, 0, sizeof(int) * nSECount);
 
 	for(i = 0; i < nQSCount; i++)
 	{
 		for(j = 0; j < nSECount; j++)
 		{
 			if((0 == strcmp(pQSeries[i], pSEName[j])) &&
 				(strlen(pQSeries[i]) == strlen(pSEName[j])))
 			{
 				pSENameCount[j] = 1;
 				nSum = 0;
 				for(k = 0; k < nSECount; k++)
 				{
 					nSum += pSENameCount[k];
 				}
 				if(nSum == nSECount)
 				{
 					memset(pSENameCount, 0, sizeof(int) * nSECount);
 					pSENameCount[j] = 1;
 					*pMinSwitch += 1;
 				}
 			}
 		}
 	}
 	free(pSENameCount);
 
 	return RET_OK;
 }
 
 int FreeMemory(char **pSEName, int nSECount, char **pQSeries, int nQSCount)
 {
 	int i = 0;
 
 	if(pSEName != NULL)
 	{
 		for(i = 0; i < nSECount; i++)
 		{
 			if(pSEName[i] != NULL)
 			{
 				free(pSEName[i]);
 				pSEName[i] = NULL;
 			}
 		}
 		free(pSEName);
 		pSEName = NULL;
 	}
 	
 	if(pQSeries != NULL)
 	{
 		for(i = 0; i < nQSCount; i++)
 		{
 			if(pQSeries[i] != NULL)
 			{
 				free(pQSeries[i]);
 				pQSeries[i] = NULL;
 			}
 		}
 		free(pQSeries);
 		pQSeries = NULL;
 	}
 
 	return RET_OK;
 }"
13897,2008,32013,PotatoChip,24481,1,TT.c,gcj/2008/32013/PotatoChip/24481/1/extracted/TT.c,"/*****************************************************/
 /* Date : 2008.07.17                                 */
 /* Author : HHJeon                                   */
 /* Description : Google Code Jam, Qualification Round, */
 /*               Train Timetable                     */
 /*****************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define RET_OK 1
 #define RET_ERROR -1
 
 /*###################################################*/
 typedef struct _TIMETABLE{
 	int nDeparture;
 	int nArrival;
 	char bTrain;
 }TimeTable;
 
 typedef struct _LINK_TIMETABLE{
 	TimeTable Time_Train;
 	struct _LINK_TIMETABLE *pNext;
 }LinkTimeTable;
 
 int ProcTT(FILE *fpInFile, FILE *fpOutFile);
 int ComputeTrainCount(TimeTable *pATimeTable, int nNACount, TimeTable *pBTimeTable, int nNBCount, int nTurnAroundTime, int *pNATCount, int *pNBTCount);
 int FreeMemory(TimeTable *pATimeTable, TimeTable *pBTimeTable);
 #if 0
 int InsertTrain(LinkTimeTable *pLinkTimeTable, int nCurTime, int *pLinkCount);
 int MoveToTrain(LinkTimeTable *pLinkTimeTable1, int *pLinkCount1, LinkTimeTable *pLinkTimeTable2, int *pLinkCount2);
 int RemoveCurTime(LinkTimeTable *pLinkTimeTable, int nCurTime, int *pLinkCount);
 #endif
 #define SWAP(x,y,z) ((z)=(x), (x)=(y), (y)=(z))
 int SimpleSortArrivalASC(TimeTable *pTimeTable, int nCount);
 int SimpleSortDepartureASC(TimeTable *pTimeTable, int nCount);
 /*###################################################*/
 
 int main(int argc, char* argv[])
 {
 	FILE *fpInFile, *fpOutFile;
 	char *sOutFileName = NULL;
 	int nOutFileNameSize = 0;
 	
 	/*+--------------------------------------------------*/
 	if(argc != 2)
 	{
 		if(NULL != strrchr(argv[0], '\'))
 		{
 			printf(αUsage %s input_filenα, strrchr(argv[0], '\') + 1);
 		}
 		else
 		{
 			printf(αUsage %s input_filenα, argv[0]);
 		}
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	nOutFileNameSize = strlen(argv[1]) + 5;
 	sOutFileName = (char *)malloc(sizeof(char) * nOutFileNameSize);
 	if(sOutFileName == NULL)
 	{
 		printf(αInsufficient memory availablenα);
 		return RET_ERROR;
 	}
 	memset(sOutFileName, 0, nOutFileNameSize);
 	sprintf(sOutFileName, α%s.outα, argv[1]);
 	/*---------------------------------------------------*/	
 
 	/*+--------------------------------------------------*/
 	fpInFile = (FILE *)fopen(argv[1], αrα);
 	if(fpInFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, argv[1]);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	fpOutFile = (FILE *)fopen(sOutFileName, αwα);
 	if(fpOutFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, sOutFileName);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*###################################################*/
 	if(RET_ERROR == ProcTT(fpInFile, fpOutFile))
 	{
 		printf(αError.nα);
 	}
 	/*###################################################*/
 
 	/*+--------------------------------------------------*/
 	fclose(fpOutFile);
 
 	fclose(fpInFile);
 
 	free(sOutFileName);
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int ProcTT(FILE *fpInFile, FILE *fpOutFile)
 {
 	int n = 0;
 	int i = 0, j = 0;
 	long nCount = 0;
 	int nTurnAroundTime = 0;
 	int nNACount = 0, nNBCount = 0;
 	int nNATCount = 0, nNBTCount = 0;
 	int nDHour = 0, nDMin = 0, nAHour = 0, nAMin = 0;
 	TimeTable *pATimeTable = NULL, *pBTimeTable = NULL;
 
 	/*+--------------------------------------------------*/
 	if(EOF == fscanf(fpInFile, α%ldnα, &nCount))
 	{
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 	
 	/*+--------------------------------------------------*/
 	for(n = 0; n < nCount; n++)
 	{
 		fscanf(fpInFile, α%ldnα, &nTurnAroundTime);
 		fscanf(fpInFile, α%d %dnα, &nNACount, &nNBCount);
 
 		pATimeTable = (TimeTable*)malloc(sizeof(TimeTable) * nNACount);
 		pBTimeTable = (TimeTable*)malloc(sizeof(TimeTable) * nNBCount);
 		if(pATimeTable == NULL || pBTimeTable == NULL)
 		{
 			printf(αInsufficient memory availablenα);
 			FreeMemory(pATimeTable, pBTimeTable);
 			return RET_ERROR;
 		}
 		for(i = 0; i < nNACount; i++)
 		{
 			fscanf(fpInFile, α%d:%d %d:%dnα, &nDHour, &nDMin, &nAHour, &nAMin);
 			pATimeTable[i].nDeparture = nDHour * 60 + nDMin;
 			pATimeTable[i].nArrival = nAHour * 60 + nAMin;
 			pATimeTable[i].bTrain = 0;
 		}
 		for(i = 0; i < nNBCount; i++)
 		{
 			fscanf(fpInFile, α%d:%d %d:%dnα, &nDHour, &nDMin, &nAHour, &nAMin);
 			pBTimeTable[i].nDeparture = nDHour * 60 + nDMin;
 			pBTimeTable[i].nArrival = nAHour * 60 + nAMin;
 			pBTimeTable[i].bTrain = 0;
 		}
 
 		ComputeTrainCount(pATimeTable, nNACount, pBTimeTable, nNBCount, nTurnAroundTime, &nNATCount, &nNBTCount);
 
 		fprintf(fpOutFile, αCase #%d: %d %dnα, n+1, nNATCount, nNBTCount);
 		/*+--------------------------------------------------*/
 		FreeMemory(pATimeTable, pBTimeTable);
 		/*---------------------------------------------------*/
 	}
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int ComputeTrainCount(TimeTable *pATimeTable, int nNACount, TimeTable *pBTimeTable, int nNBCount, int nTurnAroundTime, int *pNATCount, int *pNBTCount)
 {
 	int i = 0, j = 0, k = 0;
 	int nNAC = 0, nNBC = 0;
 	LinkTimeTable *pALinkTimeTable = NULL, *pBLinkTimeTable = NULL;
 	LinkTimeTable *pNewLinkTimeTable = NULL, *pCurLinkTimeTable = NULL, *pPrevLinkTimeTable = NULL;
 	int nALinkCount = 0, nBLinkCount = 0;
 	int nCurTime = 0, nArrivalTime = 0;
 	char bFirst = 0;
 
 	*pNATCount = 0;
 	*pNBTCount = 0;
 	nNAC = nNACount;
 	nNBC = nNBCount;
 
 	/*+--------------------------------------------------*/
 	SimpleSortDepartureASC(pATimeTable, nNACount);
 	SimpleSortDepartureASC(pBTimeTable, nNBCount);
 
 	for(i = 0; i < nNACount; i++)
 	{
 		if(i == 0)
 		{
 			pALinkTimeTable = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 			pALinkTimeTable->Time_Train.nDeparture = pATimeTable[i].nDeparture;
 			pALinkTimeTable->Time_Train.nArrival = pATimeTable[i].nArrival;
 			pALinkTimeTable->Time_Train.bTrain = pATimeTable[i].bTrain;	
 			pALinkTimeTable->pNext = NULL;
 			pCurLinkTimeTable = pALinkTimeTable;
 		}
 		else
 		{
 			pCurLinkTimeTable->pNext = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 			pCurLinkTimeTable = pCurLinkTimeTable->pNext;
 			pCurLinkTimeTable->Time_Train.nDeparture = pATimeTable[i].nDeparture;
 			pCurLinkTimeTable->Time_Train.nArrival = pATimeTable[i].nArrival;
 			pCurLinkTimeTable->Time_Train.bTrain = pATimeTable[i].bTrain;	
 			pCurLinkTimeTable->pNext = NULL;			
 		}
 	}
 	nALinkCount = nNACount;
 	for(i = 0; i < nNBCount; i++)
 	{
 		if(i == 0)
 		{
 			pBLinkTimeTable = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 			pBLinkTimeTable->Time_Train.nDeparture = pBTimeTable[i].nDeparture;
 			pBLinkTimeTable->Time_Train.nArrival = pBTimeTable[i].nArrival;
 			pBLinkTimeTable->Time_Train.bTrain = pBTimeTable[i].bTrain;	
 			pBLinkTimeTable->pNext = NULL;
 			pCurLinkTimeTable = pBLinkTimeTable;
 		}
 		else
 		{
 			pCurLinkTimeTable->pNext = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 			pCurLinkTimeTable = pCurLinkTimeTable->pNext;
 			pCurLinkTimeTable->Time_Train.nDeparture = pBTimeTable[i].nDeparture;
 			pCurLinkTimeTable->Time_Train.nArrival = pBTimeTable[i].nArrival;
 			pCurLinkTimeTable->Time_Train.bTrain = pBTimeTable[i].bTrain;	
 			pCurLinkTimeTable->pNext = NULL;			
 		}
 	}
 	nBLinkCount = nNBCount;
 	/*---------------------------------------------------*/
 	
 	while((nNAC > 0) || (nNBC > 0))
 	{
 		nCurTime = -1;
 		for(pCurLinkTimeTable = pALinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 		{
 			if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 			{
 				nCurTime = pCurLinkTimeTable->Time_Train.nDeparture;
 				break;
 			}
 		}
 		for(pCurLinkTimeTable = pBLinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 		{
 			if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 			{
 				if((nCurTime == -1) || (nCurTime > pCurLinkTimeTable->Time_Train.nDeparture))
 				{
 					nCurTime = pCurLinkTimeTable->Time_Train.nDeparture;
 				}
 				break;
 			}
 		}
 
 		bFirst = 0;
 		for(pCurLinkTimeTable = pALinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 		{
 			if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 			{
 				if(bFirst == 0)
 				{
 					if(nCurTime == pCurLinkTimeTable->Time_Train.nDeparture)
 					{
 						bFirst = 1;
 						nArrivalTime = pCurLinkTimeTable->Time_Train.nArrival;
 					}					
 					break;
 				}
 			}
 		}
 		if(bFirst)
 		{		
 			if(pALinkTimeTable->Time_Train.bTrain == 0)
 			{
 				//InsertTrain(pALinkTimeTable, nCurTime + nTurnAroundTime, &nALinkCount);
 				pNewLinkTimeTable = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 				pNewLinkTimeTable->Time_Train.nDeparture = nArrivalTime + nTurnAroundTime;
 				pNewLinkTimeTable->Time_Train.nArrival = -1;
 				pNewLinkTimeTable->Time_Train.bTrain = 1;	
 				pNewLinkTimeTable->pNext = pALinkTimeTable;
 				pALinkTimeTable = pNewLinkTimeTable;
 				nALinkCount += 1;
 
 				*pNATCount += 1;
 			}
 			else
 			{
 				pALinkTimeTable->Time_Train.nDeparture = nArrivalTime + nTurnAroundTime;
 			}
 
 			//MoveToTrain(pALinkTimeTable, &nALinkCount, pBLinkTimeTable, &nBLinkCount);
 			pNewLinkTimeTable = pALinkTimeTable;
 			pALinkTimeTable = pALinkTimeTable->pNext;
 			pNewLinkTimeTable->pNext = NULL;
 			nALinkCount -= 1;
 			nNAC--;
 
 			pPrevLinkTimeTable = NULL;
 			for(pCurLinkTimeTable = pBLinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 			{
 				if(pCurLinkTimeTable->Time_Train.nDeparture >= pNewLinkTimeTable->Time_Train.nDeparture)
 				{
 					if(pPrevLinkTimeTable == NULL)
 					{
 						pBLinkTimeTable = pNewLinkTimeTable;
 					}
 					else
 					{
 						pPrevLinkTimeTable->pNext = pNewLinkTimeTable;
 					}
 					pNewLinkTimeTable->pNext = pCurLinkTimeTable;
 
 					nBLinkCount += 1;
 					break;
 				}
 
 				pPrevLinkTimeTable = pCurLinkTimeTable;
 			}
 			if(pCurLinkTimeTable == NULL)
 			{
 				free(pNewLinkTimeTable);
 				pNewLinkTimeTable = NULL;
 			}
 
 			//RemoveCurTime(pALinkTimeTable, nCurTime, &nALinkCount);
 			pPrevLinkTimeTable = NULL;
 			for(pCurLinkTimeTable = pALinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 			{
 				if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 				{
 					if(pCurLinkTimeTable->Time_Train.nDeparture == nCurTime)
 					{
 						if(pPrevLinkTimeTable == NULL)
 						{
 							pALinkTimeTable = pCurLinkTimeTable->pNext;
 						}
 						else
 						{
 							pPrevLinkTimeTable->pNext = pCurLinkTimeTable->pNext;
 						}
 						pCurLinkTimeTable->pNext = NULL;
 						free(pCurLinkTimeTable);
 						pCurLinkTimeTable = NULL;
 
 						nALinkCount -= 1;
 						break;
 					}
 				}
 
 				pPrevLinkTimeTable = pCurLinkTimeTable;
 			}
 
 		}
 
 		bFirst = 0;
 		for(pCurLinkTimeTable = pBLinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 		{
 			if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 			{
 				if(bFirst == 0)
 				{
 					if(nCurTime == pCurLinkTimeTable->Time_Train.nDeparture)
 					{
 						bFirst = 1;
 						nArrivalTime = pCurLinkTimeTable->Time_Train.nArrival;
 					}					
 					break;
 				}
 			}
 		}
 		if(bFirst)
 		{
 			if(pBLinkTimeTable->Time_Train.bTrain == 0)
 			{
 				//InsertTrain(pBLinkTimeTable, nCurTime + nTurnAroundTime, &nBLinkCount);
 				pNewLinkTimeTable = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 				pNewLinkTimeTable->Time_Train.nDeparture = nArrivalTime + nTurnAroundTime;
 				pNewLinkTimeTable->Time_Train.nArrival = -1;
 				pNewLinkTimeTable->Time_Train.bTrain = 1;	
 				pNewLinkTimeTable->pNext = pBLinkTimeTable;
 				pBLinkTimeTable = pNewLinkTimeTable;
 				nBLinkCount += 1;
 
 				*pNBTCount += 1;
 			}
 			else
 			{
 				pBLinkTimeTable->Time_Train.nDeparture = nArrivalTime + nTurnAroundTime;
 			}
 
 			//MoveToTrain(pBLinkTimeTable, &nBLinkCount, pALinkTimeTable, &nALinkCount);
 			pNewLinkTimeTable = pBLinkTimeTable;
 			pBLinkTimeTable = pBLinkTimeTable->pNext;
 			pNewLinkTimeTable->pNext = NULL;
 			nBLinkCount -= 1;
 			nNBC--;
 
 			pPrevLinkTimeTable = NULL;
 			for(pCurLinkTimeTable = pALinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 			{
 				if(pCurLinkTimeTable->Time_Train.nDeparture >= pNewLinkTimeTable->Time_Train.nDeparture)
 				{
 					if(pPrevLinkTimeTable == NULL)
 					{
 						pALinkTimeTable = pNewLinkTimeTable;
 					}
 					else
 					{
 						pPrevLinkTimeTable->pNext = pNewLinkTimeTable;
 					}
 					pNewLinkTimeTable->pNext = pCurLinkTimeTable;
 
 					nALinkCount += 1;
 					break;
 				}
 
 				pPrevLinkTimeTable = pCurLinkTimeTable;
 			}
 			if(pCurLinkTimeTable == NULL)
 			{
 				free(pNewLinkTimeTable);
 				pNewLinkTimeTable = NULL;
 			}
 
 			//RemoveCurTime(pBLinkTimeTable, nCurTime, &nBLinkCount);		
 			pPrevLinkTimeTable = NULL;
 			for(pCurLinkTimeTable = pBLinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 			{
 				if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 				{
 					if(pCurLinkTimeTable->Time_Train.nDeparture == nCurTime)
 					{
 						if(pPrevLinkTimeTable == NULL)
 						{
 							pBLinkTimeTable = pCurLinkTimeTable->pNext;
 						}
 						else
 						{
 							pPrevLinkTimeTable->pNext = pCurLinkTimeTable->pNext;
 						}
 						pCurLinkTimeTable->pNext = NULL;
 						free(pCurLinkTimeTable);
 						pCurLinkTimeTable = NULL;
 
 						nBLinkCount -= 1;
 						break;
 					}
 				}
 
 				pPrevLinkTimeTable = pCurLinkTimeTable;
 			}
 		}
 	}
 
 	return RET_OK;
 }
 
 int FreeMemory(TimeTable *pATimeTable, TimeTable *pBTimeTable)
 {
 	if(pATimeTable != NULL)
 	{
 		free(pATimeTable);
 		pATimeTable = NULL;
 	}
 	
 	if(pBTimeTable != NULL)
 	{
 		free(pBTimeTable);
 		pBTimeTable = NULL;
 	}
 
 	return RET_OK;
 }
 
 int SimpleSortArrivalASC(TimeTable *pTimeTable, int nCount)
 {
     int i, j, temp, flag;
 
     for(i = 0; i < nCount-1; i++)
     {
         flag = 0;
         for(j = 0; j < nCount-1-i; j++)
 		{
             if(pTimeTable[j].nArrival > pTimeTable[j+1].nArrival)
             {
                 SWAP(pTimeTable[j].nDeparture, pTimeTable[j+1].nDeparture, temp);
 				SWAP(pTimeTable[j].nArrival, pTimeTable[j+1].nArrival, temp);
 				SWAP(pTimeTable[j].bTrain, pTimeTable[j+1].bTrain, temp);
                 flag = 1;
             }
 			else if(pTimeTable[j].nArrival == pTimeTable[j+1].nArrival)
 			{
 				if(pTimeTable[j].nDeparture > pTimeTable[j+1].nDeparture)
 				{
 					SWAP(pTimeTable[j].nDeparture, pTimeTable[j+1].nDeparture, temp);
 					SWAP(pTimeTable[j].nArrival, pTimeTable[j+1].nArrival, temp);
 					SWAP(pTimeTable[j].bTrain, pTimeTable[j+1].bTrain, temp);
 					flag = 1;
 				}
 			}
 		}
         if(flag == 0)
 		{
 			break;
 		}
     }
 
 	return RET_OK;
 }
 
 int SimpleSortDepartureASC(TimeTable *pTimeTable, int nCount)
 {
     int i, j, temp, flag;
 
     for(i = 0; i < nCount-1; i++)
     {
         flag = 0;
         for(j = 0; j < nCount-1-i; j++)
 		{
             if(pTimeTable[j].nDeparture > pTimeTable[j+1].nDeparture)
             {
                 SWAP(pTimeTable[j].nDeparture, pTimeTable[j+1].nDeparture, temp);
 				SWAP(pTimeTable[j].nArrival, pTimeTable[j+1].nArrival, temp);
 				SWAP(pTimeTable[j].bTrain, pTimeTable[j+1].bTrain, temp);
                 flag = 1;
             }
 			else if(pTimeTable[j].nDeparture == pTimeTable[j+1].nDeparture)
 			{
 				if(pTimeTable[j].nArrival > pTimeTable[j+1].nArrival)
 				{
 					SWAP(pTimeTable[j].nDeparture, pTimeTable[j+1].nDeparture, temp);
 					SWAP(pTimeTable[j].nArrival, pTimeTable[j+1].nArrival, temp);
 					SWAP(pTimeTable[j].bTrain, pTimeTable[j+1].bTrain, temp);
 					flag = 1;
 				}
 			}
 		}
         if(flag == 0)
 		{
 			break;
 		}
     }
 
 	return RET_OK;
 }
 
 #if 0
 int InsertTrain(LinkTimeTable *pLinkTimeTable, int nCurTime, int *pLinkCount)
 {
 	LinkTimeTable *pNewLinkTimeTable = NULL;
 
 	pNewLinkTimeTable = (LinkTimeTable*)malloc(sizeof(LinkTimeTable));
 	pNewLinkTimeTable->Time_Train.nDeparture = nCurTime;
 	pNewLinkTimeTable->Time_Train.nArrival = -1;
 	pNewLinkTimeTable->Time_Train.bTrain = 1;	
 	pNewLinkTimeTable->pNext = pLinkTimeTable;
 	pLinkTimeTable = pNewLinkTimeTable;
 	*pLinkCount += 1;
 
 	return RET_OK;
 }
 
 int MoveToTrain(LinkTimeTable *pLinkTimeTable1, int *pLinkCount1, LinkTimeTable *pLinkTimeTable2, int *pLinkCount2)
 {
 	LinkTimeTable *pNewLinkTimeTable = NULL, *pCurLinkTimeTable = NULL, *pPrevLinkTimeTable = NULL;
 
 	pNewLinkTimeTable = pLinkTimeTable1;
 	pLinkTimeTable1 = pLinkTimeTable1->pNext;
 	pNewLinkTimeTable->pNext = NULL;
 	*pLinkCount1 -= 1;
 
 	for(pCurLinkTimeTable = pLinkTimeTable2; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 	{
 		if(pCurLinkTimeTable->Time_Train.nDeparture >= pNewLinkTimeTable->Time_Train.nDeparture)
 		{
 			pPrevLinkTimeTable->pNext = pNewLinkTimeTable;
 			pNewLinkTimeTable->pNext = pCurLinkTimeTable;
 
 			*pLinkCount2 += 1;
 			break;
 		}
 
 		pPrevLinkTimeTable = pCurLinkTimeTable;
 	}
 
 	return RET_OK;
 }
 
 int RemoveCurTime(LinkTimeTable *pLinkTimeTable, int nCurTime, int *pLinkCount)
 {
 	LinkTimeTable *pCurLinkTimeTable = NULL, *pPrevLinkTimeTable = NULL;
 
 	for(pCurLinkTimeTable = pLinkTimeTable; pCurLinkTimeTable != NULL; pCurLinkTimeTable = pCurLinkTimeTable->pNext)
 	{
 		if(pCurLinkTimeTable->Time_Train.bTrain == 0)
 		{
 			if(pCurLinkTimeTable->Time_Train.nDeparture == nCurTime)
 			{
 				pPrevLinkTimeTable->pNext = pCurLinkTimeTable->pNext;
 				pCurLinkTimeTable->pNext = NULL;
 				free(pCurLinkTimeTable);
 				pCurLinkTimeTable = NULL;
 
 				*pLinkCount -= 1;
 				break;
 			}
 		}
 
 		pPrevLinkTimeTable = pCurLinkTimeTable;
 	}
 
 	return RET_OK;
 }
 #endif"
13937,2008,32013,kgiyer,24480,1,Universe.c,gcj/2008/32013/kgiyer/24480/1/extracted/Universe.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX_SEARCH_ENGINES 100
 #define MAX_QUERIES 1000
 #define MAX_NAME_LEN 100
 
 char SearchEngine[MAX_SEARCH_ENGINES][MAX_NAME_LEN + 1];
 int SearchEngineFlag[MAX_SEARCH_ENGINES] = {0};
 char Query[MAX_QUERIES][MAX_NAME_LEN + 1];
 
 int
 main()
 {
   FILE *fi;
   FILE *fo;
   int nTestcases;
   int nSearchEngines;
   int nQueries;
   int i, j, k, l;
   int nSwitches;
   int nSearchEnginesFlagged;
 
   fi = fopen(αin1α, αrα);
   fo = fopen(αout1α, αwα);
 
   fscanf(fi, α%dnα, &nTestcases);
   for (i = 1; i <= nTestcases; i++)
   {
     nSwitches = 0;
     nSearchEnginesFlagged = 0;
 
     fscanf(fi, α%dnα, &nSearchEngines);
     for (j = 0; j < nSearchEngines; j++)
     {
       fgets(SearchEngine[j], MAX_NAME_LEN, fi);
       SearchEngineFlag[j] = 0;
     }
 
     fscanf(fi, α%dnα, &nQueries);
     for (j = 0; j < nQueries; j++)
     {
       fgets(Query[j], MAX_NAME_LEN, fi);
       for (k = 0; k < nSearchEngines; k++)
       {
         if (strcmp(Query[j], SearchEngine[k]) == 0)
         {
           if (SearchEngineFlag[k] == 0)
           {
             if (++nSearchEnginesFlagged == nSearchEngines)
             {
               nSwitches++;
               for (l = 0; l < nSearchEngines; l++)
                 SearchEngineFlag[l] = 0;
               nSearchEnginesFlagged = 1;
             }            
             SearchEngineFlag[k] = 1;
           }    
           break;
         }
       }
     }
     fprintf(fo, αCase #%d: %dnα, i, nSwitches);
   }
   fclose(fi);
   fclose(fo); 
 }"
14086,2008,32013,nutki,24479,1,C.c,gcj/2008/32013/nutki/24479/1/extracted/C.c,"#include <stdio.h>
 #include <math.h>
 int n,i;
 double pi;
 int incircle(double r, double x, double y) {
 	return x*x+y*y < r*r;
 }
 double chord(double r, double h) {
 	return (r * r * acos(h/r) - h * sqrt (r*r - h*h))/2.;
 }
 double case0(double r, double x, double y, double a) {
 	double x1 = sqrt(r * r - y * y);
 //	printf(αcase 0: r %lf: %lf %lf %lf %lf, res %lfnα,r,x,x1,y,a,chord(r,x));// - chord(r,x1) - y*(x1-x));
 	return chord(r,x) - chord(r,x1) - y*(x1-x);
 }
 double case2(double r, double x, double y, double a) {
 	return chord(r,x) - chord(r,x+a) - a * y;
 }
 double case1(double r, double x, double y, double a) {
 	return case2(r,y,x,a);
 }
 double case3(double r, double x, double y, double a) {
 	double x1 = sqrt(r * r - (y+a) * (y+a));
 	return a*(x1-x) + case2(r,x1,y,x+a-x1);
 }
 int main() {
 	pi = atan(1.0)*4;
 	scanf(α%dα,&n);
 	for(i=0;i<n;i++) {
 		double f,R,t,r,g,area,holes = 0.0,step;
 		int fullholes = 0;
 		scanf(α%lf%lf%lf%lf%lfα,&f,&R,&t,&r,&g);
 		r += f;
 		g -= 2*f;
 		t = R - t - f;
 		if(t <= 0. || g <= 0.) {
 			printf(αCase #%d: %.6lfnα,i+1,1.);
 			continue;
 		}
 		area = pi * R * R / 4.0;
 //		printf(αarea: %lfnα,area);
 		holes = 0.0;
 		double j,k;
 		int j1,k1;
 		step = 2*r+g;
 		for(j1=0,j=r;j<t;j=r+ ++j1*step) {
 			for(k1=0,k=r;k<t;k=r+ ++k1*step) {
 				if(incircle(t,j+g,k+g)) {
 					fullholes++;
 				} else if(!incircle(t,j,k)) {
 //					break;
 				} else {
 					int in1 = incircle(t,j,k+g);
 					int in2 = incircle(t,j+g,k);
 					switch(in1+in2+in2) {
 					case 0: holes += case0(t,j,k,g); break;
 					case 1: holes += case1(t,j,k,g); break;
 					case 2: holes += case2(t,j,k,g); break;
 					case 3: holes += case3(t,j,k,g); break;
 					}
 				}
 			}
 		}
 		printf(αCase #%d: %lfnα,i+1,(area-holes-g*g*fullholes)/area);
 	}
 	return 0;
 }"
14114,2008,32013,tiagomt,24480,1,a.c,gcj/2008/32013/tiagomt/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXN		128
 #define MAXQ		1024
 #define MAXS		128
 
 #define INFINITO	0x33333333
 
 #define MIN(a,b)	(((a) < (b)) ? (a) : (b))
 
 char	se[MAXN][MAXS];
 int	n;
 
 char	m[MAXQ][MAXN];
 int	q;
 
 int	b[MAXQ][MAXN];
 
 int main (void)
 {
 	char	s[MAXS];
 	int	nc,
 		h;
 	int	res;
 	int	i,
 		j,
 		k;
 
 	gets(s);
 	for (sscanf(s, α%dα, &nc), h = 1; h <= nc; h++)
 	{
 		gets(s);
 		sscanf(s, α%dα, &n);
 		for (i = 0; i < n; i++)
 		{
 			gets(se[i]);
 		}
 		memset(m, 0, sizeof(m));
 		gets(s);
 		sscanf(s, α%dα, &q);
 		for (i = 1; i <= q; i++)
 		{
 			gets(s);
 			for (j = 0; j < n; j++)
 			{
 				if (strcmp(s, se[j]) == 0)
 				{
 					break;
 				}
 			}
 			if (j < n)
 			{
 				m[i][j] = 1;
 			}
 		}
 		for (j = 0; j < n; j++)
 		{
 			b[0][j] = 0;
 		}
 		for (i = 1; i <= q; i++)
 		{
 			for (j = 0; j < n; j++)
 			{
 				b[i][j] = INFINITO;
 				if (m[i][j])
 				{
 					continue;
 				}
 				for (k = 0; k < n; k++)
 				{
 					b[i][j] = MIN(b[i][j], b[i - 1][k] + 1);
 				}
 				b[i][j] = MIN(b[i][j], b[i - 1][j]);
 			}
 		}
 		res = INFINITO;
 		for (j = 0; j < n; j++)
 		{
 			if (b[q][j] < res)
 			{
 				res = b[q][j];
 			}
 		}
 		printf(αCase #%d: %dnα, h, res);
 	}
 
 	return 0;
 }"
14116,2008,32013,tiagomt,24481,1,b.c,gcj/2008/32013/tiagomt/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXN	128
 
 typedef struct _Viag
 {
 	int	s,
 		f;
 	int	m;
 } Viag;
 
 Viag	v[2][MAXN];
 int	n[2];
 
 int viagcmp1 (const void *e1, const void *e2)
 {
 	Viag	*v1,
 		*v2;
 
 	v1 = (Viag *)e1;
 	v2 = (Viag *)e2;
 
 	return (v1->s - v2->s);
 }
 
 int viagcmp2 (const void *e1, const void *e2)
 {
 	Viag	*v1,
 		*v2;
 
 	v1 = (Viag *)e1;
 	v2 = (Viag *)e2;
 
 	return (v1->f - v2->f);
 }
 
 int main (void)
 {
 	int	nc,
 		h;
 	int	t;
 	int	s1,
 		s2,
 		f1,
 		f2;
 	int	cnt[2];
 	int	i,
 		j,
 		k,
 		l;
 
 	for (scanf(α%dα, &nc), h = 1; h <= nc; h++)
 	{
 		scanf(α%dα, &t);
 		scanf(α%d%dα, &(n[0]), &(n[1]));
 		for (i = 0; i < 2; i++)
 		{
 			for (j = 0; j < n[i]; j++)
 			{
 				scanf(α%d:%d %d:%dα, &s1, &s2, &f1, &f2);
 				v[i][j].s = s1 * 60 + s2;
 				v[i][j].f = f1 * 60 + f2;
 			}
 		}
 		for (i = 0; i < 2; i++)
 		{
 			j = 1 - i;
 			qsort(v[i], n[i], sizeof(v[i][0]), viagcmp1);
 			qsort(v[j], n[j], sizeof(v[j][0]), viagcmp2);
 			for (k = 0; k < n[j]; k++)
 			{
 				v[j][k].m = 0;
 			}
 			cnt[i] = 0;
 			for (k = 0; k < n[i]; k++)
 			{
 				for (l = 0; l < n[j]; l++)
 				{
 					if ((v[j][l].f + t) > v[i][k].s)
 					{
 						l = n[j];
 						break;
 					}
 					if (!(v[j][l].m))
 					{
 						break;
 					}
 				}
 				if (l < n[j])
 				{
 					v[j][l].m = 1;
 				}
 				else
 				{
 					(cnt[i])++;
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα, h, cnt[0], cnt[1]);
 	}
 
 	return 0;
 }"
14241,2008,32013,greenoyster,24480,1,a.c,gcj/2008/32013/greenoyster/24480/1/extracted/a.c,"#include <stdio.h>
 #define MAXS 100
 #define MAXLEN 100
 #define INF 1000000000
 
 //#define DEBUG
 
 int table[2][MAXS];
 char name[MAXS][MAXLEN+1];
 int main()
 {
 	int i, j, k, n, q, min;
 	int ncase, icase;
 	char query[MAXLEN+1];
 	int *last, *now, *ptmp;
 
 	scanf(α%dα, &ncase);
 	for(icase = 0; icase < ncase; ++icase){
 		scanf(α%d α, &n);
 		for(i=0; i<n; ++i){
 			fgets(name[i], MAXLEN+1, stdin);
 			table[0][i] = 0;
 		}
 		last = table[0];
 		now = table[1];
 
 		scanf(α%d α, &q);
 		for(i=0; i<q; ++i){
 			fgets(query, MAXLEN+1, stdin);
 			for(j=0; j<n; ++j){
 				if(!strcmp(query, name[j])){
 					now[j] = INF;
 					continue;
 				}
 				now[j] = last[j];
 				for(k=0; k<n; ++k){
 					if(k == j)
 						continue;
 					if(last[k] + 1 < now[j])
 						now[j] = last[k] + 1;
 				}
 			}
 #ifdef DEBUG
 			for(j=0; j<n; ++j)
 				printf(α%d α, now[j]);
 			printf(αnα);
 #endif
 			ptmp = now;
 			now = last;
 			last = ptmp;
 		}
 		min = INF;
 		for(i=0; i<n; ++i){
 			if(last[i] < min)
 				min = last[i];
 		}
 		printf(αCase #%d: %dnα, icase+1, min);
 	}
 	return 0;
 }"
14244,2008,32013,greenoyster,24481,1,b.c,gcj/2008/32013/greenoyster/24481/1/extracted/b.c,"#include <stdio.h>
 #define MAXN 100
 //#define DEBUG
 
 typedef struct Train_T{
 	int depart, arrive;
 	int ok;
 } Train;
 
 int main()
 {
 	Train trains[2][MAXN], tmpt;
 	Train *from, *to; 
 	int i, j, k, n[2], T;
 	int icase, ncase;
 	int ta, tb, tc, td;
 	int ans[2];
 	
 	scanf(α%dα, &ncase);
 	for(icase= 0; icase < ncase; ++icase){
 		scanf(α%dα, &T);
 		scanf(α%d%dα, &n[0], &n[1]);
 		for(k=0; k<2; ++k){
 			for(i=0; i<n[k]; ++i){
 				scanf(α%d:%d %d:%dα, &ta, &tb, &tc, &td);
 				trains[k][i].depart = ta*60+tb;
 				trains[k][i].arrive = tc*60+td;
 				trains[k][i].ok = 0;
 			}
 		}
 		for(k=0; k<2; ++k){
 			for(i=0; i<n[k]; ++i){
 				for(j=i+1; j<n[k]; ++j){
 					if(trains[k][i].depart > trains[k][j].depart){
 						tmpt = trains[k][i];
 						trains[k][i] = trains[k][j];
 						trains[k][j] = tmpt;
 					}
 				}
 			}
 		}
 		for(k=0; k<2; ++k){
 			from = trains[k];
 			to = trains[1-k];
 			for(i=0; i<n[k]; ++i){
 				for(j=0; j<n[1-k]; ++j){
 					if(from[i].arrive + T <= to[j].depart && to[j].ok == 0){
 						to[j].ok = 1;
 						break;
 					}
 				}
 			}
 		}
 		for(k=0; k<2; ++k){
 			ans[k] = 0;
 			for(i=0; i<n[k]; ++i)
 				ans[k] += (1 - trains[k][i].ok);
 #ifdef DEBUG
 			for(i=0; i<n[k]; ++i)
 				printf(α%d %d %d α, trains[k][i].depart, trains[k][i].arrive, trains[k][i].ok);
 			printf(αnα);
 #endif
 		}
 		printf(αCase #%d: %d %dnα, icase+1, ans[0], ans[1]);
 	}
 
 	return 0;
 }"
14456,2008,32013,sema,24480,1,Saving the Universe.c,gcj/2008/32013/sema/24480/1/extracted/Saving the Universe.c,"#include <stdio.h>
 #include <string.h>
 
 
 void schit(FILE *f,char s[])
 {
  int j;    
  j=-1;
  do
  {
   j++;    
   fscanf(f,α%cα,&s[j]);
  } 
  while (s[j]>16); 
  s[j]=0;  
 }
 
 int main()
 {
  FILE *f,*f1,*f2;
  int a[1002][101];
  char name[100][101],sn[101];
  int n,s,i,j,q,z,l,t;
  f=fopen(αUniverse.inα,αrα);
  f1=fopen(αUniverse.outα,αwα); 
  f2=fopen(αotl.outα,αwα);
  fscanf(f,α%dα,&n);
  for (t=1;t<=n;t++)
  {
   fscanf(f,α%dα,&s);
   schit(f,name[0]);
   for (i=0;i<s;i++)
   {
    schit(f,name[i]);
  //  fprintf(f2,α%snα,name[i]);
   } 
   fscanf(f,α%dα,&q);
   z=q+1;
   for (j=0;j<s;j++)
    a[z][j]=0;
   schit(f,sn); 
   for (;q;q--)
   {
    schit(f,sn);
    for (i=0;strcmp(sn,name[i]);i++);
    z=q+1;
    for (j=0;j<s;j++)
     a[q][j]=5000;
    for (j=0;j<s;j++)
     for (l=0;l<s;l++)
      if (l!=j) 
      {
       if (a[z][j]+1<a[q][l])
        a[q][l]=a[z][j]+1;
      } 
           else if (a[q][l]>a[z][j]) a[q][l]=a[z][j];
    a[q][i]=5000;   
 //   for (j=0;j<s;j++)
 //    fprintf(f2,α%d α,a[q][j]);
 //   fprintf(f2,α%s %d %snα,sn,q,name[i]); 
    z++;    
   }
   q=a[1][0];
   for (j=1;j<s;j++)
    if (q>a[1][j]) q=a[1][j];
   fprintf(f2,αnα);  
   fprintf(f1,αCase #%d: %dnα,t,q); 
  }
  fclose(f1);
  fclose(f2);
  fclose(f);
 }"
14521,2008,32013,thejoey,24480,1,google.c,gcj/2008/32013/thejoey/24480/1/extracted/google.c,"/*
  ============================================================================
  Name        : google.c
  Author      : Joey Allcock
  ============================================================================
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int main(void) {
 	int lines, i, j, k, c, s, q, clear, cleared;
 	char sin[101][101];
 	char qin[1001][101];
 	int used[101];
 
 	scanf(α%dα, &lines);
 
 	for (i = 1; lines > 0; i++) {
 		c = 0;
 		scanf(α%dnα, &s);
 		for (j = 0; j < s; j++)
 			gets(sin[j]);
 		scanf(α%dnα, &q);
 		if (q >= s) {
 			for (j = 0; j < s; j++)
 				used[j] = 0;
 			for (j = 0; j < q; j++) {
 				gets(qin[j]);
 				for (k = 0; k < s; k++) {
 					if (strcmp(qin[j], sin[k]) == 0) {
 						used[k] = 1;
 						cleared = k;
 						break;
 					}
 				}
 				clear = 1;
 				for (k = 0; k < s; k++) {
 					if (used[k] == 0) {
 						clear = 0;
 						break;
 					}
 				}
 				if (clear == 1) {
 					c++;
 					for (k = 0; k < s; k++)
 						used[k] = 0;
 					used[cleared] = 1;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα, i, c);
 		--lines;
 	}
 	return 0;
 }"
14523,2008,32013,thejoey,24481,1,google2.c,gcj/2008/32013/thejoey/24481/1/extracted/google2.c,"/*
  ============================================================================
  Name        : google2.c
  Author      : Joey Allcock
  ============================================================================
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int ns[2000][5];
 
 void sort(int i, int len) {
 	int l, k, j;
 	int t[5];
 	k = i;
 	l = len;
 
 	if(len - i >= 1) {
 		while (l >= i) {
 			if ((ns[k][2] * 100 + ns[k][3]) > (ns[l][2] * 100 + ns[l][3]) && k < l) {
 				for (j = 0; j < 5; j++) {
 					t[j] = ns[l][j];
 					ns[l][j] = ns[k][j];
 					ns[k][j] = t[j];
 				}
 				k = l;
 				l--;
 			} else if ((ns[k][2] * 100 + ns[k][3]) < (ns[l][2] * 100 + ns[l][3]) && k > l) {
 				for (j = 0; j < 5; j++) {
 					t[j] = ns[l][j];
 					ns[l][j] = ns[k][j];
 					ns[k][j] = t[j];
 				}
 				t[0] = k;
 				k = l;
 				l = t[0];
 			} else {
 				l--;
 			}
 	    }
 		sort(i, k - 1);
 		sort(k + 1, len);
 	}
 }
 
 void plusmin(int f[2], int t) {
 	f[1] += t;
 	if (f[1] > 60) {
 		++f[0];
 		f[1] %= 60;
 	}
 }
 
 int main(void) {
 	int i, j, k, lines, t, na, nb, ca, cb, n;
 
 	scanf(α%dα, &lines);
 
 	for (i = 1; lines > 0; i++, --lines) {
 		scanf(α%dα, &t);
 		scanf(α%d %dα, &na, &nb);
 		for (j = 0; j < na; j++) {
 			scanf(α%d:%d %d:%dα, &ns[j][0], &ns[j][1], &ns[j][2], &ns[j][3]);
 			plusmin(&ns[j][2], t);
 			ns[j][4] = 0;
 		}
 		for (j = 0; j < nb; j++) {
 			scanf(α%d:%d %d:%dα, &ns[j + na][0], &ns[j + na][1], &ns[j + na][2], &ns[j + na][3]);
 			plusmin(&ns[j + na][2], t);
 			ns[j + na][4] = 1;
 		}
 		ca = na;
 		cb = nb;
 		if (na == 0) {
 			ca = 0;
 		} else if (nb == 0) {
 			cb = 0;
 		} else {
 			n = na + nb;
 			sort(0, n - 1);
 
 			for (j = 1; j < n; j++) {
 				for (k = j + 1; k <= n; k++) {
 					if ((ns[n - k][4] % 2) != (ns[n - j][4] % 2) && ns[n - k][4] < 2 &&
 					  (ns[n - k][2] < ns[n - j][0] || (ns[n - k][2] == ns[n - j][0] && ns[n - k][3] <= ns[n - j][1]))) {
 						if ((ns[n - j][4] % 2) == 1)
 							--cb;
 						else
 							--ca;
 						ns[n - k][4] += 2;
 						break;
 					}
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα, i, ca, cb);
 	}
 	return 0;
 }"
14539,2008,32013,aster,24480,1,soln.c,gcj/2008/32013/aster/24480/1/extracted/soln.c,"#include<stdio.h>
 #include<stdlib.h>
 
 int main(int argc, char **argv)
 {
 	int num_cases, num_eng, num_quer, swap_ctr, temp_cntr;
 	int *tracker;
 	//int tracker[100];
 	FILE *fsrc, *fdest;
 	char s1[102];
 	char **srch_eng;
 	int i, j, k;
 
 	if(argc != 2) {
 		printf(αError in input parametersα);
 		exit(-1);
 	}
 	fsrc = fopen(argv[1], αrα);
 	if(!fsrc) {
 		printf(αError opening input filenα);
 		exit(-1);
 	}
 	fdest = fopen(αoutputα, αwα);
 	if(!fdest) {
 		printf(αError opening output filenα);
 		exit(-1);
 	}
 	num_cases = atoi(fgets(s1, 102, fsrc));
 	printf(αNum cases = %dnα, num_cases);
 
 	for(i = 0; i < num_cases; i++) {
 		num_eng = atoi(fgets(s1, 102, fsrc));
 		printf(αCase %d:nα, i+1);
 		printf(αNum eng: %dnα, num_eng);
 
 		srch_eng = (char**)malloc(num_eng*sizeof(char*));
 		//store the search engine names
 		for(j = 0; j < num_eng; j++) {
 			srch_eng[j] = (char*)malloc(100*sizeof(char));
 			fgets(srch_eng[j], 102, fsrc);
 		}
 
 		for(j=0;j<num_eng;j++) {
 			printf(α%snα, srch_eng[j]);
 		}
 		//allocate zeroed tracker array
 		tracker = (int*)calloc(num_eng, sizeof(int));
 		swap_ctr = 0;
 
 		num_quer = atoi(fgets(s1, 102, fsrc));
 		temp_cntr = 0;
 		for(j = 0; j < num_quer; j++) {
 			fgets(s1, 102, fsrc);
 			for(k = 0; k < num_eng; k++) {
 				/* compare this to the search engines we have
 				 * if this is something new, increment count
 				 */
 				if(strcmp(s1, srch_eng[k]) == 0) {
 					if(tracker[k] == 0) {
 						printf(αFound: %snα, s1);
 						temp_cntr++;
 						printf(αTemp ctr: %dnα, temp_cntr);
 						tracker[k]++;
 					}
 					break;
 				}
 			}
 			/* when count reaches number of search engines, first
 			 * swap will be made
 			 */
 			if(temp_cntr == num_eng) {
 				printf(αLast of search engines found: %snα, s1);
 				swap_ctr++;
 				temp_cntr = k;
 				for(k = 0; k < num_eng; k++) {
 					tracker[k] = 0;
 				}
 				tracker[temp_cntr]++;
 				temp_cntr = 1;
 			}
 		}
 		//annouce result
 		printf(αNumber of swaps: %dnα, swap_ctr);
 		fprintf(fdest, αCase #%d: %dnα, i+1, swap_ctr);
 		// free data structures
 		free(tracker);
 		for(j = 0; j < num_eng; j++) {
 			free(srch_eng[j]);
 		}
 		free(srch_eng);
 	}
 	fclose(fdest);
 	fclose(fsrc);
 	return 0;
 }"
14541,2008,32013,aster,24481,1,soln.c,gcj/2008/32013/aster/24481/1/extracted/soln.c,"#include <stdio.h>
 #include <stdlib.h>
 
 void bad_sort(int *arr, int num);
 
 int main(int argc, char **argv)
 {
 	char s[15];
 	FILE *fin, *fout;
 	int num_cases, turn_arnd_time, numA, numB;
 	int *depA, *arrA, *depB, *arrB;
 	int temp_hr, temp_min;
 	int i, j, k;
 	int trainA_ctr, trainB_ctr;
 	
 	if(argc != 2) {
 		printf(αError in parametersnα);
 		exit(-1);
 	}
 
 	fin = fopen(argv[1], αrα);
 	if(!fin) {
 		printf(αError opening sourcenα);
 		exit(-1);
 	}
 
 	fout = fopen(αoutputα, αwα);
 	if(!fout) {
 		printf(αError opening destinationnα);
 		exit(-1);
 	}
 
 	fscanf(fin, α%dnα, &num_cases);
 	printf(αNUM CASES: %dnα, num_cases);
 
 	for(i = 0; i < num_cases; i++) {
 		fscanf(fin, α%dnα, &turn_arnd_time);
 		printf(αTT: %dnα, turn_arnd_time);
 
 		fscanf(fin, α%d%dnα, &numA, &numB);
 		printf(αNUMA: %dnα, numA);
 		printf(αNUMB: %dnα, numB);
 
 		depA = (int*)malloc(sizeof(int) * numA);
 		arrA = (int*)malloc(sizeof(int) * numA);
 
 		depB = (int*)malloc(sizeof(int) * numB);
 		arrB = (int*)malloc(sizeof(int) * numB);
 
 		/* Get arrival and departure times and convert them into minutes */
 
 		for(j = 0; j < numA; j++) {
 			fscanf(fin, α%d:%dα, &temp_hr, &temp_min);
 			depA[j] = temp_hr*60 + temp_min;
 			fscanf(fin, α%d:%dnα, &temp_hr, &temp_min);
 			arrA[j] = temp_hr*60 + temp_min + turn_arnd_time;
 		}
 
 		/*for(j = 0; j < numA; j++) {
 			printf(αARR %dtDEP%dnα, arrA[j], depA[j]);
 		}*/
 
 		for(j = 0; j < numB; j++) {
 			fscanf(fin, α%d:%dα, &temp_hr, &temp_min);
 			depB[j] = temp_hr*60 + temp_min;
 			fscanf(fin, α%d:%dnα, &temp_hr, &temp_min);
 			arrB[j] = temp_hr*60 + temp_min + turn_arnd_time;
 		}
 
 		// sort arrivals and departures
 		bad_sort(depA, numA);
 		bad_sort(arrA, numA);
 		bad_sort(depB, numB);
 		bad_sort(arrB, numB);
 
 		// compare departures of B with arrivals of A and vice versa to get answer
 		
 		trainB_ctr = 0;
 		trainA_ctr = 0;
 		// for B
 		for(j = 0, k = 0; (j < numA) && (k < numB); k++) {
 			if(arrA[j] > depB[k]) {	// we need a new train
 				trainB_ctr++;
 			}
 			else {
 				j++;
 			}
 		}
 		while(k < numB) {
 			trainB_ctr++;
 			k++;
 		}
 		printf(αTrains from B: %dnα, trainB_ctr);
 		// for A
 		for(j = 0, k = 0; (j < numA) && (k < numB); j++) {
 			if(arrB[k] > depA[j]) { // we need a new train
 				trainA_ctr++;
 			}
 			else {
 				k++;
 			}
 		}
 		while(j < numA) {
 			trainA_ctr++;
 			j++;
 		}
 
 		// result
 		printf(αTrains from A: %dnα, trainA_ctr);
 
 		fprintf(fout, αCase #%d: %d %dnα, i+1, trainA_ctr, trainB_ctr);
 		free(depA);
 		free(arrA);
 		free(depB);
 		free(arrB);
 	}
 	fclose(fin);
 	fclose(fout);
 	return 0;
 }
 
 void bad_sort(int *arr, int num) 
 {
 	int i, j, temp;
 	if(num == 0)
 		return;
 	for(i = 0; i < num-1; i++) {
 		for(j = i+1; j < num; j++) {
 			if(arr[i] > arr[j]) {
 				temp = arr[i];
 				arr[i] = arr[j];
 				arr[j] = temp;
 			}
 		}
 	}
 
 	// verify
 	for(i = 0; i < num; i ++)
 		printf(α%dtα, arr[i]);
 	printf(αnα);
 }"
14562,2008,32013,Srikris,24480,1,GeneralHashFunctions.c,gcj/2008/32013/Srikris/24480/1/extracted/GeneralHashFunctions.c,"#include αGeneralHashFunctions.hα
 
 unsigned int RSHash(char* str, unsigned int len)
 {
    unsigned int b    = 378551;
    unsigned int a    = 63689;
    unsigned int hash = 0;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = hash * a + (*str);
       a    = a * b;
    }
 
    return hash;
 }
 /* End Of RS Hash Function */
 
 
 unsigned int JSHash(char* str, unsigned int len)
 {
    unsigned int hash = 1315423911;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash ^= ((hash << 5) + (*str) + (hash >> 2));
    }
 
    return hash;
 }
 /* End Of JS Hash Function */
 
 
 unsigned int PJWHash(char* str, unsigned int len)
 {
    const unsigned int BitsInUnsignedInt = (unsigned int)(sizeof(unsigned int) * 8);
    const unsigned int ThreeQuarters     = (unsigned int)((BitsInUnsignedInt  * 3) / 4);
    const unsigned int OneEighth         = (unsigned int)(BitsInUnsignedInt / 8);
    const unsigned int HighBits          = (unsigned int)(0xFFFFFFFF) << (BitsInUnsignedInt - OneEighth);
    unsigned int hash              = 0;
    unsigned int test              = 0;
    unsigned int i                 = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = (hash << OneEighth) + (*str);
 
       if((test = hash & HighBits)  != 0)
       {
          hash = (( hash ^ (test >> ThreeQuarters)) & (~HighBits));
       }
    }
 
    return hash;
 }
 /* End Of  P. J. Weinberger Hash Function */
 
 
 unsigned int ELFHash(char* str, unsigned int len)
 {
    unsigned int hash = 0;
    unsigned int x    = 0;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = (hash << 4) + (*str);
       if((x = hash & 0xF0000000L) != 0)
       {
          hash ^= (x >> 24);
       }
       hash &= ~x;
    }
 
    return hash;
 }
 /* End Of ELF Hash Function */
 
 
 unsigned int BKDRHash(char* str, unsigned int len)
 {
    unsigned int seed = 131; /* 31 131 1313 13131 131313 etc.. */
    unsigned int hash = 0;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = (hash * seed) + (*str);
    }
 
    return hash;
 }
 /* End Of BKDR Hash Function */
 
 
 unsigned int SDBMHash(char* str, unsigned int len)
 {
    unsigned int hash = 0;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = (*str) + (hash << 6) + (hash << 16) - hash;
    }
 
    return hash;
 }
 /* End Of SDBM Hash Function */
 
 
 unsigned int DJBHash(char* str, unsigned int len)
 {
    unsigned int hash = 5381;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = ((hash << 5) + hash) + (*str);
    }
 
    return hash;
 }
 /* End Of DJB Hash Function */
 
 
 unsigned int DEKHash(char* str, unsigned int len)
 {
    unsigned int hash = len;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash = ((hash << 5) ^ (hash >> 27)) ^ (*str);
    }
    return hash;
 }
 /* End Of DEK Hash Function */
 
 
 unsigned int BPHash(char* str, unsigned int len)
 {
    unsigned int hash = 0;
    unsigned int i    = 0;
    for(i = 0; i < len; str++, i++)
    {
       hash = hash << 7 ^ (*str);
    }
 
    return hash;
 }
 /* End Of BP Hash Function */
 
 
 unsigned int FNVHash(char* str, unsigned int len)
 {
    const unsigned int fnv_prime = 0x811C9DC5;
    unsigned int hash      = 0;
    unsigned int i         = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash *= fnv_prime;
       hash ^= (*str);
    }
 
    return hash;
 }
 /* End Of FNV Hash Function */
 
 
 unsigned int APHash(char* str, unsigned int len)
 {
    unsigned int hash = 0xAAAAAAAA;
    unsigned int i    = 0;
 
    for(i = 0; i < len; str++, i++)
    {
       hash ^= ((i & 1) == 0) ? (  (hash <<  7) ^ (*str) * (hash >> 3)) :
                                (~((hash << 11) + (*str) ^ (hash >> 5)));
    }
 
    return hash;
 }
 /* End Of AP Hash Function */"
14564,2008,32013,Srikris,24480,1,universe.c,gcj/2008/32013/Srikris/24480/1/extracted/universe.c,"#include<string.h>
 #include<stdio.h>
 #include<stdlib.h>
 #include αGeneralHashFunctions.hα
 
 typedef struct 
 {
 	char name[102];
 	struct SvrNode * next;
 	unsigned int hash;
 	unsigned int count;
 }SvrNode;
 
 typedef struct 
 {
 	SvrNode * head;	
 	SvrNode * last;
 }HashBkt;
 
 #define DPRINTF(args...)  
 
 main(int argc , char * argv[])
 {
 FILE * fp;
 int num_tests=0,num_servers=0,num_queries=0;
 int i,j,k,temp;
 char str1[101];
 char line[1000];
 HashBkt * table;
 int runlen_change_count = 0, max_runlength = 0, current_run = 0i,switch_count =0;
 
 if(argc !=2)
 	{
 	DPRINTF(αUsage %s <input-file>nα);
 	exit(2);
 	}
 fp = fopen(argv[1],αrα);
 if ( NULL == fp )
 	{
 	DPRINTF(αInput file not found . aborting nα);
 	exit(1);
 	}
 fgets(line,1000,fp);
 sscanf(line,α%dα,&num_tests);
 DPRINTF(α Number of test cases %dnα,num_tests);
 
 for (i=0; i < num_tests; i++)
 	{
 	fgets(line,1000,fp);
 	sscanf(line,α%dα,&num_servers);
 	DPRINTF(α Number of servers %d for case %dnα,num_servers,i+1);
 
 	table = malloc(sizeof(HashBkt) * num_servers);
 	memset(table,0,(sizeof(HashBkt) * num_servers));
 	switch_count = 0;
 
 	/* read server strings */
 	DPRINTF(αservers nα);
 	for (j=0; j< num_servers;j++)
 		{
 		unsigned int hashval,index;
 		SvrNode *svrPtr,*tempPtr;
 		
 		fgets(str1,101,fp);
 		str1[strlen(str1) - 1]='0';
 		hashval = JSHash(str1,strlen(str1));
 		index = hashval % num_servers;
                 
 		/*add the node to right bucket */
 		DPRINTF(αAdd server %s to bkt %d head=%d tail=%unα,str1,index,table[index].head,table[index].last);
 		svrPtr = malloc(sizeof(SvrNode));
 		if(svrPtr == NULL)
 			{
 			DPRINTF(αUnable to allocate memory.Abortingnα);
 			exit(3);
 			}
 		svrPtr->hash = hashval;
 		svrPtr->next = NULL;
 		strncpy(svrPtr->name,str1,100);
 		svrPtr->count = 0;
 		if(!table[index].last)
 			{
 			 table[index].head = svrPtr;
 			 table[index].last = svrPtr;
 			}
 		else
 			{
 			table[index].last->next = svrPtr;
 			table[index].last = svrPtr;
 			}
 		
 		DPRINTF(α%s %d hash=%dnα,str1,j+1,hashval);
 		}
 	
 	fgets(line,1000,fp);
 	sscanf(line,α%dα,&num_queries);
 	DPRINTF(α Number of queries%d for case %dnα,num_queries,i+1);
 
 	/* set max running length of queries to max value */
 	max_runlength = num_queries;
 	for(j=0;j<num_servers;j++)
 		{
 		 SvrNode *svrPtr,*tempPtr;
 
 		 svrPtr = table[j].head;
 
 		 while(svrPtr)
 		 	{
 			svrPtr->count = max_runlength;
 			svrPtr = svrPtr->next;
 			}
 		}
 
         runlen_change_count = num_servers;
 	current_run =0;
 	
 	/* read query strings */
 	DPRINTF(αquery nα);
 	for (j=0; j< num_queries;j++)
 		{
 		unsigned int hashval,index;
 		SvrNode  *svrPtr,*tempPtr;
 
 		fgets(str1,100,fp);
 		str1[strlen(str1) - 1]='0';
 		hashval = JSHash(str1,strlen(str1)) ;
 		DPRINTF(α%s %d hash=%dnα,str1,j+1,hashval);
 		current_run++;
 
 		index = hashval % num_servers;
 		svrPtr = table[index].head;
 		DPRINTF(α^^^^^^ index=%d head=%u last=%unα,index,table[index].head,table[index].last);
 		while(svrPtr)
 			{
 			DPRINTF(α@@@@@ %d @@@@α,svrPtr->hash);
 			if(svrPtr->hash == hashval)
 				{
 				/*server match */
 				DPRINTF(αsvrCnt=%d name=%s at %u max_run=%dnα,svrPtr->count,svrPtr->name,svrPtr,max_runlength);
 				if(svrPtr->count == max_runlength)
 					{
 					runlen_change_count--;
 					DPRINTF(αServer Match %s count=%d runlen=%dnα,svrPtr->name,svrPtr->count,runlen_change_count);
 					if(0 == runlen_change_count)
 						{
 						/*we need to swtich servers here and reset logic */
 						switch_count++;
 						//printf(αswitching off %s nα,svrPtr->name);
 
 						/*reset state machine */
 						max_runlength = num_queries - (j+1);
 						runlen_change_count = num_servers - 1;/*exclude chosen server */
 						current_run = 0;
 
 						for(k=0;k<num_servers;k++)
 							{
 							SvrNode *tempPtr;
 
 							tempPtr = table[k].head;
 							while(tempPtr)
 								{
 								tempPtr->count = max_runlength;
 								DPRINTF(αreset Server %s at %u  Max to %dnα,tempPtr->name,tempPtr,tempPtr->count);
 								tempPtr = tempPtr->next;
 								}
 							}
 						/*exclude chosen server from comparison */
 						svrPtr->count = 0;
 						break;
 						}
 					}
 				if(svrPtr->count > current_run)
 					{
 					svrPtr->count = current_run;
 					}
 				break;
 				}
 			else
 				{
 				svrPtr = svrPtr->next;
 				}
 			}
 		
 		}
 	
 	printf(αCase #%d: %d nα,i+1,switch_count);
 	
 	/* free allocated memory here*/
 	for(k=0;k< num_servers;k++)
 		{
 		SvrNode *svrPtr,*tempPtr;
 
 		svrPtr = table[k].head;
 		while(svrPtr)
 			{
 			tempPtr = svrPtr;
 			svrPtr = svrPtr->next;
 			free(tempPtr);
 			}
 		}
 	free(table);
 	}/* end of for loop over num_tests */
 fclose(fp);
 }"
14568,2008,32013,Srikris,24481,1,train.c,gcj/2008/32013/Srikris/24481/1/extracted/train.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
 typedef struct node
 {
  int hour;
  int min;
  int cum;
  struct node * next;
 }NODE;
 
 typedef struct list
 {
  	NODE * head;
 }LIST;
 
 #define DPRINTF(args...)
 
 static inline parse(char *str, NODE * A, NODE *B)
 {
 char start[10],finish[10];
 int th,tm;
 
 sscanf(str,α%d:%d %d:%dα,&A->hour,&A->min,&B->hour,&B->min);
 A->cum = A->hour * 60 + A->min;
 B->cum = B->hour * 60 + B->min;
 DPRINTF(αParsed %02d:%02d %02d:%02d nα,A->hour,A->min,B->hour,B->min);
 }
 
 /* insertion into sorted list */
 /* If time permits convert this to a binary tree */
 static inline int ins_list(LIST * l, NODE * node)
 {
 
 node->next = NULL;
 
 if(l->head == NULL)
 	{
 	l->head = node;
 	}
 else
 	{
 	NODE *ptr,*prev;
 
 	ptr = l->head;
 	prev = NULL;
 	while ( ptr && (node->cum > ptr->cum))
 		{
 		prev = ptr;
 		ptr = ptr->next;
 		}
 	if(prev == NULL)
 		{
 		/* add node at the head */
 		node->next = l->head;
 		l->head = node ;
 		}
 	else
 		{
 		node->next = prev->next;
 		prev->next = node;
 		}
 	
 	}
 }
  
 LIST a_dep={0},b_arr={0},b_dep={0},a_arr={0};
 main(int argc , char * argv[])
 {
 FILE * fp;
 int i,j,k,temp;
 unsigned int num_tests = 0,delay=0;
 unsigned int a2bcnt=0,b2acnt=0;
 char str1[101];
 char line[1000];
 NODE * freeList,*freehead;
 NODE * aPtr,*dPtr;
 unsigned int acnt,bcnt;
 
 if(argc !=2)
 	{
 	DPRINTF(αUsage %s <input-file>nα);
 	exit(2);
 	}
 
 fp = fopen(argv[1],αrα);
 if ( NULL == fp )
 	{
 	DPRINTF(αInput file not found . aborting nα);
 	exit(1);
         }
 fgets(line,1000,fp);
 sscanf(line,α%dα,&num_tests);
 DPRINTF(α Number of test cases %dnα,num_tests);
 
 for (i=0; i < num_tests; i++)
         {
 	acnt = bcnt = 0;
 	fgets(line,1000,fp);
         sscanf(line,α%dα,&delay);
 
 	DPRINTF(α Turn around time =  %d nα,delay);
 	
 	fgets(line,1000,fp);
         sscanf(line,α%d %dα,&a2bcnt,&b2acnt);
 
 	DPRINTF(αa2bcnt= %d  b2acnt=%dnα,a2bcnt,b2acnt);
 
 	/*allocate memory for nodes: one Node per time elem */
 	freehead = (NODE*)calloc(((a2bcnt+b2acnt)*2),sizeof(NODE));
 	freeList = freehead;
 
 	for(j=0;j<a2bcnt;j++)
 		{
 		NODE *aNode, *bNode;
 		
 		fgets(line,1000,fp);
 		aNode = freeList++;
 		bNode = freeList++;
 		parse(line,aNode,bNode);
 		ins_list(&a_dep,aNode);
 		ins_list(&b_arr,bNode);
 		}
 	
 	for(j=0;j<b2acnt;j++)
 		{
 		NODE *aNode, *bNode;
 
 		fgets(line,1000,fp);
 		aNode = freeList++;
 		bNode = freeList++;
 		parse(line,aNode,bNode);
 		ins_list(&b_dep,aNode);
 		ins_list(&a_arr,bNode);
 		}
 			
 	{
 	NODE *ptr;
 	ptr = a_dep.head;
 	DPRINTF(αA departure list..nα);
 	while(ptr)
 		{
 		DPRINTF(α%d:%d->α,ptr->hour,ptr->min);
 		ptr = ptr->next;
 		}
 	DPRINTF(αnα);
 	}
 
 	/* run through A departure list and compate against arrival list */
 	dPtr = a_dep.head;
 	aPtr = a_arr.head;
 	while(dPtr)
 		{
 		if( (aPtr) && ( (aPtr->cum + delay) <= dPtr->cum) )
 			{
 			aPtr = aPtr->next;
 			}
 		else
 			{
 			acnt++;
 			}
 		dPtr = dPtr->next;
 		}
 	
 	/* run through B departure list and compare against arr list */
 	dPtr = b_dep.head;
 	aPtr = b_arr.head;
 	while(dPtr)
 		{
 		if( (aPtr) && ( (aPtr->cum + delay) <= dPtr->cum) )
 			{
 			aPtr = aPtr->next;
 			}
 		else
 			{
 			bcnt++;
 			}
 		dPtr = dPtr->next;
 		}
 	
 	printf(αCase #%d: %d %d nα,i+1,acnt,bcnt);
 
 	/* clean up and start all over again */
 	free(freehead);
 	freeList = NULL;
 	a_dep.head = a_arr.head = b_dep.head = b_arr.head = 0;
 	
 	}
 
 }"
14583,2008,32013,sszymczy,24479,1,fs.c,gcj/2008/32013/sszymczy/24479/1/extracted/fs.c,"#include <stdio.h>
 #include <math.h>
 
 #define PI 3.14159265358979323846
 
 double d(double x, double y) {
 	return sqrt(x * x + y * y);
 }
 
 double coord(double r, double x) {
 	return sqrt(r * r - x*x);
 }
 
 double right_triangle_area(double x1, double y1, double x2, double y2) {
 	return 0.5*(x2-x1)*(y2-y1);
 }
 
 double circular_segment_area(double r, double x1, double y1, double x2, double y2) {
 	double h = d(x1-x2, y1-y2);
 	double sina = 0.5*h/r;
 	double angle = 2.0*asin(sina);
 	double area = 0.5*r*r*(angle-sin(angle)); 
 	return area;
 }
 
 double rectangle_area(double x1, double y1, double x2, double y2) {
 	return (x2-x1)*(y2-y1);
 }
 
 int main() {
 	unsigned ncases;
 	scanf(α%unα, &ncases);
 	for(unsigned ncase = 1; ncase <= ncases; ncase++) {
 		double f, R, t, r, g, p = 0, x, y;
 		scanf(α%lf %lf %lf %lf %lfnα, &f, &R, &t, &r, &g);
 		f = f / R;
 		t = t / R;
 		r = r / R;
 		g = g / R;
 		R = 1.0;
 
 		if(g <= 2*f) p = 1.0;
 		else {
 			for(x = r; x < R-t; x += g+2.0*r) {
 				for(y = r; y < R-t; y += g+2.0*r) {
 					if(d(x+f,y+f)+f < R-t) {
 						if(d(x+g-f,y+g-f)+f <= R-t) {
 							/* Empty space inside racket */
 							p += (g-2*f)*(g-2*f);
 						} else {
 							/* Empty space partially inside racket */
 							if(d(x+f,y+g-f)+f >= R-t && d(x+g-f,y+f)+f >= R-t) {
 								/* both corners outside inner circle 
 								 * simplest to compute, area = triangle + circular segment */
 								double ty = coord(R-t-f,x+f);
 								double tx = coord(R-t-f,y+f);
 								p += right_triangle_area(x+f, y+f, tx, ty);
 								p += circular_segment_area(R-t-f, x+f, ty, tx, y+f);
 							} else if(d(x+f,y+g-f)+f >= R-t) {
 								/* top left corner outside inner circle 
 								 * area = rectangle + triangle + circular segment */
 								double ty1 = coord(R-t-f,x+f);
 								double ty2 = coord(R-t-f,x+g-f);
 								p += right_triangle_area(x+f, ty2, x+g-f, ty1);
 								p += rectangle_area(x+f, y+f, x+g-f, ty2);
 								p += circular_segment_area(R-t-f, x+f, ty1, x+g-f, ty2);
 
 							} else if(d(x+g-f,y+f)+f >= R-t) {
 								/* bottom right corner outside inner circle 
 								 * area = rectangle + triangle + circular segment */
 								double tx1 = coord(R-t-f, y+f);
 								double tx2 = coord(R-t-f, y+g-f);
 								p += right_triangle_area(tx2, y+f, tx1, y+g-f);
 								p += rectangle_area(x+f, y+f, tx2, y+g-f);
 								p += circular_segment_area(R-t-f, tx1, y+f, tx2, y+g-f);
 							} else {
 								/* only top right corner outside inner circle
 								 * triangle + 3 rectangles */
 								double tx = coord(R-t-f, y+g-f);
 								double ty = coord(R-t-f, x+g-f);
 								p += rectangle_area(x+f, y+f, tx, ty);
 								p += rectangle_area(x+f, ty, tx, y+g-f);
 								p += rectangle_area(tx, y+f, x+g-f, ty);
 								p += right_triangle_area(tx, ty, x+g-f, y+g-f);
 								p += circular_segment_area(R-t-f, tx, y+g-f, x+g-f, ty);
 							}
 						}
 					}
 				}
 			}
 			p *= 4.0;
 			p /= PI*R*R;
 			p = 1.0 - p;
 		}
 		printf(αCase #%u: %.6lfnα, ncase, p);
 	}
 }"
14585,2008,32013,sszymczy,24481,1,tt.c,gcj/2008/32013/sszymczy/24481/1/extracted/tt.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define DEBUG 0
 
 struct event {
 	unsigned time;
 	unsigned type;
 	unsigned station;
 };
 
 enum { DEPARTURE, READY };
 enum { A, B };
 
 void store_event(struct event *e, unsigned time, unsigned type, unsigned station) {
 	e->time = time;
 	e->type = type;
 	e->station = station;
 }
 
 int comparator(const void *e1, const void *e2) {
 	struct event *event1 = (struct event*) e1;
 	struct event *event2 = (struct event*) e2;
 	if(event1->time < event2->time) return -1;
 	else if(event1->time > event2->time) return 1;
 	else {
 		/* READY events before DEPARTURE events */
 		if(event1->type == READY && event2->type == DEPARTURE) return -1;
 		else if(event1->type == DEPARTURE && event2->type == READY) return 1;
 		else return 0;
 	}
 }
 
 void print_event(struct event *e) {
 	printf(αe time: %d, type: %s, station: %cnα, e->time, (e->type==DEPARTURE?αDEPARTUREα:αREADYα), (e->station==A?'A':'B'));
 }
 
 int main() {
 	unsigned ncases;
 	scanf(α%unα, &ncases);
 	for(unsigned ncase = 1; ncase <= ncases; ncase++) {
 		unsigned turntime, nabtrips, nbatrips;
 		scanf(α%unα, &turntime);
 		scanf(α%u %unα, &nabtrips, &nbatrips);
 		struct event events[2 * nabtrips + 2 * nbatrips];
 		unsigned nevents = 0;
 		for(int atrip = 0; atrip < nabtrips; atrip++) {
 			unsigned dh, dm, ah, am;
 			scanf(α%u:%u %u:%unα, &dh, &dm, &ah, &am);
 			store_event(&events[nevents++], dh * 60 + dm, DEPARTURE, A);
 			store_event(&events[nevents++], ah * 60 + am + turntime, READY, B);
 		}
 		for(int btrip = 0; btrip < nbatrips; btrip++) {
 			unsigned dh, dm, ah, am;
 			scanf(α%u:%u %u:%unα, &dh, &dm, &ah, &am);
 			store_event(&events[nevents++], dh * 60 + dm, DEPARTURE, B);
 			store_event(&events[nevents++], ah * 60 + am + turntime, READY, A);
 		}
 		qsort(events, nevents, sizeof(struct event), comparator);
 		unsigned trains_needed[2] = { 0, 0 };
 		unsigned trains_ready[2] = { 0, 0 };
 		for(int nevent = 0; nevent < nevents; nevent++) {
 			if(DEBUG) printf(αA ready: %u, B ready: %u, A needed: %u, B needed: %unα, trains_ready[0], trains_ready[1], trains_needed[0], trains_needed[1]);
 			struct event *e = &events[nevent];
 			if(DEBUG) print_event(e);
 			if(e->type == READY) trains_ready[e->station]++;
 			if(e->type == DEPARTURE) {
 				if(trains_ready[e->station] > 0) trains_ready[e->station]--;
 				else trains_needed[e->station]++;
 			}
 		}
 		printf(αCase #%u: %u %unα, ncase, trains_needed[0], trains_needed[1]);
 	}
 }"
14685,2008,32013,matheuslin,24480,1,SaveTheUniverse.c,gcj/2008/32013/matheuslin/24480/1/extracted/SaveTheUniverse.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 void removeenter(char *s){
 	int i = 0;
 	while(s[i] != 'n' && s[i] != 0) i++;
 	s[i] = 0;
 }
 
 void reset(int vect[103]){
 	int i;
 	for(i = 0; i < 103; i++){
 		vect[i] = 0;
 	}
 }
 
 int howManySwitches(char SE[][103], char Q[][103], int s, int q){
 	int boomvect[103];
 	int boom, ns;
 	int i, j;
 
 	reset(boomvect);
 	ns = 0;
 	j = 0;
 	boom = 0;
 
 	while(j < q){
 		for(i = 0; i < s; i++){
 			if(boomvect[i] == 0 && (strcmp(Q[j], SE[i]) == 0)){
 				boomvect[i] = 1;
 				boom++;
 			}
 		}
 		if(boom == s){
 			ns++;
 			reset(boomvect);
 			boom = 1;
 			for(i = 0; i < s; i++){
 				if(boomvect[i] == 0 && (strcmp(Q[j], SE[i]) == 0)){
 					boomvect[i] = 1;
 				}
 			}
 
 		}
 		j++;
 	}
 
 	return ns;
 }
 
 int main()
 {
 	FILE *in, *out;
 
 	char line[103];
 	int n, i, j, sn;
 	int s, q;
 	char SE[103][103], Q[1003][103];
 
 	printf(αinput file: α);
 	scanf(α%sα, &line);
 
 	in = fopen(line, αrα);
 	while(!in){
 		printf(αmissing file. Try again!ninput file: α);
 		scanf(α%sα, &line);
 		in = fopen(line, αrα);
 	}
 
 	strcat(line, α_outα);
 	out = fopen(line, αwα);
 
 	fgets(line, 103, in);
 	sscanf(line, α%dα, &n);
 
 	i = 1;
 	while(i <= n){
 		fgets(line, 103, in);
 		sscanf(line, α%dα, &s);
 		j = 0;
 		while(j < s){
 			fgets(line, 103, in);
 			strcpy(SE[j], line);
 			j++;
 		}
 		fgets(line, 103, in);
 		sscanf(line, α%dα, &q);
 		j = 0;
 		while(j < q){
 			fgets(line, 103, in);
 			strcpy(Q[j], line);
 			j++;
 		}
 
 		sn = howManySwitches(SE, Q, s, q);
 		fprintf(out, αCase #%d: %dnα, i, sn);
 
 		i++;
 	}
 	return 0;
 
 }"
14687,2008,32013,matheuslin,24481,1,TrainTimetable.c,gcj/2008/32013/matheuslin/24481/1/extracted/TrainTimetable.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 void update(int *h, int *m, int t){
 	(*h) += ((*m) + t) / 60;
 	(*m) = ((*m) + t) % 60;
 }
 
 
 typedef struct{
 	char io; /*0 = ready to leave, 1 = leave*/
 	int h, m;
 }stamp;
 
 
 void sort(stamp A[203], int n){
 
 	int i, j;
 	stamp aux;
 	for(i = 1; i < n; i++){
 		if((A[i].h < A[i-1].h) || ((A[i].h == A[i-1].h) && (A[i].m <= A[i-1].m))) {
 			/*Exchange*/
 			j = i;
 			aux = A[i];
 			while((j > 0) && ((aux.h < A[j-1].h) || ((aux.h == A[j-1].h) && (aux.m < A[j-1].m)))) {
 				A[j] = A[j-1];
 				j--;
 			}
 			while((j > 0) && (aux.h == A[j-1].h) && (aux.m == A[j-1].m) && (aux.io < A[j-1].io)) {
 				A[j] = A[j-1];
 				j--;
 			}
 			A[j] = aux;
 		}
 	}
 }
 
 int analyze(stamp A[203], int k){
 	int n = 0, i, need = 0;
 
 	for(i = 0; i < k; i++){
 		if(A[i].io == 0){
 			n++;
 		}
 		else if(A[i].io == 1){
 			if(n > 0){
 				n--;
 			}
 			else{
 				need++;
 			}
 		}
 	}
 
 	return need;
 }
 
 
 int main(){
 	int t, na, nb, n, i, j, k, ta, tb;
 	stamp A[203], B[203];
 	char line[40];
 	FILE *in, *out;
 
 	printf(αinput file: α);
 	scanf(α%sα, line);
 	in = fopen(line, αrα);
 	while(!in){
 		printf(αMissing input file. Try again!nα);
 		printf(αinput file: α);
 		scanf(α%sα, line);
 		in = fopen(line, αrα);
 	}
 
 	strcat(line, α_outα);
 	out = fopen(line, αwα);
 
 	fgets(line, 40, in);
 	sscanf(line, α%dα, &n);
 	for(i = 1; i <= n; i++){
 		fgets(line, 40, in);
 		sscanf(line, α%dα, &t);
 		fgets(line, 40, in);
 		sscanf(line, α%d %dα, &na, &nb);
 		k = 0;
 
 		for(j = 0; j < na; j++){
 			fgets(line, 40, in);
 			sscanf(line, α%d:%d %d:%dα, &A[k].h, &A[k].m, &B[k].h, &B[k].m);
 			update(&B[k].h, &B[k].m, t);
 			A[k].io = 1;
 			B[k].io = 0;
 			k++;
 		}
 
 		for(j = 0; j < nb; j++){
 			fgets(line, 40, in);
 			sscanf(line, α%d:%d %d:%dα, &B[k].h, &B[k].m, &A[k].h, &A[k].m);
 			update(&A[k].h, &A[k].m, t);
 			B[k].io = 1;
 			A[k].io = 0;
 			k++;
 		}
 		sort(A, k);
 
 		sort(B, k);
 
 		ta = analyze(A, k);
 		tb = analyze(B, k);
 
 		fprintf(out, αCase #%d: %d %dnα, i, ta, tb);
 
 	}
 
 	fclose(in);
 	fclose(out);
 
 	return 0;
 }"
14860,2008,32013,jovimon,24480,1,world.c,gcj/2008/32013/jovimon/24480/1/extracted/world.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int ncasos, nbusc, nquery;
 char busca[102][105];
 char query[1001][105];
 int visitados[102];
 int faltan_visitar;
 int cambios;
 
 void imprime() {
   int i;
   printf(αBuscadores %d: nα, nbusc);
   for (i = 0 ; i < nbusc ; i++) {
     printf(α%snα, busca[i]);
   }
 
   printf(αQueries %d: nα, nquery);
   for (i = 0 ; i < nquery ; i++) {
     printf(α%snα, query[i]);
   }
 
 }
 
 void inicializa_visitados() {
   int i;
   for( i = 0 ; i < nbusc ; i++ ) 
     visitados[i] = 0;
   cambios++;
   faltan_visitar = nbusc;
 }
 
 int posicion(char * query) {
   int i;
   for( i = 0 ; i < nbusc ; i++ ) {
     if (!strcmp(query, busca[i]))
       return i;
   }
 }
 
 
 int main (int argc, char * argv []) {
 
   int i, j, k, pos_act;
 
   scanf(α%dnα, &ncasos);
 
   for( i = 0 ; i < ncasos ; i++ ) {
     
     scanf(α%dnα, &nbusc);
     
     for(j = 0 ; j < nbusc ; j++ ) 
       fgets(busca[j], 104, stdin);
     
     scanf(α%dnα, &nquery);
 
     for(j = 0 ; j < nquery ; j++ ) 
       fgets(query[j], 104, stdin);
 
     /* Fichero leido. */
 
     /*  imprime(); */
 
     cambios = -1;
     inicializa_visitados();
 
     for ( k = 0 ; k < nquery ; k++ ) {
       pos_act = posicion(query[k]);
       if (!visitados[pos_act]) {
 	if (faltan_visitar > 1) {
 	  visitados[pos_act] = 1;
 	  faltan_visitar--;
 	} else {
 	  inicializa_visitados();
 	  k--;
 	}
       }
     }
 
     printf(αCase #%d: %dα, i + 1, cambios);
     if (i < ncasos - 1) printf(αnα);
 
   }
 
 
   return 0;
 }"
14914,2008,32013,bssr,24480,1,search_engine.c,gcj/2008/32013/bssr/24480/1/extracted/search_engine.c,"#include<stdlib.h>
 #include<string.h>
 int getInd(char SE[][102], char *E, int len)
 {
    int i;
    for(i=0;i<len;i++)
    {
      if(strcmp(SE[i],E)==0)
        return i;
    }
    return 0;
 }
 main()
 {
   int N,S,Q,i,j,inp[1001];
   int cnt=0,swt=0;
   char se[101][102],str[102],arr[101]={0};
   scanf(α%dα,&N);
   for(i=0;i<N;i++)
   {
     scanf(α%dα,&S);
     //printf(αS=%d:nα,S);
     for(j=0;j<S;j++)
     {
       getchar();
       scanf(α%[A-Za-z0-9 ]α,se[j]);
     //printf(α%s:nα,se[j]);
     }
     scanf(α%dα,&Q);
     //printf(αQ=%d:nα,Q);
     for(j=0;j<Q;j++)
     {
       getchar();
       scanf(α%[A-Za-z0-9 ]α,str);
     //printf(α%s:nα,str);
       inp[j] = getInd(se,str,S);
     }
     cnt=0,swt=0;
     memset(arr,0,S+1);
     for(j=0;j<Q;j++)
     {
       if(arr[inp[j]] == 0)
       {
         cnt++;
         if(cnt == S)
         {
           swt++;
           memset(arr,0,S+1);
           cnt = 1;
         }
         arr[inp[j]] = 1;
       }
     }
     printf(αCase #%d: %dnα,i+1,swt);
   }
   return 0;
 }"
14916,2008,32013,bssr,24481,1,train.c,gcj/2008/32013/bssr/24481/1/extracted/train.c,"#include<stdlib.h>
 int compare(const void *a,const void *b)
 {
   return *((int*)a)-*((int*)b);
 }
 main()
 {
   int N,NA,NB,T,i,j,k,x,y,acnt,bcnt,ru;
   int A[102],B[102],A1[102],B1[102];
   scanf(α%dα,&N);
   for(i=0;i<N;i++)
   {
     scanf(α%dα,&T);
     scanf(α%dα,&NA);
     scanf(α%dα,&NB);
     for(j=0;j<NA;j++)
     {
       scanf(α%d:%dα,&x,&y);
       A[j] = x*60+y;
       scanf(α%d:%dα,&x,&y);
       A1[j] = x*60+y;
     }
     for(j=0;j<NB;j++)
     {
       scanf(α%d:%dα,&x,&y);
       B[j] = x*60+y;
       scanf(α%d:%dα,&x,&y);
       B1[j] = x*60+y;
     }
     qsort(A,NA,sizeof(int),compare);
     qsort(A1,NA,sizeof(int),compare);
     qsort(B,NB,sizeof(int),compare);
     qsort(B1,NB,sizeof(int),compare);
     acnt = 0,ru=0;
     for(j=0,k=0;j<NA;j++)
     {
       for(;k<NB && (B1[k]+T)<=A[j];k++,ru++) ;
       if(ru>0)
         ru--;
       else
         acnt++;
     }
     bcnt = 0,ru=0;
     for(j=0,k=0;j<NB;j++)
     {
       for(;k<NA && (A1[k]+T)<=B[j];k++,ru++) ;
       if(ru>0)
         ru--;
       else
         bcnt++;
     }
     printf(αCase #%d: %d %dnα,i+1,acnt,bcnt);
   }
   return 0;
 }"
14984,2008,32013,Wess,24480,1,ej01.c,gcj/2008/32013/Wess/24480/1/extracted/ej01.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
 #define TAM_LINE 255
 
 int stringHash(char *);
 int min(int *, int, int);
 
 int main(int argc, char *argv[]) {
 
   char aux[TAM_LINE], **search_eng; FILE *fl;
   int i, j, k, nsearch_eng, nqueries, ntest, mn, resg = 0, *vector;;
 
   fl = fopen(argv[1], αrα);
 
   fgets(aux, TAM_LINE, fl);
   sscanf(aux, α%dα, &ntest);
 
   for(i = 0; i < ntest; i++) {
 
     fgets(aux, TAM_LINE, fl);
     sscanf(aux, α%dα, &nsearch_eng);
 
     search_eng = (char **) malloc(sizeof(char *) * nsearch_eng);
     vector = (int *) calloc(nsearch_eng, sizeof(int));
 
     for(j = 0; j < nsearch_eng; j++) {
       search_eng[j] = (char *) malloc(sizeof(char) * TAM_LINE);
       fgets(aux, TAM_LINE, fl); strcpy(search_eng[j], aux);
     }
 
     fgets(aux, TAM_LINE, fl);
     sscanf(aux, α%dα, &nqueries);
 
     if(nqueries > 0) {
       fgets(aux, TAM_LINE, fl);
       for(j = 0; j < nsearch_eng; j++)
         if(!strcmp(search_eng[j], aux)) vector[j] = nqueries + 1;
     }
 
     for(k = 1; k < nqueries; k++) {
       fgets(aux, TAM_LINE, fl);
 
       for(j = 0; j < nsearch_eng; j++)
         if(!strcmp(search_eng[j], aux)) resg = j;
         else vector[j] = min(vector, nsearch_eng, j);
       vector[resg] = nqueries + 1;
     }
 
     mn = vector[0];
     for(j = 0; j < nsearch_eng; j++) 
       if(vector[j] < mn) mn = vector[j];
 
     printf(αCase #%d: %dnα, (i+1), mn);
 
     //free(vector);
     //free(search_eng);
   }
 
   fclose(fl);
   return 0;
 }
 
 int min(int *vector, int limit, int pos) {
   int i, min;
 
   if(pos == 0) min = vector[0];
   else min = vector[0] + 1;
 
   for(i = 0; i < limit; i++)
     if((vector[i] + 1) < min && i != pos)  min = vector[i] + 1;
     else if(vector[i]  < min && i == pos) min = vector[i];
 
   return min;
 }
 
 int stringHash(char *string) {
   int i, j, k, value;
 
   j = strlen(string);
   for(i = 0, value = 0, k = 1; i < j; i++, k *= 10) value += (string[i] * k);
   return value;
 }"
14986,2008,32013,vmpstr,24480,1,A.c,gcj/2008/32013/vmpstr/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 int main(void)
 {
 	int cases, neng, cneng, nq, i, j, k, kk;
 	char eng[200][105], q[105];
 	int place[200] = {0};
 	int switches, restricted=-1;
 
 	scanf(α%dnα, &cases);
 	for(i=0; i<cases; i++)
 	{
 		scanf(α%dnα, &neng);
 		for(j=0; j<neng; j++)
 		{
 			fgets(eng[j], sizeof(eng[j]), stdin);
 			eng[j][strcspn(eng[j], αnrα)] = 0;
 			
 		}
 		scanf(α%dnα, &nq);
 		switches = 0;
 		cneng = 0;
 		for(j=0; j<200; j++)
 		{
 			place[j] = 0;
 		}
 		for(j=0; j<nq; j++)
 		{
 			fgets(q, sizeof q, stdin);
 			q[strcspn(q, αrnα)] = 0;
 			for(k=0; k<neng; k++)
 			{
 				if(strcmp(q, eng[k]) == 0)
 				{
 					if(place[k] == 0)
 					{
 						place[k] = j+1;
 						cneng++;
 						if(cneng == neng)
 						{
 							switches++;
 							for(kk=0; kk<200; kk++)
 							{
 								place[kk] = 0;
 							}
 							place[k] = j+1;
 							cneng = 1;
 							break;
 						}
 					}
 					break;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα, i+1, switches);
 	}
 	return 0;
 }"
14988,2008,32013,vmpstr,24481,1,B.c,gcj/2008/32013/vmpstr/24481/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 
 int main(void)
 {
 	int cases, turn, na, nb;
 	int atrain, btrain;
 	int a[101][2];
 	int b[101][2];
 	int i, j, t1, t2, cur, curp, curpick;
 	
 	scanf(α%dnα, &cases);
 	for(i=0; i<cases; i++)
 	{
 		atrain = btrain = 0;
 		scanf(α%dnα, &turn);
 		scanf(α%d %dnα, &na, &nb);
 		for(j=0; j<na; j++)
 		{
 			scanf(α%d:%d α, &t1, &t2);
 			a[j][0] = t1*60 + t2;
 			
 			scanf(α%d:%dnα, &t1, &t2);
 			a[j][1] = t1*60 + t2;
 
 		}
 		for(j=0; j<nb; j++)
 		{
 			scanf(α%d:%d α, &t1, &t2);
 			b[j][0] = t1*60 + t2;
 		
 			scanf(α%d:%dnα, &t1, &t2);
 			b[j][1] = t1*60 + t2;
 
 		}
 		for(;;)
 		{
 			cur = 1e6;
 			curp = -1;
 			curpick = -1;
 			for(j=0; j<na; j++)
 			{
 				if(a[j][0] < cur)
 				{
 					cur = a[j][0];
 					curp = j;
 					curpick = 'a';
 				}
 			}
 			for(j=0; j<nb; j++)
 			{
 				if(b[j][0] < cur)
 				{
 					cur = b[j][0];
 					curp = j;
 					curpick = 'b';
 				}
 			}
 			if(curp < 0)
 			{
 				break;
 			}
 			if(curpick == 'a')
 			{
 				atrain++;
 				cur = a[curp][1]+turn;
 				a[curp][0] = a[na-1][0];
 				a[curp][1] = a[na-1][1];
 				na--;
 				curpick = 'b';
 
 			}
 			else if(curpick == 'b')
 			{
 				btrain++;
 				cur = b[curp][1]+turn;
 				b[curp][0] = b[nb-1][0];
 				b[curp][1] = b[nb-1][1];
 				nb--;
 				curpick = 'a';
 
 			}
 			
 			for(;;)
 			{
 				int newcur = 1e6;
 				if(curpick == 'a')
 				{
 					for(j=0; j<na; j++)
 					{
 						if((a[j][0] >= cur) &&
                                                    (a[j][0] < newcur))
 						{
 							newcur = a[j][0];
 							curp = j;
 						}
 					}
 					if(newcur < 1e6)
 					{
 						cur = a[curp][1]+turn;
 						a[curp][0] = a[na-1][0];
 						a[curp][1] = a[na-1][1];
 						na--;
 						curpick = 'b';
 								
 					}
 					else break;
 				}
 				newcur = 1e6;
 				if(curpick == 'b')
 				{
 					for(j=0; j<nb; j++)
 					{
 						if((b[j][0] >= cur) &&
                                                    (b[j][0] < newcur))
 						{
 							newcur = b[j][0];
 							curp = j;
 						}
 					}
 					if(newcur < 1e6)
 					{
 						cur = b[curp][1]+turn;
 						b[curp][0] = b[nb-1][0];
 						b[curp][1] = b[nb-1][1];
 						nb--;
 						curpick = 'a';
 					}
 					else break;
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα, i+1, atrain, btrain);
 	}
 	return 0;
 }"
14995,2008,32013,abhishobhit,24480,1,SaveUniverse.c,gcj/2008/32013/abhishobhit/24480/1/extracted/SaveUniverse.c,"#include <stdlib.h>
 #include <stdio.h>
 
 
 typedef struct _Server
 {
 	char servername[102];
 	int flag;
 } Server;
 
 // main start
 
 int main(int argc , char *argv[])
 {
 	FILE *ifp;
 
 	int i,j,k,l,ncase,nserver,nswitch=0,nq,count;
 	char querry[102];
 	if(argc != 2)
 	{
 		printf(αError:nα);
 		printf(αUsage: filename <input file>nα);
 		printf(αExample: A-small.out A-small.innα);
 		exit(1);
 	}
 	ifp = fopen(argv[1] , αrα);
 	if( ifp == NULL )
 	{
 		printf(αerror in opening fileα);
 	}
 
 	// Read from the file 
 	
 	fscanf(ifp,α%dα,&ncase);
 	Server *sname = NULL;
 	for(i = 0; i < ncase ; i++)
 	{
 		fscanf(ifp,α%dα,&nserver);
 		fgetc(ifp);
 		sname = (Server *) calloc(nserver,sizeof(Server));
 		//. create memory for server names
 		nswitch=0;
 		count=nserver;
 		for( j = 0 ; j < nserver ;j++)
 		{
 			
 			fgets(sname[j].servername,101,ifp);
 			sname[j].flag = 0;
 		}
 
 		fscanf(ifp,α%dα,&nq);
 		fgetc(ifp);
 		for( j = 0 ; j < nq ; j++)
 		{
 			fgets(querry,101,ifp);
 						
 			for(k = 0 ; k < nserver ; k++)
 			{
 				if(strcmp(querry,sname[k].servername) == 0)
 				{
 					if(sname[k].flag==0)
 					{
 						sname[k].flag++;
 						count--;
 						if(count==0)
 						{
 							nswitch++;
 							count = nserver-1;
 							for(l=0;l<nserver;l++)
 							{
 								if(l!=k)
 								{
 									sname[l].flag = 0;
 								}
 							}
 							
 						}
 					}
 					
 					break;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα,i+1,nswitch); 
 		free(sname);
 	}
 	return 0;
 }"
15001,2008,32013,chaitany,24480,1,save_universe.c,gcj/2008/32013/chaitany/24480/1/extracted/save_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 int N;
 
 
 void update_indices(int S, int Q, int cur_q_index, char** search_engines, char** Queries, int* s_indices )
 {
 	int j;
 			for(j=0;j<S;j++)
 	 		{
 
 			int k;
 				
 			//printf(α n *** CheckingB4 Updating index %s isequalto = %d cur_Q %d *** n α,search_engines[j],s_indices[j],cur_q_index);
 			if(s_indices[j] <= cur_q_index)
 			{
 				s_indices[j] = -1;
 			
 				for (k = cur_q_index+1; k < Q;k++)
 				{
 					if(strcmp(search_engines[j],Queries[k]) == 0 )
 					{
 						s_indices[j] = k;
 
 						//printf(α n *** Updating index %s isequalto = %d *** n α,search_engines[j],s_indices[j]);
 						break;
 					}
 				}
 			}
 
 			}
 
 
 }
 
 int get_max_forward_edge_searchindex(int S, int* s_indices,int curr_index)
 {
 	int max_till_now = -2;
 	int index_till_now = 0;
 	int j;
 
 	for(j=0;j<S;j++)
 	{
 		if(j == curr_index) {continue;}
 		if(s_indices[j] == -1) {return j;}
 		if(s_indices[j] > max_till_now)
 		{
 			max_till_now = s_indices[j];
 			index_till_now = j;
 		}
 	}
 
 	return index_till_now;
 }
 
 
 int main(int argc, char** argv)
 {
   FILE* inpfile;
   int i;
 	 char* chumma_string;
 	 int len;
 
 	 chumma_string = (char*) malloc(1000);
 	
   inpfile = fopen(argv[1],αrα);
 	
   getline(&chumma_string,&len,inpfile);
 	 sscanf(chumma_string,α%dα,&N);
 
   for(i=0;i<N;i++)
   {
 	 char** search_engines;
 	 char** Queries;
 	 int cur_q_index = 0;
 	 int* s_indices;
 	 int S;
 	 int j,Q;
 	 int k;
 	 int min_switch_count = -1;
 
 
 	 getline(&chumma_string,&len,inpfile);
 	 sscanf(chumma_string,α%dα,&S);
 
 	 s_indices = (int*) malloc(sizeof(int)*S);
 
 	 search_engines = (char**) malloc(sizeof(char*)*S);
 	 for(j=0;j<S;j++)
 	 {
 
 		s_indices[j] = -1;
 		 search_engines[j] = (char*) malloc(sizeof(char)*100);
 		 //fscanf(inpfile,α%sα,search_engines[j]);
 		 getline(&search_engines[j],&len,inpfile);
 
     }
 		getline(&chumma_string,&len,inpfile);
 	 sscanf(chumma_string,α%dα,&Q);
 
 
 	 Queries = (char**) malloc(sizeof(char*)*Q);
 	 for(j=0;j<Q;j++)
 	 {
 		 Queries[j] = (char*) malloc(sizeof(char)*100);
 
 		 getline(&Queries[j],&len,inpfile);
 
 		 //fscanf(inpfile,α%sα,Queries[j]);
     }
 
 
 		for(j=0;j<S;j++)
 		{
 			int switch_count = 0;
 			int curr_search_engineindex = j;
 
 			 for(k=0;k<S;k++)
 			 {
 				s_indices[k] = -1;
 			 }
 
 //			update_indices(S,  Q, cur_q_index, search_engines, Queries,  s_indices );
 
 			for(k=0;k < Q; k++)
 			{
 				cur_q_index = k;
 
 				//printf(αchumma k %d j %d Se %s Qr %s cur_sw %dnα,k,j,search_engines[curr_search_engineindex],Queries[k],switch_count);
 
 				if(strcmp(search_engines[curr_search_engineindex],Queries[k]) == 0)
 				{
 					//Evict needed ...
 					//printf(αConflict found nα);
 					update_indices(S,  Q, cur_q_index, search_engines, Queries,  s_indices);
 					{
 						int temp = curr_search_engineindex;
 					curr_search_engineindex = get_max_forward_edge_searchindex(S,s_indices,curr_search_engineindex);
 					if (temp != curr_search_engineindex) {
 						//printf(αIncrementing switch countnα);
 						switch_count++;
 					}
 					}
 				}
 			}
 			
 
 			if(min_switch_count == -1) {min_switch_count = switch_count;}
 			else if(switch_count < min_switch_count) {min_switch_count = switch_count;}
 		}
 
 		printf(αCase #%d: %dnα,i+1,min_switch_count);
 
 	 //Deallocation ...............
 
 	 for(j=0;j<S;j++)
 	 {
 		 free(search_engines[j]);
 	 }
 	 free(search_engines);
 	 for(j=0;j<Q;j++)
 	 {
 		 free(Queries[j]);
 	 }
 	 free(Queries);
 
 
 
   }
 }"
15029,2008,32013,mmxd,24481,1,b.c,gcj/2008/32013/mmxd/24481/1/extracted/b.c,"#include <stdio.h>
 #define MAX 1600
 int main() {
     int i, j, N, NA, NB, T, sH, sM, tH, tM, M;
     int A, B;
     int Aneed[MAX], Ahave[MAX], Bneed[MAX], Bhave[MAX];
     int AhaveNow, BhaveNow;
     scanf(α%dα, &N);
     for(i = 1; i <= N; i++) {
 	A = 0, B = 0;
 	AhaveNow = 0, BhaveNow = 0;
 	for(j = 0; j < MAX; j++) {
 	    Aneed[j] = 0;
 	    Ahave[j] = 0;
 	    Bneed[j] = 0;
 	    Bhave[j] = 0;
 	}
 	scanf(α%dα, &T);
 	scanf(α%d %dα, &NA, &NB);
 	for(j = 0; j < NA; j++) {
 	    scanf(α%d:%d %d:%dα, &sH, &sM, &tH, &tM);
 	    M = sH * 60 + sM;
 	    Aneed[M]++;
 	    M = tH * 60 + tM + T;
 	    Bhave[M]++;
 	}
 	for(j = 0; j < NB; j++) {
 	    scanf(α%d:%d %d:%dα, &sH, &sM, &tH, &tM);
 	    M = sH * 60 + sM;
 	    Bneed[M]++;
 	    M = tH * 60 + tM + T;
 	    Ahave[M]++;
 	}
 	for(j = 0; j < 1440; j++) {
 	    AhaveNow += Ahave[j];
 	    if (Aneed[j] > AhaveNow) {
 		A += (Aneed[j] - AhaveNow);
 		AhaveNow = 0;
 	    } else {
 		AhaveNow -= Aneed[j];
 	    }
 	    BhaveNow += Bhave[j];
 	    if (Bneed[j] > BhaveNow) {
 		B += (Bneed[j] - BhaveNow);
 		BhaveNow = 0;
 	    } else {
 		BhaveNow -= Bneed[j];
 	    }
 	}
 	printf(αCase #%d: %d %dnα, i, A, B);
     }
     return 0;
 }"
15035,2008,32013,YSanthoshReddy,24480,1,test.c,gcj/2008/32013/YSanthoshReddy/24480/1/extracted/test.c,"#include <stdio.h>
 
 typedef struct tagServers
 {
 	char 		acName[120];
 	signed int  	iBest;
 } Servers;
 
 Servers		gstServers[120];
 char		gacList[1020][120];
 int		giServerCount;
 int		giQueueCount;
 int 		giSwitches = 0;
 
 #if 0
 void Fill()
 {
 	gstServers[0].acName[0] = 'A';
 	gstServers[0].acName[1] = '0';
 	gstServers[1].acName[0] = 'B';
 	gstServers[1].acName[1] = '0';
 	giServerCount = 2;
 
 	gacList[0][0] = 'A';
 	gacList[0][1] = '0';
 	gacList[1][0] = 'B';
 	gacList[1][1] = '0';
 	gacList[2][0] = 'B';
 	gacList[2][1] = '0';
 	gacList[3][0] = 'B';
 	gacList[3][1] = '0';
 	gacList[4][0] = 'A';
 	gacList[4][1] = '0';
 	giQueueCount = 5;
 
 	return;
 }
 #endif
 
 void Switches(int iStart)
 {
 	int i, j, iMax = 0;
 
 	/* Calculate Best for each Server with in the given Queue range */
 	for (i = 0; i < giServerCount; i++)
 	{
 		for (j = iStart; j < giQueueCount; j++)
 		{
 			//printf(αTest : %d %d %s %snα, i, j, gstServers[i].acName, gacList[j]);
 			if (0 == strcmp(gstServers[i].acName, gacList[j]))
 			{
 				//printf(αTest : Matchednα);
 				break;
 			}
 		}
 
 		iMax = (iMax < j) ? (j) : (iMax);
 		//printf(αTest : iMax = %dnα, iMax);
 	}
 
 	if (iMax == giQueueCount) return;
 
 	giSwitches ++;
 	Switches(iMax);
 	return;
 }
 
 int main(int argc, char *argv)
 {
 	int iCases = 0, i, j, k;
 	FILE *in;
 	char c;
 
 	in = fopen(αA-large.inα, αrα);
 	if (NULL == in)
 	{
 		return -1;
 	}
 
 	/* Read number of cases from file */
 	fscanf(in, α%dα, &iCases);
 	//printf(αTest : Cases = %dnα, iCases);
 
 	for (i = 1; i <= iCases; i++)
 	{
 		giSwitches = 0;
 
 		/* Read number of Servers */
 		fscanf(in, α%dnα, &giServerCount);
 		//printf(αTest : giServerCount = %dnα, giServerCount);
 
 		/* Read each Server name and store it */
 		for (j = 0; j < giServerCount; j++)
 		{
 			k = 0;
 			while (((c = getc(in)) != 'n') && (c != EOF))
 			{
 				gstServers[j].acName[k] = c;
 				k++;
 			}
 
 			gstServers[j].acName[k] = '0';
 			//printf(αTest : gstServers[%d] = %snα, j, gstServers[j].acName);
 		}
 
 		/* Read number of Servers in incoming Queue */
 		fscanf(in, α%dnα, &giQueueCount);
 		//printf(αTest : giQueueCount = %dnα, giQueueCount);
 
 		/* Read each Server name from incoming Queue and store it */
 		for (j = 0; j < giQueueCount; j++)
 		{
 			k = 0;
 			while (((c = getc(in)) != 'n') && (c != EOF))
 			{
 				gacList[j][k] = c;
 				k++;
 			}
 
 			gacList[j][k] = '0';
 			//printf(αTest : gacList[%d] = %snα, j, gacList[j]);
 		}
 
 		/* Calculate number of Switches */
 		Switches(0);
 		printf(αCase #%d: %dnα, i, giSwitches);
 	}
 
 #if 0
 	Fill();
 	Switches(0);
 	printf(αCase #%d: %dnα, 0, giSwitches);
 #endif
 	fclose(in);
 	return 0;
 }"
15262,2008,32013,sanchi,24480,1,su.c,gcj/2008/32013/sanchi/24480/1/extracted/su.c,"/* This Code solves the save universe Problem of Google Code Jam Competition */
 #include <stdio.h>
 #include <string.h>
 
 #define MAX_ENGINE   100
 #define MAX_NAME_LENGTH 128
 #define MAX_NUMBER_OF_QUERY 1000
 #define LARGE_NUM 30000
 
 /* Prototypes */
 void read_engine_names(int num_engines, char en[][MAX_NAME_LENGTH]);
 void read_queries(int num_queries, int num_engines, int queries[], char en[][MAX_NAME_LENGTH]);
 int  get_optimal_number_of_switch(int num_engines, int queries[], int num_queries);
 
 
 
 int main()
 {
     char engine_names[MAX_ENGINE][MAX_NAME_LENGTH];    /* Search engine names */
     char qn[1000][MAX_NAME_LENGTH];    /* Search engine names */
     int queries[MAX_NUMBER_OF_QUERY];
     int i,j;
     int ncase;
     int num_queries;
     int num_engines;
     int opt_num_switch;
     char s[20];
 
 
     /* Read number of cases*/
     gets(s);
     ncase = atoi(s);
  
     /* Solve for each case */
     for (i=0;i<ncase;i++)
     {
 
         /* Read number of engines */
         gets(s);
         num_engines = atoi(s);
 
         /* Read name of engines and store */
         read_engine_names(num_engines,engine_names);
 
         /* Read number of queries */
         gets(s);
         num_queries = atoi(s);
 
         /* Read queries, match with engine names and put the corresponding index in query array */
         read_queries(num_queries, num_engines, queries, engine_names);
         
         /* Get optimal number of switches */
         opt_num_switch=get_optimal_number_of_switch(num_engines, queries, num_queries);
 
         /* Output */
         printf(αCase #%d: %dnα,(i+1),opt_num_switch);
 /*
         printf(αEngines %d:nα,num_engines);
         for (j=0;j<num_engines;j++)
         {
              puts(engine_names[j]);
         }
         printf(αQuery %d:nα,num_queries);
         for (j=0;j<num_queries;j++)
         {
              puts(engine_names[queries[j]]);
         }
        
 
 */
 
     }
 
     return 0;
 }
 
 int  get_optimal_number_of_switch(int num_engines, int queries[], int num_queries)
 {
      int min_num_of_switches;
      int switches[MAX_ENGINE];
      int i,j,curr_min;
 
      if (num_queries<2)
      {
           min_num_of_switches=0;
      }
      else
      {
           /* Intialize switch array */
           for (i=0;i<num_engines;i++)
           {
                switches[i]=0;
           }
           switches[queries[0]] = LARGE_NUM;  /* Indicate that first query can not go to corresponding engine. i.e block this engine  */
 
 
           /* For all other queries keep updating switch array */
           /* Rule 1: additional switch required for previously blocked engine */
           /*         This will be one more than current minimum number of switches */
           /* Rule 2: Block the engine corresponding to current query */
           for (i=1;i<num_queries;i++)
           {
                /* Find the current minimum */ 
                curr_min = switches[0];
                for (j=1;j<num_engines;j++)
                {
                     if (switches[j]<curr_min)
                     {
                           curr_min = switches[j];
                     }
                 }
 
                 /* Apply Rule 1 */
                 for (j=0;j<num_queries;j++)
                 {
                      if (switches[j]==LARGE_NUM)
                      {
                          switches[j] = curr_min+1;
                      }
                  }
                  /* Apply Rule 2 */
 
                  switches[queries[i]] = LARGE_NUM;
            }
            /* Find minimum number of switches */
            min_num_of_switches = switches[0];
            for (i=0;i<num_engines;i++)
            {
                if (switches[i]<min_num_of_switches)
                {
                     min_num_of_switches = switches[i];
                }
            }
       }
       return (min_num_of_switches);
 }
 
 
    
 void read_engine_names(int num_engines, char en[][MAX_NAME_LENGTH])
 {
     int i;
 
     for (i=0;i<num_engines;i++)
     {
         gets(en[i]);
     }
     return;
 }
 
 void read_queries(int num_queries, int num_engines, int queries[], char en[][MAX_NAME_LENGTH])
 {
      int i,query_index;
      char s[MAX_NAME_LENGTH];
 
      for (i=0;i<num_queries;i++)
      {
          gets(s);
          /* Match in the engine name list */
          query_index = 0;
          while (strcmp(s,en[query_index]))
          { 
               query_index++;
               if (query_index>=num_engines)
               {
                    printf(αError: Invalid querynα);
                    exit(-1);
               }
          }
          queries[i]=query_index;
      }
      return;
 }"
15265,2008,32013,sanchi,24481,1,train.c,gcj/2008/32013/sanchi/24481/1/extracted/train.c,"/* This Code solves the Train time table Problem of Google Code Jam Competition */
 #include <stdio.h>
 #include <string.h>
 
 #define MAX_TRAINS   100
 #define MIN_PER_HOUR  60
 #define FROMA    0
 #define FROMB    1
 #define FALSE    0
 #define TRUE     1
 
 
 void sort_by_departures(int n, int dep[], int arr[]);
 
 int main()
 {
     char s[20];
     int ncase;
     int natob,nbtoa;   /* Number of trains from A to B, and B to A respectively */
     int turn_around_time;
     int i,j;
     int hh_dep, mm_dep, hh_arr, mm_arr;
     int dep_a[MAX_TRAINS];
     int arr_a[MAX_TRAINS];
     int dep_b[MAX_TRAINS];
     int arr_b[MAX_TRAINS];
     int a_i,b_i;
     int av_at_a[MAX_TRAINS];
     int av_at_b[MAX_TRAINS];
     int train_req_at_a;
     int train_req_at_b;
     int n_av_a;
     int n_av_b;
     int k,l;
     int nexttrain,av_time;
     int train_available;
 
 
 
     /* Read number of cases*/
     gets(s);
     ncase = atoi(s);
  
     /* Solve for each case */
     for (i=0;i<ncase;i++)
     {
         /* Intialize number of trains required and avilable to 0 */
         n_av_a=0;
         n_av_b=0;
         train_req_at_a=0;
         train_req_at_b=0;
         /* Read turn around time */
         gets(s);
         turn_around_time = atoi(s);
 
         /* Read number of trains from A and B */
         gets(s);
         sscanf(s,α%d %dα,&natob,&nbtoa);
 
 
         /* Read train schedule from A to B */
         for (j=0;j<natob;j++)
         {
              gets(s);
              sscanf(s,α%d:%d %d:%dα,&hh_dep, &mm_dep, &hh_arr, &mm_arr);
              dep_a[j] = MIN_PER_HOUR*hh_dep + mm_dep;
              arr_a[j] = MIN_PER_HOUR*hh_arr + mm_arr;
         }
         for (j=0;j<nbtoa;j++)
         {
              gets(s);
              sscanf(s,α%d:%d %d:%dα,&hh_dep, &mm_dep, &hh_arr, &mm_arr);
              dep_b[j] = MIN_PER_HOUR*hh_dep + mm_dep;
              arr_b[j] = MIN_PER_HOUR*hh_arr + mm_arr;
         }
         sort_by_departures(natob,dep_a,arr_a);
         sort_by_departures(nbtoa,dep_b,arr_b);
 
         a_i = 0;
         b_i = 0;
 
         while ((a_i<natob) || (b_i<nbtoa))
         {
              /* Choose the train from A or B, whichever departs earlier */
              if (a_i==natob)
                 nexttrain = FROMB;
              else if (b_i==nbtoa)
                 nexttrain = FROMA;
              else if (dep_a[a_i]<=dep_b[b_i])   
                 nexttrain = FROMA;
              else
                 nexttrain = FROMB;
                 
 
              if (nexttrain==FROMA)
              {
 
                   /* If train is available at this time then use it else start a new train
                      Make this train available at B at arrival time + turn around time */
                   train_available = FALSE;
                   if (n_av_a>0) /* Check if trains are available at A */
                   {
                        if (av_at_a[n_av_a-1]<=dep_a[a_i])
                        { 
                              /* Train is available on or before departure */
                              train_available = TRUE;
 
                              /* Delete this train from available list */
                              n_av_a--;
                         }
                   }
                   if (train_available==FALSE)
                   {
                        train_req_at_a++;  /* Start a new train */
                   }
                   /* Add this train to available at b */
                   av_time = arr_a[a_i]+turn_around_time;
 
                   /* Find appropriate place for available train so that it is in descending order */
                   k = 0;
 
                   while (k<n_av_b) 
                   {
                       if (av_at_b[k]>av_time)
                       {
                            k++;
                       }
                       else
                       {
                            break;
                       }
                   }
 
                   for (l=n_av_b-1;l>=k;l--)
                   {
                        av_at_b[l+1]=av_at_b[l];
                   }
                   av_at_b[k] = av_time;
                   n_av_b++;
                   a_i++;
              }
              else
              {
                   /* If train is available at this time then use it else start a new train
                      Make this train available at A at arrival time + turn around time */
                   train_available = FALSE;
                   if (n_av_b>0) /* Check if trains are available at B */
                   {
                        if (av_at_b[n_av_b-1]<=dep_b[b_i])
                        { 
                              /* Train is available on or before departure */
                              train_available = TRUE;
 
                              /* Delete this train from available list */
                              n_av_b--;
                         }
                   }
                   if (train_available==FALSE)
                   {
                        train_req_at_b++;  /* Start a new train */
                   }
                   /* Add this train to available at A */
                   av_time = arr_b[b_i]+turn_around_time;
 
                   /* Find appropriate place for available train so that it is in descending order */
                   k = 0;
 
                   while (k<n_av_a) 
                   {
                       if (av_at_a[k]>av_time)
                       {
                            k++;
                       }
                       else
                       {
                            break;
                       }
                   }
 
                   for (l=n_av_a-1;l>=k;l--)
                   {
                        av_at_a[l+1]=av_at_a[l];
                   }
                   av_at_a[k] = av_time;
                   n_av_a++;
                   b_i++;
               }
          }
          printf(αCase #%d: %d %dnα,(i+1),train_req_at_a,train_req_at_b);
      
     }
     
     
 
     return 0;
 }
 
 void sort_by_departures(int n, int dep[], int arr[])
 {
      int i,j,tmp;
 
      for (i=0; i<n-1; i++) 
      {
          for (j=0; j<n-1-i; j++)
          {
              if (dep[j+1] < dep[j])   /* compare the two neighbors */
              {
                  tmp = dep[j];         /* swap dep[j] and dep[j+1]      */
                  dep[j] = dep[j+1];
                  dep[j+1] = tmp;
 
                  tmp = arr[j];         /* swap arr[j] and arr[j+1]      */
                  arr[j] = arr[j+1];
                  arr[j+1] = tmp;
              }
          }
       }
       return;
 }"
15295,2008,32013,QuantumPixel,24480,1,universe.c,gcj/2008/32013/QuantumPixel/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 enum {TRUE, FALSE};
 
 typedef struct engine{
    char name[101];
    int counted;
 
 } ENGINE;
 
 int main(void)
 {
    char *inputFile = αA-large.inα;
    char *outputFile = αA-large.outα;
    FILE *fpIn;
    FILE *fpOut;
 
    int i, j, k, n;
    char c;
 
    char nCases[4];
    int numCases;
 
    char queries[1000][101];
    ENGINE searchEngine[100];
    char nEngines[4];
    int numEngines;
    char nQueries[5];
    int numQueries;
 
    int enginesCounted = 0;
    int numSwitches = 0;
 
    /* open input and output files */
    if((fpIn = fopen(inputFile, αrα)) == NULL)
    {
       fprintf(stderr, αCould not open file α%sα!nα, inputFile);
       exit(1);
    }
 
    if((fpOut = fopen(outputFile, αwα)) == NULL)
    {
       fprintf(stderr, αCould not open file α%sα!nα, outputFile);
       exit(1);
    }
 
   /* get number of cases */
    for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
    {
       nCases[i] = c;
    }
    nCases[i] = '0';
    numCases = atoi(nCases);
 
    for(n = 0; n < numCases; n++)
    {
       /* get number of engines */
       for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
       {
          nEngines[i] = c;
       }
       nEngines[i] = '0';
       numEngines = atoi(nEngines);
 
       /* get search engines */
       for(j = 0; j < numEngines; j++)
       {
          for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
          {
             searchEngine[j].name[i] = c;
          }
          searchEngine[j].name[i] = '0';
          searchEngine[j].counted = FALSE;
       }
 
       /* get number of queries */
       for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
       {
          nQueries[i] = c;
       }
       nQueries[i] = '0';
       numQueries = atoi(nQueries);
 
       /* get queries */
       for(j = 0; j < numQueries; j++)
       {
          for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
          {
             queries[j][i] = c;
          }
          queries[j][i] = '0';
       }
 
       for(i = 0; i < numQueries; i++)
       {
          for(j = 0; j < numEngines; j++)
          {
             if(strcmp(queries[i], searchEngine[j].name) == 0)
                break;
          }
          if(searchEngine[j].counted == FALSE)
          {
             searchEngine[j].counted = TRUE;
             enginesCounted++;
             if(enginesCounted == numEngines)
             {
                numSwitches++;
                enginesCounted = 1;
                for(k = 0; k < numEngines; k++)
                {
                   searchEngine[k].counted = FALSE;
                }
                searchEngine[j].counted = TRUE;
             }
          }
       }
 
       fprintf(fpOut, αCase #%d: %dnα, n + 1, numSwitches);
 
       numSwitches = 0;
       enginesCounted = 0;
 
    }
 
    fclose(fpIn);
    fclose(fpOut);
 
    return 0;
 }"
15297,2008,32013,QuantumPixel,24481,1,train.c,gcj/2008/32013/QuantumPixel/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 enum {TRUE, FALSE};
 
 typedef struct trainnode{
    int departure;
    int arrival;
    struct trainnode *next;
 } TRAINNODE;
 
 int main(void)
 {
    char *inputFile = αB-large.inα;
    char *outputFile = αB-large.outα;
    FILE *fpIn;
    FILE *fpOut;
 
    int i, j, n;
    char c;
 
    char nCases[4];
    int numCases;
    char nTurnaround[3];
    int turnaround;
    char nAdepart[4];
    int numAdepart;
    char nBdepart[4];
    int numBdepart;
 
    char tempHour[3];
    int hours;
    char tempMinutes[3];
    int minutes;
 
    TRAINNODE *NA = NULL;
    TRAINNODE *NB = NULL;
    TRAINNODE *tempNode;
    TRAINNODE *current, *currentA, *currentB;
    TRAINNODE *prev;
    TRAINNODE *arrivalB = NULL;
    TRAINNODE *arrivalA = NULL;
    
    int numTrainsA = 0;
    int numTrainsB = 0;
 
    /* open input and output files */
    if((fpIn = fopen(inputFile, αrα)) == NULL)
    {
       fprintf(stderr, αCould not open file α%sα!nα, inputFile);
       exit(1);
    }
 
    if((fpOut = fopen(outputFile, αwα)) == NULL)
    {
       fprintf(stderr, αCould not open file α%sα!nα, outputFile);
       exit(1);
    }
 
   /* get number of cases */
    for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
    {
       nCases[i] = c;
    }
    nCases[i] = '0';
    numCases = atoi(nCases);
 
    for(n = 0; n < numCases; n++)
    {
       /* get turnaround time */
       for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
       {
          nTurnaround[i] = c;
       }
       nTurnaround[i] = '0';
       turnaround = atoi(nTurnaround);
 
       /* get number of trains departing A */
       for(i = 0; (c = fgetc(fpIn)) != ' '; i++)
       {
          nAdepart[i] = c;
       }
       nAdepart[i] = '0';
       numAdepart = atoi(nAdepart);
 
       /* get number of trains departing B */
       for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
       {
          nBdepart[i] = c;
       }
       nBdepart[i] = '0';
       numBdepart = atoi(nBdepart);
 
       /* get departure and arrival times for station A */
       for(j = 0; j < numAdepart; j++)
       {
          for(i = 0; (c = fgetc(fpIn)) != ':'; i++)
          {
             tempHour[i] = c;
          }
          tempHour[i] = '0';
          hours = atoi(tempHour);
 
          for(i = 0; (c = fgetc(fpIn)) != ' '; i++)
          {
             tempMinutes[i] = c;
          }
          tempMinutes[i] = '0';
          minutes = atoi(tempMinutes);
 
          tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
          tempNode->next = NULL;
          tempNode->departure = 60 * hours + minutes;
 
          for(i = 0; (c = fgetc(fpIn)) != ':'; i++)
          {
             tempHour[i] = c;
          }
          tempHour[i] = '0';
          hours = atoi(tempHour);
 
          for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
          {
             tempMinutes[i] = c;
          }
          tempMinutes[i] = '0';
          minutes = atoi(tempMinutes);
 
          tempNode->arrival = 60 * hours + minutes;
 
          current = NA;
          prev = NULL;
 
          if(current == NULL)
             NA = tempNode;
          else
          {
             while(current != NULL)
             {
                if(tempNode->departure > current->departure)
                {
                   prev = current;
                   current = current->next;
                }
                else
                {
                   tempNode->next = current;
                   if(prev != NULL)
                      prev->next = tempNode;
                   else
                      NA = tempNode;
                   break;
                }
             }
             if(current == NULL)
                prev->next = tempNode;
          }
       }
 
       /* get departure and arrival times for station B */
       for(j = 0; j < numBdepart; j++)
       {
          for(i = 0; (c = fgetc(fpIn)) != ':'; i++)
          {
             tempHour[i] = c;
          }
          tempHour[i] = '0';
          hours = atoi(tempHour);
 
          for(i = 0; (c = fgetc(fpIn)) != ' '; i++)
          {
             tempMinutes[i] = c;
          }
          tempMinutes[i] = '0';
          minutes = atoi(tempMinutes);
 
          tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
          tempNode->next = NULL;
          tempNode->departure = 60 * hours + minutes;
 
          for(i = 0; (c = fgetc(fpIn)) != ':'; i++)
          {
             tempHour[i] = c;
          }
          tempHour[i] = '0';
          hours = atoi(tempHour);
 
          for(i = 0; (c = fgetc(fpIn)) != 'n'; i++)
          {
             tempMinutes[i] = c;
          }
          tempMinutes[i] = '0';
          minutes = atoi(tempMinutes);
 
          tempNode->arrival = 60 * hours + minutes;
 
          current = NB;
          prev = NULL;
 
          if(current == NULL)
             NB = tempNode;
          else
          {
             while(current != NULL)
             {
                if(tempNode->departure > current->departure)
                {
                   prev = current;
                   current = current->next;
                }
                else
                {
                   tempNode->next = current;
                   if(prev != NULL)
                      prev->next = tempNode;
                   else
                      NB = tempNode;
                   break;
                }
             }
             if(current == NULL)
                prev->next = tempNode;
          }
       }
       
       /* calculate number of trains at stations A and B */
       for(currentA = NA, currentB = NB; currentA != NULL || currentB != NULL; )
       {
          if(currentA == NULL || currentB == NULL)
          {
             if(currentB != NULL)
             {
                if(arrivalB != NULL)
                {
                   if(currentB->departure < arrivalB->departure)
                   {
                      numTrainsB++;
                   }
                   else
                   {
                      tempNode = arrivalB->next;
                      free(arrivalB);
                      arrivalB = tempNode;
                   }
                }
                else
                   numTrainsB++;
 
                tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
                tempNode->next = NULL;
                tempNode->departure = currentB->arrival + turnaround;
 
                current = arrivalA;
                prev = NULL;
                
                if(current == NULL)
                   arrivalA = tempNode;
                else
                {
                   while(current != NULL)
                   {
                      if(tempNode->departure > current->departure)
                      {
                         prev = current;
                         current = current->next;
                      }
                      else
                      {
                         tempNode->next = current;
                         if(prev != NULL)
                            prev->next = tempNode;
                         else
                            arrivalA = tempNode;
                         break;
                      }
                   }
                   if(current == NULL)
                      prev->next = tempNode;
                }
 
                currentB = currentB->next;
             }
             else if(currentA != NULL)
             {
                if(arrivalA != NULL)
                {
                   if(currentA->departure < arrivalA->departure)
                   {
                      numTrainsA++;
                   }
                   else
                   {
                      tempNode = arrivalA->next;
                      free(arrivalA);
                      arrivalA = tempNode;
                   }
                }
                else
                   numTrainsA++;
 
                tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
                tempNode->next = NULL;
                tempNode->departure = currentA->arrival + turnaround;
 
                current = arrivalB;
                prev = NULL;
                
                if(current == NULL)
                   arrivalB = tempNode;
                else
                {
                   while(current != NULL)
                   {
                      if(tempNode->departure > current->departure)
                      {
                         prev = current;
                         current = current->next;
                      }
                      else
                      {
                         tempNode->next = current;
                         if(prev != NULL)
                            prev->next = tempNode;
                         else
                            arrivalB = tempNode;
                         break;
                      }
                   }
                   if(current == NULL)
                      prev->next = tempNode;
                }
 
                currentA = currentA->next;
 
             }
          }
          else
          {
             if(currentA->departure <= currentB->departure)
             {
                if(arrivalA != NULL)
                {
                   if(currentA->departure < arrivalA->departure)
                   {
                      numTrainsA++;
                   }
                   else
                   {
                      tempNode = arrivalA->next;
                      free(arrivalA);
                      arrivalA = tempNode;
                   }
                }
                else
                   numTrainsA++;
 
                tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
                tempNode->next = NULL;
                tempNode->departure = currentA->arrival + turnaround;
 
                current = arrivalB;
                prev = NULL;
                
                if(current == NULL)
                   arrivalB = tempNode;
                else
                {
                   while(current != NULL)
                   {
                      if(tempNode->departure > current->departure)
                      {
                         prev = current;
                         current = current->next;
                      }
                      else
                      {
                         tempNode->next = current;
                         if(prev != NULL)
                            prev->next = tempNode;
                         else
                            arrivalB = tempNode;
                         break;
                      }
                   }
                   if(current == NULL)
                      prev->next = tempNode;
                }
 
                currentA = currentA->next;
             }
             else
             {
                if(arrivalB != NULL)
                {
                   if(currentB->departure < arrivalB->departure)
                   {
                      numTrainsB++;
                   }
                   else
                   {
                      tempNode = arrivalB->next;
                      free(arrivalB);
                      arrivalB = tempNode;
                   }
                }
                else
                   numTrainsB++;
 
                tempNode = (TRAINNODE *)malloc(sizeof(TRAINNODE));
                tempNode->next = NULL;
                tempNode->departure = currentB->arrival + turnaround;
 
                current = arrivalA;
                prev = NULL;
                
                if(current == NULL)
                   arrivalA = tempNode;
                else
                {
                   while(current != NULL)
                   {
                      if(tempNode->departure > current->departure)
                      {
                         prev = current;
                         current = current->next;
                      }
                      else
                      {
                         tempNode->next = current;
                         if(prev != NULL)
                            prev->next = tempNode;
                         else
                            arrivalA = tempNode;
                         break;
                      }
                   }
                   if(current == NULL)
                      prev->next = tempNode;
                }
 
                currentB = currentB->next;
             }
          }
       }
 
       fprintf(fpOut, αCase #%d: %d %dnα, n + 1, numTrainsA, numTrainsB);
       numTrainsA = 0;
       numTrainsB = 0;
 
       /* free all nodes */
       current = NA;
       prev = current;
       
       while(current != NULL)
       {
         current = current->next;
         free(prev);
         prev = current;
       }
       NA = NULL;
 
       current = NB;
       prev = current;
       
       while(current != NULL)
       {
         current = current->next;
         free(prev);
         prev = current;
       }
       NB = NULL;
 
       current = arrivalA;
       prev = current;
       
       while(current != NULL)
       {
         current = current->next;
         free(prev);
         prev = current;
       }
       arrivalA = NULL;
 
       current = arrivalB;
       prev = current;
       
       while(current != NULL)
       {
         current = current->next;
         free(prev);
         prev = current;
       }
       arrivalB = NULL;
 
    }
 
    fclose(fpIn);
    fclose(fpOut);
 
    return 0;
 }"
15343,2008,32013,Chard,24480,1,a.c,gcj/2008/32013/Chard/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 typedef struct QueEntryStruct
 {
     struct QueEntryStruct *NextPtr;
     struct QueEntryStruct *PrevPtr;
     char EngineName[102];
 } QUE_ENTRY_STRUCT;
 
 typedef struct QueCtrlStruct
 {
     struct QueEntryStruct *NextPtr;
     struct QueEntryStruct *PrevPtr;
     unsigned long Counter;
 } QUE_CTRL_STRUCT;
 
 QUE_CTRL_STRUCT InUse;
 QUE_CTRL_STRUCT NotInUse;
 QUE_ENTRY_STRUCT Entry[100];
 
 QUE_CTRL_STRUCT *UseIt;
 QUE_CTRL_STRUCT *DontUse;
 QUE_CTRL_STRUCT *TmpQ;
 int SwitchCnt;
 
 
 void insert(QUE_ENTRY_STRUCT *QueEntry,
             QUE_CTRL_STRUCT *QueCtrl)
 {
     QueEntry->NextPtr = (QUE_ENTRY_STRUCT *)QueCtrl;
     QueEntry->PrevPtr = QueCtrl->PrevPtr;
     QueCtrl->PrevPtr->NextPtr = QueEntry;
     QueCtrl->PrevPtr = QueEntry;
     QueCtrl->Counter++;
 }
 
 void moveq(QUE_ENTRY_STRUCT *QueEntry)
 {
     QueEntry->NextPtr->PrevPtr = QueEntry->PrevPtr;
     QueEntry->PrevPtr->NextPtr = QueEntry->NextPtr;
     UseIt->Counter--;
     
     QueEntry->NextPtr = (QUE_ENTRY_STRUCT *)DontUse;
     QueEntry->PrevPtr = DontUse->PrevPtr;
     DontUse->PrevPtr->NextPtr = QueEntry;
     DontUse->PrevPtr = QueEntry;
     DontUse->Counter++;
 }
 
 
 void searchQ(char *Query)
 {
     QUE_ENTRY_STRUCT *CurrEntry;
     int Result;
 
     CurrEntry = UseIt->NextPtr;
 
     do
     {
         Result=strcmp(CurrEntry->EngineName, Query);
         if (Result == 0)
         {
             if (UseIt->Counter>1)
             {
                 moveq(CurrEntry);
             }
             else
             {
                 SwitchCnt++;
                 TmpQ = UseIt;
                 UseIt = DontUse;
                 DontUse = TmpQ;
             }
             
             return;
         }
         
 
         CurrEntry = CurrEntry->NextPtr;
     }
     while(CurrEntry != (QUE_ENTRY_STRUCT *)UseIt);
 }
 
 void main()
 {
     int i,N;
     int S;
     int SCntr;
     int Q;
     int QCntr;
     char StrTmp[102];
 
     gets(StrTmp);
     N=atoi(StrTmp);
 
     
     for (i=1;i<=N; i++)
     {
         
         SwitchCnt=0;
 
         InUse.NextPtr = (QUE_ENTRY_STRUCT *)&InUse;
         InUse.PrevPtr = (QUE_ENTRY_STRUCT *)&InUse;
         InUse.Counter = 0;
         UseIt = &InUse;
 
         NotInUse.NextPtr = (QUE_ENTRY_STRUCT *)&NotInUse;
         NotInUse.PrevPtr = (QUE_ENTRY_STRUCT *)&NotInUse;        
         NotInUse.Counter = 0;
         DontUse = &NotInUse;
 
         gets(StrTmp);
         S=atoi(StrTmp);
         for (SCntr=0; SCntr<S; SCntr++)
         {
             gets(Entry[SCntr].EngineName);
             insert(&Entry[SCntr], &InUse);
         }
 
         gets(StrTmp);
         Q=atoi(StrTmp);
         for (QCntr=0; QCntr<Q; QCntr++)
         {
             gets(StrTmp);
             searchQ(StrTmp);
         }
 
 
         printf(αCase #%i: %inα, i, SwitchCnt);
     }
 }"
15363,2008,32013,minsikzzang,24480,1,saving_the_universe.c,gcj/2008/32013/minsikzzang/24480/1/extracted/saving_the_universe.c,"/*++
 
 	Input
 
 	The first line of the input file contains the number of cases, N. 
 	N test cases follow. 
 	Each case starts with the number S -- the number of search engines. 
 	The next S lines each contain the name of a search engine. 
 	Each search engine name is no more than one hundred characters long and contains only uppercase letters, 
 	lowercase letters, spaces, and numbers. 
 	There will not be two search engines with the same name. 
 	The following line contains a number Q -- the number of incoming queries. 
 	The next Q lines will each contain a query. 
 	Each query will be the name of a search engine in the case. 
 
 	Output
 
 	For each input case, you should output: 
 
 	Case #X: Y
 	
 	where X is the number of the test case and Y is the number of search engine switches. 
 	Do not count the initial choice of a search engine as a switch. 
 
 	Limits
 
 	0 < N  20 
 
 	Small dataset
 
 	2  S  10 
 	0  Q  100 
 
 	Large dataset
 
 	2  S  100 
 	0  Q  1000 
 
 --*/
 #include <stdio.h>
 #include <stdlib.h>
 #include <io.h>
 #include <string.h>
 
 
 #define max_character	100
 // #define _small_data_set 0
 #define min(x, y)		(((x) < (y)) ? (x) : (y))
 
 #ifdef _small_data_set
 #define max_engine		10
 #define max_query		100
 #else
 #define max_engine		100
 #define max_query		1000
 #endif
 
 
 typedef unsigned int uint;
 
 typedef struct _eitem	{
 	char name[max_character + 1];
 	int b;
 } eitem;
 
 eitem engine[max_engine];
 char query[max_query][max_character + 1] = {0, };
 uint icase = 0;
 uint ocase = 0;
 uint iengine = 0;
 uint oengine = 0;
 uint iquery = 0;
 uint oquery = 0;
 
 uint
 find_next_route(uint pos)
 {
 	uint i = 0, k;
 	uint find = 0;
 	uint last = 0;
 
 	for (i = 0; i < iengine; i++)
 	{
 		engine[i].b = 0;
 		// engine[i].cnt = 0;
 	}
 
 	for (i = pos; i < iquery; i++)
 	{
 		for (k = 0; k < iengine; k++)
 		{
 			if (!stricmp(query[i], engine[k].name))
 			{
 				if (engine[k].b == 0)
 				{
 					engine[k].b = 1;
 					find++;
 				}
 			}
 
 			if (find == iengine)
 				break;
 		}
 
 		if (find == iengine)
 			break;
 	}
 
 	if (find == iengine)
 		i = k;
 	else
 	{
 		for (i = 0; i < iengine; i++)
 		{
 			if (engine[i].b == 0)
 				break;
 		}
 	}
 	
 	return i;
 
 }
 
 char *
 out(uint *len, uint ncase)
 {
 	char *out = 0;
 	uint i = 0;
 	uint k = 0;
 	uint mi = 0;
 	
 	while (k != iquery)
 	{
 		i = find_next_route(k);
 		for ( ; k < iquery; k++)
 		{
 			if (!stricmp(engine[i].name, query[k]))
 			{
 				//
 				// bomb..
 				//
 				break;
 			}
 		}
 
 		if (k == iquery)
 		{
 			//
 			// succeeded
 			//
 			k = 0;
 			iquery = 0;
 		}		
 		else
 			mi++;
 	}
 
 	if (!(out = (char *)malloc(260)))
 	{
 		*len = 0;
 		return 0;
 	}
 
 	*len = sprintf(out, αCase #%d: %dnα, ncase + 1, mi);
 	return out;
 }
 
 int 
 saving_the_universe(int argc, char *argv[])
 {
 	FILE *fp = 0, *of;
 	char input[max_character + 1] = {0, };
 	char *buf = 0;
 	uint outlen = 0;
 
 	if (argc < 3)
 		return 0;
 
 	if (!(fp = fopen(argv[1], αrα)))
 		return 0;
 
 	if (!(of = fopen(argv[2], αwα)))
 	{
 		fclose(fp);
 		return 0;
 	}
 
 	while (!feof(fp))
 	{
 		fgets(input, max_character, fp);
 		
 		if (icase == 0)
 			icase = atoi(input);
 		else if (icase == ocase)
 			break;
 		else if (icase > ocase)
 		{
 			if (iengine == 0)
 				iengine = atoi(input);
 			else if (iengine > oengine)
  				strcpy(engine[oengine++].name, input);
 			else if (iengine == oengine)
 			{
 				if (iquery == 0)
 				{
 					if ((iquery = atoi(input)) == 0)
 					{
 						if (buf = out(&outlen, ocase++))
 						{
 							fwrite(buf, outlen, 1, of);
 							free(buf);
 						}
 
 						iquery = 0;
 						iengine = 0;
 						oengine = 0;
 					}
 				}
 				else if (iquery > oquery)
 					strcpy(query[oquery++], input);
 				else if (iquery == oquery)
 				{
 					if (buf = out(&outlen, ocase++))
 					{
 						fwrite(buf, outlen, 1, of);
 						free(buf);
 					}
 
 					iquery = 0;
 					iengine = atoi(input);
 					oengine = 0;
 					oquery = 0;					
 				}	
 			}			
 		}
 		
 
 		memset(input, 0, max_character);
 	}
 
 	if (fp)
 		fclose(fp);
 
 	if (of)
 		fclose(of);
 
 	return 0;
 }
 
 int
 main(int argc, char *argv[])
 {
 	saving_the_universe(argc, argv);
 	return 0;
 }"
15432,2008,32013,RaviMR,24480,1,a.c,gcj/2008/32013/RaviMR/24480/1/extracted/a.c,"#include <stdio.h>
 struct info
 {
 char server[101];
 char status;
 };
 
 struct info *ptr;
 void main()
 {
 	int testcases;
 	int testcount= 1;
 	scanf(α%dα,&testcases);
 	//printf(α%dnα,testcases);
 
 	while(testcount <= testcases)
 	{
 		int servers = 0;
 		int i = 0,j=0;
 		int q;
 		char server[101];
 		int count=0;
 		int switches=0;
 		scanf(α%d α,&servers);
 		//printf(α%dnα,servers);
 		
 		if (servers != 0)
 		{
 			ptr = malloc(sizeof(struct info) * servers);
 			memset(ptr, 0, sizeof(struct info) * servers);
 		}
 		while (i < servers)
 		{
 			gets(ptr[i].server);
 			//printf(α%snα,ptr[i].server);
 			ptr[i].status = 0;
 			i++;
 		}
 		
 		scanf(α%d α,&q);
 		//printf(α%dnα,q);
 		
 		while (q != 0)
 		{
 			gets(server);
 			//printf(αgot%snα,server);
 			
 			for (i = 0; i<servers; i++)
 			{
 				if (0 == (strcmp(ptr[i].server, server)))
 				{
 					//printf(αmatched at %dnα, i);
 					if (ptr[i].status == 0)
 					{
 						count++;
 						if (count == servers)
 						{
 							//printf(αvalue of switch %dnα, switches);
 							switches++;
 							count = 1;
 							for (j = 0; j<servers; j++)
 								ptr[j].status = 0;
 							
 						}
 						ptr[i].status = 1;
 						
 
 					}
 					break;
 				}
 			}
 			q--;
 		}
 		printf(αCase #%d: %dnα,testcount,switches);
 		switches = 0;
 		count=0;
 		testcount++;
 		free(ptr);
 	}
 }"
15472,2008,32013,masari,24480,1,savingTheUniverse.c,gcj/2008/32013/masari/24480/1/extracted/savingTheUniverse.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 /* typedef struct Ref ref;
 struct Ref{
 	int freq;
 	int index;
 }; */
 
 char * read();
 
 int main()
 {
 	int numOfCases, numOfSearchEngines, numOfQueries, numOfSwitches;
 	int counter, i, j, k, num;
 	char ** enginesArray;
 	char * strAux;
 	int * freqArray;
 	
 	strAux = malloc(100*sizeof(char));
 	
 	scanf(α%dα, &numOfCases);
 	for(i = 0; i < numOfCases; i++){
 		scanf(α%dα, &numOfSearchEngines);
 		enginesArray = malloc(numOfSearchEngines*sizeof(char *));
 		freqArray = calloc(numOfSearchEngines, sizeof(int));
 		//read the search engines
 		getchar();
 		for (j = 0; j<numOfSearchEngines; j++){ 
 			enginesArray[j] = malloc(sizeof(char)*100);
 			enginesArray[j] = read();
 		}
 		
 		qsort(enginesArray, numOfSearchEngines, sizeof(char *), (int (*)(const void *, const void *))strcmp);
         
 		//read the input queries
 		scanf(α%dα, &numOfQueries);
 		counter = 0;
 		numOfSwitches = 0;
 		getchar();
 		for (j = 0; j<numOfQueries; j++){
 			strAux = read();
  			k = 0;
 			while (strcmp(strAux, enginesArray[k]) != 0){
 				k++;
 			}
 			if (freqArray[k] == 0){
 				counter++;
 			}
 			freqArray[k]++;
 			if (counter == numOfSearchEngines){
 				numOfSwitches++;
 				num = k;
 				for(k = 0; k < numOfSearchEngines; k++){
 					freqArray[k] = 0;
 				}
 				freqArray[num]++;
 				counter = 1;
 			}
 		}
 		
 		printf(αCase #%d: %dnα, i+1, numOfSwitches);
 		//free(enginesArray);
 		//free(freqArray);
 	}	
 	return 0;
 }
 
 
 char * read()
 {
 	char * str;
 	char c;
 	int i = -1;
 	
 	str = malloc(sizeof(char)*100);
 	do{
 		i++;
 		c = getchar();
 		str[i] = c;
 	}while (c != 'n');
 	
 	str[i] = '0';
 	
 	return str;
 }"
15474,2008,32013,masari,24481,1,trainTimeTable.c,gcj/2008/32013/masari/24481/1/extracted/trainTimeTable.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct Travel travel;
 struct Travel{
 	// times in minutes
 	int departure; 
 	int arrival;
 	int alreadyUsed;
 };
 
 int compare(travel *t1, travel *t2);
 
 int main()
 {
 	int numOfCases, turnTime, na, nb, trainsA, trainsB;
 	int i, j, k, hours, minutes;
 	travel * ab;
 	travel * ba;
 	
 	scanf(α%dα, &numOfCases);
 	for(i = 0; i < numOfCases; i++){
 		scanf(α%dα, &turnTime);
 		scanf(α%d %dα, &na, &nb);
 		ab = malloc(na*sizeof(travel));
 		ba = malloc(nb*sizeof(travel));
 		
 		for (j=0;j<na;j++){
 			scanf(α%d:%dα, &hours, &minutes);
 			ab[j].departure = hours*60 + minutes;
 			
 			scanf(α%d:%dα, &hours, &minutes);
 			ab[j].arrival = hours*60 + minutes;
 			ab[j].alreadyUsed = 0;
 		}
 		
 		for (j=0;j<nb;j++){
 			scanf(α%d:%dα, &hours, &minutes);
 			ba[j].departure = hours*60 + minutes;
 			
 			scanf(α%d:%dα, &hours, &minutes);
 			ba[j].arrival = hours*60 + minutes;
 			ba[j].alreadyUsed = 0;
 		}
 		
 		trainsA = na;
 		trainsB = nb;
 		
 		qsort(ab, na, sizeof(travel), (int (*)(const void *, const void *))compare);
 		qsort(ba, nb, sizeof(travel), (int (*)(const void *, const void *))compare);
 		
 		for (j=0;j<na;j++){
 			for(k = 0;k<nb;k++){
 				if ((ba[k].alreadyUsed == 0)&&(ab[j].departure >= ba[k].arrival+turnTime)){
 					ba[k].alreadyUsed = 1;
 					trainsA--;
 					break;
 				}
 			}
 		}
 		
 		for (j=0;j<nb;j++){
 			for(k = 0;k<na;k++){
 				if ((ab[k].alreadyUsed == 0)&&(ba[j].departure >= ab[k].arrival+turnTime)){
 					ab[k].alreadyUsed = 1;
 					trainsB--;
 					break;
 				}
 			}
 		}
 		
 		printf(αCase #%d: %d %dnα, i+1, trainsA, trainsB);
 		free(ab);
 		free(ba);
 	}	
 	return 0;
 }
 
 //descending order
 int compare(travel *t1, travel *t2)
 {
 	if(t1->arrival > t2->arrival){
 		return -1;
 	}else{
 		if(t1->arrival < t2->arrival){
 			return 1;
 		}else{
 			return 0;
 		}
 	}
 }"
15667,2008,32013,rcillo,24480,1,switching_system.c,gcj/2008/32013/rcillo/24480/1/extracted/switching_system.c,"/* Este programa resolve o problema da rodada de qualificação do GCJ */
 /* para usa-lo basta passar como primeiro argumento o nome do arquivo de entrada */
 /* o segundo argumento é o nome do arquivo de saida */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_LEN 102
 
 int search(char * key, char ** list, int p, int q) {
   int r;
   int m;
   while (1) {
     if (p == q) return p;
     m = (q + p)/2;
     r = strcmp(key, list[m]);
     if (r == 0) return m;
     if (r < 0) q = m -1;
     else p = m +1;
   }
   return -1;
 }
 
 
 static int cmpstringp(const void *p1, const void *p2) {
   return strcmp(* (char * const *) p1, * (char * const *) p2);
 }
 
 /* a cada search_engines_num consultas distintas, é necessário um switch */
 /* o que este programa faz é ler as consultas e incrementar distintic_querys */
 /* a fim de saber quantos switchs são necessários */
 int main(int argc, char * argv[]) {
 
   int i;			/* caso em analise */
   int j;
   int k;
   int q;
   int test_cases;
   int search_engines_num;
   char ** search_engines_list;
   int query_repetition_counter[100];
   int querys_num;
   char * query = (char*)malloc(101 * sizeof(char));
   int distinct_querys = 0;
   int minimum_switchs = 0;
   FILE * input_file;
   FILE * output_file;
 
   search_engines_list = (char**)malloc(100 * sizeof *search_engines_list);
   for (j = 0; j < 100; j++) 
     search_engines_list[j] = (char*)malloc(MAX_LEN * sizeof(char));
   
   input_file = fopen(argv[1], αrα);
   output_file = fopen(argv[2], αwα);
   fscanf(input_file, α%dα, &test_cases);
   fgetc(input_file);
   for (i = 1; i <= test_cases; i++) {
     
     /* this chunk of code treats the search engines names */
     fscanf(input_file, α%dα, &search_engines_num);
     fgetc(input_file);		/* newline */
     for (j = 0; j < search_engines_num; j++) {
       fgets(search_engines_list[j], MAX_LEN, input_file);
       query_repetition_counter[j] = 0;
     }
     qsort(search_engines_list, search_engines_num, sizeof(char*), cmpstringp);
 
     /* this chunck of code looks at the query */
     fscanf(input_file, α%dα, &querys_num);
     fgetc(input_file);		/* newline */
     for (j = 0; j < querys_num; j++) {
       fgets(query, MAX_LEN, input_file);
       q = search(query, search_engines_list, 0, search_engines_num-1);
       if (!query_repetition_counter[q]) {
 	query_repetition_counter[q]++;
 	distinct_querys++;
 	if (distinct_querys == search_engines_num) {
 	  minimum_switchs++;
 	  for (k = 0; k < search_engines_num; k++)
 	    query_repetition_counter[k] = 0;
 	  query_repetition_counter[q] = 1;
 	  distinct_querys = 1;
 	}
       }
     }
     fprintf(output_file, αCase #%d: %dnα, i, minimum_switchs);
     minimum_switchs = 0;
     distinct_querys = 0;
     
   }
   fclose(input_file);
   fclose(output_file);
   for (j = 0; j < 100; j++) 
     free(search_engines_list[j]);
 
   return 0;
 }"
16002,2008,32013,edumneves,24480,1,a.c,gcj/2008/32013/edumneves/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXS 120
 #define MAXENGS 120
 #define MAXQUERYS 1020
 
 struct ENG{
 	char name[MAXS];
 	int nrep;
 };
 
 struct ENG seng[MAXENGS];
 char query[MAXQUERYS][MAXS];
 
 int comp(const void *a, const void *b)
 {
 	struct ENG a1, b1;
 	a1 = *((struct ENG*)a);
 	b1 = *((struct ENG*)b);
 	return(strcmp(a1.name, b1.name));
 }
 
 int main(void)
 {
 	int n, s, q, tc;
 	register int i,j, k;
 	int ns;
 	char ult[MAXENGS];
 	int ndisp;
 	
 	struct ENG *patual;
 	
 	scanf(α%dnα, &n);
 	tc = 1;
 	for (i=0; i< n; i++)
 	{
 		printf(αCase #%d: α, tc++);
 		scanf(α%dnα, &s);
 		
 		ns = 0;				
 		for (j=0; j<s; j++)
 			gets(seng[j].name);
 		qsort(seng, s,sizeof(seng[0]), comp);
 
 		scanf(α%dnα, &q);
 		for(j=0; j<q; j++)
 			gets(query[j]);
 		for(k=0; k<s; k++)
 			seng[k].nrep = 0;
 			
 		/*Calculating switchs*/
 		ult[0] = '0';
 		ndisp = s;
 		for(j=0; j<q; j++)
 		{
 			patual = bsearch(query[j], seng, s,sizeof(seng[0]), comp);
 						
 			(*patual).nrep++;
 					
 			if (strcmp(ult, (*patual).name) && ((*patual).nrep == 1))
 			{
 				ndisp--;
 				/* Find the last search engine, we have to change*/
 				if (ndisp == 0)
 				{
 					ns++;
 					strcpy(ult, (*patual).name);
 					ndisp = s-1;
 					for(k=0; k<s; k++)
 						seng[k].nrep = 0;
 				}
 			}
 			
 		}
 			
 		printf(α%dnα, ns);
 	}
 	
 	return 0;
 }"
16009,2008,32013,iura.alin,24481,1,TrainTable.c,gcj/2008/32013/iura.alin/24481/1/extracted/TrainTable.c,"/*
  *      TrainTable.c
  *      
  *      Copyright 2008 Iura <iura@iura-pc>
  *      
  *      This program is free software; you can redistribute it and/or modify
  *      it under the terms of the GNU General Public License as published by
  *      the Free Software Foundation; either version 2 of the License, or
  *      (at your option) any later version.
  *      
  *      This program is distributed in the hope that it will be useful,
  *      but WITHOUT ANY WARRANTY; without even the implied warranty of
  *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *      GNU General Public License for more details.
  *      
  *      You should have received a copy of the GNU General Public License
  *      along with this program; if not, write to the Free Software
  *      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  *      MA 02110-1301, USA.
  */
 
 
 #include <stdio.h>
 #include <math.h>
 
 void schedule (FILE *fin, FILE *fout, int casee)
 {
 	int tren_din_a[100][2],tren_din_b[100][2],n,m,turn,ocupat_a[100],ocupat_b[100];
 	int i,j,a,b,c,d,min,leg;
 	int nr_tren_a,nr_tren_b;
 	fscanf(fin,α%dα,&turn);
 	fscanf(fin,α%d %dα,&n,&m);
 	for (i=0; i<n; i++)
 	{
 		fscanf(fin,α%d:%d %d:%dα,&a,&b,&c,&d);
 		tren_din_a[i][0]=a*60+b;
 		tren_din_a[i][1]=c*60+d;
 		ocupat_a[i]=0;
 	}	
 	for (j=0; j<m; j++)
 	{
 		fscanf(fin,α%d:%d %d:%dα,&a,&b,&c,&d);
 		tren_din_b[j][0]=a*60+b;
 		tren_din_b[j][1]=c*60+d;
 		ocupat_b[j]=0;
 	}
 	nr_tren_a=0;
 	for (i=0; i<n; i++)
 	{
 		min=1000;
 		leg=-1;
 		for (j=0; j<m; j++)
 			if (tren_din_a[i][0]>=tren_din_b[j][1]+turn && tren_din_a[i][0]-tren_din_b[j][1]<min && ocupat_b[j]==0)
 			{
 				min=tren_din_a[i][0]-tren_din_b[j][1];
 				leg=j;
 			}
 		if (leg!=-1)
 			ocupat_b[leg]=1;
 		else
 			nr_tren_a++;
 	}
 	
 	nr_tren_b=0;
 	for (j=0; j<m; j++)
 	{
 		min=1000;
 		leg=-1;
 		for (i=0; i<n; i++)
 			if (tren_din_b[j][0]>=tren_din_a[i][1]+turn && tren_din_b[j][0]-tren_din_a[i][1]<min && ocupat_a[i]==0)
 			{
 				min=tren_din_b[j][0]-tren_din_a[i][1];
 				leg=i;
 			}
 		if (leg!=-1)
 			ocupat_a[leg]=1;
 		else
 			nr_tren_b++;
 	}				
 	fprintf(fout,αCase #%d: %d %dnα,casee,nr_tren_a,nr_tren_b);	
 }
 void citeste (void)
 {
 	int i,n;
 	FILE *fin,*fout;
 	fin=fopen(αB-large.inα,αrtα);
 	fout=fopen(αOutput.outα,αwtα);
 	fscanf(fin,α%dα,&n);
 	for (i=1; i<=n; i++)
 		schedule(fin,fout,i);
 	fclose(fin);
 	fclose(fout);
 }
 
 int main(int argc, char** argv)
 {
 	citeste();
 	return 0;
 }"
16070,2008,32013,Sunshi,24480,1,Saving_the_Universe.c,gcj/2008/32013/Sunshi/24480/1/extracted/Saving_the_Universe.c,"#include <stdio.h>
 #include <string.h>
 
 int main(int argc, char** argv){
 	int i,j,k,l,m;
 	int N;
 	int S;
 	int Q;
 	int nswitch;
 	int ifswitch;
 	char S_set[101][101];
 	char check[101];
 	char str_to_cmp[101];
 
 	scanf(α%dα,&N);	
 	for(i=0;i<N;i++){
 		ifswitch=0;
 		nswitch=0;
 		memset(S_set,0,101*101);
 		scanf(α%dα,&S);
 		getc(stdin);
 		for(j=0;j<S;j++)
 			gets(S_set[j]);
 		/* debug */
 		  /* for(j=0;j<S;j++)
 		                   printf(α%snα,S_set[j]);*/
 		scanf(α%dα,&Q);
 		getc(stdin);
 		//printf(αQ=%dnα,Q);
 		if(Q<=S){
 			printf(αCase #%d: 0nα,i+1);
 			continue;
 		}
 		else{
 			memset(check,0,101);
 			for(j=0;j<Q;j++){
 				gets(str_to_cmp);
 				//printf(α%snα,str_to_cmp);
 				for(k=0;k<S;k++){
 					if( strcmp(str_to_cmp,S_set[k])==0 ){
 						check[k]=1;
 						break;
 					}
 				}
 				/* check is full? then switch once */
 				for(l=0;l<S;l++){
 					if(check[l]==0)
 					{
 						ifswitch=0;
 						break;
 					}
 					else
 						ifswitch=1;
 				}
 				if(ifswitch)
 				{
 					nswitch+=1;
 					memset(check,0,101);
 					for(k=0;k<S;k++){
 					if( strcmp(str_to_cmp,S_set[k])==0 ){
 						check[k]=1;
 						break;
 					}				}
 					//printf(α%snα,S_set[k]);
 				}
 			}
 			printf(αCase #%d: %dnα,i+1,nswitch);
 		}		
 	}
 	return 0;
 }"
16072,2008,32013,jen,24480,1,code1.c,gcj/2008/32013/jen/24480/1/extracted/code1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 
 int main(void)
 {
 
 	FILE *fp;
 	int caseno, engines, ANS, qno;
 	int i, j, k, m;
 	char enginename[100][100];
 	char query[1000][100];
 	int store[100];
 	char temp[100];
 
 	fp = fopen(αA-small.inα, αrα);
 	fscanf(fp, α%dα, &caseno);
 
 	for (i = 0; i <caseno; i++) {
 		ANS=0;
 		fscanf(fp, α%dα, &engines);
 		fgets(temp,100,fp);
 		for (j=0; j<engines; j++){
 			fgets(enginename[j], 100, fp);
 		}
 		fscanf(fp, α%dα, &qno);
 		fgets(temp,100,fp);
 		for (j=0; j<qno; j++){
 			fgets(query[j], 100, fp);
 		}
 
                 for (k=0; k<engines; k++){
                		 store[k]=0;
                 }
 
 
 		for (j=0, m=0;j<qno;j++ )
 		{
 			for(k=0; k<engines; k++){
 			if (strcmp(query[j],enginename[k]) ==0){
 				if (store[k]==0){
 				 	store[k]=1;
 					m++;
 				}
 				k = engines;
 			}
 			}
 			if (m==engines){
 				j--;
 				m=0;
 				ANS++;
 				for (k=0; k<engines; k++){
 					store[k]=0;
 				}
 			
 			}
 			
 
 		}
 		printf(αCase #%d: %dnα, i+1, ANS);
 	}
 
 
 	fclose(fp);
 }"
16074,2008,32013,jen,24481,1,code2.c,gcj/2008/32013/jen/24481/1/extracted/code2.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 
 int main(void)
 {
 
 	FILE *fp;
 	int caseno, turnaround, AB, BA, ABans, BAans;
 	int ABtime1[100], ABtime2[100], BAtime1[100], BAtime2[100];
 	int temp1, temp2, temp3, temp4, temp5;
 	int i, j, k, m;
   
 
 	fp = fopen(αB-small.inα, αrα);
 	fscanf(fp, α%dα, &caseno);
 
 	for (i = 1; i <=caseno; i++) {
 		
 		fscanf(fp, α%dα, &turnaround);
 		fscanf(fp, α%d %dα, &AB, &BA);
 		ABans=AB;
 		BAans=BA;
 
 
 		for (j=0; j< AB; j++){
 			fscanf(fp, α%d:%d %d:%dα, &temp1, &temp2, &temp3, &temp4);
 			ABtime1[j]=temp1*60+temp2;
 			for (m=j;m>0; m--){
 				if (ABtime1[m]<ABtime1[m-1]){
 					temp5 = ABtime1[m-1];
 					ABtime1[m-1] = ABtime1[m];
 					ABtime1[m] = temp5;
 				}
 				else	m=0;
 				}
 				
 			ABtime2[j]=temp3*60+temp4+turnaround;
                         for (m=j;m>0; m--){
                                 if (ABtime2[m]<ABtime2[m-1]){
                                         temp5 = ABtime2[m-1];
                                         ABtime2[m-1] = ABtime2[m];
                                         ABtime2[m] = temp5;
                                 }
                                 else    m=0;
                                 }
                                 
 
 			}
 		for (j=0; j< BA; j++){
 			fscanf(fp, α%d:%d %d:%dα, &temp1, &temp2, &temp3, &temp4);
 			BAtime1[j]=temp1*60+temp2;
                         for (m=j;m>0; m--){
                                 if (BAtime1[m]<BAtime1[m-1]){
                                         temp5 = BAtime1[m-1];
                                         BAtime1[m-1] = BAtime1[m];
                                         BAtime1[m] = temp5;
                                 }
                                 else    m=0;
                                 }
                                 
 
 
 			BAtime2[j]=temp3*60+temp4+turnaround;
                         for (m=j;m>0; m--){
                                 if (BAtime2[m]<BAtime2[m-1]){
                                         temp5 = BAtime2[m-1];
                                         BAtime2[m-1] = BAtime2[m];
                                         BAtime2[m] = temp5;
                                 }
                                 else    m=0;
                                 }
 
 
 
 			}
 
 		for (j=0; j<AB; j++){
 			for(k=0; k<BA; k++){
 				if (ABtime1[j]>=BAtime2[k]){
 					BAtime2[k]=6000;
 					ABans--;
 					k=BA;
 				}
 			}
 		}
 
 
 		for (j=0; j<BA; j++){
 			for(k=0; k<AB; k++){
 				if (BAtime1[j]>=ABtime2[k]){
 					ABtime2[k]=6000;
 					BAans--;
 					k=AB;
 				}
 			}
 		}
 
 		printf(αCase #%d: %d %dnα, i, ABans, BAans);
 		
 	}
 	fclose(fp);
 	return 0;
 }"
16122,2008,32013,cbrain,24480,1,universe.c,gcj/2008/32013/cbrain/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_SEARCH_ENGINES 100
 static unsigned int number_of_search_engines;
 static char *search_engine_names[MAX_SEARCH_ENGINES];
 
 #define MAX_QUERIES 1000
 static unsigned int number_of_queries;
 static unsigned int queries[MAX_QUERIES];
 static unsigned int switches_up_to_query[MAX_QUERIES][MAX_SEARCH_ENGINES];
 
 unsigned int
 search_for_optimum(unsigned int current_search_engine,
 					unsigned int query_offset,
 					unsigned int switches,
 					unsigned int best_so_far)
 {
 	unsigned int search_engine;
 	unsigned int this_one;
 
 	while (query_offset < number_of_queries)
 	{
 		if (queries[query_offset] == current_search_engine)
 			break;
 
 		if (switches_up_to_query[query_offset][current_search_engine] <= switches)
 			return MAX_QUERIES;
 		switches_up_to_query[query_offset][current_search_engine] = switches;
 
 		query_offset++;
 	}
 	if (query_offset >= number_of_queries)
 		return switches;
 
 	if (switches_up_to_query[query_offset][current_search_engine] <= switches)
 		return MAX_QUERIES;
 	switches_up_to_query[query_offset][current_search_engine] = switches;
 
 	switches++;
 	if (switches > best_so_far)
 		return switches;
 
 	for (search_engine = 0;
 			search_engine < number_of_search_engines; search_engine++)
 	{
 		if (search_engine == current_search_engine)
 			continue;
 
 		this_one = search_for_optimum(search_engine,
 				query_offset, switches, best_so_far);
 		if (this_one < best_so_far)
 			best_so_far = this_one;
 	}
 
 	return best_so_far;
 }
 
 int
 main(void)
 {
 	char line[1024];
 	unsigned int number_of_test_cases;
 	unsigned int test_case_number;
 	unsigned int i, j;
 	unsigned int optimal_number_of_switches;
 	unsigned int number_of_switches;
 
 	fgets(line, sizeof line, stdin);
 	number_of_test_cases = (unsigned int)atoi(line);
 
 	for (test_case_number = 1; test_case_number <= number_of_test_cases;
 			test_case_number++)
 	{
 		fgets(line, sizeof line, stdin);
 		number_of_search_engines = (unsigned int)atoi(line);
 
 		for (i = 0; i < number_of_search_engines; i++)
 		{
 			fgets(line, sizeof line, stdin);
 			search_engine_names[i] = strdup(line);
 			if (!search_engine_names[i])
 				abort();
 		}
 
 		fgets(line, sizeof line, stdin);
 		number_of_queries = (unsigned int)atoi(line);
 
 		for (i = 0; i < number_of_queries; i++)
 		{
 			fgets(line, sizeof line, stdin);
 			queries[i] = number_of_search_engines;
 			for (j = 0; j < number_of_search_engines; j++)
 				switches_up_to_query[i][j] = MAX_QUERIES;
 			for (j = 0; j < number_of_search_engines; j++)
 			{
 				if (!strcmp(line, search_engine_names[j]))
 				{
 					queries[i] = j;
 					break;
 				}
 			}
 		}
 
 		optimal_number_of_switches = MAX_QUERIES;
 		for (i = 0; i < number_of_search_engines; i++)
 		{
 			fprintf(stderr, αTrying initial search engine %u ... α, i);
 			fflush(stderr);
 
 			number_of_switches = search_for_optimum(i,
 					0, 0, optimal_number_of_switches);
 			if (number_of_switches < optimal_number_of_switches)
 				optimal_number_of_switches = number_of_switches;
 
 			fprintf(stderr, αdone (%u switches, %u optimal)nα,
 					number_of_switches, optimal_number_of_switches);
 		}
 
 		printf(αCase #%d: %dnα, test_case_number, optimal_number_of_switches);
 
 		for (i = 0; i < number_of_search_engines; i++)
 			free(search_engine_names[i]);
 	}
 
 	return 0;
 }
 
 /* vim:ts=4:sw=4
  */"
16174,2008,32013,patil.sandip,24480,1,T2.C,gcj/2008/32013/patil.sandip/24480/1/extracted/T2.C,"#include<stdio.h>
 
 FILE *fp,*fpout;
 
 struct SearchEng
 {
 char Name[102];
 int checked;
 };
 
 struct SearchEng se[100];
 int s_count=0;
 
 int mark(char * str)
 {
 int i;
 
 for(i=0;i<s_count;i++)
 {
 	if(strcmp(se[i].Name,str)==0)
 	{
 	if(se[i].checked==1)
 	return -1;
 	else
 	se[i].checked=1;
 	return i;
 	}
 }
 return -1;
 }
 
 void clear_set_se(int index)
 {
 int i;
 for(i=0;i<s_count;i++)
 {
 	if(index==i)
 	se[i].checked=1;
 	else
 	se[i].checked=0;
 }
 }
 
 void main()
 {
 int N,i,crt_testcase,q_count;
 char str[102];
 int secount=0,se_index,max_se,cnt_checked,no_of_switch=0;
 
 clrscr();
 
 if ((fp = fopen(αd:\san\codejam\1\input.txtα, αrtα))
     == NULL)
 {
    fprintf(stderr, αCannot open input file.nα);
    return;
 }
 
 if ((fpout = fopen(αd:\san\codejam\1\output.txtα, αwtα))
     == NULL)
 {
    fprintf(stderr, αCannot open input file.nα);
    return;
 }
 
 fscanf(fp,α%dnα,&N);
 
 crt_testcase=0;
 while(crt_testcase++<N)
 {
 	fprintf(fpout,αCase #%d: α,crt_testcase);
 
 	fscanf(fp,α%dnα,&s_count);
 
 	for(i=0;i<s_count;i++)
 	{
 		se[secount].checked=0;
 		fgets(se[secount].Name,101,fp);
 		secount++;
 	}
 
 	fscanf(fp,α%dnα,&q_count);
 	for(i=0;i<q_count;i++)
 	{
 		fgets(str,101,fp);
 
 		if((se_index=mark(str))>=0)
 		{
 			max_se = se_index;
 			cnt_checked++;
 		}
 		else
 		{
 			continue;
 		}
 
 		if(cnt_checked == s_count)
 		{
 			no_of_switch++;
 			clear_set_se(max_se);
 			cnt_checked=1;
 		}
 	}
 
 	fprintf(fpout,α%dnα,no_of_switch);
 
 	secount=0;
 	no_of_switch=0;
 	cnt_checked=0;
 }
 }"
16176,2008,32013,patil.sandip,24481,1,T1.C,gcj/2008/32013/patil.sandip/24481/1/extracted/T1.C,"#include<stdio.h>
 
 
 int L[100],R[100];
 void Merge(int A[],int p,int q,int r)
 {
 int n1=q-p+1;
 int n2=r-q;
 int i,j,k;
 
 for(i=0;i<n1;i++)
    L[i]=A[p+i];
 
 for(j=0;j<n2;j++)
    R[j]=A[q+j+1];
 
 i=j=0;
 
 for(k=p;k<=r;k++)
    {
    if(L[i] <= R[j])
      {
      A[k]=L[i];
      i++;
      }
    else
      {
      A[k]=R[j];
      j++;
      }
 
      if(i==n1)
      {
      k++;
      for(;j<n2;j++)
 	A[k++]=R[j];
      break;
      }
      if(j==n2)
      {
      k++;
      for(;i<n1;i++)
 	A[k++]=L[i];
      break;
      }
    }
 
 
 }
 
 void Merge_Sort(int A[],int p, int r)
 {
 if(p<r)
   {
   int q=(p+r)/2;
   Merge_Sort(A,p,q);
   Merge_Sort(A,q+1,r);
   Merge(A,p,q,r);
   }
 }
 
 void main()
 {
 int train_A,train_B,i;
 int AA[100],DA[100],AB[100],DB[100],AA_cnt,DA_cnt,AB_cnt,DB_cnt;
 int cnt_A,cnt_B,h1,m1,h2,m2;
 int crt_testcase,N,turnaround;
 FILE *fp,*fpout;
 clrscr();
 
 if ((fp = fopen(αd:\san\codejam\2\input.txtα, αrtα))
     == NULL)
 {
    fprintf(stderr, αCannot open input file.nα);
    return;
 }
 
 if ((fpout = fopen(αd:\san\codejam\2\output.txtα, αwtα))
     == NULL)
 {
    fprintf(stderr, αCannot open input file.nα);
    return;
 }
 
 fscanf(fp,α%dnα,&N);
 
 crt_testcase=0;
 while(crt_testcase++<N)
 {
 	fprintf(fpout,αCase #%d: α,crt_testcase);
 
 	fscanf(fp,α%dnα,&turnaround);
 	fscanf(fp,α%dnα,&cnt_A);
 	fscanf(fp,α%dnα,&cnt_B);
 	printf(α%dn%d %dα,turnaround,cnt_A,cnt_B);
 
 	for(i=0;i<cnt_A;i++)
 	{
 		fscanf(fp,α%d:%d %d:%dnα,&h1,&m1,&h2,&m2);
 		DA[i]=h1*60+m1;
 		AB[i]=h2*60+m2+turnaround;
 		//printf(α%d:%d %d:%d   %d  %dnα,h1,m1,h2,m2,DA[i],AB[i]);
 	}
 
 	for(i=0;i<cnt_B;i++)
 	{
 		fscanf(fp,α%d:%d %d:%dnα,&h1,&m1,&h2,&m2);
 		DB[i]=h1*60+m1;
 		AA[i]=h2*60+m2+turnaround;
 		//printf(α%d:%d %d:%d   %d  %dnα,h1,m1,h2,m2,DB[i],AA[i]);
 	}
 
 
 	train_A=calculate(AA,DA,cnt_B,cnt_A);
 	train_B=calculate(AB,DB,cnt_A,cnt_B);
 	fprintf(fpout,α%d %dnα,train_A,train_B);
 }
 
 }
 
 int calculate(int A[],int D[],int A_cnt,int D_cnt)
 {
 int traincnt=0,A_ptr=0,D_ptr=0;
 Merge_Sort(A,0,A_cnt-1);
 Merge_Sort(D,0,D_cnt-1);
 
 while(A_ptr<A_cnt && D_ptr<D_cnt)
 {
 	if(A[A_ptr]<=D[D_ptr])
 	{
 		A_ptr++;
 		D_ptr++;
 	}
 	else
 	{
 		traincnt++;
 		D_ptr++;
 	}
 }
 
 if(A_ptr==A_cnt&&D_ptr<D_cnt)
 {
 	traincnt = traincnt + D_cnt - D_ptr;
 }
 return traincnt;
 }"
16242,2008,32013,takfjt,24481,1,01.c,gcj/2008/32013/takfjt/24481/1/extracted/01.c,"#include <stdio.h>
 
 #include <limits.h>
 
 enum event {
     START_FROM_A,
     START_FROM_B,
     READY_AT_A,
     READY_AT_B,
 };
 
 struct time_table {
     int time;
     enum event event;
     int data;
     struct time_table *next;
 };
 
 int
 s2a(char *t)
 {
     return ((t[0] - '0') * 10 + (t[1] - '0')) * 60
         + (t[3] - '0') * 10 + (t[4] - '0');
 }
 
 int
 main()
 {
     struct time_table *t_start = NULL, *t_tmp, *t, **t_prev, *t2;
     
     int turn;
     int na, nb;
     int ra, rb;
     int ua, ub;
 
     int line, l;
     int i;
     char s1[6], s2[6];
 
     scanf(α%dα, &line);
 
     for (l = 0; l < line; l++) {
         ra = rb = 0;
         ua = ub = 0;
         scanf(α%dα, &turn);
         scanf(α%d %dα, &na, &nb);
 
         for (i = 0; i < na; i++) {
             t_tmp = malloc(sizeof(*t_tmp));
             //printf(αmalloc:%pnα, t_tmp);
             memset(t_tmp, 0, sizeof(*t_tmp));
             scanf(α%s %sα, s1, s2);
             t_tmp->time = s2a(s1);
             t_tmp->data = s2a(s2) + turn;
             t_tmp->event = START_FROM_A;
 
             if (t_start == NULL) t_start = t_tmp;
             else {
                 for (t = t_start, t_prev = &t_start; t; t_prev = &t->next, t = t->next) {
                     if (t->time > t_tmp->time) {
                         *t_prev = t_tmp;
                         t_tmp->next = t;
                         break;
                     }
                     if (t->next == NULL) {
                         t->next = t_tmp;
                         t_tmp->next = NULL;
                         break;
                     }
                 }
             }
         }
         for (i = 0; i < nb; i++) {
             t_tmp = malloc(sizeof(*t_tmp));
             //printf(αmalloc:%pnα, t_tmp);
             memset(t_tmp, 0, sizeof(*t_tmp));
             scanf(α%s %sα, s1, s2);
             t_tmp->time = s2a(s1);
             t_tmp->data = s2a(s2) + turn;
             t_tmp->event = START_FROM_B;
 
             if (t_start == NULL) t_start = t_tmp;
             else {
                 for (t = t_start, t_prev = &t_start; t; t_prev = &t->next, t = t->next) {
                     if (t->time > t_tmp->time) {
                         *t_prev = t_tmp;
                         t_tmp->next = t;
                         break;
                     }
                     if (t->next == NULL) {
                         t->next = t_tmp;
                         t_tmp->next = NULL;
                         break;
                     }
                 }
             }
         }
 
         // go!
 
         t = t_start;
         t_start = NULL;
         while (t) {
             //fprintf(stderr, α(%d %d %d) (%d %d %d)nα, na, ra, ua, nb, rb, ub);
             fprintf(stderr, α%02d:%02d %02d:%02d %snα,
                     t->time / 60,
                     t->time % 60,
                     t->data / 60,
                     t->data % 60,
                     t->event == START_FROM_A ? αA->Bα :
                     t->event == START_FROM_B ? αB->Aα :
                     t->event == READY_AT_A ? αReady Aα :
                     t->event == READY_AT_B ? αReady Bα : α-α);
 
             switch (t->event) {
             case START_FROM_A:
                 if (ra > 0) ra--;
                 else {
                     na--;
                     ua++;
                 }
                 t->event = READY_AT_B;
                 t->time = t->data;
                 t->data = 0;
                 break;
             case START_FROM_B:
                 if (rb > 0) rb--;
                 else {
                     nb--;
                     ub++;
                 }
                 t->event = READY_AT_A;
                 t->time = t->data;
                 t->data = 0;
                 break;
             case READY_AT_A:
                 t->time = -1;
                 ra++;
                 break;
             case READY_AT_B:
                 t->time = -1;
                 rb++;
                 break;
             }
 
             t_tmp = t;
             t = t->next;
             
             if (t_tmp->time > 0) {
                 for (t2 = t, t_prev = &t; t2; t_prev = &t2->next, t2 = t2->next) {
                     if (t2->time >= t_tmp->time) {
                         *t_prev = t_tmp;
                         t_tmp->next = t2;
                         break;
                     }
                     if (t2->next == NULL) {
                         t2->next = t_tmp;
                         t_tmp->next = NULL;
                         break;
                     }
                 }
             } else {
                 //printf(α%pnα, t_tmp);
                 printf(αα);
                 free(t_tmp);
             }
         }
         fprintf(stderr, α%d / %dnα, na, nb);
         printf(αCase #%d: %d %dnα, l + 1, ua, ub);
 
 
     }
 
     return 0;
 }"
16247,2008,32013,veeJay,24480,1,srch.c,gcj/2008/32013/veeJay/24480/1/extracted/srch.c,"#include<stdio.h>
 #include<string.h>
 main()
 {
     char srch[100][1000],qry[1000][1000];
 	int sr[100];
     int n,s,q,l;
 	int max;
 	int count;
     int i,j,k;
     scanf(α%dα,&n);
 	for(i=1;i<=n;i++)
 	{
 		scanf(α%dα,&s);
 		for(j=0;j<=s;j++)
 		{
 			gets(srch[j]);
 			sr[j]=0;
 		}
 		scanf(α%dα,&q);
 		for(j=0;j<=q;j++)
 		    gets(qry[j]);
 		count=0;
 		max=0;
 		l=1;
 		if(q==0)
 			count=1;
 		//Now we will check for minimum switching
 		while(l<=q)
 		{
 			for(k=1;k<=s;k++)
 			{
 				j=l;
 				while(strcmp(srch[k],qry[j]) && j<=q)
 					j++;
 				sr[k]=j;
 //				printf(αsr[%d]=%dnα,k,sr[k]);
 			}
 			for(k=1;k<=s;k++)
 				max=(sr[k]>max)?sr[k]:max;
 			l=max;
 //			printf(αmax=%dnα,max);
 			count++;
 		}
 		printf(αCase #%d: %dnα,i,count-1);
 	}
 	getch();
 }"
16299,2008,32013,varunbj,24480,1,universe.c,gcj/2008/32013/varunbj/24480/1/extracted/universe.c,"#include<stdio.h>
 #include<stdlib.h>
 //#include<alloc.h>
 
 #define len 102
 #define max 10000
 
 void findoccur(char **si,int s,char **qu,int q,int *x,int idx)
 {
  int i,j;
  for(i=0;i<s;i++)
    *(x+i)=max;
    for(i=0;i<s;i++)
               for(j=idx;j<q;j++)                      
                   if(strcmp(*(si+i),*(qu+j))==0)
                            {
                            *(x+i)=j;
                            break;
                            } 
      
 }    
 
 int findmax(int *x,int s)
 {
     int i,j=0,val=*x;
     for(i=0;i<s;i++)
     if(val<*(x+i))
     val=*(x+i);
     return val;
 }    
 
 int main()
 {
   char buff[len];
   int n,s,q,i,j,count,cases,*x;
   char **si,**qu;
   FILE *file=NULL;  /* declare a FILE pointer  */
   FILE *file1=NULL;
   file = fopen(αd:input.inα,αrα);
   file1 = fopen(αd:output.txtα,αwα); 
   /* open a text file for reading */
      printf(αFile opened successfully. Contents:nnα);
         fgets(buff,len,file);
         n=atoi(buff);
         printf(α%dnα,n);
         cases=1;
         while(cases<=n)
         {        j=0;count=-1;
               s=atoi(fgets(buff,len,file));
               printf(α%dnα,s);
               si=malloc(sizeof (char *) * s);
               x= malloc(sizeof (int) * s);
               for(i=0;i<s;i++)
               {             
                             *(si+i)=malloc(sizeof (char *) * len);
                             fgets(*(si+i),102,file);
                             printf(α%snα,*(si+i));
                             *(x+i)=-1;
               }
               
               q=atoi(fgets(buff,102,file));
               printf(α%dnα,q);
               qu=malloc(sizeof (char *) * q); 
               for(i=0;i<q;i++)
               {             
                             *(qu+i)=malloc(sizeof (char *) * len);
                             fgets(*(qu+i),102,file);
                             printf(α%snα,*(qu+i));
               }  
               while(j<=q)
                        {
                             findoccur(si,s,qu,q,x,j);
                             j= findmax(x,s);
                             printf(αj=%dnα,j);
                             count++;
                        }
                            
              fprintf(file1,αCase #%d: %dnα,cases++,count);
              free(x);
              for(i=0;i<s;i++)
               {             
                             free(*(si+i));
               }
               free(si);
              for(i=0;i<q;i++)
               {             
                             free(*(qu+i));
               }      
               free(qu);    
         }
         
     printf(αnnNow closing file...nα);
     fclose(file);
    fclose(file1); 
     getchar();
    
     
     return 0;
 }"
16301,2008,32013,sunnyboy,24480,1,A.c,gcj/2008/32013/sunnyboy/24480/1/extracted/A.c,"#include<stdio.h>
 #include<string.h>
 int main(void)
 {
     FILE *fin  = fopen (αA-large.inα, αrα);
     FILE *fout = fopen (αA-large.outα, αwα);
     
     int num,t,n,m,k,i,j,ans;
     char c[120];
     fscanf(fin,α%dα,&num);
     for(t=1;t<=num;t++){
         char s[120][120];
         int a[120]={0};
         fscanf(fin,α%d α,&n);
         for(i=1;i<=n;i++){
             fgets(s[i],1024,fin);
         }    
         ans=0;
         a[0]=n;
         fscanf(fin,α%d α,&m);
         for(j=1;j<=m;j++){
             fgets(c,1024,fin);
             for(i=1;i<=n;i++)
                 if(a[i]==ans){
                     if(strcmp(s[i],c)==0){
                         a[i]++;
                         a[0]--;
                         if(a[0]==0){
                             a[0]=n-1; 
                             ans++;
                             a[i]++;
                         }    
                         break;
                     }    
                 }    
         }    
         fprintf(fout,αCase #%d: %dnα,t,ans);
     }    
     return 0;
 }"
16309,2008,32013,Srinivas,24480,1,1.c,gcj/2008/32013/Srinivas/24480/1/extracted/1.c,"#include<stdio.h>
 #include<stdlib.h>
 int checkzero(int count[],int n,int s)
 {
 	int i,flag=0;
 	for(i=0;i<n;i++)
 	{
 		if(count[i]==0 && i!=s)
 		{
 			flag=1;
 			break;
 		}
 	}
 	return flag;
 }
 main()
 {
 	int num,i,j,k,check,total=0,pres;
 	scanf(α%dα,&num);
 	for(i=0;i<num;i++)
 	{
 		int no;
 		pres=-1;
 		scanf(α%dα,&no);
 		char engine[no][100];
 		for(j=0;j<no;j++)
 			scanf(α %[^n]α,engine[j]);
 		int noq;
 		scanf(α%dα,&noq);
 		char query[noq][100];
 		for(j=0;j<noq;j++)
 			scanf(α %[^n]α,query[j]);
 		int count[no];
 		for(j=0;j<no;j++)
 			count[j]=0;
 		for(j=0;j<noq;j++)
 		{
 			for(k=0;k<no;k++)
 			{
 				if(strcmp(query[j],engine[k])==0)
 				{
 					count[k]++;
 					break;
 				}
 			}
 			check = checkzero(count,no,pres);
 			if(check == 0)
 			{
 				total++;
 				pres=k;
 				for(k=0;k<no;k++)
 					count[k]=0;
 			}
 		}
 		printf(αCase #%d: %dnα,i+1,total);
 		total = 0;
 	}
 }"
16428,2008,32013,bcoder,24480,1,savinguniv.c,gcj/2008/32013/bcoder/24480/1/extracted/savinguniv.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int isallOne(int a[],int s);
 int runonce();
 //FILE *fp;
 
 int main()
 {
 	int n;
 	int i;
   /*	FILE *op;
 
 	fp = fopen(αtrial.inα,αrα);
 	op = fopen(αoutput.txtα,αwα);
 	*/
 	/*if(!fp || !op)
 	{
 			  printf(αunable to open or make gile ... α);
 			  return 0;
 	} */
 	fflush(stdin);
 	scanf(α%dα,&n);
 	fflush(stdin);
 
 	//printf(αnnn = %dα,n);
 	int x;
 
 	for(i=0;i<n;i++)
 	{
 		fflush(stdin);		
 		x = runonce();
 		printf(αCase #%d: %dnα,i+1,x);
 	}
 	//getchar();
 	//fclose(fp);
 	//fclose(op);
 	return 0;
 }
 
 int isallOne(int a[],int s)
 {
 	int i=0;
 	for(i=0;i<s;i++)
 	{
 		if(a[i]==0)
 			return 0;
 	}
 	return 1;
 }
 
 int runonce()
 {
 	char **str,query[103];
 	int s,q;
 	int *arr_index;
 	int swtch=0,i;
 
 	fflush(stdin);
 	scanf(α%dα,&s);
 	getchar();	
 	//fflush(stdin);
 
 	//assert(s>0);
 	//printf(αns = %dnα,s);
 	fflush(stdin);	
 	str = (char**)malloc(sizeof(char*)*s);
 	arr_index = (int*)malloc(sizeof(int)*s);
 	if(!arr_index)
 	{
 		printf(αnerror in 1...α);
 	}
 	for(i=0;i<s;i++)
 		arr_index[i]=0;
 
 	if(!str)
 	{
 			printf(αerror in memory allocationα);
 	}
 
 	for(i=0;i<s;i++)
 	{
 			str[i] = (char*)malloc(sizeof(char)*101);
 			if(!str[i])
 			{
 			  	printf(αerror ... α);
 			}
 	}
 	
 	fflush(stdin);
 	for(i=0;i<s;i++)
 	{
 					fflush(stdin);
 					fgets(str[i],100,stdin);
 					fflush(stdin);
 					
 					//printf(αni = %d, s = %d str = %snα,i,s,str[i]);
 	}
 
 	int j;
 
 	fflush(stdin);
 	scanf(α%dα,&q);
 	fflush(stdin);
 	getchar();
 	//printf(αnq = %dα,q);
 	for(i=0;i<q;i++)
 	{
 
 				   fflush(stdin);
 					fgets(query,102,stdin);
 				   //printf(αnq = %d, i = %d querynα,q,i);
 				   fflush(stdin);
 				  //getchar();
 					for(j=0;j<s;j++)
 					{
 										   if(strcmp(query,str[j])==0)
 										   {
 											arr_index[j]=1;
 											break;
 											}
 					}
 				  //  fflush(stdin);
 					int temp=j;
 					if(isallOne(arr_index,s))
 					{
 											swtch++;
 											for(j=0;j<s;j++)
 													arr_index[j]=0;
 					}
 					if(temp<s)
 						   arr_index[temp]=1;
 	}
 	free(arr_index);
 	for(i=0;i<s;i++)
 		free(str[i]);
 	free(str);
 	return swtch;
 }"
16476,2008,32013,Saikat,24480,1,universe.c,gcj/2008/32013/Saikat/24480/1/extracted/universe.c,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 #define SIZE 1000
 int main()
 {  
    int testcase,output[SIZE]; 
    char server[SIZE][SIZE];
    char query[SIZE][SIZE];
    FILE *fp;
    fp=fopen(αoutput.txtα,αwα);
    int server_size,query_size,index,i,j,no_switch,m,k,max,l;
    int a[SIZE];
    scanf(α%dα,&testcase);
    fflush(stdin);
    for(l=0;l<testcase;l++)
    {
     scanf(α%dα,&server_size);
     fflush(stdin);
     for(m=0;m<server_size;m++)
     {
      gets(server[m]);
                        //       fflush(stdin);
     }                          
     scanf(α%dα,&query_size);
     fflush(stdin);
     for(m=0;m<query_size;m++)
     gets(query[m]);
     j=0;
     
     no_switch=-1;
     while(j<query_size)
     {
       for(i=0;i<server_size;i++)
       {
          index=i;
          for(k=j;k<query_size;k++)
          {
             if(strcmp(server[index],query[k])==0)
             {
                   printf(αIndex for %s=%dnα,server[index],k);
                   break;
             }      
          }
 
          a[index]=k;
       }
       max=a[0];
       for(m=1;m<server_size;m++)
       {
          if(max < a[m])
             max=a[m];
       }
       printf(αmax=%dnα,max);  
       j=max;
       no_switch++;
     }                    
     if(no_switch == -1)
        no_switch=0;             
     output[l]=no_switch;
   }
   for(k=0;k<testcase;k++)
   {
   fprintf(fp,αCase #%d: %dnα,k+1,output[k]);
   }
   fclose(fp);
   getch();                          
 }"
16540,2008,32013,YSP,24481,1,train.C,gcj/2008/32013/YSP/24481/1/extracted/train.C,"# include <iostream>
 # include <fstream>
 using namespace std;
 
 void sort (int *a, int n)
    {int pass, j, tmp;
     bool xchange = true;
     for (pass = 1; pass < n && xchange == true; pass++)
     { xchange = false;
       for (j=0; j < n - pass; j++)
       { if (a[j] > a[j+1])
         { tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;
           xchange = true;
         } /* end of if */
       } /* end of inner for loop */
     } /* end of outer for loop */
    } /* end of bubble sort */
 
 
 int main()
 {int NoOfTestCases;
 ifstream fin(αtest.inputα, ios::in);
 fin >> NoOfTestCases;
 for (int i=1; i<=NoOfTestCases; i++)
 	{int TurnTime;
 	fin >> TurnTime;
 	int NA, NB;
 	fin >> NA >> NB;
 	int DepartFromA[NA];
 	int ArriveAtA[NB];
 	int DepartFromB[NB];
 	int ArriveAtB[NA];
 	for (int j=0; j<NA; j++)
 		{int dummyhr, dummymin;
 		char dummychar;
 		fin >> dummyhr >> dummychar >> dummymin;
 		DepartFromA[j]=(dummyhr*60 + dummymin);
 		fin >> dummyhr >> dummychar >> dummymin;
 		ArriveAtB[j]=(dummyhr*60 + dummymin);}
 	for (int j=0; j<NB; j++)
 		{int dummyhr, dummymin;
 		char dummychar;
 		fin >> dummyhr >> dummychar >> dummymin;
 		DepartFromB[j]=(dummyhr*60 + dummymin);
 		fin >> dummyhr >> dummychar >> dummymin;
 		ArriveAtA[j]=(dummyhr*60 + dummymin);}
 	sort (DepartFromA, NA);
 	sort (ArriveAtA, NB);
 	sort (DepartFromB, NB);
 	sort (ArriveAtB, NA);
 	
 	int ReqdFromA=0, ReqdFromB=0;
 	int k=0;
 	for (int j=0; j<NA; j++)
 		{if ( (k<NB) && ( (DepartFromA[j]-ArriveAtA[k]) >= TurnTime) )
 			k++;
 		else
 			ReqdFromA++;
 		}
 	k=0;
 	for (int j=0; j<NB; j++)
 		{//cerr << ArriveAtB[k] << endl;
 		if ( (k<NA) && ( (DepartFromB[j]-ArriveAtB[k]) >= TurnTime) )
 			k++;
 		else
 			ReqdFromB++;
 		}
 //	cerr<<TurnTime << α α <<NA<<α α << NB<<endl;
 	cout << αCase #α << i << α: α << ReqdFromA << α α << ReqdFromB << endl;
 	}
 }"
16550,2008,32013,WhiteShadow,24480,1,a.c,gcj/2008/32013/WhiteShadow/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_NAME    105
 #define MAX_ENGINES 105
 #define MAX_QUERY   1005
 
 char e[MAX_ENGINES][MAX_NAME];
 char can[MAX_ENGINES];
 int q[MAX_QUERY];
 int ne, nq;
 
 int num(char *s) {
   int i;
   for (i=0; i<ne; i++) {
     /*printf(α(%s) (%s)nα,e[i],s);*/
     if (!strcmp(s, e[i])) return i;
   }
   return -1;
 }
 
 int main() {
   int i, j, n, count, remain;
   char tmp[MAX_NAME];
   
   scanf(α%dα,&n);
   for (i=1; i<=n; i++) {
     scanf(α%dα,&ne);
     gets(tmp);
     for (j=0; j<ne; j++)
       gets(e[j]);
     scanf(α%dα,&nq);
     gets(tmp);
     for (j=0; j<nq; j++) {
       gets(tmp);
       q[j] = num(tmp);
     }
 
     memset(can, 1, sizeof(can));
     count = 0; remain=ne;
     for (j=0; j<nq; j++) {
       if (q[j]>=0 && can[q[j]]) {
 	can[q[j]]=0;
 	remain--;
       }
       if (remain == 0) {
 	count++;
 	remain = ne;
 	memset(can, 1, sizeof(can));
 	can[q[j]]=0;
 	remain--;
       }
     }
     
     printf(αCase #%d: %dnα, i, count);
   }
 
 
 
   return 0;
 }"
16552,2008,32013,WhiteShadow,24479,1,new.c,gcj/2008/32013/WhiteShadow/24479/1/extracted/new.c,"#include <stdio.h>
 #include <math.h>
 #include <limits.h>
 
 // pi * r^2
 
 #define PRECISION 0.0000001
 
 double f, R, t, r, g, p, aux_r;
 
 double area(double x1, double y1, double x2, double y2) {
   double mx, my;
 
   //printf(α(%.4lf,%.4lf) size %.4lfnα,x1,y1,x2-x1);
 
   if (x2-x1 < PRECISION) return 0;
   //puts(α1α);
 
   if (x1*x1 + y1*y1 >= aux_r) return 0;
   //puts(α2α);
   
   if (x2*x2 + y2*y2 < aux_r)
     return (x2-x1)*(y2-y1);
   //puts(α3α);
 
   mx = (x1+x2)/2.0;
   my = (y1+y2)/2.0;
 
   return area(x1,y1,mx,my) + 
     area(mx,y1,x2,my) +
     area(x1,my,mx,y2) +
     area(mx,my,x2,y2);
   
 }
 
 int main() {
   int i, n;
   double a;
   double x, y, factor;
 
   scanf(α%dα,&n);
   for (i=1; i<=n; i++) {
     scanf(α%lf %lf %lf %lf %lfα,&f, &R, &t, &r, &g);
 
     factor = R;
     R/=factor;
     f/=factor;
     t/=factor;
     r/=factor;
     g/=factor;
 
     t+= f;
     r+= f;
     g-=f+f;
     if (g<0) g=0;
     aux_r = (R-t)*(R-t);
 
     a = 0.0;
     for (x=r; x<R-t; x+=g+r+r)
       for (y=r; y<R-t; y+=g+r+r) {
 	a += area(x,y,x+g,y+g);      
     }
 
 
     p = a / (M_PI*R*R / 4);
     printf(αCase #%d: %.6lfnα, i, 1-p);
   }
 
   return 0;
 }"
16554,2008,32013,WhiteShadow,24481,1,b.c,gcj/2008/32013/WhiteShadow/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_TIME 3600
 
 int t, na, nb;
 int a[MAX_TIME], b[MAX_TIME];
 
 int main() {
   int i,j,k,n,m,h,aux;
   int mina, minb;
 
   scanf(α%dα,&n);
   for (i=1; i<=n; i++) {
     scanf(α%dα,&t);
     scanf(α%d %dα,&na,&nb);
     memset(a,0,sizeof(a));
     memset(b,0,sizeof(b));
     for (j=0; j<na; j++) {
       scanf(α%d:%dα,&h,&m); aux=h*60+m;
       for (k=aux;k<MAX_TIME;k++) a[k]--;
       scanf(α%d:%dα,&h,&m); aux=h*60+m;
       for (k=aux+t;k<MAX_TIME;k++) b[k]++;
     }
     for (j=0; j<nb; j++) {
       scanf(α%d:%dα,&h,&m); aux=h*60+m;
       for (k=aux;k<MAX_TIME;k++) b[k]--;
       scanf(α%d:%dα,&h,&m); aux=h*60+m;
       for (k=aux+t;k<MAX_TIME;k++) a[k]++;
     }
 
     mina = minb = 0;
     for (k=0; k<MAX_TIME; k++) {
       if (a[k]<mina) mina=a[k];
       if (b[k]<minb) minb=b[k];
     }
     printf(αCase #%d: %d %dnα,i,-mina,-minb);
   }
 
 
   return 0;
 }"
16719,2008,32013,ForceSource,24480,1,a.c,gcj/2008/32013/ForceSource/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int numn,i,j,n,s,q,countswitch=0;
 char engine[100][100],query[100];
 int countengine[100]={0};
 
 void reallycleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 }
 
 void cleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 	countengine[j]++;		
 }
 
 void checkarray() {
 	int index,zerocount=0;
 	for(index=0; index<s; index++)
 		if(!countengine[index]) zerocount++;
 	if(zerocount == 0) { 
 		countswitch++;
 		cleararray();
 	}
 }
 
 int main() {
 	scanf(α%dα,&n);
 	for(numn=0; numn<n; numn++) {
 		scanf(α%dα,&s);
 		getchar();
 		for(i=0; i<s; i++) {
 			gets(engine[i]);
 		}
 		scanf(α%dα,&q);
 		getchar();
 		for(i=0; i<q; i++) {
 			gets(query);
 			for(j=0; j<s; j++) {
 				if(!strcmp(query,engine[j])) {
 					countengine[j] += !strcmp(query,engine[j]);
 					break;
 				}	
 			}
 			checkarray();
 		}	
 		reallycleararray();
 		printf(αCase #%d: %dnα,numn+1,countswitch);
 		countswitch = 0;
 	}
 	return 0;
 }"
16721,2008,32013,ForceSource,24481,1,train.c,gcj/2008/32013/ForceSource/24481/1/extracted/train.c,"#include<stdio.h>
 
 int n,a,b,i,j,k,l,t,counta,countb,q;
 int tmp1,tmp2,tmp3,tmp4;
 int tafrom[200],tato[200],tat[200];
 int flag,what;
  
 int route(int index) {
     int m;
     if(flag == 0) {
         flag = 1;
         what = tat[index];
     }
     if(tat[index] == 0) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 1)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     } else
     if(tat[index] == 1) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 0)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     }
     tat[index] = -1;
     return what;
 }
 
 
 
 
 
 
    
 int main() {
     scanf(α%dα,&n);
     for(l=0;l<n;l++) {
         scanf(α%dα,&t);
         scanf(α%d %dα,&a,&b);
         for(j=0; j<a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 0;
         }
         for(; j<b+a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 1;
         }
     
 // Sort
     for(i=0;i<a+b-1;i++)
         for(j=0;j<a+b-1;j++)
             if(tafrom[j] > tafrom[j+1]) {
                 tmp1 = tafrom[j];
                 tafrom[j] = tafrom[j+1];
                 tafrom[j+1] = tmp1;
                 tmp1 = tato[j];
                 tato[j] = tato[j+1];
                 tato[j+1] = tmp1;
                 tmp1 = tat[j];
                 tat[j] = tat[j+1];
                 tat[j+1] = tmp1;
             }
     for(i=0; i<a+b; i++) {
 
       
         q = route(i);
         if(q == 0) {
             counta++;
             flag = 0;
         }
         if(q == 1) {
             countb++;
             flag = 0;
         }
         if(q == -1)
             flag = 0;
     }
 
     printf(αCase #%d: %d %dnα,l+1,counta,countb);
 
 
     for(i=0; i<a+b; i++) {
         tafrom[i] = 0;
         tato[i] = 0;
         tat[i] = 0;
     }
     counta = 0;
     countb = 0;
     flag = 0;
 
     }
 
 return 0;
 }"
16855,2008,32013,tsipi,24480,1,universe.c,gcj/2008/32013/tsipi/24480/1/extracted/universe.c,"// Saving the Universe
 
 #include <stdio.h>
 #include <string.h>
 
 #define MAX_STRING 101 //size includes NULL char
 
 //----------------------------------------------------------------
 
 void filter_input(char *input){
   char *ptr;
 
   if((ptr = strchr(input, 'r')) != NULL){
     *ptr = '0';
   }
 }
 
 //----------------------------------------------------------------
 
 int main(int argc, char* argv[]){
   FILE *fin;
   int x, y, z, w;
   int cases, engines, queries;
   char *engine_list;
   int *engine_stats; //for storing first encounter of each engine
   char tmp[MAX_STRING];
   char current[MAX_STRING];
   int counter, max_id;
   int switches = 0;
 
   if(argc != 2){
     printf(αERROR! Please use syntax: universe input.txtnα);
     exit(1);
   }
 
   fin = fopen(argv[1], αrα);
 
   if(!fin){
     printf(αERROR! Cannot open input file!nα);
     exit(1);
   }
   
   fscanf(fin, α%dα, &cases);
 
   for(x=0; x<cases; x++){
     strcpy(current, αα);
 
     fscanf(fin, α%dα, &engines);
     fgets(tmp, MAX_STRING - 1, fin);
     engine_list = (char*)malloc(engines * MAX_STRING * sizeof(char));
     engine_stats = (int*)malloc(engines * sizeof(int));
 
     for(y=0; y<engines; y++){
       engine_stats[y] = -1;
       fgets(tmp, MAX_STRING - 1, fin);
       filter_input(tmp);
       strcpy(&engine_list[y * MAX_STRING], tmp);
     }
 
     fscanf(fin, α%dα, &queries);
     counter = 0;
 
     //advance to next line
     fgets(tmp, MAX_STRING - 1, fin);
 
     for(y=0; y<queries; y++){
       //determine when is the first appearance of each engine
       bzero(tmp,MAX_STRING);
       fgets(tmp, MAX_STRING - 1, fin);
       //printf(αbefore: -%s-nα, tmp);
       filter_input(tmp);
       //printf(αafter: -%s-nα, tmp);
 
       for(z=0; z<engines; z++){
 	if(strcmp(tmp, &engine_list[z * MAX_STRING]) == 0 && engine_stats[z] == -1){
 	  if(strcmp(current, tmp) != 0){
 	    //note down the query id where the engine is found for the first time`
 	    engine_stats[z] = y;
 	    counter++;
 	  }
 	}
       }
 
       //stop iterating through queries as soon as all engines are used
       //at that point a change is necessary, since we can assume that for
       //all previous queries, this latest engine was being used
       if(counter == engines){
 	switches++;
 	counter = 1;
 	max_id = -1;
 
 	for(z=0; z<engines; z++){
 	  if(engine_stats[z] > max_id){
 	    max_id = engine_stats[z];
 	    strcpy(current, &engine_list[z * MAX_STRING]);
 	  }
 	}
 
 	for(z=0; z<engines; z++){
 	  engine_stats[z] = -1;
 	}
       }
     } 
 
     printf(αCase #%d: %dnα, x+1, switches);
 
     //initialize variables for new case
     switches = 0;
     free(engine_stats);
     free(engine_list);
     engines = 0;
     queries = 0;
     counter = 0;
   }
 
   fclose(fin);
 }
 
 //----------------------------------------------------------------"
16879,2008,32013,maismail,24480,1,saveUniverse.c,gcj/2008/32013/maismail/24480/1/extracted/saveUniverse.c,"#include <stdio.h>
 #include <math.h>
  
 int getMinimum(int * flags, int size,int exclude);
 void computeFlags(int * flags,char ** searchEngineNames , char **queries ,int noOfSearchEngines ,int noOfQueries );
 int main (void )
 {
 
  int x;
  FILE* out = fopen(αoutput.txtα,αwα);
  FILE* f = fopen (αfile.txtα,αrα);
  int noOfSwitches = 0;
  if(f == 0) return 0;
  int j ,i , k;
  int noOfCases = 0 ;
  fscanf(f,α%dα,&noOfCases);
 
 
  for( j= 0 ; j<noOfCases; j++)  
  {
   int noOfSearchEngines = 0 ;
   fscanf(f,α%dα,&noOfSearchEngines);
 	//printf(αno Of search %dnα,noOfSearchEngines);
   getc(f);
 	
   char ** searchEngineNames = malloc (noOfSearchEngines * sizeof(*searchEngineNames ));
   char c ;
   int counter = 0 ;
   for(i = 0 ; i<noOfSearchEngines; i++)
   {
 	searchEngineNames[i] = malloc (100);
 	counter = 0;
 	c = getc(f);
 	while ( c != 'n')
 	{
 		searchEngineNames[i][counter] = c;
 		counter ++;
 		c = getc(f);
 	}
   }
   
   int noOfQueries = 0;
   fscanf(f,α%dα,&noOfQueries );
   getc(f);
    //printf(αno Of Que %dnα,noOfQueries);
   char ** queries = malloc (noOfQueries * sizeof(*queries ));
   for (i = 0 ; i < noOfQueries ; i++)
   {
 	 queries[ i] = malloc(100) ;
 	counter = 0;
         c = getc(f);
 	while ( c != 'n')
 	{
 		queries[ i][counter] = c;
 		counter ++;
 		c = getc(f);
 	}
 	queries[ i][counter]  = '0';
   }
 
  	int * flags = malloc (noOfSearchEngines*sizeof(int));
 	int currentSearchIndex  = -1;
 	while (noOfQueries > 0)
 	{
 		computeFlags(flags,searchEngineNames,queries,noOfSearchEngines,noOfQueries);
 		currentSearchIndex = getMaximum(flags,noOfSearchEngines,currentSearchIndex ) ; 
 		
 		if(flags[currentSearchIndex] == noOfQueries )
 		{
 			noOfSearchEngines = 0 ;
 			noOfQueries = 0 ;
 		}
 		else
 		{
 			noOfSwitches++;		
 			noOfQueries -= flags[currentSearchIndex];
 			queries += flags[currentSearchIndex];
 		}
 	}
 	fprintf(out,αCase #%d: %dnα,j+1,noOfSwitches);		
   	noOfSwitches = 0 ;
  }
 }
 
 void computeFlags(int * flags,char ** searchEngineNames , char **queries ,int noOfSearchEngines ,int noOfQueries )
 {
 	int k ,i;
 	for(k = 0 ; k<noOfSearchEngines; k++)
   	{
 		flags[k] = 0 ;
 		for(i = 0 ; i <noOfQueries; i++ )
 		{
 
 			if(strcmp(queries[i],searchEngineNames[k]) != 0)
 			{			
 				flags[k]++;
 			}
 			else
 			{
 				break;
 			}
 		}
   	}	
 	
 }
 int getMaximum(int * flags, int size,int exclude)
 {
 	
 	int i = 0 ;
 	int  max;
 	int index ;
 	if (exclude != 0)
 	{
 	 max = flags[0];
  	index = 0;
 	}
 	else 
 	{
 	 max = flags[1];
  	index = 1;
 	}
 	for ( i = 1 ; i < size; i++)
 	{	
 		
 		if(i == exclude)
 		continue;
 		if(flags[i] > max)
 		{	
 			max = flags[i];
 			index = i;
 
 		}
 	}	
 
 	return index;
 }"
16961,2008,32013,shami.thoke,24481,1,multimap.C,gcj/2008/32013/shami.thoke/24481/1/extracted/multimap.C,"#include <cstdio>
 #include <iostream>
 #include <list>
 #include <vector>
 #include <map>
 #include <set>
 #include <string>
 
 using namespace std;
 
 class StationMaster {
   multimap<int, int> A_departure;
   multimap<int, int> B_departure;
   list<int> A_available;
   list<int> B_available;
 
   int TxA;
   int TxB;
   int tat;
   public:
     StationMaster () : TxA(0), TxB(0) {}
     ~StationMaster () {}
     void ReadInput (FILE* fp);
     int getTrainsFromA (void) { return TxA; }
     int getTrainsFromB (void) { return TxB; }
     void computeMinTrains (void);
     void printItinary_A (void);
     void printItinary_B (void);
 };
 
 void StationMaster::printItinary_A (void)
 {
   multimap<int, int>::iterator itx = A_departure.begin();
   multimap<int, int>::iterator itx_end = A_departure.end();
   for(; itx != itx_end; ++itx) {
     cout << αLeaving A at α << (itx->first)/3600 << α:α << ((itx->first) - (((itx->first)/3600)*3600))/60 << endl;
     cout << αReaching B at α << (itx->second)/3600 << α:α << ((itx->second) - (((itx->second)/3600)*3600))/60 << endl;
   }
 }
 
 void StationMaster::printItinary_B (void)
 {
   multimap<int, int>::iterator itx = B_departure.begin();
   multimap<int, int>::iterator itx_end = B_departure.end();
   for(; itx != itx_end; ++itx) {
     cout << αLeaving B at α << (itx->first)/3600 << α:α << ((itx->first) - (((itx->first)/3600)*3600))/60 << endl;
     cout << αReaching A at α << (itx->second)/3600 << α:α << ((itx->second) - (((itx->second)/3600)*3600))/60 << endl;
   }
 
 }
 
 void StationMaster::ReadInput(FILE* fp)
 {
   fscanf(fp, α%dα, &tat);
   // cout << αTurnaround time is : α << tat << endl;
   int Na, Nb;
   fscanf(fp, α%dα, &Na);
   fscanf(fp, α%dα, &Nb);
   // cout << αNumber of Trains leaving A: α << Na << endl;
   // cout << αNumber of Trains leaving B: α << Nb << endl;
   for(int a = 0; a < Na; ++a) {
     char deptA[10], arrvB[10];
     fscanf(fp, α%sα, deptA);
     fscanf(fp, α%sα, arrvB);
 
    /* Stupid string parsing */
     char A_Hr[10], A_Min[10], B_Hr[10], B_Min[10];
     strncpy(A_Hr, deptA, 2);
     strncpy(A_Min, deptA+3, 2);
     strncpy(B_Hr, arrvB, 2);
     strncpy(B_Min, arrvB+3, 2);
     int HrA = atoi(A_Hr);
     int MnA = atoi(A_Min);
     int HrB = atoi(B_Hr);
     int MnB = atoi(B_Min);
 
    // cout << αStarting from A at α << HrA << α hour and α << MnA << α mins.α << endl;
    // cout << αReaching at B at α << HrB << α hour and α << MnB << α mins.α << endl;
 
     // check if first entry is dept or not 
     int departure_A = HrA*3600 + MnA*60;
     int arrival_B = HrB*3600 + MnB*60;
     if(departure_A < arrival_B) {
       A_departure.insert(pair<int, int> (departure_A, arrival_B));  
     }
     else {
       A_departure.insert(pair<int, int> (arrival_B, departure_A));  
     }
   }
   for(int b = 0; b < Nb; ++b) {
     char deptB[10], arrvA[10];
     fscanf(fp, α%sα, deptB);
     fscanf(fp, α%sα, arrvA);
     // cout << αLeaving B at α << deptB << α, Reaching A at α << arrvA << endl;
 
    /* Stupid string parsing */
     char A_Hr[10], A_Min[10], B_Hr[10], B_Min[10];
     strncpy(B_Hr, deptB, 2);
     strncpy(B_Min, deptB+3, 2);
     strncpy(A_Hr, arrvA, 2);
     strncpy(A_Min, arrvA+3, 2);
     int HrA = atoi(A_Hr);
     int MnA = atoi(A_Min);
     int HrB = atoi(B_Hr);
     int MnB = atoi(B_Min);
 
    // cout << αStarting from B at α << HrB << α hour and α << MnB << α mins.α << endl;
    // cout << αReaching at A at α << HrA << α hour and α << MnA << α mins.α << endl;
 
     // check if first entry is dept or not 
     int departure_B = HrB*3600 + MnB*60;
     int arrival_A = HrA*3600 + MnA*60;
     if((departure_B < 86400) && (arrival_A < 86400) ) {
       if(departure_B < arrival_A) {
         B_departure.insert(pair<int, int> (departure_B, arrival_A));  
       }
       else {
         B_departure.insert(pair<int, int> (arrival_A, departure_B));  
       }
     }
   }
 } 
 
 void StationMaster::computeMinTrains (void)
 {
   multimap<int, int>::iterator itx_A = A_departure.begin();
   multimap<int, int>::iterator itx_B = B_departure.begin();
   multimap<int, int>::iterator itx_A_end = A_departure.end();
   multimap<int, int>::iterator itx_B_end = B_departure.end();
 
   while ( (itx_A != itx_A_end) && (itx_B != itx_B_end) ) {
     int A = itx_A->first;
     int B = itx_B->first;
     if( A <= B ) {
     multimap<int, int>::iterator mItxA;
     for(mItxA = A_departure.lower_bound(A); mItxA != A_departure.upper_bound(A); ++ mItxA) {
       if ( A_available.size() != 0 ) {
         if (A_available.front() > A) { // train NOT available at A at THIS time need to start a new
           ++TxA; 
         }
         else { // the first available train is used
           A_available.pop_front();
         }
       }
       else { // NO trains available at A 
         ++TxA;
       }
       int timeB = mItxA->second;
       if(timeB+tat*60 < 86400) {
         B_available.push_back (timeB+tat*60); 
         B_available.sort();
       }
       ++itx_A;
     }
     } 
     else {
     multimap<int, int>::iterator mItxB;
     for(mItxB = B_departure.lower_bound(B); mItxB != B_departure.upper_bound(B); ++ mItxB) {
       if ( B_available.size() != 0 ) {
         if (B_available.front() > B) { // train NOT available at A at THIS time need to start a new
           ++TxB; 
         }
         else { // the first available train is used
           B_available.pop_front();
         }
       }
       else { // NO trains available at B
         ++TxB;
       }
       int timeA = mItxB->second;
       if(timeA+tat*60 < 86400) {
         A_available.push_back (timeA+tat*60); 
         A_available.sort();
       }
       ++itx_B;
     }
     }
   }
 
   while (itx_A != itx_A_end) {
     if ( A_available.size() != 0 ) {
       if (A_available.front() > (itx_A->first)) { // train NOT available at A at THIS time need to start a new
         ++TxA; 
       }
       else { // the first available train is used
         A_available.pop_front();
       }
     }
     else { // NO trains available at A 
       ++TxA;
     }
     ++itx_A;
   }  
 
   while (itx_B != itx_B_end) {
     if ( B_available.size() != 0 ) {
       if (B_available.front() > (itx_B->first)) { // train NOT available at A at THIS time need to start a new
         ++TxB; 
       }
       else { // the first available train is used
         B_available.pop_front();
       }
     }
     else { // NO trains available at B
       ++TxB;
     }
     ++itx_B;
   }  
 
 }
 
 int main (int argc, char** argv)
 {
   if(argc != 2) {
     cout << αError! Usage: <binary_name> <test_file>α << endl;
     exit (-1);
   }
 
   FILE* fp = fopen(argv[1], αrα);
   int N;
   fscanf(fp, α%dα, &N);
 
   for(int i = 1; i <= N; ++i) {
     StationMaster Sm;
     Sm.ReadInput(fp);
     Sm.computeMinTrains ();
     cout << αCase #α << i << α: α << Sm.getTrainsFromA() << α α << Sm.getTrainsFromB() << endl;
   } 
   return 0;
 }"
16995,2008,32013,jazzman,24480,1,a.c,gcj/2008/32013/jazzman/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define NMAX	21
 #define SMAX	101
 #define QMAX	1001
 #define SLENMAX	101
 
 
 int n, s, q;
 char engines[SMAX][SLENMAX];
 int searched[SMAX];
 int available, sol;
 
 void read_engine(char *engine)
 {
     fgets(engine, SLENMAX - 1, stdin);
     if (engine[strlen(engine) - 1] == 'n')
 	engine[strlen(engine) - 1] = 0;
 }
 
 void reset()
 {
     int i;
     
     available = s;
     for (i = 0; i < s; i++)
 	searched[i] = 0;
 }
 
 
 int main(int argc, char **argv)
 {
     int k, i, j;
     char tline[SLENMAX];
 
     scanf(α%dα, &n);
     for (k = 0; k < n; k++) {
 	scanf(α%dα, &s);
 	read_engine(tline);
 	for (i = 0; i < s; i++)
 	    read_engine(engines[i]);
 	    
 	reset();
 	sol = 0;
 	
 	scanf(α%dα, &q);
 	read_engine(tline);
 	for (i = 0; i < q; i++) {
 	    read_engine(tline);
 	    for (j = 0; j < s; j++)
 		if (!strcmp(tline, engines[j])) {
 		    if (!searched[j]) {
 			if (available == 1) {
 			    reset();
 			    sol++;
 			}
 			searched[j] = 1;
 			available--;
 		    }
 		    
 		    break;
 		}
 	}
 	
 	printf(αCase #%d: %dnα, k + 1, sol);
     }
 
     return 0;
 }"
17164,2008,32013,GPS,24480,1,searchengine.c,gcj/2008/32013/GPS/24480/1/extracted/searchengine.c,"#include<stdio.h>
 #include<string.h>
 
 typedef struct 
 {
 	int *Query;
 	int QueryCount;
 	int EngineCount;
 
 	int Switches;
 }
 TESTCASE;
 
 int EvaluateSearchEngines(TESTCASE *tc)
 {
 	int fTable[100];
 	int QCount;
 
 	int i, j;
 
 	tc->Switches = 0;
 
 	QCount		= tc->EngineCount;
 	for(i = 0; i < tc->EngineCount; i++)
 	{
 		fTable[i] = 0;
 	}
 
 	for(i = 0; i < tc->QueryCount; i++)
 	{
 		if(fTable[tc->Query[i]] == 0)
 		{
 			QCount--;
 			fTable[tc->Query[i]] = 1;
 		}
 
 		if(QCount == 0)
 		{
 			tc->Switches++;
 
 			QCount		= tc->EngineCount - 1;
 			for(j = 0; j < tc->EngineCount; j++)
 			{
 				fTable[j] = 0;
 			}
 			fTable[tc->Query[i]] = 1;
 		}
 	}
 
 	return 0;
 }
 
 int GetTestCaseCount(FILE *fin, int *tcCount)
 {
 	fscanf(fin, α %dα, tcCount);
 	return 0;
 }
 
 int GetNextTestCase(FILE *fin, TESTCASE *tc)
 {
 	int i, j;
 
 	char EngineNames[100][101];		/* EngineName[EngineNo][CharNo] */
 
 	char Query[101];
 
 	fscanf(fin, α %dα, &tc->EngineCount);
 
 	for(i = 0; i < tc->EngineCount; i++)
 	{
 		fscanf(fin, α %[a-zA-Z0-9 ]α, EngineNames[i]);
 	}
 
 	fscanf(fin, α %dα, &tc->QueryCount);
 
 	for(i = 0; i < tc->QueryCount; i++)
 	{
 		fscanf(fin, α %[a-zA-Z0-9 ]α, Query);
 
 		for(j = 0; j < tc->EngineCount; j++)
 		{
 			if(0 == strncmp(Query, EngineNames[j], 100))
 			{
 				tc->Query[i] = j;
 				break;
 			}
 		}
 	}
 
 	return 0;
 }
 
 int PrintUsage(char *ExeName)
 {
 	fprintf(stderr, αUsage: nt%s [<input file> [<output file>]]nnα, ExeName);
 	fprintf(stderr, αIf input file is not provided, stdin will be used.nIf output file is not provided, stdout will be usednnα);
 	return 0;
 }
 
 int main(int cArg, char **vArg)
 {
 	FILE *fin;
 	FILE *fout;
 	int tcCount;
 	TESTCASE	tc;
 
 	int Queries[1000];
 	int i;
 
 	tc.Query = Queries;
 
 	fin = stdin;
 	fout = stdout;
 
 	if(cArg > 3)
 	{
 		PrintUsage(vArg[0]);
 		return 0;
 	}
 
 	cArg--;
 	if(cArg)
 	{
 		fin = fopen(vArg[1], αrα);
 		if(!fin)
 		{
 			fprintf(stderr, αCannot open input file [%s], will read from stdinnα, vArg[1]);
 			fin = stdin;
 		}
 
 		cArg--;
 		if(cArg)
 		{
 			fin = fopen(vArg[2], αwα);
 			if(!fin)
 			{
 				fprintf(stderr, αCannot open output file [%s], will write to stdoutnα, vArg[2]);
 				fin = stdout;
 			}
 		}
 	}
 
 
 	if(GetTestCaseCount(fin, &tcCount))
 	{
 		fprintf(stderr, αError reading Input file, Abortingnnα);
 		return 0;
 	};
 
 	for(i = 0; i < tcCount; i++)
 	{
 		if(GetNextTestCase(fin, &tc))
 		{
 			fprintf(stderr, αError reading Input file, Abortingnnα);
 			return 0;
 		}
 
 		EvaluateSearchEngines(&tc);
 		fprintf(fout, αCase #%d: %dnα, (i+1), tc.Switches);
 	}
 
 	if(stdin != fin)
 		fclose(fin);
 
 	if(stdout != fout)
 		fclose(fout);
 
 	return 0;
 }"
17166,2008,32013,GPS,24481,1,traintt.c,gcj/2008/32013/GPS/24481/1/extracted/traintt.c,"#include<stdio.h>
 
 
 typedef struct 
 {
 	int *ArrivalAtA;
 	int *ArrivalAtB;
 	int *DepartureFromA;
 	int *DepartureFromB;
 
 	int TurnAroundTime;
 
 	int NA;				/* Number of Arrivals at A */
 	int NB;				/* Number of Arrivals at B */
 
 	int	TrainsAtA;
 	int TrainsAtB;
 }
 TESTCASE;
 
 int EvaluateTrains(TESTCASE *tc)
 {
 	int i, j;
 
 	int temp;
 	int prevDep; int prevj;
 
 	for(i = 0; i < tc->NA; i++)
 	{
 		tc->ArrivalAtA[i] += tc->TurnAroundTime;
 	}
 	for(i = 0; i < tc->NB; i++)
 	{
 		tc->ArrivalAtB[i] += tc->TurnAroundTime;
 	}
 
 
 	for(i = 0; i < tc->NA; i++)
 	{
 		temp = 2500;
 		prevj = -1;
 
 		for(j = 0; j < tc->NB; j++)
 		{
 			if(tc->DepartureFromA[j] >= tc->ArrivalAtA[i])
 			{
 				if(temp > (tc->DepartureFromA[j] - tc->ArrivalAtA[i]))
 				{
 					temp = (tc->DepartureFromA[j] - tc->ArrivalAtA[i]);
 					prevj = j;
 				}
 			}
 		}
 
 		if(prevj >= 0)
 			tc->DepartureFromA[prevj] = -1;
 	}
 
 	for(i = 0; i < tc->NB; i++)
 	{
 		temp = 2500;
 		prevj = -1;
 
 		for(j = 0; j < tc->NA; j++)
 		{
 			if(tc->DepartureFromB[j] >= tc->ArrivalAtB[i])
 			{
 				if(temp > (tc->DepartureFromB[j] - tc->ArrivalAtB[i]))
 				{
 					temp = (tc->DepartureFromB[j] - tc->ArrivalAtB[i]);
 					prevj = j;
 				}
 			}
 		}
 
 		if(prevj >= 0)
 			tc->DepartureFromB[prevj] = -1;
 	}
 
 
 	tc->TrainsAtA = 0;
 	tc->TrainsAtB = 0;
 
 	for(i = 0; i < tc->NB; i++)
 	{
 		if(tc->DepartureFromA[i] >= 0)
 			tc->TrainsAtA++;
 	}
 	for(i = 0; i < tc->NA; i++)
 	{
 		if(tc->DepartureFromB[i] >= 0)
 			tc->TrainsAtB++;
 	}
 
 	return 0;
 }
 
 
 int GetTestCaseCount(FILE *fin, int *tcCount)
 {
 	fscanf(fin, α %dα, tcCount);
 	return 0;
 }
 
 int GetNextTestCase(FILE *fin, TESTCASE *tc)
 {
 	int hr, min;
 	int i;
 
 	fscanf(fin, α %dα, &tc->TurnAroundTime);
 	fscanf(fin, α %d %dα, &tc->NB, &tc->NA);
 
 	for(i = 0; i < tc->NB; i++)
 	{
 		fscanf(fin, α %2d : %2dα, &hr, &min);
 		tc->DepartureFromA[i] = (hr * 60) + min;
 
 		fscanf(fin, α %2d : %2dα, &hr, &min);
 		tc->ArrivalAtB[i] = (hr * 60) + min;
 	}
 
 	for(i = 0; i < tc->NA; i++)
 	{
 		fscanf(fin, α %2d : %2dα, &hr, &min);
 		tc->DepartureFromB[i] = (hr * 60) + min;
 
 		fscanf(fin, α %2d : %2dα, &hr, &min);
 		tc->ArrivalAtA[i] = (hr * 60) + min;
 	}
 
 	return 0;
 }
 
 int PrintUsage(char *ExeName)
 {
 	fprintf(stderr, αUsage: nt%s [<input file> [<output file>]]nnα, ExeName);
 	fprintf(stderr, αIf input file is not provided, stdin will be used.nIf output file is not provided, stdout will be usednnα);
 	return 0;
 }
 
 int main(int cArg, char **vArg)
 {
 	FILE *fin;
 	FILE *fout;
 	int tcCount;
 	TESTCASE	tc;
 
 	int i;
 
 	int ArrA[100];
 	int ArrB[100];
 	int DepA[100];
 	int DepB[100];
 
 	tc.ArrivalAtA = ArrA;
 	tc.ArrivalAtB = ArrB;
 	tc.DepartureFromA = DepA;
 	tc.DepartureFromB = DepB;
 
 	fin = stdin;
 	fout = stdout;
 
 	if(cArg > 3)
 	{
 		PrintUsage(vArg[0]);
 		return 0;
 	}
 
 	cArg--;
 	if(cArg)
 	{
 		fin = fopen(vArg[1], αrα);
 		if(!fin)
 		{
 			fprintf(stderr, αCannot open input file [%s], will read from stdinnα, vArg[1]);
 			fin = stdin;
 		}
 
 		cArg--;
 		if(cArg)
 		{
 			fin = fopen(vArg[2], αwα);
 			if(!fin)
 			{
 				fprintf(stderr, αCannot open output file [%s], will write to stdoutnα, vArg[2]);
 				fin = stdout;
 			}
 		}
 	}
 
 
 	if(GetTestCaseCount(fin, &tcCount))
 	{
 		fprintf(stderr, αError reading Input file, Abortingnnα);
 		return 0;
 	};
 
 	for(i = 0; i < tcCount; i++)
 	{
 		if(GetNextTestCase(fin, &tc))
 		{
 			fprintf(stderr, αError reading Input file, Abortingnnα);
 			return 0;
 		}
 
 		EvaluateTrains(&tc);
 		printf(αCase #%d: %d %dnα, (i+1), tc.TrainsAtA, tc.TrainsAtB);
 	}
 
 	if(stdin != fin)
 		fclose(fin);
 
 	if(stdout != fout)
 		fclose(fout);
 
 	return 0;
 }"
17168,2008,32013,arekay,24480,1,savingtheuniverse.c,gcj/2008/32013/arekay/24480/1/extracted/savingtheuniverse.c,"#include αmainfile.hα
 #define MAXINPLEN 100
 
 void fnReadsearchenginenames(char *Datafname,char **sSearchenginename,int *iHashsearchengine,int iNumsearchengines,int iNumskip);
 void fnSkipelements(FILE *fp,int iNumskip);
 void fnCleararr(int *iProcessarr, int iNumsearchengines);
 
 int main(int argc, char **argv)
 {
 	FILE *fpDatafile;
 	int iNumcases,iNumsearchengines;int index;
 	char **sSearchengine;int *iHashsearchengine;
 	int *iProcessarr; //tells whether the array element has been processed
 
 	//test cases
 	int iNumtestcase;int iNumskip;int iLen;int freeindex;
 	int iNumleft;
 	char sStr[MAXINPLEN];
 	int testcaseno,srchengno;
 	int *iSwitchno;
 	FILE *fpOpt;
 	int caseno;
 
 
 	fncreatelogfile(); //create the log file
 	fnlogfnname( __FUNCTION__ ,1);//entry and exit information for the log file in main
 
 
 	if (argc!= 2)
 	{
 			printf (αnUsage:: savingtheuniverse.exe <filename>α);
 			exit(1);
 	 }
 
 	fpDatafile = fopen(argv[1],αrα);
 	fscanf(fpDatafile,α%dα,&iNumcases);
 	iNumskip = 1;
 	iSwitchno = (int*)calloc(iNumcases,sizeof(int));
 	fclose(fpDatafile);
 
 	iNumskip = 1;
 
 	for (caseno=0;caseno<iNumcases;caseno++)
 	{
 		fpDatafile = fopen(argv[1],αrα);
 		fnSkipelements(fpDatafile,iNumskip);
 		fscanf(fpDatafile,α%dα,&iNumsearchengines);
 		//printf(α%dnα,iNumsearchengines);
 		iNumskip = iNumskip + 1;
 		//printf(α%dnα,iNumskip);
 		fclose(fpDatafile);
 
 		//allocate the memory for reading the searchengine names
 		sSearchengine = (char**)calloc(iNumsearchengines,sizeof(char**));
 		for (index=0;index<iNumsearchengines;index++)
 			*(sSearchengine+index) = (char*)calloc(MAXINPLEN,sizeof(char*));
 
 		iHashsearchengine = (int*)calloc(iNumsearchengines,sizeof(int));
 		iProcessarr = (int*)calloc(iNumsearchengines,sizeof(int));
 		fnCleararr(iProcessarr,iNumsearchengines);
 		fnReadsearchenginenames(argv[1],sSearchengine,iHashsearchengine,iNumsearchengines,iNumskip);
 		iNumskip = iNumskip + iNumsearchengines;
 
 		iNumleft = iNumsearchengines;
 
 		fpDatafile = fopen(argv[1],αrα);
 		fnSkipelements(fpDatafile,iNumskip);
 		fscanf(fpDatafile,α%dα,&iNumtestcase);
 		//printf(αn%dnα,iNumtestcase);
 		iNumskip = iNumskip + 1;
 		//printf(αnnn%dα,iNumtestcase);
 		fgets(sStr,MAXINPLEN,fpDatafile);//one to read the enter after reading the number
 		for (testcaseno = 0;testcaseno < iNumtestcase;testcaseno++)
 		{
 		fgets(sStr,MAXINPLEN,fpDatafile);
 		//puts(sStr);
 		iLen = strlen(sStr) - 1;
 		for (srchengno = 0;srchengno<iNumsearchengines;srchengno++)
 		{
 			if (*(iHashsearchengine+srchengno) == iLen)
 			{
 				if (stricmp(*(sSearchengine+srchengno),sStr) == 0)
 				{
 					if 	(*(iProcessarr+srchengno) == 0)
 					{
 						*(iProcessarr + srchengno) = 1;
 						iNumleft = iNumleft - 1;
 						if (iNumleft == 0)
 						{
 							*(iSwitchno+caseno) = *(iSwitchno + caseno) + 1;
 							fnCleararr(iProcessarr,iNumsearchengines);
 							*(iProcessarr + srchengno) = 1;
 							iNumleft = iNumsearchengines - 1;
 						  }
 					  }
 				  }
 
 			  }
 		  }
 	      }
 		  iNumskip = iNumskip + iNumtestcase;
 		  fclose(fpDatafile);
 
 		  printf(α%dnα,*(iSwitchno+caseno));
 
 		//deallocate the memory
  		for (freeindex=0;freeindex<iNumsearchengines;freeindex++)
 				  		free(*(sSearchengine+freeindex)) ;
 	    free(sSearchengine);
 		free(iProcessarr);
 		free(iHashsearchengine);
 
  	   }
 
 	fpOpt = fopen(αOutput.vecα,αwα);
 	for (index = 0;index<iNumcases;index++)
 	{
 		fprintf(fpOpt,αCase #%d: %dnα,index+1,*(iSwitchno+index));
 	}
 	fclose(fpOpt);
 
 	free(iSwitchno);
 
 	fnlogfnname(__FUNCTION__,0);//exit
 
 	return(0);
 }
 
 
 void fnReadsearchenginenames(char *Datafname,char **sSearchenginename,int *iHashsearchengine,int iNumsearchengines,int iNumskip)
 {	//this function reads the search engine names hashes it and sends it back
 	int index;
 	int itemp;
 	char sStr[MAXINPLEN];
 	FILE *fpDatafile;
 
 	fnlogfnname( __FUNCTION__ ,1);
 	fpDatafile = fopen(Datafname,αrα);
 	//read the first element
 	//iNumskip = 2; //for the number of elements
 	//printf(α%dnα,iNumskip);
 	fnSkipelements(fpDatafile,iNumskip);
 
 	//fscanf(fpDatafile,α%sα,*sSearchenginename);
 	//puts(*sSearchenginename);
 
 	for (index=0;index<iNumsearchengines;index++)
 	{
 		fgets(*(sSearchenginename+index),MAXINPLEN,fpDatafile);
 		*(iHashsearchengine+index) = strlen(*(sSearchenginename+index)) - 1;
 		//puts(*(sSearchenginename+index));
 		//printf(α%dnα,*(iHashsearchengine+index));
 	 }
 	fnlogfnname( __FUNCTION__ ,0);
 	fclose(fpDatafile);
 }
 
 
 
 void fnSkipelements(FILE *fp,int iNumskip)
 {
 	int index;
 	char sStr[MAXINPLEN];
 
 	fnlogfnname( __FUNCTION__ ,1);
 
 	for (index = 0; index < iNumskip;index++)
 	{
 		fgets(sStr,MAXINPLEN,fp);
 	 }
 
 	fnlogfnname( __FUNCTION__ ,0);
 
 }
 
 
 
 void fnCleararr(int *iProcessarr, int iNumsearchengines)
 {
 	int index;
 
 	fnlogfnname( __FUNCTION__ ,1);
 	for (index=0;index<iNumsearchengines;index++)
 	{
 		*(iProcessarr+index) = 0;
  	 }
  	 fnlogfnname( __FUNCTION__ ,0);
 
 }"
17171,2008,32013,arekay,24480,1,genlogfile.c,gcj/2008/32013/arekay/24480/1/extracted/genlogfile.c,"#include αgenlogfile.hα
 /**************************************************************************************
 /* this file contains the methods for logging the flow the program into the logfile
 /* Three functions are initially planned
 /* The first function is supposed to create the log file 
 /* The second function appends a line of program into the logfile
 /* The third clears the log file after an iteration is over
 **************************************************************************************/
 
 //this creates the logfile that is to be used for analysis
 //returns 0 if the file is not created
 //returns 1 if the file has been created
 int fncreatelogfile()
 {
 	FILE *fplogfile;
 
 	fplogfile = fopen(LOGFILE,αwα);
 	if (fplogfile==NULL)
 	{
 		return (0);//the logfile could not be created error
 	}
 	fclose(fplogfile);
 	return(1);//success
 }
 
 //this function logs the function name in the logfile
 //if direction is 1 it means entry
 //if direction is 0 it means exit
 void fnlogfnname(char *fnname,int direction)
 {
 	#ifndef LBL_RUNNING
 	FILE *fplogfile;
 
 	fplogfile = fopen(LOGFILE,αaα);//open in the mode for appending
 	if (direction == 1)
 	{
 		fprintf(fplogfile,αEntry :: %snα,fnname);
 	}
 	else
 	{
 		fprintf(fplogfile,αExit  :: %snα,fnname);
     }
 	fclose(fplogfile);
 	#endif //compile the code only if it is for testing 
 }
 
 //this function clears the logfile 
 //this can be used once we know an iteration is over
 void fnclearlog()
 {
 	FILE *fplogfile;
 
 	fplogfile = fopen(LOGFILE,αwα);
 	fclose(fplogfile);
 }"
17246,2008,32013,codetoergosum,24480,1,First.c,gcj/2008/32013/codetoergosum/24480/1/extracted/First.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 char* engines[104];
 char* queries[1004];
 int apps[104];
 
 void initialise(){
   int i;
   for(i=0;i<104;i++)
     engines[i] = (char*) malloc(105*(sizeof(char)));
     
   for(i=0;i<1004;i++)
     queries[i] = (char*) malloc(105*(sizeof(char)));
 }
 
 int getno(char* s){
   int i = 1;
   while(0 != (strcmp(s,engines[i])))
     i++;
   return (i);
 }
 
 int findans(int e, int q){ // number of engines and queries
   int total = 0;
   int at = 1;
   int j;
   int ans = 0;
   int num;
 
   
   while(at<=q){
     for(j=1;j<=e;j++)
       apps[j] = 0;
     
     total = 0;
     
     for(;((at<=q)&&(total<e));at++){
       num = getno(queries[at]);
 
       if (apps[num] == 0){
 	total++;
 	
 	if (total == e){
 	  at--;  
 	  ans++;
 	}
 	
 	apps[num] = 1;
 	
       }
      
     }
   }
 
   return(ans);
 }
 
 
 void doacase(int caseno){
   int e,q;
   int i;
   int linesize = 110;
   scanf(α%dα,&e);
   getchar();
   
   for(i=1;i<=e;i++){
     getline(engines+i,&linesize,stdin);
   }
   
   scanf(α%dα,&q);
 
   getchar();
   
   for(i=1;i<=q;i++){
     getline(queries+i,&linesize,stdin);
   }
 
   printf(αCase #%d: %dnα,caseno,findans(e,q));
 }
 
 
 int main(){
   int nofcases;
   int i;
 
   initialise();
   scanf(α%dα,&nofcases);
   getchar();
   
   for(i=1;i<=nofcases;i++)
     doacase(i);
   
   return(0);
 }"
17292,2008,32013,hnaves,24480,1,universe.c,gcj/2008/32013/hnaves/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_SEARCH_ENGINES  128
 #define MAX_NAME_SIZE       128
 #define MAX_QUERIES        1024
 
 static int S, Q;
 static char search_engines[MAX_SEARCH_ENGINES][MAX_NAME_SIZE];
 static int queries[MAX_QUERIES];
 
 
 int cmp_names (const void *ptr1, const void *ptr2)
 {
   char *name1 = (char *) ptr1;
   char *name2 = (char *) ptr2;
   return strcmp (name1, name2);
 }
 
 static int  solution[MAX_SEARCH_ENGINES];
 
 int solve (void)
 {
   int i, j;
   int oldmin, min;
   for (i = 0; i < S; i++) {
     if (queries[0] != i) solution[i] = 0;
     else solution[i] = -1;
   }
   min = 0;
   for (j = 1; j <= Q; j++) {
     oldmin = min;
     min = oldmin + 1;
     for (i = 0; i < S; i++) {
       if (queries[j] == i) solution[i] = -1;
       else {
         if (solution[i] == -1)
           solution[i] = oldmin + 1;
         else {
           if (solution[i] == oldmin) {
             min = oldmin;
           }
         }
       }
     }
   }
   return min;
 }
 
 int main (int argc, char **argv)
 {
   int t, N;
   char buf[MAX_NAME_SIZE];
   scanf (α %d α, &N);
   for (t = 1; t<= N; t++) {
     int i, j, k;
     scanf (α %d α, &S);
     for (i = 0; i < S; i++) {
       fgets (search_engines[i], MAX_NAME_SIZE, stdin);
     }
     qsort (search_engines, S, MAX_NAME_SIZE, &cmp_names);
 
     scanf (α %d α, &Q);
     for (i = 0; i < Q; i++) {
       fgets (buf, MAX_NAME_SIZE, stdin);
        
       for (k = j = 0; buf[k] != '0'; ) {
         if (buf[k] == search_engines[j][k]) k++;
         else j++;
       }
       queries[i] = j;
     }
     queries[Q] = -1;
      
     printf (αCase #%d: %dnα, t, solve ());
   }
   return 0;
 }"
17294,2008,32013,hnaves,24481,1,timetable.c,gcj/2008/32013/hnaves/24481/1/extracted/timetable.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX_TRIPS 128
 
 static int NA, NB, T;
 static int solA, solB;
 
 static int A_start[MAX_TRIPS];
 static int A_end[MAX_TRIPS];
 static int B_start[MAX_TRIPS];
 static int B_end[MAX_TRIPS];
 
 int cmp_int (const void *ptr1, const void *ptr2)
 {
   int *i1 = (int *) ptr1;
   int *i2 = (int *) ptr2;
   return (*i1) - (*i2);
 }
 
 void solve (void)
 {
   int t, min, c, i1, i2;
 
   qsort (A_start, NA, sizeof (int), &cmp_int);
   qsort (A_end, NA, sizeof (int), &cmp_int);
   qsort (B_start, NB, sizeof (int), &cmp_int);
   qsort (B_end, NB, sizeof (int), &cmp_int);
 
   c = 0;
   i1 = i2 = 0;
   min = 0;
   for(t = 0; t < 24*60; t++) {
     while (A_start[i1] == t) {
       i1++; c--;
     }
     while (B_end[i2] == t) {
       i2++; c++;
     }
     if (min > c) min = c;
   }
   solA = -min;
 
   c = 0;
   i1 = i2 = 0;
   min = 0;
   for(t = 0; t < 24*60; t++) {
     while (B_start[i1] == t) {
       i1++; c--;
     }
     while (A_end[i2] == t) {
       i2++; c++;
     }
     if (min > c) min = c;
   }
   solB = -min;
 }
 
 
 
 int main (int argc, char **argv)
 {
   int N, t;
   int i, h1, m1, h2, m2;
   scanf (α %d α, &N);
   for(t = 1; t <= N; t++) {
     scanf (α %d α, &T);
     scanf (α %d %d α, &NA, &NB);
     for (i = 0; i < NA; i++) {
       scanf (α %d:%d %d:%d α, &h1, &m1, &h2, &m2);
       A_start[i] = 60 * h1 + m1;
       A_end[i] = 60 * h2 + m2 + T;
     }
     A_start[NA] = A_end[NA] = -1;
 
     for (i = 0; i < NB; i++) {
       scanf (α %d:%d %d:%d α, &h1, &m1, &h2, &m2);
       B_start[i] = 60 * h1 + m1;
       B_end[i] = 60 * h2 + m2 + T;
     }
     B_start[NB] = B_end[NB] = -1;
 
     solve ();
     printf (αCase #%d: %d %dnα, t, solA, solB);
   }
   return 0;
 }"
17335,2008,32013,gepa,24480,1,Asol.c,gcj/2008/32013/gepa/24480/1/extracted/Asol.c,"#include <iostream>
 #include <vector>
 #include <string>
 #include <cstdio>
 
 using namespace std;
 
 #define MAX_LENGTH 200
 
 vector <string> parseVS() {
 	int c;
 	scanf(α%dnα, &c);
 	vector <string> v;
 	char buf[MAX_LENGTH];
 	for (int i = 0; i < c; i++) {
 		fgets(buf, MAX_LENGTH, stdin);
 		v.push_back(string(buf));
 	}
 	return v;
 }
 
 #define MAX_ENGINES 500
 
 int minSwitches(vector <string> engines, vector <string> queries) {
 	int used[MAX_ENGINES];
 	int ne = engines.size();
 	for (int i = 0; i < ne; i++) used[i] = 0;
 	int c = 0;
 	int s = 0;
 	for (int i = 0; i < queries.size(); i++) {
 		int p;
 		for (p = 0; p < ne; p++) {
 			if (queries[i] == engines[p]) break;
 		}
 		if (p < ne && !used[p]) {
 			c++;
 			if (c == ne) {
 				s++;
 				for (int j = 0; j < ne; j++) used[j] = 0;
 				c = 1;
 			}
 			used[p] = 1;
 		}
 	}
 	return s;
 }
 
 int main() {
 	int N;
 	vector <string> engines;
 	vector <string> queries;
 	scanf(α%dnα, &N);
 	for (int i = 1; i <= N; i++) {
 		engines = parseVS();
 		queries = parseVS();
 		int cnt = minSwitches(engines, queries);
 		printf(αCase #%d: %dnα, i, cnt);
 	}
 }"
17337,2008,32013,gepa,24479,1,C.c,gcj/2008/32013/gepa/24479/1/extracted/C.c,"#include <iostream>
 #include <cmath>
 #include <vector>
 #include <cstdio>
 
 using namespace std;
 
 long double aPoly(vector <long double> x, vector <long double> y) {
 	long double r = 0.0;
 	for (int i = 1; i < x.size(); i++) {
 		r += x[i] * y[i - 1] - x[i - 1] * y[i];
 	}
 	if (r < 0.0) r = -r;
 	return (r / 2.0);
 }
 
 long double aArc(vector <long double> a) {
 	long double da = a[1] - a[0];
 	return (da - sin(da)) / 2.0;
 }
 
 long double getArea(long double x1, long double x2, long double y1, long double y2, long double R) {
 	long double R2 = R * R;
 	vector <long double> x;
 	vector <long double> y;
 	vector <long double> an;
 	x.push_back(x1);
 	y.push_back(y1);
 	int a[4];
 	a[0] = (x1 * x1 + y1 * y1 < R2);
 	a[1] = (x2 * x2 + y1 * y1 < R2);
 	a[2] = (x2 * x2 + y2 * y2 < R2);
 	a[3] = (x1 * x1 + y2 * y2 < R2);
 	if (a[0] && (!a[1])) {
 		x.push_back(sqrt(R2 - y1 * y1));
 		y.push_back(y1);
 		an.push_back(asin(y1 / R));
 	}
 	if (a[1]) {
 		x.push_back(x2);
 		y.push_back(y1);
 	}
 	if (a[1] && (!a[2])) {
 		x.push_back(x2);
 		y.push_back(sqrt(R2 - x2 * x2));
 		an.push_back(acos(x2 / R));
 	}
 	if (a[2]) {
 		x.push_back(x2);
 		y.push_back(y2);
 	}
 	if (a[3] && (!a[2])) {
 		x.push_back(sqrt(R2 - y2 * y2));
 		y.push_back(y2);
 		an.push_back(asin(y2 / R));
 	}
 	if (a[3]) {
 		x.push_back(x1);
 		y.push_back(y2);
 	}
 	if (a[0] && (!a[3])) {
 		x.push_back(x1);
 		y.push_back(sqrt(R2 - x1 * x1));
 		an.push_back(acos(x1 / R));
 	}
 	x.push_back(x[0]);
 	y.push_back(y[0]);
 	return (aPoly(x, y) + R2 * aArc(an));
 }
 
 long double getProb(long double f, long double R, long double t, long double r, long double g) {
 	if (g <= 2.0 * f) return 1.0;
 	long double s = g + 2.0 * r;
 	long double d = (g - 2.0 * f) / 2.0;
 	long double R2 = R - t - f;
 	long double R22 = R2 * R2;
 	int k = (int)(R / s) + 3;
 	int c = 0;
 	long double z1 = 0.0;
 	for (int i = 0; i < k; i++) {
 		for (int j = 0; j < k; j++) {
 			long double x1 = s * i + s / 2.0 - d;
 			long double x2 = s * i + s / 2.0 + d;
 			long double y1 = s * j + s / 2.0 - d;
 			long double y2 = s * j + s / 2.0 + d;
 			if (x2 * x2 + y2 * y2 <= R22) {
 				c++;
 			} else if (x1 * x1 + y1 * y1 < R22) {
 				z1 += getArea(x1, x2, y1, y2, R2);
 			}
 		}
 	}
 	long double freeArea = c * (4.0 * d * d) + z1;
 	long double totalArea = M_PI * R * R / 4.0;
 	return 1.0 - freeArea / totalArea;
 }
 
 int main() {
 	int N;
 	cin >> N;
 	for (int i = 1; i <= N; i++) {
 		long double f, R, t, r, g;
 		cin >> f >> R >> t >> r >> g;
 		long double P = getProb(f, R, t, r, g);
 		printf(αCase #%d: %.8llfnα, i, P);
 	}
 }"
17339,2008,32013,gepa,24481,1,B.c,gcj/2008/32013/gepa/24481/1/extracted/B.c,"#include <iostream>
 #include <cstdio>
 
 using namespace std;
 
 #define NUM_MINS 1600
 
 int fromA[NUM_MINS];
 int toA[NUM_MINS];
 int fromB[NUM_MINS];
 int toB[NUM_MINS];
 
 int needA;
 int needB;
 
 void countTrains() {
 	needA = 0;
 	needB = 0;
 	int cA = 0;
 	int cB = 0;
 	for (int i = 0; i < NUM_MINS; i++) {
 		cA += toA[i];
 		cB += toB[i];
 		if (fromA[i] > cA) {
 			needA += fromA[i] - cA;
 			cA = fromA[i];
 		}
 		if (fromB[i] > cB) {
 			needB += fromB[i] - cB;
 			cB = fromB[i];
 		}
 		cA -= fromA[i];
 		cB -= fromB[i];
 	}
 }
 
 int main() {
 	int N;
 	cin >> N;
 	for (int i = 1; i <= N; i++) {
 		int T;
 		int NA;
 		int NB;
 		cin >> T;
 		cin >> NA;
 		cin >> NB;
 		for (int j = 0; j < NUM_MINS; j++) {
 			fromA[j] = 0;
 			toA[j] = 0;
 			fromB[j] = 0;
 			toB[j] = 0;
 		}
 		int h1, m1, h2, m2;
 		char c1, c2;
 		for (int j = 0; j < NA; j++) {
 			cin >> h1 >> c1 >> m1 >> h2 >> c2 >> m2;
 			fromA[h1 * 60 + m1]++;
 			toB[h2 * 60 + m2 + T]++;
 		}
 		for (int j = 0; j < NB; j++) {
 			cin >> h1 >> c1 >> m1 >> h2 >> c2 >> m2;
 			fromB[h1 * 60 + m1]++;
 			toA[h2 * 60 + m2 + T]++;
 		}
 		for (int j = 0; j < NUM_MINS; j++) {
 #ifdef DEBUG
 			if (fromA[j] > 0 || fromB[j] > 0 || toA[j] > 0 || toB[j] > 0) {
 				printf(α%5d %5d %5d %5d %5dnα, j, fromA[j], toA[j], fromB[j], toB[j]);
 			}
 #endif
 		}
 		countTrains();
 		printf(αCase #%d: %d %dnα, i, needA, needB);
 	}
 }"
17449,2008,32013,watermix,24480,1,save_the_universe.c,gcj/2008/32013/watermix/24480/1/extracted/save_the_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_STR       100
 #define MAX_ENGINES   100
 #define MAX_SEARCHES  1000
 
 typedef unsigned char bool;
 #define true  (bool)(3>2)
 #define false (bool)(3<2)
 
 #define DEBUG if(debug) printf
 bool debug = false;
 
 
 void swap( char s1[], char s2[] )
 {
   char temp[MAX_STR];
 
   strcpy( temp, s1 );
   strcpy( s1, s2 );
   strcpy( s2, temp );
 
   return;
 }
 
 void getstring( FILE *file, char str[] )
 {
   //fscanf( file, α%snα, str );
   fgets( str, MAX_STR, file );
   str[strlen( str ) - 1] = '0';
 }
 
 
 bool run_case( FILE *infile, int *result )
 {
   bool retval = false;
   int num_engines,
       num_searches;
   char *engines[MAX_ENGINES],
        *searches[MAX_SEARCHES],
        in[MAX_STR];
   int candidates;
   int switches = 0;
   bool found;
 
   int i;
   int j;
 
 
   *result = -1;
 
   getstring( infile, in );
   num_engines = atoi( in );
 
   DEBUG( α====================================nα );
   DEBUG( αnum_engines is %dnα, num_engines );
 
   engines[0] = (char *)calloc( (MAX_STR * MAX_ENGINES), sizeof( char ) );
   if( engines )
   {
     for( i = 1; i < MAX_ENGINES;  i++ )
     {
       engines[i] = engines[0] + (i * MAX_STR);
     }
     for( i = 0;  i < num_engines;  i++ )
     {
       getstring( infile, engines[i] );
       DEBUG( αengines[%d] is %snα, i, engines[i] );
     }
 
 
     getstring( infile, in );
     num_searches = atoi( in );
 
     DEBUG( αnum_searches is %dnα, num_searches );
     DEBUG( α---------------------------------nα );
 
     /*
      * Now search
      */
     retval = true;
     candidates = num_engines;
     for( i = 0;  retval && (i < num_searches);  i++ )
     {
       found = false;
 
       getstring( infile, in );
 
       DEBUG( αsearch is %snα, in );
       for( j = 0;  j < candidates;  j++ )
       {
         found = ( strcmp( in, engines[j] ) == 0 );
         if( found )
         {
           DEBUG( αSwapping %s and %snα, engines[j], engines[candidates - 1]);
           swap( engines[j], engines[candidates - 1] );
           candidates--;
         }
       }
 
       if( candidates == 0 )
       {
         DEBUG( α>>>>>>>>> Switchingnα );
         switches++;
         swap( engines[0], engines[num_engines - 1] );
         candidates = num_engines - 1;
       }
     }
 
     *result = switches;
     DEBUG( αresult is %dnα, *result );
   }
   else
   {
     perror( αCouldn't allocate enginesα );
   }
 
   return retval;
 }
 
 
 
 int main( int argc, char *argv[] )
 {
   FILE *infile = NULL,
        *outfile = NULL;
   char in[MAX_STR];
   int runs;
   int i;
   int result;
 
   if( argc > 1 )
   {
     infile = fopen( argv[1], αrα );
     if( !infile )
     {
       perror( αCouldn't open infileα );
       exit( 1 );
     }
   }
 
   outfile = fopen( αoutput.txtα, αwα );
   if( !outfile )
   {
     perror( αCouldn't open outfileα );
     exit( 5 );
   }
 
   if( argc > 2 )
   {
     if( atoi( argv[2] ) == 1 )
     {
       debug = true;
     }
   }
 
 
   fscanf( infile, α%snα, in );
   runs = atoi( in );
   DEBUG( αNum cases is %dnα, runs );
 
   for( i = 1;  i <= runs;  i++ )
   {
     if( run_case( infile, &result ) )
     {
       fprintf( outfile, αCase #%d: %dnα, i, result );
     }
     else
     {
       perror( αCase failedα );
     }
   }
 
 
   if( infile ) fclose( infile );
   if( outfile ) fclose( outfile );
 }"
17461,2008,32013,alexandrehdk,24480,1,Universe.c,gcj/2008/32013/alexandrehdk/24480/1/extracted/Universe.c,"/* Autor:   Alexandre Hideki Hagihara
  *          alexandre.hagihara@gmail.com
  */
 
 /* Arquivos de include bsicos */
 #include αstdio.hα
 #include αstdlib.hα
 #include αstring.hα
 #include αmath.hα
 
 /* Defines */
 int contabiliza(int desde);
 int processa(void);
 int menorLista(void);
 int percorre(int desde, int conta);
 
 /* Structs / Typedefs / Enums */
 char listSearches[100][101];
 char listQueries[1000][101];
 int indexes[1000];
 
 /* Functions */
 
 /* Funo readLine
  * L uma linha da entrada padro
  * Parmetros:  lineBuffer  - buffer para onde armazenaremos a linha lida
  *              maxSize     - tamanho mximo do buffer
  *              nCase       - nmero do caso que estamos tratando
  * Retorno:     lineBuffer, se conseguiu ler
  * Se no conseguir ler linha, exibe mensagem de erro e termina o programa
  */
 char* readLine(char *lineBuffer, int maxSize, int nCase)
 {
     char *temp;
     // Leitura da linha
     temp = fgets(lineBuffer, maxSize, stdin);
     // Se no conseguiu ler
     if(temp == NULL)
     {
         fprintf(stderr, αErro na leitura de dados para caso %inα, nCase);
         exit(0);
     }
     return temp;
 }
 
 /* Funo readCases
  * L o nmero de casos da entrada padro
  * Retorno:     nmero de casos
  * Se no conseguir ler linha, exibe mensagem de erro e termina o programa
  */
 int readCases(void)
 {
     int temp;
     if(scanf(α%i α, &temp) != 1)
     {
         fprintf(stderr, αErro na leitura do nmero de casosnα);
         exit(0);
     }
     return temp;
 }
 
 /* Programa principal.
  * Para usar, redirecione o arquivo de entrada para a entrada padro,
  * a sada padro para um arquivo e a sada de erro padro para NUL
  * (ou para algum arquivo, se voc deseja debugar)
  * Exemplo: alien <A-small.in 1>alien.out 2>NUL         => Uso mais comum
  *          alien <A-small.in 1>alien.out 2>alien.dbg   => Debug em arquivo
  *          alien <A-small.in 1>alien.out               => Debug na tela
  *          alien <A-small.in                           => Sada e debug na tela
  */
 int search; // Nmero de motores de busca
 int querie;
 int conta[100];
 int main(void)
 {
     char line[4096];
 
     // L o nmero de casos para processar
     int nCases = readCases();
 
     // Loop que l dados de cada caso, processa os dados e joga na sada
     // o resultado do processamento
     for(int c = 1; c <= nCases; c++)
     {
 
         scanf(α%i α, &search);
 
         for(int s = 0; s < search; s++)
         {
             readLine(line, sizeof(line), c);
             strncpy(listSearches[s], line, 100);
             listSearches[s][100] = 0;
         }
 
         scanf(α%i α, &querie);
         for(int q = 0; q < querie; q++)
         {
             readLine(line, sizeof(line), c);
             strncpy(listQueries[q], line, 100);
             listQueries[q][100] = 0;
         }
         fprintf(stderr, αS = %i | Q = %inα, search, querie);
         int minimo = processa();
 
         printf(αCase #%i: %iα, c, minimo);
 
         printf(αnα);
     }
     return 1;
 }
 
 int menor;
 int processa(void)
 {
     contabiliza(0);
     if(menorLista() == 0)
         return 0;
     else
     {
         menor = percorre(0, 0);
         
     }
     return menor;
 }
 
 // desde: querie
 // conta: nmero de trocas
 int percorre(int desde, int conta)
 {
     //fprintf(stderr,αDesde %i Atual %i Conta %i Menor %inα, desde, atual, conta, menor);
     // Se trocamos um valor menor que antes
     int sMax = -1;
     int dMax = 0;
     int dCount;
     for(int s = 0; s < search; s++)
     {
         dCount = 0;
         for(int q = desde; q < querie; q++)
         {
             if(indexes[q] != s)
                 dCount++;
             else
                 break;
         }
         if(dCount > dMax)
         {
             dMax = dCount;
             sMax = s;
         }
     }    
     // sMax contm o ndice da busca que pode ir mais longe
     fprintf(stderr, αBusca atual: %s [%d](%d)nα, listSearches[sMax], desde, dMax);
     if(desde+dMax < querie)
     {
         return percorre(desde+dMax, conta+1);
     }
     return conta;
 }
 
 int menorLista(void)
 {
     int menor = querie;
     for(int i = 0; i < search; i++)
     {
         if(conta[i] < menor)
             menor = conta[i];
     }
     return menor;
 }
 
 // Conta quantas vezes ocorre o nome do mecanismo de busca na lista
 // de queries desde um certo valor
 int contabiliza(int desde)
 {
     for(int i = 0; i < 100; i++)
         conta[i] = 0;
     for(int q = desde; q < querie; q++)
     {
         for(int s = 0; s < search; s++)
         {
             if(strcmp(listQueries[q], listSearches[s]) == 0)
             {
                 indexes[q] = s;
                 //fprintf(stderr, αQ[%i]:%inα, q, s);
                 conta[s]++;
             }
         }
     }
 }"
17463,2008,32013,Rufus,24480,1,Switches_1.c,gcj/2008/32013/Rufus/24480/1/extracted/Switches_1.c,"// Google codejam template TWO
 
 //  $g++ -g -W -Wall [executable name].c -o [executable name] -lm
 //  $gdb [executable name]
 
 #include <stdio.h>
 #include <iostream>
 #include <math.h>
 // for strtok
 #include <cstring>
 
 using namespace std;
 
 // ASSIGN:
 #define LINES 1200
 #define LENGTH 110
 #define NENAMES 101
 
 inline int name_to_num(const char name_set[][LENGTH], int num_names, const char in_name[]);
 
 // ASSIGN:
 char infile[] = αA-large.inα;
 //char infile[] = αSwitchesTest.inα;
 char outfile[] = αSwitches-large.outα;
 //char outfile[] = αSwitchesTest.outα;
 
 FILE *p_infile = NULL;
 FILE *p_outfile = NULL;
 
 #define ZERO(a,len,eye) 
 for (eye=0;eye<len;eye++) 
 a[eye]=0
 
 #define cZERO(a,len,eye) 
 for (eye=0;eye<len;eye++) 
 a[eye]='0'
 
 #define GETLINE() 
 if (fgets(line_data[curr_line], LENGTH, p_infile)==NULL) 
 { 
     cout << αProblem in file...α; 
     fclose(p_infile); 
     exit(0); 
 } 
 strtok(line_data[curr_line],chk)
 
 
 
 int main() 
 {
 
   // ASSIGN:
   char line_data[LINES][LENGTH] = {{'0'}};
   char engine_names[NENAMES][LENGTH] = {{'0'}};
 
   int total_cases;
 
   p_infile = fopen(infile, αrα); 
   if(p_infile==NULL) {
     printf(αError: can't open file.nα);
     return 1;
   }
 
   
   p_outfile = fopen(outfile, αwα); 
   if(p_outfile==NULL) {
     printf(αError: can't open file.nα);
     return 1;
   }
 
 
   
   char trials[20];
   if (fgets(trials, LENGTH, p_infile)==NULL)
     {
 	cout << αProblem in file...α;
 	fclose(p_infile);
 	exit(0);
     }
   total_cases = atoi(trials);
 
   long curr_line;
   int i,j,k;
   int zero_int;
   int S_in;
   int Q_in;
   char chk[] = {'n','0'};
   int nameNUMS[LINES] = {0};
   int site_hits[NENAMES];
   int num_switches, num_used;
   char buf[50];
   for (i=0;i<total_cases;i++)
   {
 
     curr_line = 0;
     GETLINE();
     S_in = atoi(line_data[curr_line]);
     curr_line++;
 
     for (k=0;k<S_in;k++)
     {
 	GETLINE();
 	curr_line++;
     }
 
     GETLINE();
     Q_in = atoi(line_data[curr_line]);
     curr_line++;
 
     for (k=0;k<Q_in;k++)
     {
 	GETLINE();
 	nameNUMS[k] = name_to_num(line_data, S_in, line_data[curr_line]);
 	curr_line++;
     }
 
     // carryforwards: nameNUMS[0 to Q_in-1] w/ each value 1 to S_in, file pointer
 
 
     num_switches = 0;
     num_used = 0;
     ZERO(site_hits,NENAMES,zero_int);
     for (k=0;k<Q_in;k++)
     {
 	if (site_hits[nameNUMS[k]] == 0)
 	{
 	  site_hits[nameNUMS[k]]=1;
 	  num_used++;
 	}
 	if (num_used==S_in)
 	{
 	  num_switches++;
 	  num_used = 0;
 	  ZERO(site_hits,NENAMES,zero_int);
 	  k--;
 	}
     }
 
 	
     sprintf(buf,αCase #%d: %dnα,i+1,num_switches);
     fputs(buf, p_outfile);
 //    putc('n', p_outfile);
 
 
 
 
     for (j=0;j<LINES;j++)
 	cZERO(line_data[j],LENGTH,zero_int);
     for (j=0;j<NENAMES;j++)
 	cZERO(engine_names[j],LENGTH,zero_int);
     ZERO(nameNUMS,LINES,zero_int);
 
   }	// cases
 
 
 
 
   fclose(p_outfile);
   fclose(p_infile);
 }
 
 
 
 
 inline int name_to_num(const char name_set[][LENGTH], int num_names, const char in_name[])
 {
   int i;
   for (i=1;i<=num_names;i++)
   {
     if (strcmp(name_set[i],in_name)==0)
 	return i;
   }
   cout << αoops!α << endl;
   return -1;
 }"
17495,2008,32013,Mainak,24480,1,universe.c,gcj/2008/32013/Mainak/24480/1/extracted/universe.c,"#include<stdio.h>
 char s[100][100],q[1000][100];
 int count,count1;
 int findvalue(int n)
 {
 	int k,j,i,number[100],l=0,answer=0;
 	for(i=0;i<100;i++)
 		number[i]=0;
 	if(n==count1)
 		return(0);
 	else
 	{
 		for(k=n;k<count1;k++)
 			for(j=0;j<count;j++)
 				if(strcmp(q[k],s[j])==0)
 					number[j]++;
 		for(j=0;j<count;j++)
 			if(number[j]==0)
 				break;
 		if(j==count)
 		{
 			for(k=0;k<count;k++)
 				if(strcmp(q[n],s[k])==0)
 					break;
 			for(j=0;j<count;j++)
 			{
 				if(j!=k)
 				{
 					for(i=n+1;i<count1;i++)
 						if(strcmp(s[j],q[i])==0)
 							break;
 					if(answer<i)
 						answer=i;
 				}
 			}
 			return(1+findvalue(answer));
 		}
 		else
 			return(0);
 	}
 }
 int main(int argc,char *argv[])
 {
 	int *number,l,i,j,k,min,select,answer,num;
         FILE *fp;
         fp=fopen(argv[1],αrα);
         fscanf(fp,α%dα,&num);
 	char t[100];
         for(i=0;i<num;i++)
         {
 		answer=l=0;
         	fscanf(fp,α%dα,&count);
 		fgets(t,100,fp);
 		for(j=0;j<count;j++)
 			fgets(s[j],100,fp);
 		fscanf(fp,α%dα,&count1);
 		fgets(t,100,fp);
 		for(j=0;j<count1;j++)
 			fgets(q[j],100,fp);
 		if(count1>0)
 		{
 			answer=findvalue(0);
 		}
 		printf(αCase #%d: %dnα,i+1,answer);
 	}
 }"
17497,2008,32013,Mainak,24481,1,train.c,gcj/2008/32013/Mainak/24481/1/extracted/train.c,"#include<stdio.h>
 typedef struct
 {
 	int hr;
 	int min;
 	char station;
 	int arrdep;
 }time;
 int main(int argc,char *argv[])
 {
 	time t[400],p;
 	char time[6];
 	int num,i,count=0,count1=0,j,k,tm,Acount[2]={0,0},Bcount[2]={0,0};
 	FILE *fp;
 	fp=fopen(argv[1],αrα);
 	fscanf(fp,α%dα,&num);
 	for(i=0;i<num;i++)
 	{
 		count=0,count1=0;
 		for(j=0;j<2;j++)
 		{
 			Acount[j]=Bcount[j]=0;
 		}
 		fscanf(fp,α%dα,&tm);
 		fscanf(fp,α%dα,&count1);
 		count=count1;
 		fscanf(fp,α%dα,&count1);
 		for(j=0;j<2*count;j++)
 		{
 			fscanf(fp,α%sα,time);
 			t[j].hr=(time[0]-48)*10+(time[1]-48);
 			t[j].min=(time[3]-48)*10+(time[4]-48);
 			if(j%2==0)
 			{
 				t[j].station='A';
 				t[j].arrdep=1;
 			}
 			else
 			{
 				t[j].min+=tm;
 				if(t[j].min>=60)
 				{
 					t[j].min=t[j].min-60;
 					t[j].hr++;
 				}
 				t[j].station='B';
 				t[j].arrdep=0;
 			}
 		}
 		for(j=2*count;j<2*count+2*count1;j++)
 		{
 			fscanf(fp,α%sα,time);
 			t[j].hr=(time[0]-48)*10+(time[1]-48);
 			t[j].min=(time[3]-48)*10+(time[4]-48);
 			if(j%2==0)
 			{
 				t[j].station='B';
 				t[j].arrdep=1;
 			}
 			else
 			{
 				t[j].min+=tm;
 				if(t[j].min>=60)
 				{
 					t[j].min=t[j].min-60;
 					t[j].hr++;
 				}
 				t[j].station='A';
 				t[j].arrdep=0;
 			}
 		}
 		count=2*count+2*count1;
 /*		for(j=0;j<count;j++)
 		{
 			printf(α%d:%d %c %dnα,t[j].hr,t[j].min,t[j].station,t[j].arrdep);
 		}
 		printf(αnα);*/
 		for(k=0;k<count-1;k++)
 		{
 			for(j=0;j<count-k-1;j++)
 			{
 				if(t[j].hr>t[j+1].hr)
 				{
 					p=t[j];
 					t[j]=t[j+1];
 					t[j+1]=p;
 				}
 				else if(t[j].hr==t[j+1].hr)
 				{
 					if(t[j].min>t[j+1].min)
 					{
 						p=t[j];
 						t[j]=t[j+1];
 						t[j+1]=p;
 					}
 					else if(t[j].min==t[j+1].min)
 					{
 						if(t[j].arrdep==1&&t[j+1].arrdep==0)
 						{
 							p=t[j];
 							t[j]=t[j+1];
 							t[j+1]=p;
 						}
 					}
 				}
 			}
 		}
 /*		for(j=0;j<count;j++)
 		{
 			printf(α%d:%d %c %dnα,t[j].hr,t[j].min,t[j].station,t[j].arrdep);
 		}*/
 		for(j=0;j<count;j++)
 		{
 			if(t[j].arrdep==1&&t[j].station=='A')
 			{
 				if(Acount[0]==0)
 					Acount[1]++;
 				else
 					Acount[0]--;
 			}		
 			else if(t[j].arrdep==1&&t[j].station=='B')
 			{
 				if(Bcount[0]==0)
 					Bcount[1]++;
 				else
 					Bcount[0]--;
 			}
 			else if(t[j].arrdep==0&&t[j].station=='A')
 				Acount[0]++;
 			else if(t[j].arrdep==0&&t[j].station=='B')
 				Bcount[0]++;
 		}		
 		printf(αCase #%d: %d %dnα,i+1,Acount[1],Bcount[1]);
 	}
 }"
17578,2008,32013,MonkeyLa,24480,1,A.c,gcj/2008/32013/MonkeyLa/24480/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int main(){
     int N, S, Q;
     int i, j, k;
     int answer;
     char sname[150][150];
     int sflag[150], scount;
     char query[150];
 
     gets(query);
     N = atoi(query);
 
     for(i = 0; i < N; i++){
           answer = 0;
           memset(sflag, 0, sizeof(sflag));
           scount = 0;
 
           gets(query);
           S = atoi(query);
           for(j = 0; j < S; j++){
                 gets(sname[j]);
           }
 
           gets(query);
           Q = atoi(query);
           for(j = 0; j < Q; j++){
                 gets(query);
                 for(k = 0; k < S; k++){
                       if(strcmp(query, sname[k]) == 0) break;
                 }
                 if(k == S) printf(αerrornα);
 
                 if(sflag[k] == 0){
                       sflag[k] = 1;
                       scount++;
 
                       if(scount == S){
                            answer++;
                            memset(sflag, 0, sizeof(sflag));
                            scount = 1;
                            sflag[k] = 1;
                       }
                 }
           }
           printf(αCase #%d: %dnα, i + 1, answer);
     }
 
     return 0;
 }"
17806,2008,32013,Cleo,24481,1,train.c,gcj/2008/32013/Cleo/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 #define NMAX 101
 #define HMAX 1439 //23:59
 
 int n, t, na, nb;
 FILE *fi, *fo;
 
 struct timetable {
        int departure, arrival;
 }listA[NMAX], listB[NMAX];
 
 int minutes (int h, int m) { return h*60+m;}
 
 void sort (struct timetable listX[], int nx)
 {
      int i, j, pos;
      struct timetable aux;
      
      for (i = 0; i < nx; ++i)
      {
          pos = i;
          for (j = i + 1; j < nx; ++j)
              if (listX[pos].departure == listX[j].departure && listX[pos].arrival > listX[j].arrival) pos = j;
              else
                  if (listX[pos].departure > listX[j].departure) pos = j;
          //swap
          aux = listX[i];
          listX[i] = listX[pos];
          listX[pos] = aux;
      }     
 }
 
 int minAB (int ia, int ib) //true when A is min
 {
      if (ia == na) return 0;
      if (ib == nb) return 1;     
      if (listA[ia].departure>listB[ib].departure) return 0;
      if (listA[ia].departure<listB[ib].departure) return 1;
      if (listA[ia].arrival>listB[ib].arrival) return 0;
      return 1;
 }
 
 int existsTrain (int uz[], int maxDeparture)
 {
      int i;
      for (i=maxDeparture; i>=0; --i)
      {
          if (uz[i]>0)
          {
             uz[i]--;
             return 1;//found
          }    
      }   
      return 0;//not found
 }
 void solve (int nCase)
 {
      int ia, ib;
      int resA, resB;
      int arrival;
      int uzA[HMAX+1], uzB[HMAX+1];
      
      for (ia = 0; ia < HMAX ; ++ia) uzA[ia] = uzB[ia] = 0;
      
      resA = resB = 0;
      ia = ib = 0;
      while (ia<na || ib<nb)
      {
          if (minAB(ia, ib))
          {
             if (!existsTrain(uzA, listA[ia].departure)) resA++;
             arrival = listA[ia].arrival + t;
             if (arrival <= HMAX) uzB[arrival]++;
             ia++;
          }
          else
          {
             if (!existsTrain(uzB, listB[ib].departure)) resB++;
             arrival = listB[ib].arrival + t;
             if (arrival <= HMAX) uzA[arrival]++;
             ib++;
          }
      }
      fprintf(fo, αCase #%d: %d %dnα, nCase, resA, resB);
 }
 
 int main()
 {
     int i, k;
     int h, m;
 	fi = fopen (αB-large.inα, αrα);
 	fo = fopen (αoutputα, αwα);
 	fscanf(fi, α%dα, &n);
 	for (i = 1; i <= n; ++i)
 	{
 		fscanf(fi, α%d %d %dα, &t, &na, &nb);
 		for (k = 0; k < na; ++k)
 		{
 			fscanf(fi, α%d:%dα, &h, &m);
 			listA[k].departure = minutes(h, m);
 			fscanf(fi, α%d:%dα, &h, &m);
 			listA[k].arrival = minutes(h, m);	
 		}
 		sort (listA, na);
 		
 		for (k = 0; k < nb; ++k)
 		{
 			fscanf(fi, α%d:%dα, &h, &m);
 			listB[k].departure = minutes(h, m);
 			fscanf(fi, α%d:%dα, &h, &m);
 			listB[k].arrival = minutes(h, m);
 		}
 		sort (listB, nb);
 	
 		solve(i);
 	}
 	fclose(fi);
 	fclose(fo);
 	return 0;
 }"
17835,2008,32013,lpereira,24481,1,train.c,gcj/2008/32013/lpereira/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <malloc.h>
 #define MIN(a,b) (((a)<(b))?(a):(b))
 
 int compint(int* a, int* b) {
   return(*a - *b);
 }
 
 int main(void) {
   int c, tc;
   scanf(α %dα,&tc);
   for(c=1;c<=tc;c++){
     int puta[128], putb[128], takea[128], takeb[128];
     int na, nb, i, t, j, cp, ct;
     int ca, cb, mina, minb;
     printf(αCase #%d: α,c);
     scanf(α %dα,&t);
     scanf(α %d %dα,&na,&nb);
     for(i=0;i<na;i++) {
       int ha,ma,hb,mb,ta,tb;
       scanf(α %d:%d %d:%dα,&ha,&ma,&hb,&mb);
       ta = ha*60 + ma; tb = hb*60+mb+t;
       takea[i] = ta;
       putb[i] = tb;
     }
     for(i=0;i<nb;i++) {
       int ha,ma,hb,mb,ta,tb;
       scanf(α %d:%d %d:%dα,&hb,&mb,&ha,&ma);
       ta = ha*60 + ma + t; tb = hb*60 + mb;
       takeb[i] = tb;
       puta[i] = ta;
     }
     qsort(takea,na,sizeof(int),compint);
     qsort(takeb,nb,sizeof(int),compint);
     qsort(puta,nb,sizeof(int),compint);
     qsort(putb,na,sizeof(int),compint);
     
     mina = 0; ca = 0; i=0; cp = 0; ct = 0;
     for(j=0;j<=24*60 + 60;j++) {
       while(takea[ct] == j && ct < na) {
 	ca--; ct++;
       }
       while(puta[cp] == j && cp < nb) {
 	ca++; cp++;
       }
       mina = MIN(ca,mina);
     }
     minb = 0; cb = 0; i=0; cp = 0; ct = 0;
     for(j=0;j<=24*60 + 60;j++) {
       while(takeb[ct] == j && ct < nb) {
 	cb--; ct++;
       }
       while(putb[cp] == j && cp < na) {
 	cb++; cp++;
       }
       minb = MIN(cb,minb);
     }
     printf(α%d %dnα,-mina,-minb);
     
   }
   return(0);
 }"
18116,2008,32013,lbackstrom,24479,1,geo.c,gcj/2008/32013/lbackstrom/24479/1/extracted/geo.c,"double trarc(double x1, double y1, double r){
 	double x2 = sqrt(r*r-y1*y1);
 	double y2 = sqrt(r*r-x1*x1);
 	double alpha = atan2(y2,x1) - atan2(y1,x2);
 	double a = r*r*alpha/2;
 	a -= (y2-y1)*x1/2;
 	a -= (x2-x1)*y1/2;
 	return a;
 }
 double area(double x1, double y1, double x2, double y2, double r){
 	if(x2<x1 || y2 < y1 || x1*x1+y1*y1 >= r*r)return 0;
 	if(x2*x2+y2*y2 < r*r)return (x2-x1)*(y2-y1);
 	if(x1*x1+y2*y2 > r*r){
 		if(x2*x2+y1*y1 > r*r){
 			return trarc(x1,y1,r);
 		}else{
 			return trarc(x1,y1,r) - trarc(x2,y1,r);
 		}
 	}else{
 		if(x2*x2+y1*y1 > r*r){
 			return trarc(x1,y1,r) - trarc(x1,y2,r);
 		}else{
 			return trarc(x1,y1,r) - trarc(x2,y1,r) - trarc(x1,y2,r);;
 		}
 	}
 }
 int main(){
 	int N,i,j,k;
 	double f,R,t,r,g, A, x1, y1, a;
 	scanf(α%dα,&N);
 	for(i = 1; i<=N; i++){
 		scanf(α%lf%lf%lf%lf%lfα,&f,&R,&t,&r,&g);
 		A = 0;
 		for(j = 0; j<1100; j++){
 			for(k = 0; k<1100; k++){
 				x1 = j*(g+r+r)+r+f;
 				y1 = k*(g+r+r)+r+f;
 				a = area(x1,y1,x1+g-f-f,y1+g-f-f,R-t-f);
 				A += a;
 				if(a == 0)break;
 			}
 		}
 		A*=4;
 		printf(αCase #%d: %0.6lfnα,i,1-A/(R*R*acos(0)*2));
 	}
 }"
18118,2008,32013,lbackstrom,24481,1,train.c,gcj/2008/32013/lbackstrom/24481/1/extracted/train.c,"int cmp(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
 }
 int main(){
 	int N, NA, NB, T, i, j, k, pa, pb, h1, m1,h2,m2, na, nb,ra,rb;
 	int A[1000];
 	int B[1000];
 	scanf(α%dα,&N);
 	for(i = 1; i<=N; i++){
 		pa = pb = na = nb = ra = rb = 0;
 		scanf(α%d%d%dα,&T,&NA,&NB);
 		for(j = 0; j < NA; j++){
 			scanf(α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
 			A[pa++] = (h1*60+m1)*2+1;
 			B[pb++] = (h2*60+m2+T)*2;
 		}
 		for(j = 0; j < NB; j++){
 			scanf(α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
 			B[pb++] = (h1*60+m1)*2+1;
 			A[pa++] = (h2*60+m2+T)*2;
 		}
 		qsort(A,pa,sizeof(int),cmp);
 		qsort(B,pb,sizeof(int),cmp);
 		for(j = 0; j<pa; j++){
 			if(A[j]%2 == 0)na++;
 			else na--;
 			if(-na > ra)ra = -na;
 		}
 		for(j = 0; j<pb; j++){
 			if(B[j]%2 == 0)nb++;
 			else nb--;
 			if(-nb > rb)rb = -nb;
 		}
 		printf(αCase #%d: %d %dnα,i,ra,rb);
 
 	}
 }"
18310,2008,32013,ponnuvel,24480,1,v1.c,gcj/2008/32013/ponnuvel/24480/1/extracted/v1.c,"/* Give the filename as parameter */
 #include <stdio.h>
 #include <string.h>
 int N,noe,i,t,nq,op;
 int sw,z;
 char S[1100][200];
 char line[200];
 char Q[1100][200];
 FILE *fp;
 
 void main(int argc, char *argv[])
 {
 int c;
 fp=fopen(argv[1],αrα);
 fgets(line, sizeof(line), fp );
 N=atoi(line);
 for(c=0;c<N;c++)
 {
 fun();
 fun9();
 printf(αCase #%d: %dnα,c+1,op);
 }
 
 fclose(fp);
 }
 
 fun()
 {
 fgets(line, sizeof(line), fp );
 noe=atoi(line);
 
 for (i=0;i<noe;i++)
 {
 fgets(line, sizeof(line), fp );
 strcpy(S[i],line);
 }
 
 fgets(line, sizeof(line), fp );
 nq=atoi(line);
 printf(αnα);
 for (i=0;i<nq;i++)
 {
 fgets(line, sizeof(line), fp );
 strcpy(Q[i],line);
 }
 }
 
 int fun9()
 {
 int index;
 int h=0;
 char *eng;
 op=0;
 if (nq==0)  return;
 index=swit(0);
 strcpy(eng, S[index]);
 for (h=0;h<nq;h++)
 {
         if (strcmp(Q[h],eng) == 0)
         {
         index=swit(h);
         strcpy(eng,S[index]);
         op++;
         }
 }
 
 }
 
 int swit(int h)
 {
 int count[1000];
 int ret;int u,y;
 for(y=0;y<1000;y++)
 count[y]=1000;
         for (y=0;y<noe;y++)
         {
                 for (u=h;u<nq;u++)
                 {
                 if(strcmp(Q[u],S[y])==0)
                 {
                         count[y]=u-h+1;
                         break;
                 }
                 }
         }
 
 ret= count[0];
 /* for (u=0;u<noe;u++)
 printf(α %d α,count[u]); */
 
 for (u=0; u<noe; u++)
 if (count[u]>ret)
 ret = count[u];
 
 for (u=0;u<noe;u++)
 if (count[u]==ret)
 {
 ret=u;
 break;
 }
 /*printf(α%s α,S[ret]);*/
 return ret;
 }"
18371,2008,32013,Dari,24480,1,stu.c,gcj/2008/32013/Dari/24480/1/extracted/stu.c,"/*
  	CODED BY DAVID RIOS PUIG
 	FOR GOOGLE CODE JAM
 	17/07/2008
 */
 
 #include <stdio.h>
 #include <string.h>
 
 void getname(char *name, FILE *fin);
 
 void main(int argc, char **argv)
 {
 	if (argc != 2)
 	{
 		printf(αUsage: ./stu A-small.innα);
 		exit(0);
 	}
 	
 	//File input & File output
 	FILE *fin, *fout;
 
 	//Number of case
 	int ncase;
 
 	//Number os search engines and querys
 	int nse,nquerys;
 
 	//Struct of search engines
 	struct se { int pos; char name[100]; } *se_array;
 
 	//Struct of querys
 	struct que { char name[100]; } *que_array;
 
 	//Iterators and controls
 	int i, j, k, final=0, act=0;
 
 	//Number of switchs and actual max
 	int sw; char *aname;
 
 	//Opening input file
 	if((fin=fopen(argv[1],αrα)) == NULL)
 	{
 		printf(αError opening input filenα);
 		exit(-1);
 	}
 
 	//Setting number of case
 	fscanf(fin,α%dα, &ncase);
 
 	//Opening output file
 	if((fout=fopen(αA-small.outα,αwα)) == NULL)
 	{
 		printf(αError opening output filenα);
 		exit(-1);
 	}
 
 	for(k=0;k<ncase; k++)
 	{
 		//Init switchs
 		sw = 0;
 
 		//Init act
 		act = 0;
 		
 		//Init final
 		final = 0;
 
 		//Reading number of Search Engines
 		fscanf(fin,α%dnα, &nse);
 		se_array = malloc(nse * sizeof(struct se));
 
 		//Init Search Engines		
 		for(i=0;i<nse;i++)
 		{
 			getname(se_array[i].name,fin);
 			se_array[i].pos = -1;
 		}
 		
 		//Reading number of Querys
 		fscanf(fin,α%dnα,&nquerys);
 
 		if(nquerys > 0)
 		{
 			que_array = malloc(nquerys * sizeof(struct que));
 	
 			//Init Querys
 			for(i=0;i<nquerys;i++)
 			{
 				getname(que_array[i].name,fin);		
 			}
 			
 			//Algorithm
 			while(final == 0)
 			{
 				for(i=0;i<nse;i++)
 				{
 					for(j=act;j<nquerys;j++)
 					{
 						if(!strcmp(se_array[i].name,que_array[j].name))
 						{
 							se_array[i].pos = j;
 							j=nquerys;
 						}
 					}
 
 					if(se_array[i].pos == -1)
 					{
 						i = nse;
 						final = 1;
 					}			
 				}
 				if (final == 0)
 				{
 					act = se_array[0].pos;
 					se_array[0].pos = -1;
 
 					for(i=1;i<nse;i++)
 					{
 						if(se_array[i].pos>act)
 						{
 							act = se_array[i].pos;
 						}
 						se_array[i].pos = -1;
 					}
 					sw++;
 				}
 			}
 			free(que_array);
 			free(se_array);
 		}
 		fprintf(fout,αCase #%d: %dnα, k+1, sw);
 	}
 	fclose(fout);
 	fclose(fin);
 	exit(0);
 }
 
 void getname(char *name, FILE *fin)
 {
 	char c;
 	int i=0;
 	
 	while(1)
 	{
 		if(fscanf(fin,α%cα,&c) != EOF)
 		{
 			if(c!= 'n')
 			{
 				name[i++]=c;
 			}
 			else
 			{
 				name[i]='0';
 				break;
 			}
 		}
 		else
 		{
 			name[i]='0';
 			break;
 		}
 	}
 }"
18438,2008,32013,siva.sona,24481,1,ss5.c,gcj/2008/32013/siva.sona/24481/1/extracted/ss5.c,"#include<stdio.h>
 struct temp
 {
 int t,v;
 }tmp,a[1000];
 int ata,atb,na,nb,turn,a1,a2,a3,a4,i,j,k,nc,inc,ta,tb;
 void main()
 {
 scanf(α%dα,&nc);
 for(i=0;i<nc;i++)
 {
 scanf(α%dα,&turn);
 scanf(α%d%dα,&na,&nb);
 inc=0;
 for(j=0;j<na;j++)
 {
 scanf(α%d:%d%d:%dα,&a1,&a2,&a3,&a4);
 a[inc].t=a1*60+a2;
 a[inc++].v=-1;
 a[inc].t=a3*60+a4+turn;
 a[inc++].v=2;
 }
 for(j=0;j<nb;j++)
 {
 scanf(α%d:%d%d:%dα,&a1,&a2,&a3,&a4);
 a[inc].t=a1*60+a2;
 a[inc++].v=-2;
 a[inc].t=a3*60+a4+turn;
 a[inc++].v=1;
 }
 for(k=0;k<inc-1;k++)
 for(j=k+1;j<inc;j++)
 
 if((a[k].t>a[j].t)||(a[k].t==a[j].t&&a[k].v<a[j].v))
 {
 tmp=a[k];
 a[k]=a[j];
 a[j]=tmp;
 }
 
 ata=0;atb=0;
 ta=0;tb=0;
 for(j=0;j<inc;j++)
 {
 //printf(αn%d:%d-- %dnα,a[j].t/60,a[j].t%60,a[j].v);
 if(a[j].v==-1)
 if(ta==0)
 ata++;
 else
 ta--;
 else if(a[j].v==-2)
 if(tb==0)
 atb++;
 else
 tb--;
 else if(a[j].v==2)
 tb++;
 else
 ta++;
 }
 printf(αCase #%d: %d %dnα,i+1,ata,atb);
 }
 }"
18446,2008,32013,aank,24480,1,SWIT.C,gcj/2008/32013/aank/24480/1/extracted/SWIT.C,"#include<stdio.h>
 #include<string.h>
 #include<alloc.h>
 #include<conio.h>
 #define M1 120
 #define M2 1010
 
 
 int solution(char *[],char *[],int,int);
 
 void main()
 {
 	 FILE *f1,*f2;
 	 char *s[M1],*kword[M2],string[M1];
 	 int i,j,z=0,k,length,x,value,y;
 	 clrscr();
 
 	 f1=fopen(αswitch.txtα,αrα);
 	 if(f1==NULL)
 	 {
 		  printf(αnCannot open input file...α);
 	 }
 	 else
 	 {
 		  f2=fopen(αans.txtα,αwα);
 		  if(f2==NULL)
 		  {
 				printf(αnCannot open output fileα);
 		  }
 
 
 		  else
 		  {
 				fscanf(f1,α %[^n]sα,string);
 				fgetc(f1);
 				length=strlen(string);
 				for(i=0;i<length;i++)
 				{
 					z=z*10+(string[i]-48);
 				}
 				for(k=0;k<z;k++)
 				{
 					x=0;y=0;
 
 					fscanf(f1,α %[^n]sα,string);
 					fgetc(f1);
 					length=strlen(string);
 					for(i=0;i<length;i++)
 					{
 						 x=x*10+(string[i]-48);
 					}
 					for(j=0;j<x;j++)
 					{
 						fscanf(f1,α %[^n]sα,string);
 
 						fgetc(f1);
 						length=strlen(string);
 						s[j]=(char *)malloc((length+1)*sizeof(char));
 						if(s[j]==NULL)
 						{
 							printf(αndont have enough memoryα);
 							break;
 						}
 						strcpy(s[j],string);
 
 					}
 					fscanf(f1,α %[^n]sα,string);
 					fgetc(f1);
 					length=strlen(string);
 					for(i=0;i<length;i++)
 					{
 						 y=y*10+(string[i]-48);
 					}
 					for(j=0;j<y;j++)
 					{
 						fscanf(f1,α %[^n]sα,string);	fgetc(f1);
 						length=strlen(string);
 						kword[j]=(char *)malloc((length+1)*sizeof(char));
 						if(kword[j]==NULL)
 						{
 							printf(αndont have enough memoryα);
 							break;
 						}
 						strcpy(kword[j],string);
 					}
 
 					value=solution(s,kword,y,x);
 
 
 					for(i=0;i<y;i++)
 						free(kword[i]);
 
 					for(i=0;i<x;i++)
 						free(s[i]);
 
 
 
 					printf(αnCase #%d: %dα,k+1,value);
 					fprintf(f2,αCase #%d: %dnα,k+1,value);
 				}
 		  }
 		  fclose(f2);
 	 }
 	 fclose(f1);
 	 getch();
 }
 
 int solution(char *s[],char *kword[],int i,int j)
 {
 	int num=0,k,a[M1]={0},value=0,p,l;
 
 	for(k=0;k<i;k++)
 	{
 		for(l=0;l<j;l++)
 		{
 			if(!strcmp(kword[k],s[l]))
 			{
 				if(a[l]==0)
 				{
 					num++;
 					a[l]=1;
 				}
 
 				if(num==j)
 				{
 					num=1;
 					for(p=0;p<j;p++)
 						a[p]=0;
 					value++;
 					a[l]=1;
 				}
 
 				break;
 			}
 		}
 	}
 	return value;
 }"
18490,2008,32013,wub,24480,1,goo.c,gcj/2008/32013/wub/24480/1/extracted/goo.c,"#include <stdio.h>
 #include <string.h>
 
 typedef struct {
 	char	buf[101];
 	int	flag;
 } string;
 
 string unsort[100], server[100];
 char query[1000][101];
 int sn, qn;
 
 FILE *fp;
 
 #define DEBUG 0
 
 int cmpserver(char *q)
 {
 	int head = 0;
 	int tail = sn - 1;
 	int mid = sn / 2;
 	int r;
 	while(1) {
 		r = strcmp(server[mid].buf, q);
 		if(r == 0)
 			return mid;
 
 		if(head >= tail)
 			return -1;
 
 		if(r < 0) {
 			head = mid + 1;
 			mid = (mid + tail + 1) / 2;
 		} else {
 			tail = mid - 1;
 			mid = (head + mid) / 2;
 		}
 	}
 	return -1;
 }
 
 int run()
 {
 	int i, j, first;
 	int counter = 0;
 	string *p;
 	int ser_nr;
 	int ret;
 	char buf[100];
 
 	/* get server. */
 	fscanf(fp, α%dα, &sn);
 	fgets(buf, 1000, fp);
 	for(i = 0; i < sn; i++) {
 		fgets(unsort[i].buf, 1000, fp);
 		unsort[i].flag = 0;
 	}
 
 	/* get query. */
 	fscanf(fp, α%dα, &qn);
 	fgets(buf, 1000, fp);
 	for(i = 0; i < qn; i++) {
 		fgets(query[i], 1000, fp);
 	}
 
 	/* sort server. */
 	for(i = 0; i < sn; i++) {
 		first = 0;
 		for(j = 0; j < sn; j++ ) {
 			if(unsort[j].flag == 1)
 				continue;
 
 			if(first == 0) {
 				p = &unsort[j];
 				first = 1;
 			} else {
 				if(strcmp(p->buf, unsort[j].buf) > 0) {
 					p = &unsort[j];
 				}
 			}
 		}
 		p->flag = 1;
 		strcpy(server[i].buf, p->buf);
 		server[i].flag = 0;
 	}
 
 	/* do it. */
 	ser_nr = 0;
 	for(i = 0; i < qn; i++) {
 		ret = cmpserver(query[i]);
 #if DEBUG
 	printf(αret: %dnα, ret);
 #endif
 		if(ret == -1)
 			continue;
 
 		if(server[ret].flag == 1)
 			continue;
 
 		ser_nr++;
 		if(ser_nr == sn) {
 			for(j = 0; j < sn; j++)
 				server[j].flag = 0;
 			ser_nr = 1;
 			counter++;
 		}
 		server[ret].flag = 1;
 	}
 
 	return counter;
 }
 
 int main()
 {
 	int n;
 	int i;
 
 	fp = fopen(αdataα, αrα);
 	if(fp == NULL) {
 		printf(αerror in open file!nα);
 		return 0;
 	}
 
 	fscanf(fp, α%dα, &n);
 	for(i = 0; i < n; i++) {
 		printf(αCase #%d: %dnα, i + 1, run());
 	}
 	return 0;
 }"
18498,2008,32013,mysangle,24480,1,universe.c,gcj/2008/32013/mysangle/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_LEN	   100
 
 char* filename = αA-small.inα;
 
 struct sto_eng {
     char engine_name[MAX_LEN+1];
     int tag;
 };
 
 void getline_from_file(FILE* f, char* line)
 {
     int len = 0;
 
     fgets(line, MAX_LEN, f);
     len = strlen(line);
     if (line[len-1] == 'n') {
         int i = 1;
         if (line[len-2] == 'n') {
             i++;
         }
         line[len-i] = '0';
     }
 }
 
 int find_name(struct sto_eng* se, int num_engine, char* line)
 {
     int i;
 
     for (i=0; i < num_engine; i++) {
         if (strcmp(se[i].engine_name, line) == 0) {
             return i;
         }
     }
 
     return -1;
 }
 
 void init_sto_eng(struct sto_eng* se, int num_engine, FILE* f)
 {
     int i;
     char line[MAX_LEN+1];
 
     for (i = 0; i < num_engine; i++) {
         getline_from_file(f, line);
         strcpy(se[i].engine_name, line);
         se[i].tag = 1; 
     }
 }
 
 int main(int argc, char** argv)
 {
     FILE* f;
     char line[MAX_LEN+1];
     int len = 0;
     int cases = 0;
     int num_engine = 0;
     int query = 0;
     int i, j, k;
     struct sto_eng* se;
     int ret;
     int switches;
     int switch_pp;
 
     f = fopen(filename, αrα);
     getline_from_file(f, line);
     cases = atoi(line);
     for (i; i < cases; i++) {
         switch_pp = 0;
         getline_from_file(f, line);
         switches = num_engine = atoi(line);
         se = (struct sto_eng*)malloc(num_engine * sizeof(struct sto_eng));
         init_sto_eng(se, num_engine, f);
 
         getline_from_file(f, line);
         query = atoi(line);
         
         for (j=0; j < query; j++) {
             getline_from_file(f, line);
             ret = find_name(se, num_engine, line);
             if (se[ret].tag == 1) {
                 se[ret].tag = 0;
                 switches--;
             }
             if (switches == 0) {
                 switch_pp++;
                 switches = num_engine;
                 for (k=0; k < num_engine; k++) {
                     se[k].tag = 1;
                 }
                 ret = find_name(se, num_engine, line);
                 if (se[ret].tag == 1) {
                     se[ret].tag = 0;
                     switches--;
                 }
                 
             }
         }
         fprintf(stdout, αCase #%d: %dnα, i+1, switch_pp);
         
         free(se);
     }
 
     fclose(f);
 
     return;
 }"
18518,2008,32013,manatok,24480,1,univ.c,gcj/2008/32013/manatok/24480/1/extracted/univ.c,"#include <stdio.h>
 #include <string.h>
 
 int main() {
     char s[200];
     
     char e_names[101][200];
     char e_ques[1001][200];
     
     int cases;
     int S;
     int Q;
     int i;
     int x;
     
     int tmp[101];
     
     int count = 0;
     int crossed = 0;
     int y = 0;
     int j,k;
     
     
     gets(s);
     sscanf(s,α%dα,&cases);
     for(i=1;i<=cases;i++) {
      y=0;
      crossed = 0;
      count = 0;
      gets(s);
      sscanf(s,α%dα,&S);
      for(x=0;x<S;x++) {
         gets(e_names[x]);
         //printf(αis : %sα,&e_names[x]);
      }
      gets(s);
      sscanf(s,α%dα,&Q);
      for(x=0;x<Q;x++) {
         gets(e_ques[x]);
      }
      
      for(x=0;x<101;x++) tmp[x] = 2;
      for(x=0;x<S;x++) tmp[x] = 1;
      //printf(αQ: %dnα,Q);
      
      for(x=0;x<Q;x++) {//current query
         //printf(αcurrent x:%d Q: %snα,x,e_ques[x]);
         for(y=0;y<S;y++) {//current eng
         //printf(αcurrent y: %d S: %snα,y,e_names[y]);
           if(strcmp(e_ques[x],e_names[y]) == 0) { //match
           //printf(αmatchnα);
              if(tmp[y] == 1) {
                 tmp[y] = 0;
                 crossed++;
                 
                 if(crossed == S) {
                    count++;
                    for(j=0;j<S;j++) tmp[j] = 1;
                    tmp[y] = 0;
                    crossed = 1;
                 }
            
              }
              break;
           }
          // else  printf(αno matchnα);
         }
      }
      printf(αCase #%d: %dnα,i,count);
      //getch();
     }
     
 return 0;
 }"
18520,2008,32013,manatok,24481,1,train.c,gcj/2008/32013/manatok/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 
 int get_hours(char *in);
 void sort_it();
 
 
 struct train {
    int dep_time;
    int arr_time;
    int dest;//b=1,a=0
    int loc;
 };
 typedef struct train Train;
 
 Train pop();
 
 Train dep_list[1000];
 int A[1000];
 int B[1000];//stations
 
 int A_count;
 int B_count;
 int train_count;
 
  int NA;
  int NB;
 int main() {
  
  char s[200];
  int cases = 0;
  int a_need = 0;//final
  int b_need = 0;
  int T;
 
  int x;
  int i;
  int j;
  char tmp_from_a_l[200][6];
  char tmp_from_b_l[200][6];
  char tmp_from_a_a[200][6];
  char tmp_from_b_a[200][6];
  int found = 0;
  Train temp_train;
  int k = 0;
  gets(s);
  sscanf(s,α%dα,&cases);
  
  
  for(i=1;i<=cases;i++) {
       A_count = 0;
       B_count = 0;
       a_need = 0;
       b_need = 0;
       for(x=0;x<1000;x++) A[x] = 0;
       for(x=0;x<1000;x++) B[x] = 0;
    //   for(x=0;x<1000;x++) dep_list[x] = 0;
       train_count = 0;
       gets(s);
       sscanf(s,α%dα,&T);
       gets(s);
       sscanf(s,α%d %dα,&NA,&NB);
       
       for(x=0;x<NA;x++) {
        gets(s);
        sscanf(s,α%s %sα,tmp_from_a_l[x],tmp_from_a_a[x]);
       }
       for(x=0;x<NB;x++) {
        gets(s);
        sscanf(s,α%s %sα,tmp_from_b_l[x],tmp_from_b_a[x]);
       // printf(αscanedB: %s - %snα,tmp_from_b_l[x],tmp_from_b_a[x]);
       }
       x=0;
       for(x=0;x<NA;x++) {
          dep_list[x].dep_time = get_hours(tmp_from_a_l[x]);
          dep_list[x].arr_time = get_hours(tmp_from_a_a[x]);
          dep_list[x].dest = 1;
          dep_list[x].loc = 0;
          train_count++;
       }
       for(x=0;x<NB;x++) {
          dep_list[x+NA].dep_time = get_hours(tmp_from_b_l[x]);
          dep_list[x+NA].arr_time = get_hours(tmp_from_b_a[x]);
          dep_list[x+NA].dest = 0;
          dep_list[x+NA].loc = 1;
          train_count++;
       }
       
       sort_it();  
       //for(x=0;x<NA+NB;x++)
         // printf(αarr: %d - dep: %dnα,dep_list[x].arr_time,dep_list[x].dep_time);
       
         
       for(x=0;x<NA+NB;x++) {//for each train
         /* for(k=0;k<NA+NB;k++)
          printf(αarr: %d - dep: %dnα,dep_list[k].arr_time,dep_list[k].dep_time);
          for(k=0;k<10;k++) printf(αA: %d - α,A[k]);
          printf(αnα);
          for(k=0;k<10;k++) printf(αB: %d - α,B[k]);
          printf(αnα);*/
          found = 0;
          //printf(αtmp_loc: %dnα,dep_list[0].loc);
          if(dep_list[0].loc == 0) {
            //printf(αloc in Anα);
            for(j=0;j<1000;j++) {
               if(A[j] <= dep_list[0].dep_time && A[j] != 0) {
                   for(k=0;k<1000;k++) {
                     if(B[k] == 0) {
                       B[k] = dep_list[0].arr_time+T;
                       break;
                     }
                   }
                   A[j] = 0;
                   found = 1;
                   //printf(αfound in Anα);
                   break;
               }
            }
            if(found == 0) {
               //printf(αnot found in Anα);
                a_need++;
                for(k=0;k<1000;k++) {
                 if(B[k] == 0) {
                   B[k] = dep_list[0].arr_time+T;
                   break;
                 }
               }
            }
          }
          else {
               //printf(αloc in Bnα);
               for(j=0;j<1000;j++) {
               if(B[j] <= dep_list[0].dep_time && B[j] != 0) {
                   for(k=0;k<1000;k++) {
                     if(A[k] == 0) {
                       A[k] = dep_list[0].arr_time+T;
                       break;
                     }
                   }
                   B[j] = 0;
                   found = 1;
                   //printf(αfound in Bnα);
                   break;
               }
            }
            if(found == 0) {
                //printf(αnot in Bnα);
                b_need++;
                for(k=0;k<1000;k++) {
                 if(A[k] == 0) {
                   A[k] = dep_list[0].arr_time+T;
                   break;
                 }
               }
            }
          }
          pop();
       }
       printf(αCase #%d: %d %dnα,i,a_need,b_need);
       //getch();
  }
  
  
    
 return 0;
 }
 
 int get_hours(char *in) {
     //printf(αin: %snα,in);
     char hours[3];
     char mins[3];
     int h=0;
     int m = 0;
     int t = 0;
     hours[0] = in[0];
     hours[1] = in[1];
     hours[2] = '0';
     mins[0] = in[3];
     mins[1] = in[4];
     mins[2] = '0';
     
     h=atoi(hours);
     m=atoi(mins);
     //printf(αhours: %dnmin: %dnα,h,m);
     t = (h*60)+m;
     return t;
 }
 
 void sort_it(){
      int i;
      int j;
      Train hold;
      for(i=1;i<NA+NB;i++) {
       for(j=0;j<NA+NB-1;j++) {
          if(dep_list[j].dep_time > dep_list[j+1].dep_time) {
             hold.arr_time = dep_list[j].arr_time;
             hold.dep_time = dep_list[j].dep_time;
             hold.dest = dep_list[j].dest;
             hold.loc = dep_list[j].loc;
             
             dep_list[j].arr_time = dep_list[j+1].arr_time;
             dep_list[j].dep_time = dep_list[j+1].dep_time;
             dep_list[j].dest = dep_list[j+1].dest;
             dep_list[j].loc = dep_list[j+1].loc;
             
             dep_list[j+1].arr_time  = hold.arr_time;
             dep_list[j+1].dep_time  = hold.dep_time;
             dep_list[j+1].dest  = hold.dest;
             dep_list[j+1].loc  = hold.loc;
 
          }
          else if(dep_list[j].dep_time == dep_list[j+1].dep_time){
               if(dep_list[j].arr_time > dep_list[j+1].arr_time){
                 hold.arr_time = dep_list[j].arr_time;
             hold.dep_time = dep_list[j].dep_time;
             hold.dest = dep_list[j].dest;
             hold.loc = dep_list[j].loc;
             
             dep_list[j].arr_time = dep_list[j+1].arr_time;
             dep_list[j].dep_time = dep_list[j+1].dep_time;
             dep_list[j].dest = dep_list[j+1].dest;
             dep_list[j].loc = dep_list[j+1].loc;
             
             dep_list[j+1].arr_time  = hold.arr_time;
             dep_list[j+1].dep_time  = hold.dep_time;
             dep_list[j+1].dest  = hold.dest;
             dep_list[j+1].loc  = hold.loc;
               }
          }
       }
      }
 }
 
 Train pop() {
   Train tmp;
   tmp.arr_time = dep_list[0].arr_time;
   tmp.dep_time = dep_list[0].dep_time;
   tmp.dest = dep_list[0].dest;
   tmp.loc = dep_list[0].loc;
   int i;
   for(i=0;i<train_count-1;i++) {
    dep_list[i] = dep_list[i+1];
   }
   train_count--;
 }"
18567,2008,32013,L156steven,24480,1,a.c,gcj/2008/32013/L156steven/24480/1/extracted/a.c,"#include <stdio.h>
 #include <strings.h>
 
 int lastappearance(int query[], int numEngines, int numQueries) {
   int switches = 0;
 
   int checklist[numEngines];
   for (int i = 0; i < numEngines; i++) {
     if (checklist[i] != 0) 
       checklist[i]=0;
   }
  
     
   
   int checkdif = numEngines-1;
 
   for (int i = 0; i < numQueries; i++) {
 
     checklist[query[i]]++;
     if (checklist[query[i]] > 1)
       checkdif++;
     if (i >= checkdif) { //if we go past the number of search engines we have
       //for (int j = 0; j <= checkdif; j++) {
 	/*
 	  if (zeroIndexs(checklist, numEngines) != NULL) {//if there is an engine that hasn't been used
 	  
 	}
 	*/
 	//else { //if all engines are used, the last engine must have been the one
 	  //do process again from beginning:
 	  //reset checklist
 	  //  mark the last query
 	  //reset checkdif
 	  //increase switches
       //printf(αin!nα);
       for (int k = 0; k < numEngines; k++)
 	checklist[k] = 0;
       
       checklist[query[i]] = 1;
       checkdif = i+numEngines-1;
       
       switches++;
       //if (switches == 1)
       //	printf(αStarted with %dnα, query[i]);
       //else
       //	printf(αSwitched to %dnα, query[i]);
       
 	  //}
     }
     //printf(αok!nα);
   }
 
   return switches;
 }
 
 //retrurns an array of all of the indexes that have 0s if 0s are found, null otherwise.
 //int* zeroIndexes() {
 
 
 
 int main() {
   FILE *fp;
   FILE *new;
   fp = fopen(αA-small.inα, αrtα);
   new = fopen(αtest2.txtα, αwα);
 
   char line[100];
   
   int cases = atoi(fgets(line, 100, fp));
 
 
   for (int i = 1; i <= cases; i++) {
 
     int numEngines = atoi(fgets(line, 100, fp));
     char engines[numEngines][100];
 
     //names search engines
     for (int j = 0; j < numEngines; j++) {
       strcpy(engines[j], (fgets(line, 100, fp)));
     }
     
     int query = atoi(fgets(line, 100, fp));
 
     
     int numberedquery[query];
     //makes an array numberedquery where every name is switched with  numbers.
     for (int k = 0; k < query; k++) {
       fgets(line, 100, fp); //
 
       for (int l = 0; l < numEngines; l++) {
 	if (strcmp(line, engines[l]) == 0) {
 	  numberedquery[k] = l;
 
 	  break;
 	}
 
       }
     
     }
 
     
     fprintf(new, αCase #%d: %dnα, i, lastappearance(numberedquery, numEngines, query));
     
   }
 
   
   
   return 0;
 }"
18593,2008,32013,aleph5381,24480,1,a.c,gcj/2008/32013/aleph5381/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 int main(int argc, char* argv[])
 {
 	int n, n2=0;
 	if (argc < 2)
 		exit(0);
 	FILE *fp = fopen(argv[1],αrα);
 	if (!fp)
 		exit(0);
 	fscanf(fp,α%dnα,&n);
 	while (n--) {
 		int S, Q;
 		char engine[100][256];
 		char query[1000][256];
 		fscanf(fp,α%dnα,&S);
 		int i, j;
 		char c;
 		for (i=0; i<S; i++) {
 			j = 0;
 			while ((c=fgetc(fp)) && c!='n' && c!=EOF) {
 				engine[i][j++] = c;
 			}
 			engine[i][j] = '0';
 		}
 		fscanf(fp,α%dnα,&Q);
 		for (i=0; i<Q; i++) {
 			j = 0;
 			while ((c=fgetc(fp)) && c!='n' && c!=EOF) {
 				query[i][j++] = c;
 			}
 			query[i][j] = '0';
 		}
 		////
 		int s = S;
 		int ans = 0;
 		int x[S];
 		int z;
 		for (z=0; z<S; z++) {
 			x[z] = 1;
 		}
 		for (i=0; i<Q; i++) {
 			for (j=0; j<S; j++) {
 				if (strcmp(query[i],engine[j])==0) {
 					if (x[j]==1) {
 						x[j] = 0;
 						s--;
 					}
 					break;
 				}
 			}
 			if (s==0) {
 				ans++;
 				s = S;
 				for (z=0; z<S; z++) {
 					x[z] = 1;
 				}
 				i--;
 			}
 		}
 		// print result
 		printf(αCase #%d: %dnα,++n2,ans);
 	}
 	fclose(fp);
 	return 0;
 }"
18596,2008,32013,aleph5381,24481,1,b.c,gcj/2008/32013/aleph5381/24481/1/extracted/b.c,"#include <stdio.h>
 #include <string.h>
 
 struct time
 {
 	int hh;
 	int mm;
 };
 
 int mycomp(const void *aa, const void *bb)
 {
 	struct time a = *(struct time *) aa;
 	struct time b = *(struct time *) bb;
 	return (a.hh-b.hh)?(a.hh-b.hh):(a.mm-b.mm);
 }
 
 int main(int argc, char* argv[])
 {
 	int n, n2=0;
 	if (argc < 2)
 		exit(0);
 	FILE *fp = fopen(argv[1],αrα);
 	if (!fp)
 		exit(0);
 	fscanf(fp,α%dnα,&n);
 	while (n--) {
 		int T, NA, NB;
 		fscanf(fp,α%dn%d %dnα,&T,&NA,&NB);
 		struct time aout[NA];
 		struct time ain[NB];
 		struct time bout[NB];
 		struct time bin[NA];
 		int i, j;
 		for (i=0; i<NA; i++) {
 			fscanf(fp,α%d:%d %d:%dnα,
 					&(aout[i].hh), &(aout[i].mm),
 					&(bin[i].hh), &(bin[i].mm));
 		}
 		for (i=0; i<NB; i++) {
 			fscanf(fp,α%d:%d %d:%dnα,
 					&(bout[i].hh), &(bout[i].mm),
 					&(ain[i].hh), &(ain[i].mm));
 		}
 		////
 		qsort(aout, NA, sizeof(struct time), mycomp);
 		qsort(bin, NA, sizeof(struct time), mycomp);
 		qsort(bout, NB, sizeof(struct time), mycomp);
 		qsort(ain, NB, sizeof(struct time), mycomp);
 		int N = NA + NB;
 		int ans1 = NA;
 		int ans2 = NB;
 
 		i = j = 0;
 		struct time temp;
 		while (i < NA && j < NB) {
 			temp.hh = bin[i].hh;
 			temp.mm = bin[i].mm + T;
 			if (temp.mm >= 60) {
 				temp.mm -= 60;
 				temp.hh++;
 			}
 			if (mycomp(&temp, &bout[j]) <= 0) {
 				ans2--;
 				i++;
 			}
 			j++;
 		}
 
 		i = j = 0;
 		while (i < NB && j < NA) {
 			temp.hh = ain[i].hh;
 			temp.mm = ain[i].mm + T;
 			if (temp.mm >= 60) {
 				temp.mm -= 60;
 				temp.hh++;
 			}
 			if (mycomp(&temp, &aout[j]) <= 0) {
 				ans1--;
 				i++;
 			}
 			j++;
 		}
 
 		//
 		printf(αCase #%d: %d %dnα,++n2,ans1,ans2);
 	}
 	fclose(fp);
 	return 0;
 }"
18644,2008,32013,mahsheed,24480,1,SavingTheUniverse.c,gcj/2008/32013/mahsheed/24480/1/extracted/SavingTheUniverse.c,"#include<stdio.h>
 #include<string.h>
 #define MAX_NUMBER_OF_SEARCH_ENGINES 100
 #define MAX_NUMBER_OF_QUERIES 1000
 #define FILENAME αA-large.inα
 
 typedef struct searchEnginesStruct
 {
     char name[MAX_NUMBER_OF_SEARCH_ENGINES][100];
     int flag[MAX_NUMBER_OF_SEARCH_ENGINES];
 }searchEnginesStruct;
 
 typedef struct queryStruct
 {
     char name[MAX_NUMBER_OF_QUERIES][100];
 }queryStruct;
 
 int solveInput(searchEnginesStruct searchEngines, queryStruct queries, int N, int S, int Q, int* start, int *finish)
 {
     int i, j, k, count;
     for(i=0; i<S; i++)
         searchEngines.flag[i]=0;
 
     count=0;
     for(i=*start; i<Q; i++)  // go thru the queries
     {
         for(j=0; j<S; j++)  // go thru the search engines
             if(strcmp(queries.name[i],searchEngines.name[j])==0)
             {
                 if(searchEngines.flag[j]==0)
                 {
                     searchEngines.flag[j]=1;
                     count++;
                 }
                 break;
             }
        if(count==S-1 && i+1!=Q)  //only one engine remaining
        {
            for(k=0; k<S; k++)
            {
                if(strcmp(queries.name[i+1], searchEngines.name[k])==0 && searchEngines.flag[k]==0)
 
                 {
                     *finish=i+1;
                     return 1;
                 }
            }
        }
     }
     return 0;
 }
 
 
 int main()
 {
     searchEnginesStruct searchEngines;
     queryStruct queries;
     FILE *file;
     FILE *fileOut;
     int N, S, Q;
     int noOfChanges=-1;
     int start;
 
     int i, j;
 
 
     file=fopen(FILENAME, αrα);
     fileOut=fopen(αoutput.txtα, αwα);
 
     if(file==NULL)
     {
         printf(αError: can't open file.nα);
         return 1;
     }
     else
     {
 
         printf(αFile opened successfully.nα);
 
         fscanf(file, α%dα, &N);
         for(i=0; i<N; i++)
         {
             fscanf(file,α%dα, &S);
             for(j=-1; j<S; j++)
             {
                 fgets((searchEngines.name[j]), 100, file);
                 searchEngines.name[j][strlen(searchEngines.name[j])-1]='0';
             }
             fscanf(file,α%dα, &Q);
             for(j=-1; j<Q; j++)
             {
                 fgets((queries.name[j]), 100, file);
                 queries.name[j][strlen(queries.name[j])-1]='0';
             }
 
             start=0;
             noOfChanges=0;
             while(solveInput(searchEngines, queries, N, S, Q, &start, &start)!=0 )
             {
                 noOfChanges++;
             }
             fprintf(fileOut,αCase #%d: %dnα,i+1, noOfChanges);
             printf(αCase #%d: %dnα,i+1, noOfChanges);
         }
     }
 
     fclose(file);
     fclose(fileOut);
     return 1;
 }"
18693,2008,32013,mani.manu2,24480,1,universe.c,gcj/2008/32013/mani.manu2/24480/1/extracted/universe.c,"#include <stdlib.h>
 #include <stdio.h>
 
 
 typedef struct _Server
 {
 	char name[102];
 	int check;
 } Server;
 
 // main start
 
 int main(int argc , char *argv[])
 {
 	FILE *ip,*op;
 
 	int i,j,k,l,ncase,nserver,nswitch=0,nq,count;
 	char buff[102];
 	if(argc != 2)
 	{
 		printf(αError:nα);
 		printf(αUsage: universe <input file>nα);
 		printf(αExample: universe A-small-attempt0.innα);
 		exit(1);
 	}
 	ip = fopen(argv[1] , αrα);
 	if( ip == NULL )
 	{
 		printf(αerror in opening fileα);
 	}
 
 	// Read from the file 
 	
 	fscanf(ip,α%dα,&ncase);
 	Server *sname = NULL;
 	for(i = 0; i < ncase ; i++)
 	{
 		fscanf(ip,α%dα,&nserver);
 		fgetc(ip);
 		sname = (Server *) calloc(nserver,sizeof(Server));
 		//. create memory for server names
 		nswitch=0;
 		count=nserver;
 		for( j = 0 ; j < nserver ;j++)
 		{
 			
 			fgets(sname[j].name,101,ip);
 			sname[j].check = 0;
 		}
 
 		fscanf(ip,α%dα,&nq);
 		fgetc(ip);
 		for( j = 0 ; j < nq ; j++)
 		{
 			fgets(buff,101,ip);
 						
 			for(k = 0 ; k < nserver ; k++)
 			{
 				if(strcmp(buff,sname[k].name) == 0)
 				{
 					if(sname[k].check==0)
 					{
 						sname[k].check++;
 						count--;
 						if(count==0)
 						{
 							nswitch++;
 							count = nserver-1;
 							for(l=0;l<nserver;l++)
 							{
 								if(l!=k)
 								{
 									sname[l].check = 0;
 								}
 							}
 							
 						}
 					}
 					
 					break;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα,i+1,nswitch); 
 		free(sname);
 	}
 	return 0;
 }"
18798,2008,32013,senthilkumaran,24480,1,first.c,gcj/2008/32013/senthilkumaran/24480/1/extracted/first.c,"#include <stdio.h>
 
 int 
 main ()
 {
   typedef struct enginfo
   {
     char searchengine[100];
     int used;
   }engineinfo;
 
   int noftestcases;
   int nofsearchengines;
   int nofsearchitems;
   char queryitems[100];
   int allsearchenginesused=1;
   int i=0, j=0, k=0;
   int sw[20];
   engineinfo testeinfo[100];
   scanf (α%dα, &noftestcases);
 
   for (i=0;i<noftestcases;i++)
     {
       sw[i] = 0;
       scanf (α%dα, &nofsearchengines);
       getchar ();
       for (j=0;j < nofsearchengines; j++)
 	{
 	  gets (testeinfo[j].searchengine);
 	  testeinfo[j].used=0;
 	}
       
       for (j=0;j < nofsearchengines; j++)
 	{
 	  printf (α%snα, (testeinfo[j].searchengine));
 	}
 
       scanf (α%dα, &nofsearchitems);
       printf (αQuery items: %dnα, nofsearchitems);
       getchar ();
       for (j=0;j<nofsearchitems;j++)
 	{
 	  gets (queryitems);
 	  for (k=0;k<nofsearchengines; k++)
 	    {
 	      if (strcmp (testeinfo[k].searchengine, queryitems) == 0)
 		{
 		  testeinfo[k].used = 1;
 		}
 	    }
 
 	  allsearchenginesused = 1;
 	  for (k=0;k<nofsearchengines;k++)
 	    {
 	      if (testeinfo[k].used != 1)
 		{
 		  allsearchenginesused = 0;
 		  break;
 		}
 	    }
 	  
 	  if (allsearchenginesused == 1)
 	    {
 	      sw[i] = sw[i] + 1;
 	    
 	      for (k=0;k<nofsearchengines; k++)
 		{
 		  if (strcmp (testeinfo[k].searchengine, queryitems) != 0)
 		    {
 		      testeinfo[k].used = 0;
 		    }
 		}
 	    }
 	}
 
       for (j=0;j < nofsearchengines; j++)
 	{
 	  testeinfo[j].searchengine[0] = '0';
 	  testeinfo[j].used=0;
 	}
     }
 
   for (i=0;i<noftestcases;i++)
     {
       printf (αCase #%d: %dnα,i+1,sw[i]);
     }
   return 0;
 }"
18845,2008,32013,Nevis,24480,1,A.c,gcj/2008/32013/Nevis/24480/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 char A[100][200];
 char Str[200];
 
 int B[1000];
 
 int Map[100][1000];
 
 int N,S,Q,I;
 
 int main()
 {
 	int i,j,k,m,min;
 	scanf(α%dα,&N);
 	for(i=1;i<=N;i++)
 	{
 		scanf(α%dα,&S);
 		gets(Str);
 		for(j=0;j<S;j++)
 			gets(A[j]);
 		scanf(α%dα,&Q);
 		gets(Str);
 		for(j=0;j<Q;j++)
 		{
 			gets(Str);
 			for(k=0;k<S;k++)
 			{
 				if(strcmp(Str,A[k])==0)
 				{
 					B[j]=k;
 					break;
 				}
 			}
 		}
 		for(j=0;j<Q;j++)
 		{
 			if(j==0)for(k=0;k<S;k++)
 			{
 				if(B[j]==k)Map[k][j]=1;
 				else Map[k][j]=0;
 			}
 			else for(k=0;k<S;k++)
 			{
 				if(B[j]==k)
 				{
 					min=-1;
 					for(m=0;m<S;m++)
 					{
 						if(m==k)continue;
 						if(Map[m][j-1]<min || min==-1)
 						{
 							min=Map[m][j-1];
 						}
 						Map[k][j]=min+1;
 					}
 				}
 				else Map[k][j]=Map[k][j-1];
 			}
 		}
 		/*for(j=0;j<S;j++)
 		{
 			for(k=0;k<Q;k++)
 				printf(α%dα,Map[j][k]);
 			printf(αnα);
 		}*/
 		min=-1;
 		for(j=0;j<S;j++)
 		{
 			if(min==-1 || min>Map[j][Q-1])
 			{
 				min=Map[j][Q-1];
 			}
 		}
 		printf(αCase #%d: %dnα,i,min);
 		
 	}
 	return 0;
 }"
18891,2008,32013,bec42,24480,1,qual.c,gcj/2008/32013/bec42/24480/1/extracted/qual.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_FILENAME 20
 #define MAX_LINE_LENGTH 50
 #define MAX_TEST_CASES 20
 #define MAX_SEARCHENGINES 100
 
 void process_testcase(FILE *, FILE *, int, int);
 
 main()
 {
 
 	char str_buf[MAX_FILENAME + 2];
 	FILE *filePtr = NULL;
 	FILE *outfile = NULL;
 	char line[MAX_LINE_LENGTH + 2];
 	int input_number, testcases, i;
 
 	printf(αEnter input type (1 for small, 2 for large):nα);
 	fgets(str_buf, MAX_LINE_LENGTH + 1, stdin);
 	sscanf(str_buf, α%dα, &input_number);
 	if (input_number == 1)
 	{
 		filePtr = fopen(αA-small.inα, αrα);
 	}
 	else if (input_number == 2)
 	{
 		filePtr = fopen(αA-large.inα, αrα);
 	}
 	if (filePtr == NULL)
 	{
 		fprintf(stderr, αError: input file not found.nα);
 		return;
 	}
 
 	outfile = fopen(αqual.outα, αwα);
 
 	while (fgets(line, MAX_LINE_LENGTH + 1, filePtr) != NULL)
 	{
 		sscanf(line, α%dα, &testcases);
 
 		if (testcases < 1 || testcases > MAX_TEST_CASES)
 		{
 			fprintf(stderr, αError: invalid number of test cases, must be between 1 and %d inclusive.nα, MAX_TEST_CASES);
 			return;
 		}
 
 		for (i=0; i<testcases; i++)
 		{
 			process_testcase(filePtr, outfile, i+1, input_number);
 		}
 	}
 
 	fclose(filePtr);
 	fclose(outfile);
 	
 	return;
 }
 
 void process_testcase(FILE *filePtr, FILE *outfile, int test_case, int input_number)
 {
 	char line[MAX_LINE_LENGTH + 2];
 	int searchengines, queries, i, j, k;
 	char *searchenginelist[MAX_SEARCHENGINES];
 	char searchenginename[MAX_LINE_LENGTH + 1];
 	char query[MAX_LINE_LENGTH + 1];
 	int visited[MAX_SEARCHENGINES];
 	int switchcount = 0, hitcount = 0;
 	
 	fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 	sscanf(line, α%dα, &searchengines);
 
 	if (searchengines < 2 || (input_number == 1 && searchengines > 10) || searchengines > MAX_SEARCHENGINES)
 	{
 		fprintf(stderr, αError: too many search engines.nα);
 		return;
 	}
 
 	for (i=0; i<searchengines; i++)
 	{
 		fgets(searchenginename, MAX_LINE_LENGTH + 1, filePtr);
 		searchenginelist[i] = (char *) malloc(strlen(searchenginename) +1);
 		strcpy(searchenginelist[i], searchenginename);
 		visited[i] = 0;
 	}
 
 	fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 	sscanf(line, α%dα, &queries);
 
 if (queries < 0 || (input_number == 1 && queries > 100) || queries > 1000)
 	{
 		fprintf(stderr, αError: too many queries.nα);
 		return;
 	}
 
 	for (i=0; i<queries; i++)
 	{
 		fgets(query, MAX_LINE_LENGTH + 1, filePtr);
 		j = 0;
 		while (j < searchengines && strcmp(query, searchenginelist[j]) != 0)
 			j++;
 
 		if (j < searchengines)
 		{
 			if (visited[j] != 1)
 			{
 				visited[j] = 1;
 				if (hitcount < searchengines - 1)
 					hitcount++;
 				else
 				{
 					switchcount++;
 					for (k=0; k<searchengines; k++)
 						if (k != j)
 							visited[k] = 0;
 					hitcount = 1;
 				}
 			}
 		}
 	}
 
 	fprintf(outfile, αCase #%d: %dnα, test_case, switchcount);
 
 	return;
 
 }"
18893,2008,32013,bec42,24481,1,qual_trains.c,gcj/2008/32013/bec42/24481/1/extracted/qual_trains.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_LINE_LENGTH 50
 #define MAX_TEST_CASES 100
 #define MAX_TRAINS 100
 
 void process_testcase(FILE *, FILE *, int, int);
 void time_sort(int *, int *, int *, int *, int);
 
 
 main()
 {
 
 	char str_buf[MAX_LINE_LENGTH + 2];
 	FILE *filePtr = NULL;
 	FILE *outfile = NULL;
 	char line[MAX_LINE_LENGTH + 2];
 	int input_number, testcases, i;
 
 	printf(αEnter input type (1 for small, 2 for large):nα);
 	fgets(str_buf, MAX_LINE_LENGTH + 1, stdin);
 	sscanf(str_buf, α%dα, &input_number);
 	if (input_number == 1)
 	{
 		filePtr = fopen(αB-small.inα, αrα);
 	}
 	else if (input_number == 2)
 	{
 		filePtr = fopen(αB-large.inα, αrα);
 	}
 	if (filePtr == NULL)
 	{
 		fprintf(stderr, αError: input file not found.nα);
 		return;
 	}
 
 	outfile = fopen(αqual.outα, αwα);
 
 	while (fgets(line, MAX_LINE_LENGTH + 1, filePtr) != NULL)
 	{
 		sscanf(line, α%dα, &testcases);
 
 		if (testcases < 1 || testcases > MAX_TEST_CASES)
 		{
 			fprintf(stderr, αError: invalid number of test cases, must be between 1 and %d inclusive.nα, MAX_TEST_CASES);
 			return;
 		}
 
 		for (i=0; i<testcases; i++)
 		{
 			process_testcase(filePtr, outfile, i+1, input_number);
 		}
 	}
 
 	fclose(filePtr);
 	fclose(outfile);
 	
 	return;
 }
 
 void process_testcase(FILE *filePtr, FILE *outfile, int test_case, int input_number)
 {
 	char line[MAX_LINE_LENGTH + 2];
 	int turnaround, na, nb, i, j;
 	int a_hrs_arrive[MAX_TRAINS];
 	int b_hrs_arrive[MAX_TRAINS];
 	int a_mins_arrive[MAX_TRAINS];
 	int b_mins_arrive[MAX_TRAINS];
 	int a_hrs_depart[MAX_TRAINS];
 	int b_hrs_depart[MAX_TRAINS];
 	int a_mins_depart[MAX_TRAINS];
 	int b_mins_depart[MAX_TRAINS];
 	int a_saved[MAX_TRAINS];
 	int b_saved[MAX_TRAINS];
 	int a_needed, b_needed;
 
 	fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 	sscanf(line, α%dα, &turnaround);
 	
 	// error checking
 	
 	fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 	sscanf(line, α%d %dα, &na, &nb);
 	
 	a_needed = na;
 	b_needed = nb;
 	
 	// error checking
 	
 	for (i=0; i<na; i++)
 	{
 		fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 		sscanf(line, α%d:%d %d:%dα, &a_hrs_depart[i], &a_mins_depart[i], &a_hrs_arrive[i], &a_mins_arrive[i]);
 		a_saved[i] = 0;
 	}
 
 	for (i=0; i<nb; i++)
 	{
 		fgets(line, MAX_LINE_LENGTH + 1, filePtr);
 		sscanf(line, α%d:%d %d:%dα, &b_hrs_depart[i], &b_mins_depart[i], &b_hrs_arrive[i], &b_mins_arrive[i]);
 		b_saved[i] = 0;
 	}
 	
 	time_sort(a_hrs_arrive, a_mins_arrive, a_hrs_depart, a_mins_depart, na);
 	time_sort(b_hrs_depart, b_mins_depart, b_hrs_arrive, b_mins_arrive, nb);
 
 	
 	for (i=0; i<na; i++)
 	{
 		a_mins_arrive[i] += turnaround;
 		if (a_mins_arrive[i] > 59)
 		{
 			a_mins_arrive[i] -= 60;
 			a_hrs_arrive[i] += 1;
 		}
 		for (j=0; j<nb; j++)
 		{
 			if (time_compare(a_hrs_arrive[i], a_mins_arrive[i], b_hrs_depart[j], b_mins_depart[j]) <= 0 && b_saved[j] == 0)
 			{
 				b_saved[j] = 1;
 				b_needed--;
 				break;
 			}
 		}
 	}
 	
 	time_sort(b_hrs_arrive, b_mins_arrive, b_hrs_depart, b_mins_depart, nb);
 	time_sort(a_hrs_depart, a_mins_depart, a_hrs_arrive, a_mins_arrive, na);
 	
 	for (i=0; i<nb; i++)
 	{
 		b_mins_arrive[i] += turnaround;
 		if (b_mins_arrive[i] > 59)
 		{
 			b_mins_arrive[i] -= 60;
 			b_hrs_arrive[i] += 1;
 		}
 		for (j=0; j<na; j++)
 		{
 			if (time_compare(b_hrs_arrive[i], b_mins_arrive[i], a_hrs_depart[j], a_mins_depart[j]) <= 0 && a_saved[j] == 0)
 			{
 				a_saved[j] = 1;
 				a_needed--;
 				break;
 			}
 		}
 	}
 	
 	fprintf(outfile, αCase #%d: %d %dnα, test_case, a_needed, b_needed);
 	
 	return;
 }
 
 int time_compare(int a_hrs, int a_mins, int b_hrs, int b_mins)
 {
 	if (a_hrs < b_hrs)
 		return -1;
 	else if (a_hrs > b_hrs)
 		return 1;
 	else
 	{
 		if (a_mins < b_mins)
 			return -1;
 		else if (a_mins > b_mins)
 			return 1;
 		else if (a_mins == b_mins)
 			return 0;
 	}
 
 }
 
 void time_sort(int *hours_1, int *mins_1, int *hours_2, int *mins_2, int size)
 {
 	int i, j;
 	int temp_h1, temp_m1, temp_h2, temp_m2;
 
 	for (i=1; i<size; i++)
 	{
         temp_h1 = hours_1[i]; temp_m1 = mins_1[i];
 		temp_h2 = hours_2[i]; temp_m2 = mins_2[i];
         j = i-1;
         while (j >= 0 && time_compare(hours_1[j], mins_1[j], temp_h1, temp_m1) > 0)
         {
 			hours_1[j+1] = hours_1[j]; mins_1[j+1] = mins_1[j];
 			hours_2[j+1] = hours_2[j]; mins_2[j+1] = mins_2[j];
 			j = j-1;
         }
 		hours_1[j+1] = temp_h1; mins_1[j+1] = temp_m1;
 		hours_2[j+1] = temp_h2; mins_2[j+1] = temp_m2;
     }
 
 }"
18982,2008,32013,aespinosa,24481,1,train.c,gcj/2008/32013/aespinosa/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int to_mins(int hr, int min)
 {
 	return hr * 60 + min;
 }
 
 int comp(const int * a,const int * b)
 {
 	if (*a==*b)
 		return 0;
 	else
 		if (*a < *b)
 			return -1;
 		else
 			return 1;
 }
 
 int main()
 {
 	int sa[1440], sb[1440];
 	int N;
 	int zz;
 	scanf(α%dα, &N);
 	for(zz = 1; zz <= N; zz++)
 	{
 		int T;
 		int NA, NB;
 		int i;
 		int ara[100], arb[100];
 		for( i = 0; i < 1440; i++ )
 		{
 			sa[i] = 0;
 			sb[i] = 0;
 		}
 		for( i = 0; i < 100; i++ )
 		{
 			ara[i] = 0;
 			arb[i] = 0;
 		}
 		scanf(α%dα, &T);
 		scanf(α%dα, &NA);
 		scanf(α%dα, &NB);
 		printf(αCase #%d: α, zz);
 		for(i = 0; i < NA; i++)
 		{
 			char c;
 			int hr, min;
 			scanf(α%dα, &hr);
 			scanf(α%cα, &c);
 			scanf(α%dα, &min);
 			sa[to_mins(hr, min)]++;
 			scanf(α%dα, &hr);
 			scanf(α%cα, &c);
 			scanf(α%dα, &min);
 			arb[i] = to_mins(hr, min) + T;
 		}
 		for(i = 0; i < NB; i++)
 		{
 			char c;
 			int hr, min;
 			scanf(α%dα, &hr);
 			scanf(α%cα, &c);
 			scanf(α%dα, &min);
 			sb[to_mins(hr, min)]++;
 			scanf(α%dα, &hr);
 			scanf(α%cα, &c);
 			scanf(α%dα, &min);
 			ara[i] = to_mins(hr, min) + T;
 		}
 		qsort(arb, NA, sizeof(int),comp) ;
 		qsort(ara, NB, sizeof(int),comp) ;
 		for(i = 0; i < NA; i++)
 		{
 			int j;
 			for(j = arb[i]; j < 1440; j++)
 			{
 				if( sb[j] )
 				{
 					sb[j]--;
 					break;
 				}
 			}
 		}
 		for(i = 0; i < NB; i++)
 		{
 			int j;
 			for(j = ara[i]; j < 1440; j++)
 			{
 				if( sa[j] )
 				{
 					sa[j]--;
 					break;
 				}
 			}
 		}
 		int suma = 0;
 		int sumb = 0;
 		for(i = 0; i < 1440; i++)
 		{
 			suma = sa[i] + suma;
 			sumb = sb[i] + sumb;
 		}
 		printf(α%d %dnα, suma, sumb);
 	}
 	return 0;
 }"
19126,2008,32013,Marijan,24480,1,queries.c,gcj/2008/32013/Marijan/24480/1/extracted/queries.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define S 100
 #define Q 1000
 #define MAX 101
 
 char s[S][MAX];
 char *q[Q];
 
 int f(const void *l,const void *d) {
 	return strcmp(l,d); }
 
 main() {
 	int i,j,k,l,n,bs,bq,cq,mq;
 	char buff[MAX],*ms;
 
 	gets(buff);
 	sscanf(buff,α%dα,&n);
 	for (k=1;k<=n;k++) {
 		gets(buff);
 		sscanf(buff,α%dα,&bs);
 		for (i=0;i<bs;i++) gets(s[i]);
 		qsort(s,bs,MAX,f);
 		gets(buff);
 		sscanf(buff,α%dα,&bq);
 		for (i=0;i<bq;i++) q[i]=bsearch(gets(buff),s,bs,MAX,f);
 		for (cq=mq=0,l=0;;l++,cq=mq) {
 			for (ms=s[cq],i=0;i<bs;i++) {
 				for (j=cq;j<bq;j++) if (s[i]==q[j]) break;
 				if (j==bq) break;
 				if (mq<j) { ms=s[i]; mq=j; }
 			}
 			if (i!=bs) break;
 		}
 		printf(αCase #%d: %dnα,k,l);
 	}
 }"
19128,2008,32013,Marijan,24481,1,trains.c,gcj/2008/32013/Marijan/24481/1/extracted/trains.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define M 100
 
 struct trip { int a,d; } a[M],b[M];
 
 int fa(const void *l, const void *d) {
 	if (((struct trip *)l)->a>((struct trip *)d)->a) return 1;
 	if (((struct trip *)l)->a<((struct trip *)d)->a) return -1;
 	return 0;
 }
 
 int fd(const void *l, const void *d) {
 	if (((struct trip *)l)->d>((struct trip *)d)->d) return 1;
 	if (((struct trip *)l)->d<((struct trip *)d)->d) return -1;
 	return 0;
 }
 
 main() {
 	int i,j,k,n,na,nb,h,m,tt,nv,mav,mbv;
 
 	scanf(α%dα,&n);
 	for (k=1;k<=n;k++) {
 		scanf(α%dα,&tt);
 		scanf(α%d %dα,&na,&nb);
 		for (i=0;i<na;i++) {
 			scanf(α%d:%dα,&h,&m);
 			a[i].d=m+h*60;
 			scanf(α%d:%dα,&h,&m);
 			a[i].a=m+h*60;
 		}
 		for (i=0;i<nb;i++) {
 			scanf(α%d:%dα,&h,&m);
 			b[i].d=m+h*60;
 			scanf(α%d:%dα,&h,&m);
 			b[i].a=m+h*60;
 		}
 		qsort(a,na,sizeof(struct trip),fd);
 		qsort(b,nb,sizeof(struct trip),fa);
 		for (mav=nv=j=i=0;i<na;i++) {
 			while (j<nb) if (b[j].a+tt<=a[i].d) j++, nv++;
 				else break;
 			nv--;
 			if (nv<mav) mav=nv;
 		}
 		qsort(a,na,sizeof(struct trip),fa);
 		qsort(b,nb,sizeof(struct trip),fd);
 		for (mbv=nv=j=i=0;i<nb;i++) {
 			while (j<na) if (a[j].a+tt<=b[i].d) j++, nv++;
 				else break;
 			nv--;
 			if (nv<mbv) mbv=nv;
 		}
 		printf(αCase #%d: %d %dnα,k,-mav,-mbv);
 		fflush(stdin);
 	}
 }"
19369,2008,32013,asasin,24480,1,1.c,gcj/2008/32013/asasin/24480/1/extracted/1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int S,Q;
 int A[1001][1002];
 int B[1001][1002];
 int C[1002];
 int D[1002][1002];
 int lengthb[1001];
 int lengthd[1002];
 
 int set()
 {
     int i,j;
     S=0;
     Q=0;
     for(j=0;j<102;j++)
     {
         for(i=0;i<11;i++)
         {
             A[i][j]=0;
             B[i][j]=0;
             D[i][j]=0;
         }
         C[j]=0;
         lengthd[j]=0;
     }
     for(i=0;i<11;i++)
     {
         lengthb[i]=0;
     }
     return 0;
 }
 
 int checksame(int i,int j)
 {
     int k;
     for(k=0;k<=lengthb[j];k++)
     {
         //printf(αB[%d][%d]= %d , D[%d][%d]= %d nα,j,k,B[j][k],i,k,D[i][k]);
         if(B[j][k]==D[i][k])
             continue;
         else
         {
             return 1;
         }
     }
 return 0;
 }
 
 int convertdc()
 {
     C[0]=1000;
     int i,j,k;
     for(i=1;i<=Q;i++)
     {
         for(j=1;j<=S;j++)
         {
             if(lengthb[j]==lengthd[i])
             {
                 k=checksame(i,j);
                 if(k==0)
                 {
                     C[i]=j;
                     break;
                 }
                 else
                     continue;
             }
         }
         if(C[i]==0)
             C[i]=1000; 
     }
 return 0;
 }
 
 int findmina(int i)
 {
     int j,k;
     k=A[i][1];
     for(j=2;j<=S;j++)
     {
         if(k>A[i][j])
             k=A[i][j];
     }
 return k;    
 }
 
 int setvaluesa()
 {
     int i,j,k;
     for(i=1;i<=Q;i++)
     {
         for(j=0;j<=S;j++)
         {
             if(C[i]==j)
                 A[i][j]=1000;
             else
             {
                 k=findmina(i-1);
                 k++;
                 if(k>A[i-1][j])
                     A[i][j]=A[i-1][j];
                 else
                     A[i][j]=k;
             }
         }
     }
 return 0;
 }
 
 int main()
 {
     int N,i,j,k,result;
     FILE *fp;
         if((fp = fopen(αKVS1α, αwα))==NULL)
         {
             exit(1);
         }
     scanf(α%dα,&N);
     for(i=1;i<=N;i++)
     {
         set();
         scanf(α%dα,&S);
         for(j=0;j<=S;j++)
         {
             for(k=0;k<102;k++)
             {
                 scanf(α%cα,&B[j][k]);
                 if(B[j][k]==10)
                 {
                     lengthb[j]=k;
                     break;
                 }
             }
         }
         scanf(α%dα,&Q);
         for(j=0;j<=Q;j++)
         {
             for(k=0;k<102;k++)
             {
                 scanf(α%cα,&D[j][k]);
                 if(D[j][k]==10)
                 {
                     lengthd[j]=k;
                     break;
                 }
             }
         }
 /*        for(j=0;j<10;j++)
     {
         for(i=0;i<Q;i++)
         {
             printf(αB[%d][%d] = %d   α,i,j,B[i][j]);
             printf(αD[%d][%d] = %dnα,i,j,D[i][j]);
         }
     }
 */        
         convertdc();
         setvaluesa();
         result=findmina(Q);
         fprintf(fp,αCase #%d: %dnα,i,result);
 
         printf(αCase #%d: %dnα,i,result);
 /*        for(j=0;j<=Q;j++)
         {
         printf(αC[%d] = %dnα,j, C[j]);
         }
         for(i=0;i<=Q;i++)
         {
             for(j=0;j<=S;j++)
             {
             printf(αA[%d][%d] = %dα,i,j, A[i][j]);
             }
             printf(αnα);
         }*/
     }
     fclose(fp);
 return 0;
 }"
19403,2008,32013,CTB,24480,1,a.c,gcj/2008/32013/CTB/24480/1/extracted/a.c,"#include <stdio.h>
 
 // #define DEBUGINPUT
 // #define DEBUGPATHS
 // #define DEBUGCOSTS
 // #define DEBUGADDPATHS
 // #define DEBUGWARSHALL
 
 // infinity value (leave space for adding two infinity values)
 #define INF 1000000000
 
 char sen[101][1000];
 int  qry[1001];
 
 char buffer[1000];
 
 typedef struct sPath {
   int s, from, to;
 } Path;
 
 int lastqok[101];
 
 int npaths;
 Path path[101*1001];
 Path * curpath[101];
 
 int d[1001][1001];
 
 int debuginput(int s, int q)
 {
   int i,j;
 
   printf(αs=%dnα, s);
   for (i = 1; i <= s; i++)
     printf(αs[%d] = %snα, i, sen[i]);
   printf(αq=%dnα, q);
   for (i = 1; i <= q; i++)
     printf(αq[%d] = s[%d] = %snα, i, qry[i], sen[qry[i]]);
 }
 
 int debugpaths(int s)
 {
   int i,j;
 
   for (i = 1; i <= s; i++)
   {
     int comma;
     printf(αs[%d] = %s: paths={α, i, sen[i]);
     for (j = 0, comma = 0; j < npaths; j++)
       if (path[j].s == i)
         printf (α%s%d-%dα, (comma++)?α, α:αα, path[j].from, path[j].to);
     printf(α}nα);
   }
   for (j = 0; j < npaths; j++)
     printf (α%4d: s[%d] = %s, %d-%dnα, j+1, path[j].s, sen[path[j].s], path[j].from, path[j].to);
 }
 
 int debugcosts(int q)
 {
   int i,j;
 
   printf(α    α);
   for (j = 1; j <= q; j++)
     printf(α %3dα, j);
   printf(αnα);
 
   for (i = 1; i <= q; i++)
   {
     printf(α%3d α, i);
     for (j = 1; j <= q; j++)
     if (d[i][j] == INF)
       printf(α  ooα);
     else
       printf(α %3dα, d[i][j]);
     printf(αnα);
   }   
 }
 
 int solve(int c)
 {
   int s, q, i, j, k, l, cost;
 
   // parse input
   scanf(α%dnα, &s);
   for (i = 1; i <= s; i++)
   {
     gets(sen[i]);
   }
 
   scanf(α%dnα, &q); 
   for (j = 1; j <= q; j++)
   {
     gets(buffer);
     for (i = 1; i <= s; i++)
       if (strcmp(buffer, sen[i])==0) qry[j] = i;
   }
 
 #ifdef DEBUGINPUT
   debuginput(s, q);
 #endif 
   
   // compute paths which require 0 switches
   npaths = 0;
   for (j = 1; j <= s; j++)
   {
     lastqok[j]  = -1;
     curpath[j] = NULL;
   }
 
   for (i = 1; i <= q; i++)
   {
     for (j = 1; j <= s; j++)
     {
       if (qry[i] != j) // we can use j for query i
       {
         if (lastqok[j] < i-1)
         {
           path[npaths].s    = j;
           path[npaths].from = i;
           curpath[j] = &path[npaths];
           npaths++;
         }
         curpath[j]->to = i;
         lastqok[j] = i;
       }
     } 
   }
 
 #ifdef DEBUGPATHS
   debugpaths(s);
 #endif 
 
   // compute cost matrix using Floyd/Warshall algorithm
 
   // initialize cost matrix to infinity for i<>j, 0 for i==j
   for (i = 1; i <= q; i++)
     for (j = i; j <= q; j++)
        d[i][j] = (i==j)?0:INF;
 
   // add all computed paths and their subpaths which require 0 switches.
   for (i = 0; i < npaths; i++)
   {
 #ifdef DEBUGADDPATHS
     printf(αfrom=%d to=%dnα, path[i].from, path[i].to);
 #endif
     for (k = path[i].from; k < path[i].to; k++)
       for (l = k; l <= path[i].to; l++)
       {
 #ifdef DEBUGADDPATHS
         printf(α  k=%d l=%d d[%d][%d]=%dnα, k,l,k,l,0);
 #endif
          d[k][l] = 0;
       }
   }
 
 #ifdef DEBUGCOSTS
   debugcosts(q);
 #endif
 
   for (k = 1; k <= q; k++)
     for (i = 1; i <= k; i++)
       for (j = k+1; j <= q; j++)
       {
 #ifdef DEBUGWARSHALL
         printf(αi=%d k=%d j=%d: d[%d][%d]=%d d[%d][%d]=%dnα, i,k,j, i,k,d[i][k],k+1,j, d[k+1][j]);
 #endif
         cost = d[i][k]+d[k+1][j]+1;
         if (cost < d[i][j])
         {
           d[i][j] = cost;
         }
       }
 
 #ifdef DEBUGCOSTS
   debugcosts(q);
 #endif 
  
   printf(αCase #%d: %dnα, c, d[1][q]);
 }
 
 int main(int argc, char **argv)
 {
   int i, n;
   scanf(α%dα, &n);
   for (i = 1; i <= n; i++) solve(i);
 }"
19405,2008,32013,CTB,24481,1,b.c,gcj/2008/32013/CTB/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 // #define DEBUGINPUT
 // #define DEBUGSCHEDULE
 
 int t, na, nb;
 
 #define A 0
 #define B 1
 
 typedef struct sTrip {
   int from;
   char dep[6];
   char arr[6];
   int  tdep;
   int  tarr;
   int  sched;
 } Trip;
 
 typedef int (*compfn)(const void*, const void*);
 
 Trip trip[2*100+1];
 int ntrips;
 
 int compare(Trip *elem1, Trip *elem2)
 {
    if ( elem1->tdep < elem2->tdep)
       return -1;
 
    else if (elem1->tdep > elem2->tdep)
       return 1;
 
    else
       if (elem1->tarr < elem1->tarr)
         return -1;
       else if (elem1->tarr > elem1->tarr)
         return 1;
       else
         return 0;
 }
 
 int solve(int c)
 {
   char dep[6], arr[6];
   int i, j, k, s[2], prev, found;
 
   scanf(α%dnα, &t);
   scanf(α%d %dnα, &na, &nb);
 
   ntrips = 0;
   for(i = 0; i < na + nb; i++)
   {
     trip[ntrips].from = (i<na)?A:B;
     trip[ntrips].sched = 0;
     scanf(α%s %snα, trip[ntrips].dep, trip[ntrips].arr);
     trip[ntrips].tdep = atoi(trip[ntrips].dep)*60 + atoi(&trip[ntrips].dep[3]);
     trip[ntrips].tarr = atoi(trip[ntrips].arr)*60 + atoi(&trip[ntrips].arr[3]);
     ntrips++;
   }
 
   qsort((void *)&trip, ntrips, sizeof(Trip), (compfn)compare );
 
 #ifdef DEBUGINPUT
   printf(αt=%d na=%d nb=%dnα, t, na, nb);
 
   for(i = 0; i < ntrips; i++)
   {
     printf(αtrip %3d: from=%s dep=%s arr=%s tdep=%d tarr=%dnα, i+1, (trip[i].from==A)?αAα:αBα, trip[i].dep, trip[i].arr, trip[i].tdep, trip[i].tarr);
   }
 
 #endif
 
   s[A] = s[B] = 0; // initialize number of trains that start from A and B
 
   for (k = 0; k < ntrips; k++)
   {
     i = k;
     prev = -1; // no previous trip
 
     do
     {
       found = 0;
 
       if (!trip[i].sched)
       {
         trip[i].sched = 1; 
 
         if (prev == -1) s[trip[i].from]++;
 
 #ifdef DEBUGSCHEDULE
         printf(αtrip %3d: prev=%3d from=%s dep=%s arr=%s tdep=%d tarr=%d s[%s]=%dnα, i+1, prev, (trip[i].from==A)?αAα:αBα, trip[i].dep, trip[i].arr, trip[i].tdep, trip[i].tarr, (trip[i].from==A)?αAα:αBα, s[trip[i].from]);
 #endif
 
         // find next trip with same train
         for (j = i+1; j < ntrips; j++)
           if (!trip[j].sched)
             if (trip[j].from == !trip[i].from)
               if (trip[j].tdep >= trip[i].tarr + t)
               {
                 found = 1; prev = i; i = j; break;
               }
       }
     } while (found);
   } 
 
   printf(αCase #%d: %d %dnα, c, s[A], s[B]);
 }
 
 int main (int argc, char **argv)
 {
   int i, n;
   scanf(α%dnα, &n);
   for (i = 1; i <= n; i++) solve(i);
 }"
19597,2008,32013,d00rm4n,24480,1,main.c,gcj/2008/32013/d00rm4n/24480/1/extracted/main.c,"#include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
 #include <malloc.h>
 #include <string.h>
 #include <pthread.h>
 #include <ctype.h>
 #include αlist.hα
 
 
 #define FOR( iter, end, statement )          for( iter = 0; iter < end; iter++ ) statement
 #define FOR_LIST( iter, lhead, statement )   for( iter = lhead; iter; iter = ( iter )->next ) statement
 #define MALLOC( type, count )                ( ( type * )malloc( sizeof( type ) * count ) )
 
 
 #define MAX_THREADS       10
 #define THREAD_FREE       0
 #define THREAD_BUSY       1
 #define THREAD_FINISHED   2
 
 #define ST_NOT_STARTED    0
 #define ST_STARTED        1
 #define ST_FINISHED       2
 #define ST_DONE           3
 
 
 struct mthread {
 	pthread_t thr;
 	int current_block;
 	int status;
 };
 
 struct input {
 	struct list *engines;
 	struct list *queries;
 	int switches;
 	int status;
 };
 
 typedef struct mthread thread_t;
 typedef struct input input_t;
 
 
 thread_t thread[MAX_THREADS];
 
 input_t *data;
 int data_count;
 
 
 void *thread_job( void *ptr );
 void thread_manager();
 void switcher( input_t *path );
 void read_input( FILE *fp );
 void write_output( FILE *fp );
 
 
 void *thread_job( void *ptr ) {
 	
 	int tid = *( ( int * )ptr );
 	
 	thread[tid].status = THREAD_BUSY;
 	
 	switcher( &data[thread[tid].current_block] );
 	
 	thread[tid].status = THREAD_FINISHED;
 	
 }
 
 
 void thread_manager() {
 	
 	int i, j, done;
 	int index[MAX_THREADS];
 	
 	memset( thread, 0, sizeof( thread_t ) * MAX_THREADS );
 	
 	for( i = 0; i < MAX_THREADS; i++ )
 		index[i] = i;
 	
 	while( 1 == 1 ) {
 		for( i = 0; i < MAX_THREADS; i++ ) {
 			if( thread[i].status == THREAD_FREE ) {
 				for( j = 0; j < data_count; j++ ) {
 					if( data[j].status == ST_NOT_STARTED ) {
 						data[j].status = ST_STARTED;
 						thread[i].current_block = j;
 						pthread_create( &thread[i].thr, NULL, thread_job, ( void *)&index[i] );
 						break;
 					}
 				}
 			}
 			if( thread[i].status == THREAD_FINISHED ) {
 				pthread_join( thread[i].thr, NULL );
 				thread[i].status = THREAD_FREE;
 				data[thread[i].current_block].status = ST_DONE;
 			}
 		}
 		done = 0;
 		for( i = 0; i < data_count; i++ )
 			if( data[i].status == ST_DONE )
 				done++;
 		if( done == data_count )
 			break;
 	}
 	
 }
 
 
 /********************************
  *                              *
  *      SWITCHER FUNCTIONS      *
  *                              *
  ********************************/
 
 
 void tie_lists( struct list *engines, struct list *queries ) {
 	
 	int i, all = -1;
 	struct lnode *e_node, *q_node;
 	
 	FOR_LIST( e_node, engines->head, {
 		i = 0;
 		all = -1;
 		FOR_LIST( q_node, queries->head, {
 			all++;
 			if( q_node->ref != NULL ) {
 				if( q_node->ref == e_node ) {
 					i++;
 					if( i == 1 )
 						e_node->distance = all;
 				}
 			} else if( strcmp( e_node->name, q_node->name ) == 0 ) {
 				i++;
 				q_node->ref = e_node;
 				if( i == 1 )
 					e_node->distance = all;
 			}
 		} )
 		e_node->count = i;
 		if( e_node->count == 0 )
 			e_node->distance = MAX_QUERIES + 1;
 	} )
 	
 }
 
 
 struct lnode *get_min_count( struct list *lst, struct lnode *not_allowed ) {
 	
 	struct lnode *node, *min_count;
 	
 	min_count = lst->head;
 	if( min_count == not_allowed )
 		min_count = min_count->next;
 	
 	FOR_LIST( node, lst->head, {
 		if( node == not_allowed )	
 			continue;
 		if( node->distance > min_count->distance )
 			min_count = node;
 	} )
 	
 	return min_count;
 	
 }
 
 
 struct lnode *consume_query( struct list *engines, struct list *queries ) {
 	
 	struct lnode *node, *ret = queries->head->next;
 	
 	delete_from_list( queries, queries->head );
 	
 	tie_lists( engines, queries );
 	
 	return ret;
 	
 }
 
 
 void switcher( input_t *path ) {
 	
 	struct lnode *node, *min, *curr;
 	
 	path->switches = 0;
 	
 	tie_lists( path->engines, path->queries );
 	
 	curr = min = get_min_count( path->engines, NULL );
 	
 	node = path->queries->head;
 	while( node ) {
 		if( node->ref != curr ) {
 			node = consume_query( path->engines, path->queries );
 			continue;
 		}
 		path->switches++;
 		node = consume_query( path->engines, path->queries );
 		curr = get_min_count( path->engines, curr );
 	}
 	
 	destroy( path->engines->head );
 	
 }
 
 
 /************************************
  *                                  *
  *     INPUT / OUTPUT FUNCTIONS     *
  *                                  *
  ************************************/
 
 
 void read_input( FILE *fp ) {
 	
 	int i, j, no;
 	char string[MAX_NAME];
 	
 	fscanf( fp, α%d%*cα, &data_count );
 	
 	/// allocate the memory space
 	data = ( input_t * )malloc( data_count * sizeof( input_t ) );
 	memset( data, 0, data_count * sizeof( input_t ) );
 	
 	/// read the file
 	FOR( i, data_count, {
 		init_list( &data[i].engines );
 		init_list( &data[i].queries );
 		fscanf( fp, α%d%*cα, &no );
 		FOR( j, no, {
 			fscanf( fp, α%100[^n]%*cα, string );
 			add_to_list( data[i].engines, string, NULL );
 		} )
 		fscanf( fp, α%d%*cα, &no );
 		FOR( j, no, {
 			fscanf( fp, α%100[^n]%*cα, string );
 			add_to_list( data[i].queries, string, NULL );
 		} )
 	} )
 	
 }
 
 
 void write_output( FILE *fp ) {
 	
 	int i;
 	struct lnode *node;
 	
 	for( i = 0; i < data_count; i++ ) {
 		fprintf( fp, αCase #%d: %dnα, i + 1, data[i].switches );
 	}
 	
 }
 
 
 /*************************
  *                       *
  *     MAIN FUNCTION     *
  *                       *
  *************************/
 
 
 int main( int argc, char **argv ) {
 	
 	FILE *fin, *fout;
 	int i;
 	
 	/// check the command-line arguments
 	if( argc != 3 ) {
 		printf( αUsage: %s file_in file_outnα, argv[0] );
 		return EXIT_FAILURE;
 	}
 	
 	/// open the input and output files
 	fin = fopen( argv[1], αrα );
 	fout = fopen( argv[2], αwα );
 	if( ( fin == NULL ) || ( fout == NULL ) ) {
 		if( fin == NULL )
 			printf( αCannot open input file...nα );
 		else
 			printf( αCannot open output file...nα );
 		fcloseall();
 		return EXIT_FAILURE;
 	}
 	
 	/// read the input file
 	read_input( fin );
 	
 	/// start the jobs
 	thread_manager();
 	
 	/// write the output
 	write_output( fout );
 	
 	fcloseall();
 	
 	return EXIT_SUCCESS;
 	
 }"
19601,2008,32013,d00rm4n,24481,1,main.c,gcj/2008/32013/d00rm4n/24481/1/extracted/main.c,"#include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
 #include <malloc.h>
 #include <string.h>
 #include <pthread.h>
 #include <ctype.h>
 #include αlist.hα
 
 
 #define FOR( iter, end, statement )          for( iter = 0; iter < end; iter++ ) statement
 #define FOR_LIST( iter, lhead, statement )   for( iter = lhead; iter; iter = ( iter )->next ) statement
 #define MALLOC( type, count )                ( ( type * )malloc( sizeof( type ) * count ) )
 
 
 #define MAX_THREADS       10
 #define THREAD_FREE       0
 #define THREAD_BUSY       1
 #define THREAD_FINISHED   2
 
 #define ST_NOT_STARTED    0
 #define ST_STARTED        1
 #define ST_FINISHED       2
 #define ST_DONE           3
 
 #define MAX_PAUSE         5
 
 #define MINS_IN_DAY       1440
 #define MINS_IN_HOUR      60
 #define HOURS_IN_DAY      24
 
 #define TABLE_SIZE        ( MINS_IN_DAY + MAX_PAUSE )
 
 
 struct mthread {
 	pthread_t thr;
 	int current_block;
 	int status;
 };
 
 struct input {
 	struct list *a_to_b;
 	struct list *b_to_a;
 	unsigned short pause;
 	unsigned short na;
 	unsigned short nb;
 	int status;
 };
 
 struct minute {
 	unsigned int a_dep;
 	unsigned int a_arr;
 	unsigned int b_dep;
 	unsigned int b_arr;
 	unsigned int used;
 };
 
 typedef struct mthread thread_t;
 typedef struct input input_t;
 
 
 thread_t thread[MAX_THREADS];
 
 input_t *data;
 int data_count;
 
 
 void *thread_job( void *ptr );
 void thread_manager();
 void route( input_t *schedule );
 void read_input( FILE *fp );
 void write_output( FILE *fp );
 
 
 void *thread_job( void *ptr ) {
 	
 	int tid = *( ( int * )ptr );
 	
 	thread[tid].status = THREAD_BUSY;
 	
 	route( &data[thread[tid].current_block] );
 	
 	thread[tid].status = THREAD_FINISHED;
 	
 }
 
 
 void thread_manager() {
 	
 	int i, j, done;
 	int index[MAX_THREADS];
 	
 	memset( thread, 0, sizeof( thread_t ) * MAX_THREADS );
 	
 	for( i = 0; i < MAX_THREADS; i++ )
 		index[i] = i;
 	
 	while( 1 == 1 ) {
 		for( i = 0; i < MAX_THREADS; i++ ) {
 			if( thread[i].status == THREAD_FREE ) {
 				for( j = 0; j < data_count; j++ ) {
 					if( data[j].status == ST_NOT_STARTED ) {
 						data[j].status = ST_STARTED;
 						thread[i].current_block = j;
 						pthread_create( &thread[i].thr, NULL, thread_job, ( void *)&index[i] );
 						break;
 					}
 				}
 			}
 			if( thread[i].status == THREAD_FINISHED ) {
 				pthread_join( thread[i].thr, NULL );
 				thread[i].status = THREAD_FREE;
 				data[thread[i].current_block].status = ST_DONE;
 			}
 		}
 		done = 0;
 		for( i = 0; i < data_count; i++ )
 			if( data[i].status == ST_DONE )
 				done++;
 		if( done == data_count )
 			break;
 	}
 	
 }
 
 
 /********************************
  *                              *
  *    TRAIN ROUTE FUNCTIONS     *
  *                              *
  ********************************/
 
 
 void translate_table( input_t *sch, struct minute *tbl ) {
 	
 	struct lnode *node;
 	int hh, mm;
 	
 	FOR_LIST( node, sch->a_to_b->head, {
 		sscanf( node->start, α%02d%*c%02dα, &hh, &mm );
 		tbl[hh * MINS_IN_HOUR + mm].a_dep++;
 		tbl[hh * MINS_IN_HOUR + mm].used = 1;
 		sscanf( node->end, α%02d%*c%02dα, &hh, &mm );
 		tbl[hh * MINS_IN_HOUR + mm + sch->pause].a_arr++;
 		tbl[hh * MINS_IN_HOUR + mm + sch->pause].used = 1;
 	} )
 	
 	FOR_LIST( node, sch->b_to_a->head, {
 		sscanf( node->start, α%02d%*c%02dα, &hh, &mm );
 		tbl[hh * MINS_IN_HOUR + mm].b_dep++;
 		tbl[hh * MINS_IN_HOUR + mm].used = 1;
 		sscanf( node->end, α%02d%*c%02dα, &hh, &mm );
 		tbl[hh * MINS_IN_HOUR + mm + sch->pause].b_arr++;
 		tbl[hh * MINS_IN_HOUR + mm + sch->pause].used = 1;
 	} )
 	
 	destroy( sch->a_to_b->head );
 	destroy( sch->b_to_a->head );
 	
 }
 
 
 void route( input_t *schedule ) {
 	
 	int i, trains_in_a = 0, trains_in_b = 0;
 	struct minute table[TABLE_SIZE];
 	
 	memset( table, 0, sizeof( struct minute ) * TABLE_SIZE );
 	schedule->na = schedule->nb = 0;
 	
 	translate_table( schedule, table );
 	
 	FOR( i, TABLE_SIZE, {
 		if( table[i].used == 0 )
 			continue;
 		/// trains leaving A
 		if( table[i].a_dep > 0 ) {
 			if( table[i].b_arr > 0 )
 				trains_in_a += table[i].b_arr;
 			if( table[i].a_dep > trains_in_a ) {
 				schedule->na += table[i].a_dep - trains_in_a;
 				trains_in_a = table[i].a_dep;
 			}
 			trains_in_a -= table[i].a_dep;
 		}
 		/// trains coming to B
 		if( table[i].a_arr > 0 ) {
 			trains_in_b += table[i].a_arr;
 		}
 		/// trains leaving B
 		if( table[i].b_dep > 0 ) {
 			if( table[i].b_dep > trains_in_b ) {
 				schedule->nb += table[i].b_dep - trains_in_b;
 				trains_in_b = table[i].b_dep;
 			}
 			trains_in_b -= table[i].b_dep;
 		}
 		/// trains coming to A
 		if( table[i].b_arr > 0 ) {
 			if( table[i].a_dep == 0 )
 				trains_in_a += table[i].b_arr;
 		}
 	} )
 	
 }
 
 
 /************************************
  *                                  *
  *     INPUT / OUTPUT FUNCTIONS     *
  *                                  *
  ************************************/
 
 
 void read_input( FILE *fp ) {
 	
 	int i, j, no_a, no_b;
 	char dep[MAX_DIST], arr[MAX_DIST];
 	
 	fscanf( fp, α%d%*cα, &data_count );
 	
 	/// allocate the memory space
 	data = ( input_t * )malloc( data_count * sizeof( input_t ) );
 	memset( data, 0, data_count * sizeof( input_t ) );
 	
 	/// read the file
 	FOR( i, data_count, {
 		init_list( &data[i].a_to_b );
 		init_list( &data[i].b_to_a );
 		fscanf( fp, α%d%*cα, &data[i].pause );
 		fscanf( fp, α%d%*c%d%*cα, &no_a, &no_b );
 		FOR( j, no_a, {
 			fscanf( fp, α%s%*c%s%*cα, dep, arr );
 			add_to_list( data[i].a_to_b, dep, arr, NULL );
 		} )
 		FOR( j, no_b, {
 			fscanf( fp, α%s%*c%s%*cα, dep, arr );
 			add_to_list( data[i].b_to_a, dep, arr, NULL );
 		} )
 	} )
 	
 }
 
 
 void write_output( FILE *fp ) {
 	
 	int i;
 	
 	for( i = 0; i < data_count; i++ ) {
 		fprintf( fp, αCase #%d: %d %dnα, i + 1, data[i].na, data[i].nb );
 	}
 	
 }
 
 
 /*************************
  *                       *
  *     MAIN FUNCTION     *
  *                       *
  *************************/
 
 
 int main( int argc, char **argv ) {
 	
 	FILE *fin, *fout;
 	int i;
 	
 	/// check the command-line arguments
 	if( argc != 3 ) {
 		printf( αUsage: %s file_in file_outnα, argv[0] );
 		return EXIT_FAILURE;
 	}
 	
 	/// open the input and output files
 	fin = fopen( argv[1], αrα );
 	fout = fopen( argv[2], αwα );
 	if( ( fin == NULL ) || ( fout == NULL ) ) {
 		if( fin == NULL )
 			printf( αCannot open input file...nα );
 		else
 			printf( αCannot open output file...nα );
 		fcloseall();
 		return EXIT_FAILURE;
 	}
 	
 	/// read the input file
 	read_input( fin );
 	
 	/// start the jobs
 	thread_manager();
 	
 	/// write the output
 	write_output( fout );
 	
 	fcloseall();
 	
 	free( data );
 	
 	return EXIT_SUCCESS;
 	
 }"
19689,2008,32013,rodbrambilla,24480,1,Teste02.c,gcj/2008/32013/rodbrambilla/24480/1/extracted/Teste02.c,"#include <stdio.h>
 #include <string.h>
 int main ()
 {
     FILE *arqent, *arqsai;
     char strlista[101][100];
     char strval[1001][100];
     int wpos, contador, a, b, c, wposatu, h, nocor, nbuscador, nlista, x, wposreg, wposant;  
     arqsai = fopen (αA-large.outα, αwα);
     arqent = fopen (αA-large.inα, αrα);
     fscanf(arqent, α%dα, &nocor);
     printf(αnocor - %dnα, nocor); 
     for (a=1; a <= nocor; a++)
     {
         fscanf(arqent, α%dα, &nbuscador);
         printf(αnbuscador - %dnα, nbuscador); 
         for (b=0; b <= nbuscador; b++ )
         {
             fgets (strlista[b], 100, arqent);
             printf(αEntrada - %snα, strlista[b]); 
         }
         fscanf(arqent, α%dα, &nlista);
         printf(αnlista - %dnα, nlista); 
         for (c=0; c <= nlista; c++ )
         {
             fgets (strval[c], 100, arqent);
             printf(αLista - %snα, strval[c]);
         }
         fprintf(arqsai, αCase #%d: α,a);
         contador=0;
         if (nlista>0)
         {   
            for (wpos=1; wpos<nlista;)  
            {
                wposant=0;
                for (b=1; b <= nbuscador; b++)
                {
                    c=wpos; 
                    while (c <= nlista)
                    {
                       /* printf(αBuscador = %snα, strlista[b]); 
                        printf(αString = %snα, strval[c]); 
                        printf(αc = %dnα, c); 
                        printf(αb = %dnα, b); 
                        printf(αwposreg = %dnα, wposreg); */
                        if (strcmp(strlista[b],strval[c])==0)
                        {
                           wposreg=c;
                           c=nlista+1;
                        }    
                        else
                        {  
                           if (c==nlista)
                           {
                              wposreg=nlista+1;
                              c=nlista+1;
                           }
                           else
                           {  
                              c++;
                           }    
                        }
                        printf(αc = %dnα, c); 
                        printf(αwposreg = %dnα, wposreg); 
                    }        
                if (wposreg > wposant)
                   wposatu=wposreg;
                else
                   wposatu=wposant; 
                wposant=wposatu;
                wposreg=0;
                }             
                wpos=wposatu;
                contador++;
                printf(αContador - %dnα, contador); 
            }
            if (wposatu==nlista)
                fprintf(arqsai, α%dnα,contador);
            else
                fprintf(arqsai, α%dnα,contador-1);
         }
         else
            fprintf(arqsai, α%dnα,contador);
     }    
     fclose(arqent);
     fclose(arqsai);
     system(αpauseα);
     return(0);
 }"
19740,2008,32013,jchen,24480,1,SavingTheUniverse.c,gcj/2008/32013/jchen/24480/1/extracted/SavingTheUniverse.c,"#include <stdio.h>
 #include <string.h>
 
 char engines[100][256];
 char tables[100];
 char line[100];
 char query[256];
 
 int N,S,Q;
 
 void initTables()
 {
 	int j;
 	for(j=0;j<S;j++)
 		tables[j]= 1;
 }
 
 char full()
 {
 	int j;
 	for(j=0;j<S;j++)
 		if(tables[j])return 0;
 	return 1;
 }
 
 int main(void)
 {
 	int index;
 	int i,j,result;
 	scanf(α%dnα, &N);
 	for(index=1;index<=N;index++)
 	{
 		scanf(α%dnα, &S);
 		for(i=0;i<S;i++)
 			gets(engines[i]);
 		scanf(α%dnα, &Q);
 		result= 0;
 		initTables();
 		for(i=0;i<Q;i++)
 		{
 			gets(query);
 			for(j=0;j<S;j++)
 				if(strcmp(query, engines[j])==0)break;
 			tables[j]= 0;
 			
 			if(full())
 			{
 				initTables();
 				tables[j]= 0;
 				result++;
 			}
 		}
 			
 		printf(αCase #%d: %dnα,index, result);
 	}
 	
 	return 0;
 }"
19742,2008,32013,jchen,24481,1,TrainTimetable.c,gcj/2008/32013/jchen/24481/1/extracted/TrainTimetable.c,"#include <stdio.h>
 
 typedef struct
 {
 	int hour;
 	int min;
 }CT;
 
 CT aout[100], bout[100], aready[100], bready[100];
 char ar[100], br[100];
 
 int N,NA,NB,T;
 
 char before(CT c1, CT c2)
 {
 	return (c1.hour<c2.hour)||((c1.hour==c2.hour)&&(c1.min<=c2.min));
 }
 
 void sort(CT c[], int n)
 {
 	int i,j;
 	int buf;
 	for(i=0;i<n-1;i++)
 		for(j=i+1;j<n;j++)
 		{
 			if(before(c[j],c[i]))
 			{
 				buf= c[j].hour;
 				c[j].hour= c[i].hour;
 				c[i].hour= buf;
 				buf= c[j].min;
 				c[j].min= c[i].min;
 				c[i].min= buf;
 			}
 		}
 }
 
 int main(void)
 {
 	int index;
 	int i,j,ca, cb;
 	scanf(α%dnα, &N);
 	for(index=1;index<=N;index++)
 	{
 		scanf(α%dnα, &T);
 		scanf(α%d %dnα, &NA, &NB);
 		for(i=0;i<NA;i++)
 		{
 			scanf(α%d:%d %d:%dnα, &aout[i].hour, &aout[i].min, &aready[i].hour, &aready[i].min);
 			aready[i].min+=T;
 			if(aready[i].min>59)
 			{
 				aready[i].hour++;
 				aready[i].min-=60;
 			}
 		}
 		sort(aout, NA);
 		sort(aready, NA);
 		for(i=0;i<NB;i++)
 		{
 			scanf(α%d:%d %d:%dnα, &bout[i].hour, &bout[i].min, &bready[i].hour, &bready[i].min);
 			bready[i].min+=T;
 			if(bready[i].min>59)
 			{
 				bready[i].hour++;
 				bready[i].min-=60;
 			}
 		}
 		sort(bout, NB);
 		sort(bready, NB);
 		ca= cb= 0;
 		for(i=0;i<NA;i++)
 			ar[i]= 1;
 		for(i=0;i<NB;i++)
 			br[i]= 1;
 		
 		for(i=0;i<NA;i++)
 		{
 			for(j=0;j<NB;j++)
 				if(br[j] && before(bready[j], aout[i]))
 				{
 					br[j]= 0;
 					break;
 				}
 			if(j==NB)ca++;
 		}
 		
 		for(i=0;i<NB;i++)
 		{
 			for(j=0;j<NA;j++)
 				if(ar[j] && before(aready[j], bout[i]))
 				{
 					ar[j]= 0;
 					break;
 				}
 			if(j==NA)cb++;
 		}
 		
 			
 		printf(αCase #%d: %d %dnα,index, ca, cb);
 	}
 	
 	return 0;
 }"
19749,2008,32013,LatinMax,24480,1,main.c,gcj/2008/32013/LatinMax/24480/1/extracted/main.c,"#include <stdio.h>
 #include <string.h>
 #include <malloc.h>
 #include <stdlib.h>
 
 
 //#define argv[1] αA.inα
 #define ARCHIVO_SALIDA αA.outα
 
 
 
 int main(int argc, char *argv[]){
 
 	FILE *archivo;
 	FILE *archivo2;
 	char linea[250];
 	char* motores[100];
 	char* consultas[1000];
 	int distanciaMotor[100];
 	int cantCasos, cantConsultas, cantMotores;
 	int k, i, j, PRIMERO, cantCambiosBuscador;
 
 	if ((archivo=fopen(argv[1],αrα))==NULL){
 		printf(αERROR FATAL [1]. No se pudo abrir el archivo de entrada de datos α%sαnα,argv[1]);
 		exit(1);
 	}
 	else {
 		printf(αArchivo de datos de entrada abierto correctamente [α%sα]nα,argv[1]);
 	}
 	
 	if ((archivo2=fopen(ARCHIVO_SALIDA,αwα))==NULL){
 		printf(αERROR FATAL [1]. No se pudo abrir el archivo de salida de datos α%sαnα,ARCHIVO_SALIDA);
 		exit(1);
 	}
 	else {
 		printf(αArchivo de datos de salida abierto correctamente [α%sα]nα,ARCHIVO_SALIDA);
 	}
 
 	fgets (linea, 250, archivo);
 	cantCasos=atoi(linea);
 	printf (αLa cantidad de casos es %i nα, cantCasos);
 	printf(α-----------------Salida al archivo A.out------------------nα);
 
 	for (k=0;k<cantCasos;k++){
 	
 		//leo los motores de busqueda
 		fgets (linea, 250, archivo);
 		cantMotores = atoi(linea);
 		for (i=0;i<cantMotores;i++) {
 			fgets (linea, 250, archivo);
 			motores[i] = (char*)malloc(sizeof(char)*(strlen(linea)+1));
 			strcpy(motores[i], linea);
 		}
 		
 		//leo las consultas
 		fgets (linea, 250, archivo);
 		cantConsultas = atoi(linea);
 		for (i=0;i<cantConsultas;i++) {
 			fgets (linea, 250, archivo);
 			consultas[i] = (char*)malloc(sizeof(char)*(strlen(linea)+1));
 			strcpy(consultas[i], linea);
 		}
 		
 		PRIMERO=0;
 		cantCambiosBuscador=0;
 		
 		while (PRIMERO<cantConsultas) {
 			// guarda en distanciaMotor las distancias al motor mas proximo en la lista de consultas
 			for (i=0;i<cantMotores;i++) {
 				j=PRIMERO;
 				while ((j<cantConsultas) && strcmp(consultas[j],motores[i])) {
 					//printf(αValor j-(%i)nα,j);
 					//printf(α%s-%s-(%i)nnα,consultas[j],motores[i],strcmp(motores[i],consultas[j]));
 						j++;
 				} 
 				distanciaMotor[i]=j;
 			}
 			
 			for (i=0;i<cantMotores;i++) {
 				//printf(αdistanciaMotor[%i]=%inα,i,distanciaMotor[i]);
 			}
 
 			//obtengo en j el indice del motor mas lejano en la lista de consultas
 			j=0;
 			for (i=0;i<cantMotores;i++) {
 				if (distanciaMotor[j]<distanciaMotor[i]) {
 					j=i;
 				}
 			}
 			
 			PRIMERO=distanciaMotor[j];
 			
 			if (PRIMERO<cantConsultas) cantCambiosBuscador++;
 			//printf(αPRIMERO=%in----------------------------------nα,PRIMERO);
 
 			
 		}
 		
 		printf(αCase #%i: %inα,k+1,cantCambiosBuscador);
 		fprintf(archivo2,αCase #%i: %inα,k+1,cantCambiosBuscador);
 		
 	}
 	
 
 
 	if (fclose(archivo)!=0){
 		printf(αERROR DE CIERRE [2]. No se pudo cerrar el archivo de entrada de datos α%sαnα,argv[1]);
 	}
 	
 	if (fclose(archivo2)!=0){
 		printf(αERROR DE CIERRE [3]. No se pudo cerrar el archivo de salida de datos α%sαnα,αA.outα);
 	}
 	else {
 		printf(α---------------FIN EJECUCION---------------nα);
 	}
 
 	return 0;
 }"
19785,2008,32013,Bond007,24481,1,B.C,gcj/2008/32013/Bond007/24481/1/extracted/B.C,"#include<stdio.h>
 #include<conio.h>
 #include<alloc.h>
 
 struct table
 {
 int depth,deptm;
 int arrth,arrtm;
 int ava,flag;
 };
 
 int comp(struct table,struct table);
 
 void main()
 {
  int i,j,k,l,n;
  int na,nb,t;
  int h,m,noa,nob,no;
  char c;
  struct table tshed[300];
  struct table tra[450];
  struct table temp;
 
  FILE *fp,*fp1;
  clrscr();
  fp=fopen(αsmallt2.txtα,αrα);
  fscanf(fp,α%dα,&n);
  printf(α%dnα,n);
  fp1=fopen(αsmall2op.txtα,αwα);
  for(i=0;i<n;i++)
  {
   noa=0;
   nob=0;
   no=0;
   fscanf(fp,α%d %d %dα,&t,&na,&nb);
  // printf(αNA=%d  NB=%d  t=%dα,na,nb,t);
   //tshed=(struct table *)malloc(sizeof(struct table)*(na+nb));
   for(j=0;j<na+nb;j++)
   {
    fscanf(fp,α%d%c%dα,&temp.depth,&c,&temp.deptm);
    fscanf(fp,α %d%c%dα,&temp.arrth,&c,&temp.arrtm);
    if(j<na)
    temp.flag=0;
    else
    temp.flag=1;
    //printf(αnDeparture time %d%c%d  -  Arrival time %d%c%dnα
    //,temp.depth,c,temp.deptm,temp.arrth,c,temp.arrtm);
    //getch();
    if(j==0)
    tshed[j]=temp;
    else
    {
     for(k=0;k<j;k++)
     {
       if(comp(temp,tshed[k])==1)
       {
 	for(l=j;l>k;l--)
 	tshed[l]=tshed[l-1];
 	break;
       }
     }
     tshed[k]=temp;
   }
  }
 
   for(j=0;j<na+nb;j++)
   {
    for(k=0;k<no;k++)
    {
      if(tra[k].flag==tshed[j].flag)
      {
       if(comp(tra[k],tshed[j])==1)
       {
 	 if(tshed[j].arrtm+t>=60)
 	 {
 	   tra[k].depth=tshed[j].arrth+1;
 	   tra[k].deptm=tshed[j].arrtm+t-60;
 	 }
 	  else
 	  {
 	   tra[k].depth=tshed[j].arrth;
 	   tra[k].deptm=tshed[j].arrtm+t;
 	  }
 	  tra[k].arrth=tshed[j].depth;
 	  tra[k].arrtm=tshed[j].deptm;
 	  if(tra[k].flag==0)
 	      tra[k].flag=1;
 	   else
 	    tra[k].flag=0;
 	  break;
       }
 
 
      }
    }
    if(k==no)
    {
       if(tshed[j].arrtm+t>=60)
        {
 	tra[no].depth=tshed[j].arrth+1;
 	tra[no].deptm=tshed[j].arrtm+t-60;
 	}
        else
        {
 	tra[no].depth=tshed[j].arrth;
 	tra[no].deptm=tshed[j].arrtm+t;
        }
       if(tshed[j].flag==0)
       {
        tra[no].arrth=tshed[j].depth;
        tra[no].arrtm=tshed[j].deptm;
        tra[no].flag=1;
        noa++;
        no++;
       }
       else
       {
       tra[no].arrth=tshed[j].depth;
       tra[no].arrtm=tshed[j].deptm;
       tra[no].flag=0;
       no++;
       nob++;
      }
    }
 
   }
   //////////////////////////
 // printf(αnn no of trains from A : %dα,noa);
 // printf(αnn no of trains from B : %dα,nob);
  fprintf(fp1,αCase #%d: %d %dnα,i+1,noa,nob);
 // getch();
  //clrscr();
  }
  fclose(fp);
  fclose(fp1);
 }
 
 int comp(struct table temp1,struct table temp2)
 {
 int flag=0;
 if(temp1.depth<temp2.depth)
 flag=1;
 else if(temp1.depth==temp2.depth)
 {
  if(temp1.deptm<=temp2.deptm)
  flag=1;
  /*else if(temp1.deptm==temp2.deptm)
  {
    if(temp1.flag==0)
    flag=1;
  } */
 }
 return flag;
 }"
19845,2008,32013,alex.gartrell,24480,1,searchEngine2.c,gcj/2008/32013/alex.gartrell/24480/1/extracted/searchEngine2.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int minNumSwitches();
 
 int numCases;
 int curNumEngines;
 int curNumQueries;
 char engines[100][101];
 char queries[1000][101];
 
 int res[100][1000];
 
 
 int main(int argc, char **argv)
 {
 	FILE *f;
 	int t;
 	char buffer[256];
 	char *s;
 	int i, j;
 	
 	if(argc < 2)
 	{
 		fprintf(stderr, αNeeds an argumentnα);
 		exit(1);
 	}
 
 	if((f = fopen(argv[1], αrα)) == NULL)
 	{
 		fprintf(stderr, αFile doesn't existnα);
 		exit(2);
 	}
 
 	fgets(buffer, 256, f);
 	sscanf(buffer, α%dα, &numCases);
 
 
 	for(i = 0; i < numCases; i++)
 	{
 		fgets(buffer, 256, f);
 		sscanf(buffer, α%dα, &curNumEngines);
 		
 		for(j = 0; j < curNumEngines; j++)
 		{
 			fgets(engines[j], 101, f);
 			if((s = strchr(engines[j], 'n')))
 				*s = '0';
 		}
 
 		fgets(buffer, 256, f);
 		sscanf(buffer, α%dα, &curNumQueries);
 		
 		for(j = 0; j < curNumQueries; j++)
 		{
 			fgets(queries[j], 101, f);
 			if((s = strchr(queries[j], 'n')))
 				*s = '0';
 		}
 
 		printf(αCase #%d: %dnα, i + 1, (t = minNumSwitches()));
 	fprintf(stderr, αCase #%d: %dnα, i + 1, t);
 	}
 
 	return 0;
 }
 
 int minNumSwitches()
 {
 	int q, e, prevMin, curMin;
 
 	if(curNumQueries <= 1) return 0;
 
 	q = curNumQueries - 1;
 
 	for(e = 0; e < curNumEngines; e++)
 	{
 		if(strcmp(engines[e], queries[q]) == 0)
 			res[e][q] = -1;
 		else
 			res[e][q] = 0;
 	}
 
 	prevMin = 0;
 	curMin = -1;
 
 	for(q = curNumQueries - 2; q >= 0; q--)
 	{
 		curMin = -1;
 		for(e = 0; e < curNumEngines; e++)
 		{
 			if(strcmp(engines[e], queries[q]) == 0)
 				res[e][q] = -1;
 			else
 			{
 				if(res[e][q + 1] == -1)
 					res[e][q] = prevMin + 1;
 				else
 					res[e][q] = res[e][q + 1];
 
 				if(res[e][q] < curMin || curMin == -1)
 					curMin = res[e][q];
 			}
 
 		}
 		prevMin = curMin;
 	}
 
 	return prevMin;
 }"
20057,2008,32013,Trinadha,24480,1,TEST1.C,gcj/2008/32013/Trinadha/24480/1/extracted/TEST1.C,"#include<stdio.h>
 #include<conio.h>
 struct engine
 {
  char name[102];
  int set;
 }s[100];
 void main()
 {
  FILE *fp,*fp1;
  int count=0;
  int noq;
  int nosw=0;
  int not;//not--no of testcases
  int nos;//nos--no of search engines
  int rem;
  int i,j,k,z;
  char q[102];
  clrscr();
  fp=fopen(αinput.txtα,αrα);
  fp1=fopen(αoutput.txtα,αwα);
  fscanf(fp,α%dα,&not);
  fp->curp++;
  for(z=0;z<not;z++)
  {
   fscanf(fp,α%dα,&nos);
   fgetc(fp);
   for(i=0;i<nos;i++)
   {
    fgets(s[i].name,101,fp);
    s[i].name[strlen(s[i].name)-1]='0';
   }
   fscanf(fp,α%dα,&noq);
   fgetc(fp);
   for(j=0;j<noq;j++)
   {
    fgets(q,101,fp);
    q[strlen(q)-1]='0';
    for(i=0;i<nos;i++)
    {
     if(!strcmp(q,s[i].name))
     {
      if(s[i].set==0)
      {
 
       count++;
       if(count==nos)
       {
        nosw++;
        for(k=0;k<nos;k++)
 	s[k].set=0;
        count=1;
       }
       s[i].set=1;
      }
      break;
     }
    }
   }
   for(i=0;i<nos;i++)
    s[i].set=0;
   count=0;
   fprintf(fp1,αCase #%d: %dnα,z+1,nosw);
   printf(αnCase #: %dα,nosw);
   nosw=0;
  }
  getch();
  fclose(fp);
 }"
20059,2008,32013,Trinadha,24481,1,TEST2.C,gcj/2008/32013/Trinadha/24481/1/extracted/TEST2.C,"#include<stdio.h>
 #include<conio.h>
 void mergesort(int*,int,int);
 void merge(int*,int,int,int);
 void main()
 {
  FILE *fp,*fp1;
  int aarr[100],adep[100],barr[100],bdep[100];
  int i,j,k,z;
  int not;
  int nota,notb,notra,notrb;
  int temp;
  int NA,NB;
  int tat;
  char q[102];
  clrscr();
  fp=fopen(αinput.txtα,αrα);
  fp1=fopen(αoutput.txtα,αwα);
  fscanf(fp,α%dα,&not);
  fgetc(fp);
  for(z=0;z<not;z++)
  {
   fscanf(fp,α%dα,&tat);
   fgetc(fp);
   fscanf(fp,α%dα,&NA);
   fgetc(fp);
   fscanf(fp,α%dα,&NB);
   fgetc(fp);
   for(i=0;i<NA;i++)
   {
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    adep[i]=temp*60;
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    adep[i]+=temp;
 
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    barr[i]=temp*60;
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    barr[i]+=temp;
   }
   for(i=0;i<NB;i++)
   {
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    bdep[i]=temp*60;
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    bdep[i]+=temp;
 
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    aarr[i]=temp*60;
    fscanf(fp,α%dα,&temp);
    fgetc(fp);
    aarr[i]+=temp;
   }
   mergesort(adep,0,NA-1);
   mergesort(aarr,0,NB-1);
   mergesort(bdep,0,NB-1);
   mergesort(barr,0,NA-1);
   nota=0;
   notra=0;
   i=j=0;
   while(1)
   {
    if(i==NB || j==NA)
     break;
    if((aarr[i]+tat)<adep[j])
    { nota++;i++;}
    else
     if((aarr[i]+tat)==adep[j])
     {i++;j++;}
     else
      {if(nota==0)notra++;else nota--;j++;}
   }
   if(i==NB)
   notra+=(nota>(NA-j)?0:(NA-j-nota));
 
   notb=0;
   notrb=0;
   i=j=0;
 
   while(1)
   {
    if(i==NA || j==NB)
     break;
    if((barr[i]+tat)<bdep[j])
    { notb++;i++;}
    else
     if((barr[i]+tat)==bdep[j])
     {i++;j++;}
     else
      {if(notb==0)notrb++;else notb--;j++;}
   }
   if(i==NA)
   notrb+=(notb>(NB-j)?0:(NB-j-notb));
   fprintf(fp1,αCase #%d: %d %dnα,z+1,notra,notrb);
 
  }
  getch();
  fclose(fp);
  fclose(fp1);
 }
 void mergesort(int a[],int start,int end)
 {
  int mid;
  if(start>=end)
   return;
  mid=(start+end)/2;
  mergesort(a,start,mid);
  mergesort(a,mid+1,end);
  merge(a,start,mid,end);
 }
 void merge(int a[],int start,int mid,int end)
 {
  int b[100],k,i,j;
  for(i=start,j=mid+1,k=0;i<=mid && j<=end;k++)
  {
   if(a[i]<a[j])
    b[k]=a[i++];
   else
    b[k]=a[j++];
  }
  if(i==(mid+1))
   for(;j<=end;j++,k++)
    b[k]=a[j];
  else
   for(;i<=mid;i++,k++)
    b[k]=a[i];
  for(k=start;k<=end;k++)
   a[k]=b[k-start];
 }"
20089,2008,32013,beta.C,24481,1,train.c,gcj/2008/32013/beta.C/24481/1/extracted/train.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 void main()
 {
 	FILE* fIn,*fOut;
 	int NA,NB,arrA[100],depA[100],arrB[100],depB[100];
 	char temp[5],tempa[3],tempb[3];
 	int hr,min,trainA,trainB,i,j,T,N,l,trainAno[100],trainBno[100],jstore,mingap,gap[100];
 
 	fIn = fopen(αinput.txtα,αrbα);
 	fOut = fopen(αoutput.txtα,αwbα);
 	fscanf(fIn,α%dα,&N);
 	for(l=1;l<=N;l++)
 	{
 		for(i=0;i<100;i++)
 		{ 
 			trainAno[i] = 0;
 			trainBno[i] = 0;
 		}
 		fscanf(fIn,α%dα,&T);
 		fscanf(fIn,α%dα,&NA);
 		fscanf(fIn,α%dα,&NB);
 		trainA = NA;
 		trainB = NB;
 		for(i=0;i<NA;i++)
 		{
 			fscanf(fIn,α%sα,temp);
 			tempa[0] = temp[0];
 			tempa[1] = temp[1];
 			tempa[2] = '0';
 			tempb[0] = temp[3];
 			tempb[1] = temp[4];
 			tempb[2] = '0';
 
 			hr = atoi(tempa);
 			min = atoi(tempb);
 
 			depA[i] = hr*60 + min;		
 			
 			fscanf(fIn,α%sα,temp);
 
 			tempa[0] = temp[0];
 			tempa[1] = temp[1];
 			tempa[2] = '0';
 			tempb[0] = temp[3];
 			tempb[1] = temp[4];
 			tempb[2] = '0';
 
 			hr = atoi(tempa);
 			min = atoi(tempb);
 			arrA[i] = hr*60 + min;	
 		}
 
 		for(i=0;i<NB;i++)
 		{
 			fscanf(fIn,α%sα,temp);
 			tempa[0] = temp[0];
 			tempa[1] = temp[1];
 			tempa[2] = '0';
 			tempb[0] = temp[3];
 			tempb[1] = temp[4];
 			tempb[2] = '0';
 
 			hr = atoi(tempa);
 			min = atoi(tempb);
 			depB[i] = hr*60 + min;		
 			
 			fscanf(fIn,α%sα,temp);
 			tempa[0] = temp[0];
 			tempa[1] = temp[1];
 			tempa[2] = '0';
 			tempb[0] = temp[3];
 			tempb[1] = temp[4];
 			tempb[2] = '0';
 
 			hr = atoi(tempa);
 			min = atoi(tempb);
 			arrB[i] = hr*60 + min;	
 		}
 		
 		for(i=0;i<NA;i++)
 		{
 			mingap = 24*60;
 			jstore = -1;
 
 			for(j=0;j<NB;j++)
 			{
 				gap[j] = (depB[j]-arrA[i]);
 				if(gap[j]>=T)
 				{	
 					if(gap[j] < mingap && trainBno[j] != 1)
 					{
 						jstore = j;
 						mingap = gap[j];
 					}
 				}
 			}
 			if(jstore>-1)
 				trainBno[jstore] = 1;
 		}
 		for(j=0;j<NB;j++)
 		{
 			trainB -= trainBno[j];
 		}
 		for(i=0;i<NB;i++)
 		{
 			mingap = 24*60;
 			jstore = -1;
 
 			for(j=0;j<NA;j++)
 			{
 				gap[j] = (depA[j]-arrB[i]);
 				if(gap[j]>=T)
 				{	
 					if(gap[j] < mingap  && trainAno[j] != 1)
 					{
 						jstore = j;
 						mingap = gap[j];
 					}
 				}
 			}
 			if(jstore>-1)
 				trainAno[jstore] = 1;
 		}
 		for(j=0;j<NA;j++)
 		{
 			trainA -= trainAno[j];
 		}
 
 
 		fprintf(fOut,αCase #%d: %d %dnα,l,trainA,trainB);
 	}
 	fclose(fIn);
 	fclose(fOut);
 }"
20127,2008,32013,Marco,24480,1,code.c,gcj/2008/32013/Marco/24480/1/extracted/code.c,"#include <stdio.h>
 
 int main(){
   char c;
   int n, i, j, ns, nq, melhor, p;
   int dini, dini2, switches;
   int s[100], q[1000];
   scanf(α%dα, &n);
   for(i=0;i<n;i++){
     scanf(α%dα, &ns);
     c=getchar();
     for(j=0;j<ns;j++){
       s[j]=0;
       p=1;
       while((c=getchar())!='n'){
 	s[j]=s[j]+(c*c)*(p++);
       }
     }
     scanf(α%dα, &nq);
     c=getchar();
     for(j=0;j<nq;j++){
       q[j]=0;
       p=1;
       while((c=getchar())!='n'){
 	q[j]=q[j]+(c*c)*(p++);
       }
     }
 
 
     for(dini=0, switches=0; dini<nq; switches++){
       melhor=-1;
       for(j=0, dini2=dini;j<ns && dini2<nq; j++, dini2=dini){
 	if(s[j]==q[dini2]) continue;
 	while(s[j]!=q[dini2] && dini2<nq) dini2++;
 	if(melhor==-1) melhor=dini2;
 	if(melhor<dini2) melhor=dini2;
       }
       dini=melhor;
     }
 
     if(switches==0) switches++;
     printf(αCase #%d: %dnα, i+1, switches-1);
   }
   return 0;
 }"
20129,2008,32013,Marco,24481,1,train.c,gcj/2008/32013/Marco/24481/1/extracted/train.c,"#include <stdio.h>
 
 void ordena(int horario[100], int n){
   int i, j, t;
   for(i=n;i>0;i--){
     for(j=1;j<i;j++){
       if(horario[j-1]>horario[j]){
 	t=horario[j-1];
 	horario[j-1]=horario[j];
 	horario[j]=t;
       }
     }
   }
 }
 
 int menor_rec(int v1, int v2){
   if(v1==-1) return v2;
   if(v2==-1) return v1;
   if(v1<v2) return v1;
   else return v2;
 }
 
 int menor(int v1, int v2, int v3, int v4){
   int x;
   x=menor_rec(menor_rec(v1, v2), menor_rec(v3, v4));
   if(x==-1) return 5;
   if(x==v2) return 2;
   if(x==v4) return 4;
   if(x==v1) return 1;
   if(x==v3) return 3;
 }
 
 int main(){
   int n, i, chega_a[101], sai_a[101], chega_b[101], sai_b[101], p;
   int hora, min, tempo, na, nb, tot_a, tot_b, as, ac, bs, bc, ema, emb;
   scanf(α%dα, &n);
   for(i=0;i<n;i++){
     scanf(α%dα, &tempo);
     scanf(α%d %dα, &na, &nb);
     for(p=0;p<na;p++){
       scanf(α%d:%dα, &hora, &min);
       sai_a[p]=hora*60+min;
       scanf(α%d:%dα, &hora, &min);
       chega_b[p]=hora*60+min+tempo;
     }
     sai_a[p]=-1;
     chega_b[p]=-1;
     ordena(sai_a, na);
     ordena(chega_b, na);
     for(p=0;p<nb;p++){
       scanf(α%d:%dα, &hora, &min);
       sai_b[p]=hora*60+min;
       scanf(α%d:%dα, &hora, &min);
       chega_a[p]=hora*60+min+tempo;
     }
     sai_b[p]=-1;
     chega_a[p]=-1;
     ordena(sai_b, nb);
     ordena(chega_a, nb);
     
     tot_a=tot_b=as=ac=bs=bc=ema=emb=0;
     p=1;
     while(p){
       tempo=menor(sai_a[as], chega_b[bc], sai_b[bs], chega_a[ac]);
       switch (tempo){
       case 1:
 	//SAI DE A
 	if(ema==0) {ema++; tot_a++;}
 	ema--;
 	as++;
 	//if(as==na) sai_a[as]=-1;
 	break;
       case 2:
 	//CHEGA EM B
 	emb++;
 	bc++;
 	//if(bc==na) chega_b[bc]=-1;
 	break;
       case 3:
 	//SAI DE B
 	if(emb==0) {emb++; tot_b++;}
 	emb--;
 	bs++;
 	//if(bs==nb) sai_b[bs]=-1;
 	break;
       case 4:
 	//CHEGA EM A
 	ema++;
 	ac++;
 	//if(ac==nb) chega_a[ac]=-1;
 	break;
       case 5:
 	//TODOS COM -1
 	p=0;
       }
     }
     printf(αCase #%d: %d %dnα, i+1, tot_a, tot_b);
   }
   return 0;
 }"
20169,2008,32013,chansarav2020,24480,1,SEARCHEN.C,gcj/2008/32013/chansarav2020/24480/1/extracted/SEARCHEN.C,"/* PROGRAM TO FIND THE MINIMUN NUMBER OF SWITHCES NEEDED FOR A CENTRAL SYSTEM
    TO DIRECT SET OF QUERIES ACROSS DIFFERENT SEARCH ENGINES*/
 #include<stdio.h>
 #include<string.h>
 void main()
 {
  FILE *fip,*fop;
  int nocase,nosearcheng,noquery,caseread=0,searchread=0,queryread=0,noswitch[21],cfoundflag=1,matchfound=0,foundflag[101],startmatchindex=0;
  char searcheng[101][101],newlinec,*ifilename,query[101],*ofilename;
  printf(αenter the input filename along with path and extensionnα);
  scanf(α%sα,ifilename);
  printf(αenter the output filename along with path and extensionnα);
  scanf(α%sα,ofilename);
  fip=fopen(ifilename,αrα);
  fop=fopen(ofilename,αwα);
  if(fip==NULL)
   printf(αInput file is not openingα);
  else  if(fop==NULL)
   printf(αOutput file is not openingα);
  else
  {
   fscanf(fip,α%dα,&nocase);
   printf(α%dα,nocase);
   while(caseread<nocase)
   {
    if(feof(fip))
     break;
    searchread=0;
    fscanf(fip,α%dα,&nosearcheng);
    while(searchread<nosearcheng)
    {
     newlinec=getc(fip);
     fscanf(fip,α%[^n]sα,searcheng[searchread]);
     foundflag[searchread++]=0;
    }
    matchfound=0;
    cfoundflag=1;
    queryread=0;
    fscanf(fip,α%dα,&noquery);
    while(queryread<noquery)
    {
     newlinec=getc(fip);
     fscanf(fip,α%[^n]sα,query);
     if(queryread==0)
     {
     for(searchread=0;searchread<nosearcheng;searchread++)
      {
       if(!strcmp(query,searcheng[searchread]))
       {
        foundflag[searchread]++;
        startmatchindex=searchread;
        break;
       }
      }
     }
     for(searchread=0;searchread<nosearcheng;searchread++)
     {
      if((foundflag[searchread]<cfoundflag)&&(startmatchindex!=searchread))
      {
       if(!strcmp(query,searcheng[searchread]))
       {
        foundflag[searchread]++;
        matchfound++;
        break;
       }
      }
     }
     if(matchfound==(nosearcheng-1))
     {
      cfoundflag++;
      matchfound=0;
      startmatchindex=searchread;
      foundflag[searchread]++;
     }
     queryread++;
    }
    ++caseread;
    fprintf(fop,αCase #%d: %dnα,caseread,cfoundflag-1);
   }
  }
  fclose(fop);
  fclose(fip);
 }"
20171,2008,32013,chansarav2020,24481,1,TRAIN.C,gcj/2008/32013/chansarav2020/24481/1/extracted/TRAIN.C,"/* PROGRAM TO FIND THE MINIMUN NUMBER OF SWITHCES NEEDED FOR A CENTRAL SYSTEM
    TO DIRECT SET OF QUERIES ACROSS DIFFERENT SEARCH ENGINES*/
 #include<stdio.h>
 #include<string.h>
 struct time
 {
  int hour;
  int minute;
 }ab[100][2],ba[100][2],t1,t2;
 void read();
 int timediff(struct time ,struct time);
 int alg(struct time a[][2], int na,struct time b[][2], int nb,int tt);
 void main()
 {
  /*t1.hour=0; t1.minute=0;
  t2.hour=23; t2.minute=30;
  printf(α ndiference is %dα, timediff(t1,t2));*/
 
 read();
 }
 void read()
 {
  FILE *fip,*fop;
  int nocase,caseread=0,na,nb,tt,naread=0,nbread=0,h,m,natrains,nbtrains;
  char ifilename[25],ofilename[25],tempc;
  printf(αnnenter the input filename along with path and extensionnα);
  scanf(α%sα,ifilename);
  printf(αenter the output filename along with path and extensionnα);
  scanf(α%sα,ofilename);
  fip=fopen(ifilename,αrα);
  fop=fopen(ofilename,αwα);
  if(fip==NULL)
   printf(αInput file is not openingα);
  else  if(fop==NULL)
   printf(αOutput file is not openingα);
  else
  {
   fscanf(fip,α%dα,&nocase);
   printf(α%dα,nocase);
   while(caseread<nocase)
   {
    if(feof(fip))
     break;
    fscanf(fip,α%d%d%dα,&tt,&na,&nb);
    printf(αn%d%d%dα,tt,na,nb);
    naread=nbread=0;
    while(naread<na)
    {
     fscanf(fip,α%d%c%dα,&ab[naread][0].hour,&tempc,&ab[naread][0].minute);
     fscanf(fip,α%d%c%dα,&ab[naread][1].hour,&tempc,&ab[naread][1].minute);
     //printf(αn%d%c%d  α,ab[naread][0].hour,tempc,ab[naread][0].minute);
     //printf(α%d%c%dα,ab[naread][1].hour,tempc,ab[naread][1].minute);
     naread++;
    }
    while(nbread<nb)
    {
     fscanf(fip,α%d%c%dα,&ba[nbread][0].hour,&tempc,&ba[nbread][0].minute);
     fscanf(fip,α%d%c%dα,&ba[nbread][1].hour,&tempc,&ba[nbread][1].minute);
     //printf(αn%d%c%d  α,ba[nbread][0].hour,tempc,ba[nbread][0].minute);
     //printf(α%d%c%dα,ba[nbread][1].hour,tempc,ba[nbread][1].minute);
     nbread++;
    }
    natrains=alg(ab,na,ba,nb,tt);
    nbtrains=alg(ba,nb,ab,na,tt);
    ++caseread;
    fprintf(fop,αCase #%d: %d %dnα,caseread,natrains,nbtrains);
   }
  }
  fclose(fop);
  fclose(fip);
 }
 int timediff(struct time t1 ,struct time t2)
 {
  int diff = (t1.hour*60+t1.minute)-(t2.hour*60+t2.minute);
  return diff;
 }
 
 int alg(struct time ab[][2], int na,struct time ba[][2], int nb,int tt)
 {
  int naread=0,nbread=0,ntrains=na,bstart=0,min=0,minindex=-1,diff;//ntrains
   struct time t1,t0;
  for(naread=0;naread<na;naread++)
  {
   min=1440;
   minindex=-1;
   for(nbread=bstart;nbread<nb;nbread++)
   {
    diff=timediff(ab[naread][0],ba[nbread][1]);
    if(diff>=tt)
    {
     if(min>diff)
     {
      min=diff;
      minindex=nbread;
      printf(αn%dnα,minindex);
     }
    }
   }
   if(minindex!=-1)
   {
    ntrains--;
    //swapba(bstart,minindex);
    t0=ba[bstart][0];
    t1=ba[bstart][1];
    ba[bstart][0]=ba[minindex][0];
    ba[bstart][1]=ba[minindex][1];
    ba[minindex][0]=t0;
    ba[minindex][1]=t1;
    bstart++;
   }
  }
  return ntrains;
 }"
20185,2008,32013,Yeusin,24480,1,p1.c,gcj/2008/32013/Yeusin/24480/1/extracted/p1.c,"#include <stdio.h>
 #include <string.h>
 
 char engine[100][101] = {'x0'};
 int engine_num = 0;
 char query[1000][101] = {'x0'};
 int query_num = 0;
 
 int mm[100][1000] = {0};
 
 
 int init()
 {
     int i, j;
     for(i = 0; i < engine_num; i++)
     {
         //printf(αquery : %sα, query[0]);
         //printf(αengine : %sα, engine[i]);
         if(strcmp(query[0], engine[i]) != 0)
             mm[i][0] = 0;
         else
             mm[i][0] = 1;
     }
     /*
         for(i = 0; i < engine_num; i++)
         {
             for(j = 0; j < query_num; j++)
             {
                 //printf(α%d α, mm[i][j]);
             }
                 //printf(αnα);
         }
     */
 }
 int min()
 {
     init();
     int i,j,k;
     for(i = 1; i < query_num; i++)
     {
         int min = 9999;
         int temp = 0;
         for(j = 0; j < engine_num; j++)
         {
             min = 9999;
             temp = 0;
             for(k = 0; k < engine_num; k++)
             {
                 temp = mm[k][i - 1];
                 //printf(αtemp(%d, %d - 1) : %dnα, k, i, temp);
                 if(k != j)
                 {
                     //printf(αFrom others +1nα);
                     temp++;
                 }
                 if(strcmp(query[i], engine[k]) == 0)
                 {
                     //printf(αQuery +1nα);
                     temp = 9999;
                 }
                 //printf(αtemp < min : %d < %dnα, temp, min);
                 if(temp < min)
                 {
                     min = temp;
                 }
             }
             //printf(αm[%d][%d] = %dnα, j, i, min);
             mm[j][i] = min;
         }
     }
 }
 int main(int argc, char * args[])
 
 {
     int i = 0;
     int j = 0;
     int k = 0;
 
     int n = 0;
 
     fscanf(stdin, α%dα, &n);
     //printf(αn : %dnα, n);
 
     for(i = 0; i < n; i++)
     {
         fscanf(stdin, α%dα, &engine_num);
         fgetc(stdin);
         //printf(αengine_num : %dnα, engine_num);
         for(j = 0; j < engine_num; j++)
         {
             fgets(engine[j], 100, stdin);
             //printf(αengine %d : %snα, j, engine[j]);
         }
 
         fscanf(stdin, α%dα, &query_num);
         //printf(αquery_num : %dnα, query_num);
         fgetc(stdin);
 
         for(j = 0; j < query_num; j++)
         {
             //fscanf(stdin, α%sα, &query[j]);
             fgets(query[j], 100, stdin);
             //printf(αquery %d : %snα, j, query[j]);
         }
 
         min();
 
         int min_switch_count = 9999;
         for(j = 0; j < engine_num; j++)
         {
             if(min_switch_count > mm[j][query_num -1])
             {
                 min_switch_count = mm[j][query_num - 1];
             }
         }
        if(engine_num == 0 || query_num ==0)
             min_switch_count = 0;
         fprintf(stdout, αCase #%d: %dnα, i + 1, min_switch_count);
         /*
         for(j = 0; j < query_num; j++)
         {
             printf(α%c α, query[j][0]);
         }
         printf(αnα);
         for(j = 0; j < engine_num; j++)
         {
             for(k = 0; k < query_num; k++)
             {
                 printf(α%d α, mm[j][k]);
             }
                 printf(αnα);
         }
         */
     }
 
     return 0;
 }"
20265,2008,32013,ScorpionKing,24480,1,GOOGLE1.C,gcj/2008/32013/ScorpionKing/24480/1/extracted/GOOGLE1.C,"#include<stdio.h>
 #include<alloc.h>
 #include<stdlib.h>
 
 typedef struct
 {
  char name[1000];
  int flag;
 }search_engine;
 
 int main()
 {
  search_engine **se;
  FILE *fp,*fp1;
  int min,ns,mse,i,j,k,temp,n_cases,n_se,n_r;
  int done=0;
  char **req;
  char tr[1000];
  int i_cases=-1;
  int count=0;
 
  fp=fopen(αinput.datα,αrα);
  fp1=fopen(αoutput.datα,αwα);
  if(fp==NULL)
  {
   printf(αfile not foundα);
   exit(1);
  }
  if(fp1==NULL)
  {
   printf(αfile not foundα);
   exit(1);
  }
 
 
  fscanf(fp,α%dnα,&n_cases);
 
 
  while(++i_cases<n_cases)
  {
   fscanf(fp,α%dnα,&n_se);
   se=(search_engine **)malloc(sizeof(search_engine *)*n_se);
 
   for(i=0;i<n_se;i++)
   {
    se[i]=NULL;
    se[i]=(search_engine *)malloc(sizeof(search_engine));
    fscanf(fp,α%[^n]nα,se[i]->name);
    se[i]->flag=0;
   }
 
   fscanf(fp,α%dnα,&n_r);
   req=(char **)malloc(sizeof(char *)*n_r);
 
   for(i=0;i<n_r;i++)
   {
    fscanf(fp,α%[^n]nα,tr);
    if(i>0 && stricmp(req[i-1],tr)==0)
    {
     n_r--;
     i--;
    }
    else
    {
     req[i]=NULL;
     req[i]=(char *)malloc(sizeof(char)*strlen(tr)+1);
     if(req[i]==NULL)
     {
      printf(αNot enough memory spaceα);
      exit(1);
     }
     strcpy(req[i],tr);
    }
   }
 
   ns=0;
   count=0;
   done=0;
   for(i=0;i<n_r;i++)
   {
    for(j=0;j<n_se;j++)
    {
     if(stricmp(req[i],se[j]->name)==0 && se[j]->flag==0)
     {
      if(done==1)
      {
       ns++;
       count=0;
       done=0;
       for(k=0;k<n_se;k++)
        se[k]->flag=0;
      }
      se[j]->flag=1;
      count++;
      if(count==n_se-1)
      {
       done=1;
 //      ns++;
 //      count=0;
 //      for(k=0;k<n_se;k++)
 //       se[k]->flag=0;
      }
      break;
     }
    }
   }
 //  if(ns>0)
 //   ns--;
 
   fprintf(fp1,αCase #%d: %dnα,i_cases+1,ns);
   printf(αCase #%d: %dnα,i_cases,ns);
   for(i=0;i<n_se;i++)
    free(se[i]);
   free(se);
   for(i=0;i<n_r;i++)
    free(req[i]);
   free(req);
  }
  fclose(fp);
  fclose(fp1);
  return 0;
 }"
20502,2008,32013,VishalJain1981,24480,1,main.c,gcj/2008/32013/VishalJain1981/24480/1/extracted/main.c,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 #include<stdlib.h>
 // Server Name max length
 #define serverNameLenghtMax 100
 #define numServerMax 100
 #define numServerMin 2
 #define numQueriesMax 1000
 
 // Errors
 typedef enum ERROR_e
 {
   NO_ERROR,
   ERROR_OPENING_FILE,
   ERROR_MORE_THAN_MAX_SERVER,
   ERROR_LESS_THAN_MIN_SERVER,
   ERROR_MORE_THAN_MAX_QUERIES
 }Error_t;
 
 #define INF 0xFFFFFFF
 
 /* Model problem as αmost late used in futureα */
 typedef struct querySet // This is one test case
 {
     int countQuery;
 	int countServer;
 	char ServerName[numServerMax][serverNameLenghtMax];
 	char QueryList[numQueriesMax][serverNameLenghtMax];
 }querySet_t;
 
 typedef enum status_e
 {
    DONE,
    NOT_DONE
 }status_t;
 
 querySet_t q;
 
 int getMaxIndex(int * array)
 {
     int max=array[0],index=0;
     int itr=0;
     for(itr=0;itr<q.countServer;itr++)
     {
        if(max<array[itr])
        {
           max=array[itr];
           index=itr;
        }
     }
     return max;
 }
 
 int updateTimeStamp(int * timeStamp,int startIndex,int countQuery,int countServer)
 {
      int itrCountQuery = countQuery,itrCountServer=countServer;
 
 	 // Make all time INF
 	 itrCountServer = q.countServer;
 	 while(itrCountServer--)
 	 {
 		 timeStamp[itrCountServer]=INF;
 	 }
      itrCountServer=countServer;
      if(startIndex>countQuery)
      {
        return DONE;
      }
      // traverse from end and go to index and update itr into timeStamp
      while(itrCountServer--!=0)
      {
        itrCountQuery=countQuery;
        while(itrCountQuery-->startIndex)
        {
          if(!strcmp(q.ServerName[itrCountServer],q.QueryList[itrCountQuery]))
 		 	timeStamp[itrCountServer]=itrCountQuery;
        }
 	 }
 
 }
 
 int main(void)
 {
 	int itrCountServer=0,itrCountQuery=0,index=0,maxValue=0;
 	int nextServiceIndex=0;
 	int leftOverReq,switchIndex,switchCount;
 	int numTests,numTestsItr;
 	int * timeStamp=NULL;
 	char ch;
 	FILE  * fp;
 	FILE  * fpOUT;
 
     fp=fopen(αd://input.txtα,αrα) ;
 	if(!fp)
 		exit(ERROR_OPENING_FILE);
 
     fpOUT=fopen(αd://output.txtα,αwα);
 	if(!fpOUT)
     	exit(ERROR_OPENING_FILE);
 
     // Read number of tests
 	fscanf(fp,α%dα,&numTests);
 
     // For each test case do
     for(numTestsItr=1;numTestsItr<=numTests;numTestsItr++)
     {
         // Read server Count
         fscanf(fp,α%dα,&(q.countServer));
 
 		if(q.countServer>numServerMax)
 			exit(ERROR_MORE_THAN_MAX_SERVER);
 
 		if(q.countServer<numServerMin)
 			exit(ERROR_LESS_THAN_MIN_SERVER);
 
 		// Skip n
         fscanf(fp,α%cα,&ch);
 
 		// allocating equal number of server timestamp record for most late used
         timeStamp= (int *)malloc(sizeof(int)*(q.countServer));
 
         // iterating through server to read its name
         for(itrCountServer=0;itrCountServer<q.countServer;itrCountServer++)
 	    {
              fgets(&(q.ServerName[itrCountServer][0]),serverNameLenghtMax,fp);
 	    }
 
         // Read Query numbers
         fscanf(fp,α%dα,&(q.countQuery));
 		if(q.countQuery>numQueriesMax)
 			exit(ERROR_MORE_THAN_MAX_QUERIES);
 
 		// Skip n
         fscanf(fp,α%cα,&ch);
 
         // read queries into array of string
         for(itrCountQuery=0;itrCountQuery<q.countQuery;itrCountQuery++)
         {
             fgets(q.QueryList[itrCountQuery],serverNameLenghtMax,fp);
         }
 
         // Here starts algo
 
         itrCountServer = q.countServer;
         switchIndex=0; // initialize switch index to zero
         switchCount=0; // intialize switch count to zero
         nextServiceIndex=0;
         // Continue till this seq ends, all query string exhausted
         while(1)
         {
             // Update with most late used
             updateTimeStamp(timeStamp,nextServiceIndex,q.countQuery,q.countServer);
 
             // get Maximum Value
             maxValue=getMaxIndex(timeStamp);
 
             // Next Service Index
             nextServiceIndex=maxValue;
 
             // Done so go out ....
             if(nextServiceIndex>q.countQuery)
             {
                 break;
             }
 
             // Incr switch count
             switchCount++;
           }
 		
 		 // Free timestamp
          free(timeStamp);
 
 		 // One case over so print result
 		 fprintf(fpOUT,αCase #%d: %dnα,numTestsItr,switchCount);
 
     }
    fclose(fpOUT);
    fclose(fp);
 
     return 0;
 }"
20618,2008,32013,ytyoun,24481,1,train.c,gcj/2008/32013/ytyoun/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define NA 102
 #define NB 102
 #define LENGTH NA+NB
 
 /* define the direction as a type */
 typedef enum DIREC_
 {
 	A,
 	B
 } direction;
 
 typedef struct train_
 {
 	direction d;
 	int start;
 } train;
 
 typedef struct schedule_
 {
 	direction d;
 	int start;
 	int end;
 } schedule;
 
 /* array of schedules */
 schedule S[LENGTH];
 int S_size;
 /* array of trains */
 train T[LENGTH];
 int T_size;
 /* turnaround time */
 int turnaround;
 /* number of trains from A and B*/
 int from_A, from_B;
 
 /**
  * used for qsort
  */
 int cmp(schedule *a, schedule *b)
 {
 	if (a->start != b->start)
 		return a->start - b->start;
 	else
 		a->end - b->end;
 }
 /*
 int old_cmp(const void *a, const void *b)
 {
 	if (((schedule *)a->start) != ((schedule *)b->start))
 		return ((schedule *)a->start) - ((schedule *)b->start);
 	else
 		return ((schedule *)a->end) - ((schedule *)b->end);
 }
 */
 
 /**
  * Convert hour:min to min
  */
 int convert(int hour, int min)
 {
 	return 60*hour + min;
 }
 
 /**
  * Only for debugging
  */
 void show_schedule()
 {
 	int i;
 
 	for (i = 0; i < S_size; i++)
 	{
 		printf(α to %c %d:%d ~ %d:%dnα, 'A' + S[i].d,
 					 S[i].start / 60, S[i].start % 60, S[i].end / 60, S[i].end % 60);
 	}
 }
 
 /**
  * Returns the index of compatible train. If not, returns -1.
  */
 int find_compatible(schedule s)
 {
 	int i;
 
 	for (i = 0; i < T_size; i++)
 	{
 		if (T[i].start <= s.start && T[i].d == s.d)
 			return i;
 	}
 
 	return -1;
 }
 
 void show_trains()
 {
 	int i;
 	for (i = 0; i < T_size; i++)
 		printf(α  train %d: to %c after %d:%dnα,
 					 i+1, 'A' + T[i].d, T[i].start / 60, T[i].start % 60);
 	printf(α  ---nα);
 }
 
 int allocate()
 {
 	/* temporary index */
 	int i;
 	/* train index */
 	int tr;
 
 	for (i = 0; i < S_size; i++)
 	{
 		tr = find_compatible(S[i]);
 		if (tr == -1)
 			/* there is no matching train. add a new train */
 		{
 			/* switch the direction */
 			T[T_size].d = 1 - S[i].d;
 			T[T_size].start = S[i].end + turnaround;
 			T_size++;
 
 			/* increment the number of trains */
 			if (S[i].d == A)
 				from_B++;
 			else
 				from_A++;
 		}
 		else
 			/* find a matching train. update the information */
 		{
 			/* switch the direction */
 			T[tr].d = 1 - T[tr].d;
 			T[tr].start = S[i].end + turnaround;
 		}
 		
 /*		show_trains(); */
 	}
 
 	return 0;
 }
 
 int main()
 {
 	int N;
 	int na, nb;
 	/* index varialbe */
 	int i, j;
 	/* depature hour and minute */
 	int d_h, d_m;
 	/* arrival hour and minute */
 	int a_h, a_m;
 
 	scanf(α%dα, & N);
 
 	for (i = 1; i <= N; i++)
 	{
 		/* initialize schedule size and train size */
 		S_size = 0;
 		T_size = 0;
 		from_A = 0;
 		from_B = 0;
 
 		scanf(α%dα, &turnaround);
 
 		scanf(α%d %dα, &na, &nb);
 
 		/* schedule from A to B */
 		for (j = 0; j < na; j++)
 		{
 			scanf(α%d:%d %d:%dα, &d_h, &d_m, &a_h, &a_m);
 			S[S_size].d = B;
 			S[S_size].start = convert(d_h, d_m);
 			S[S_size].end = convert(a_h, a_m);
 			S_size++;
 		}
 
 		/* schedule from B to A */
 		for (j = 0; j < nb; j++)
 		{
 			scanf(α%d:%d %d:%dα, &d_h, &d_m, &a_h, &a_m);
 			S[S_size].d = A;
 			S[S_size].start = convert(d_h, d_m);
 			S[S_size].end = convert(a_h, a_m);
 			S_size++;
 		}
 
 		/* sort the schedules */
 		qsort(S, S_size, sizeof(schedule), cmp);
 
 /*		show_schedule();*/
 
 		allocate(S_size);
 
 		printf(αCase #%d: %d %dnα, i, from_A, from_B);
 	}
 
 	return 0;
 }"
20628,2008,32013,peterpan,24480,1,savingTheUniverse.c,gcj/2008/32013/peterpan/24480/1/extracted/savingTheUniverse.c,"#include <stdio.h>
 
 int iseq(char *s1, char *s2);
 int main(int argc, char *argv[]){
     FILE *fin,*fout;
     int N,n,i,j,k,S,Q,eng[100],sum,switches;
     char engines[100][102],word[102],ch;
     
     if (argc>1)
        fin=fopen(argv[1],αrα);
     else
        fin=fopen(αsavingTheUniverse.in.txtα,αrα);
     if (!fin)
        return 1;
     if (argc>2)
        fout=fopen(argv[2],αwα);
     else
        fout=fopen(αsavingTheUniverse.out.txtα,αwα);
     if (!fout){
        fclose(fin);
        return 1;
        }
     fscanf(fin,α%dnα,&N);
        /***************
        printf(αCases: %dnα,N);
        //getchar();
        /***************/
     for (n=1;n<=N;n++){
        switches=0;
        fscanf(fin,α%dα,&S);
        /***************
        printf(α#egines: %dnα,S);
        //getchar();
        /***************/
        do
           fscanf(fin,α%cα,&ch);
        while (ch!='n');
        for (i=0;i<S;i++){
           fgets(engines[i],102,fin);
           /***************
           printf(αegine #%d:%s.nα,i+1,engines[i]);
           //getchar();
           /***************/
           eng[i]=1;
           }
        fscanf(fin,α%dα,&Q);
        /***************
        printf(α#queries: %dnα,Q);
        //getchar();
        /***************/
        do
           fscanf(fin,α%cα,&ch);
        while (ch!='n');
        sum=S;
        for (i=0;i<Q;i++){
           fgets(word,102,fin);
           for (j=0;j<S;j++)
              if (iseq(engines[j],word))
                 break;
           if(j==S) {printf(αBUG!!ncase #%dnword #%d/%d:%s.nα,n,i+1,Q,word); system(αpauseα);}
           /***************
           printf(αword #%d ->%d:%s.nα,i+1,j+1,word);
           //getchar();
           /***************/
           if (eng[j]){
              sum--;
              if (!sum){
                 switches++;
                 sum=S-1;
                 for (k=0;k<S;k++)
                    eng[k]=1;
                 }
              eng[j]=0;
              }
           /***************
           printf(αsum:%d α,sum);
           for(j=0;j<S;j++) printf(α%dα,eng[j]);
           printf(αnα);
           //getchar();
           /***************/
           }
        fprintf(fout,αCase #%d: %dnα,n,switches);
        }
        fclose(fin);
        fclose(fout);
     return 0;
 }
 
 int iseq(char *s1, char *s2){
    int i=0;
    while (s1[i] && s2[i] && s1[i]==s2[i]) i++;
    if (s1[i]==s2[i])
       return 1;
    if ((s1[i]==0 && s2[i]=='n') || (s2[i]==0 && s1[i]=='n'))
       return 2;
    return 0;
 }"
20630,2008,32013,peterpan,24481,1,trainTimetable.c,gcj/2008/32013/peterpan/24481/1/extracted/trainTimetable.c,"#include <stdio.h>
 
 char items[15][101];
 
 void quickSort(int a[],int l,int r);
 int partition(int a[],int l,int r);
 
 int main(int argc, char *argv[]){
     FILE *fin,*fout;
     int N,n,NA,NB,T,i,j,trainsAd[100],trainsAa[100],trainsBd[100],trainsBa[100],tra,trb;
     char ch;
     
     if (argc>1)
        fin=fopen(argv[1],αrα);
     else
        fin=fopen(αtrainTimetable.in.txtα,αrα);
     if (!fin)
        return 1;
     if (argc>2)
        fout=fopen(argv[2],αwα);
     else
        fout=fopen(αtrainTimetable.out.txtα,αwα);
     if (!fout){
        fclose(fin);
        return 1;
        }
     fscanf(fin,α%dnα,&N);
     for (n=1;n<=N;n++){
        fscanf(fin,α%dα,&T);
        fscanf(fin,α%dα,&NA);
        fscanf(fin,α%dα,&NB);
        /***************
        printf(αT: %dnNA: %dnNB: %dnα,T,NA,NB);
        getchar();
        ***************/
        for (i=0;i<NA;i++){
           fscanf(fin,α%dα,&j);
           trainsAd[i]=60*j;
           fscanf(fin,α%cα,&ch);
           fscanf(fin,α%dα,&j);
           trainsAd[i]+=j;
           fscanf(fin,α%dα,&j);
           trainsAa[i]=60*j;
           fscanf(fin,α%cα,&ch);
           fscanf(fin,α%dα,&j);
           trainsAa[i]+=j+T;
           }
        for (i=0;i<NB;i++){
           fscanf(fin,α%dα,&j);
           trainsBd[i]=60*j;
           fscanf(fin,α%cα,&ch);
           fscanf(fin,α%dα,&j);
           trainsBd[i]+=j;
           fscanf(fin,α%dα,&j);
           trainsBa[i]=60*j;
           fscanf(fin,α%cα,&ch);
           fscanf(fin,α%dα,&j);
           trainsBa[i]+=j+T;
           }
        quickSort(trainsAd,0,NA-1);
        quickSort(trainsAa,0,NA-1);
        quickSort(trainsBd,0,NB-1);
        quickSort(trainsBa,0,NB-1);
        /***************
        printf(αA depnα);
        for (i=0;i<NA;i++)
            printf(α%d:%dnα,trainsAd[i]/60,trainsAd[i]%60);
        printf(αA arnα);
        for (i=0;i<NA;i++)
            printf(α%d:%dnα,(trainsAa[i]-T)/60,(trainsAa[i]-T)%60);
        printf(αB depnα);
        for (i=0;i<NB;i++)
            printf(α%d:%dnα,trainsBd[i]/60,trainsBd[i]%60);
        printf(αB arnα);
        for (i=0;i<NB;i++)
            printf(α%d:%dnα,(trainsBa[i]-T)/60,(trainsBa[i]-T)%60);
        getchar();
        /***************/
        tra=0;
        trb=0;
        for (i=0,j=0;i<NA;i++){
           while(j<NB && trainsBd[j]<trainsAa[i]){
              trb++;
              j++;
              }
           if (j==NB)
              break;
           j++;
           }
        trb+=NB-j;
        for (i=0,j=0;i<NB;i++){
           while(j<NA && trainsAd[j]<trainsBa[i]){
              tra++;
              j++;
              }
           if (j==NA)
              break;
           j++;
           }
        tra+=NA-j;
        if (NA==0)
           trb=NB;
        if (NB==0)
           tra=NA;
        fprintf(fout,αCase #%d: %d %dnα,n,tra,trb);
        }
        fclose(fin);
        fclose(fout);
     return 0;
 }
 
 
 
 void quickSort(int a[],int l,int r){
    int j;
 
    if(l<r){
       j = partition( a, l, r);
       quickSort( a, l, j-1);
       quickSort( a, j+1, r);
       }
 }
 
 
 
 int partition(int a[],int l,int r){
    int pivot,i,j,t;
    
    pivot=a[l];
    i=l;
    j=r+1;	
    while(1){
    	  do
          ++i; 
       while(a[i]<=pivot && i<=r);
    	  do
          --j;
       while(a[j]>pivot);
    	  if( i >= j ) break;
    	  t=a[i];
       a[i]=a[j];
       a[j]=t;
    }
    t=a[l];
    a[l]=a[j];
    a[j]=t;
    return j;
 }"
20706,2008,32013,rabbitxp,24480,1,1.c,gcj/2008/32013/rabbitxp/24480/1/extracted/1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 main(int argc, char **argv){
 	int N,S,Q,n,s,q;
 	char Sname[100][256];
 	char line[256];
 	int Query[1000];
 	int Stable[100];
 	int M,sw;
 	FILE *in,*out;
 	in=fopen(argv[1],αrα);
 	out=fopen(argv[2],αwα);
 	fscanf(in,α%dα,&N);
 	for(n=0;n<N;n++){
 		fscanf(in,α%dα,&S);
 		fgets(line,255,in);
 		for(s=0;s<S;s++) fgets(Sname[s],255,in);
 		fscanf(in,α%dα,&Q);
 		fgets(line,255,in);
 		for(q=0;q<Q;q++){
 			fgets(line,255,in);
 			for(s=0;s<S;s++){
 				if(!strcmp(Sname[s],line)){
 					Query[q]=s;
 					break;
 				}
 			}
 		}
 		q=0;
 		sw=-1;
 		while(q<Q){//??
 			M=S;	//??
 			for(s=0;s<S;s++) Stable[s]=1;
 			while(M && q<Q){
 				if(Stable[Query[q]]){
 					M--;
 					Stable[Query[q]]=0;
 				}
 				if(M) q++;
 			}
 			sw++;
 		}
 		if(sw==-1) sw=0;
 		fprintf(out,αCase #%d: %dnα,n+1,sw);
 	}
 }"
20709,2008,32013,rabbitxp,24481,1,2.c,gcj/2008/32013/rabbitxp/24481/1/extracted/2.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct Trip{
 	int s,e;
 	int d;
 	struct Trip *next;
 };
 
 int tra(char *t){
 	return((t[0]-'0')*600+(t[1]-'0')*60+(t[3]-'0')*10+t[4]-'0');
 };
 
 int comp(const void *x,const void *y){
 	struct Trip *t1,*t2;
 	t1=(struct Trip *)x;
 	t2=(struct Trip *)y;
 	if(t1->s < t2->s) return -1;
 	if(t1->s == t2->s) return 0;
 	else return 1;
 };
 
 main(int argc, char **argv){
 	struct Trip trip[200];
 	int n,N,NA,NB,T,na,nb,e,d;
 	int remain,rtable[200];
 	int i,j,k;
 	char t1[8],t2[8];
 	FILE *in,*out;
 	in=fopen(argv[1],αrα);
 	out=fopen(argv[2],αwα);
 	fscanf(in,α%dα,&N);
 	for(n=0;n<N;n++){
 		fscanf(in,α%d %d %dα,&T,&NA,&NB);
 		for(i=0;i<NA+NB;i++){
 			fscanf(in,α%s %sα,t1,t2);
 			trip[i].s=tra(t1);
 			trip[i].e=tra(t2)+T;
 			trip[i].d=(i<NA)?1:-1;
 		}
 		qsort(trip, NA+NB, sizeof(struct Trip), comp);
 		na=0;
 		nb=0;
 		remain=NA+NB;
 		for(i=0;i<NA+NB;i++) rtable[i]=0;
 		while(remain){
 			i=0;
 			while(rtable[i]) i++;
 			rtable[i]=1;
 			d=trip[i].d;
 			e=trip[i].e;
 			(d>0)?na++:nb++;
 			remain--;
 			i++;
 			d=-d;
 			while(remain && i<NA+NB){
 				if(!rtable[i] && trip[i].d==d && trip[i].s>=e){
 					rtable[i]=1;
 					e=trip[i].e;
 					remain--;
 					d=-d;
 				}
 				i++;
 			}
 		}
 		fprintf(out,αCase #%d: %d %dnα,n+1,na,nb);
 
 	}
 }"
20777,2008,32013,vikasd,24480,1,stu.c,gcj/2008/32013/vikasd/24480/1/extracted/stu.c,"#include <stdio.h>
 #include <stdlib.h>
 
 /**************************************
 Replace all ' ' white spaces with 
 '_'under score in the input file
 using any text editor 
 **************************************/
 
 int main()
 {
 	int nc,ne,nq,i,j,c=0, *a, no,s = 0,k=0;
 	char buff[100], e[100][1000];
 	FILE *inp ,*oup;
 	
 	inp = fopen(αinput.inα, αrα);
 	oup = fopen(αout.inα, αwα);
 	fscanf(inp,α%dα,&nc);
 
 	while(nc!=0)
 	{
 		c++;
 		s=0;		
 		fscanf(inp,α%dα,&ne);
 		no = ne ;
 		j = ne;//printf(αne = %dnα,ne);
 		i = 0;
 		while(j!=0)
 		{
 			fscanf(inp,α%sα, e[i]);//printf(αe = %snα, e[i]);
 			i++;
 			j--;//printf(αje = %dnα,j);
 		}
 		fscanf(inp,α%dα,&nq);
 		j = nq ;//printf(αnq = %dnα,nq);
 		a = malloc(sizeof(int)*no);
 		for(i=0;i<ne;i++)
 		a[i]=1;
 		while(j!=0)
 		{
 			fscanf(inp,α%sα, buff);
 			for(i = 0;i<ne;i++)
 			{
 				if((!strcmp(buff,e[i]))&a[i])
 				{
 					a[i] = 0;k=i;
 					no--;
 					break;
 				}
 			}
 			j--;//printf(αbuff = %s no = %dnα,buff,no);
 			if(no == 0 )
 			{
 				s++;
 				for(i=0;i<ne;i++)
 				a[i]=1;
 				a[k]=0;
 				no = ne-1;
 			}
 			
 		}
 		{
 			fprintf(oup,αCase #%d: %dnα,c,s);
 		}
 		nc--;
 		free(a);
 	}
 	close(inp);
 	close(oup);
 }"
20803,2008,32013,Kar,24480,1,search.c,gcj/2008/32013/Kar/24480/1/extracted/search.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 // one params
 // 1: Filename
 
 void freadline(char *, FILE *);
 int is_set(int *, int);
 int sematch(char *q, char *selist);
 
 void clear_array(int *array, int num) {
   int i;
 
   for(i=0; i<num; i++) 
     array[i]=0;
 }
 
 int strsize(char *str) {
   int retval=0;
   
   while(str[retval++]!='0');
 
   return (retval-1);
 }
 
 int main(int argc, char **argv) {
 
   FILE *f1, *f2;
   char sname[100][80], qname[1000][80], tmp[80], *a;
   long n, s, q;
   int i, j, k, last=-1, sarray[100], cnt=0, num_switch=0;
 
   f1=fopen(argv[1], αrα);
 
   freadline(tmp, f1);
   n=strtol(tmp, &a, 10);
 
   k=0;
   while(k<n) {
     num_switch=0;
     freadline(tmp, f1);
     s=strtol(tmp, &a, 10);
     //read all the search engines in
     for(i=0; i<s; i++) 
       freadline(sname[i], f1);
     
     clear_array(sarray, s);
     freadline(tmp, f1);
     q=strtol(tmp, &a, 10);
     //read all the queries in
     for(i=0; i<q; i++) 
       freadline(qname[i], f1);
     
     cnt=0;
     while(cnt<q) {
       while(!is_set(sarray, s)) {
 	for(i=0; i<s; i++) {
 	  if(sematch(qname[cnt], sname[i]) != -1) {
 	    sarray[i]=1;
 	    last=i;
 	    break;
 	  }
 	}
 	cnt++;
 	if(cnt == q) break;
       }   
       if(is_set(sarray, s)) {
 	num_switch++;
 	//	printf(α%d. %s  α, num_switch, sname[last]);
 	clear_array(sarray, s);
 	cnt--;
       }
       else if(cnt == q) {
 	j=-1;
 	while(sarray[++j]==1);
 	//	printf(α%d: %sα, (num_switch+1), sname[j]);
       }
     }
     //printf(αnα);
     printf(αCase #%d: %dnα, ((k++)+1), num_switch); 
   }
 }
 
 void freadline(char *s, FILE *f) {
   int i=0;
   while((s[i++] = fgetc(f)) != 'n');
   
   s[i-1]='0';
   return;
 }
 
 int is_set(int *sa, int s) {
   int i, retval=1;
 
   for(i=0;i<s; i++) {
     if(sa[i] == 0) {
       retval=0;
       break;
     }
   }
 
   return retval;
 }
 
 
 // Returns -1 or num search engine that matches 
 int sematch(char *q, char *selist) {
   int retval=-1, i;
   
   if((strstr(selist, q) != NULL) && (strsize(q) == strsize(selist))) 
     retval = i;
 
   return retval;
 }"
20837,2008,32013,enlighten,24480,1,a.c,gcj/2008/32013/enlighten/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int main()
 {
     int allnum,casenum,ennum,connum,sw,cnt;
     char buffer[128];
     char en[100][128];
     int i,j,k;
     char map[100];
     FILE *fp = fopen(αa.inα,αrα);
     fgets(buffer,128,fp);
     allnum = atoi(buffer);
     for(casenum=1;casenum<=allnum;casenum++)
     {
            fgets(buffer,128,fp);
            ennum = atoi(buffer);                 
            for(i=0;i<ennum;i++)
            {
                fgets(en[i],128,fp);
             }
             fgets(buffer,128,fp);
             connum = atoi(buffer);
             memset(map,0,100);
             sw = 0;
             cnt = 0;
             for(i=0;i<connum;i++)
             {
                 fgets(buffer,128,fp);
                 for(j=0;j<ennum;j++)
                 {
                      if(strcmp(buffer,en[j]) == 0)
                          break;               
                 }
                 if(j<ennum)
                 {
                   if(map[j] == 0)
                   {
                         cnt++;
                         if(cnt == ennum)
                         {
                           memset(map,0,100);
                           cnt=1;    
                           sw++;   
                         }       
                         map[j] = 1;        
                   }           
                            
                 }                 
                                  
              }                        
                                             
                                             
             printf(αCase #%d: %dnα,casenum,sw);         
         }
     
     
     
     return 0;
     }"
20881,2008,32013,Revas,24480,1,Main.c,gcj/2008/32013/Revas/24480/1/extracted/Main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 typedef unsigned int    uint;
 typedef enum tagBOOL 
 {  
     FALSE, 
     TRUE 
 } BOOL;
 
 #define LOCAL           static
 
 
 #define ABSF(f)         (((f) >= 0.0) ? (f) : ((f) * -1.0))
 
 typedef struct tagSInfo
 {
     char strSearch[101];
     int iNumTo;
 }SINFO;
 
 /*
  * 
  */
 int main(int argc, char** argv) 
 {
     char strFileName[30];
     FILE *pF;
     
     char strTotal[101];
     uint uiTotalIn;
     uint uiCont;
     FILE *pfOutput;
     
     char strS[101];
     int iS;
     int iX;
     SINFO *ptrSInfoIni;
     SINFO *ptrSInfo;
     
     char strQ[101];
     int iQ;
     int iY;
     char *ptrQueriesIni;
     char *ptrQueries;
     
     FILE *pOut;
     int iSwitch;
     
     BOOL bOk;
     int iMax;
     int iLenQ;
     
 
     
     // try to get user's file
     if (argc > 1) {
         strcpy(strFileName, argv[1]);
     }
     // no one specified, use default
     else {
         strcpy(strFileName, αA-large.inα);
     }
     
     // if sucessfull open arqchive
     if ((pF = fopen(strFileName, αrtα)) != NULL) {
         
         pOut = fopen(αA-large.outα, αwtα);
         
         fgets(strTotal, 100, pF);
         uiTotalIn = atoi(strTotal);
         printf(αTotal Input: %unα, uiTotalIn);
         
         for (   uiCont = 0; 
                 uiCont < uiTotalIn; 
                 //uiCont < 3; 
                 ++uiCont) 
         {
             
             fgets(strS, 100, pF);
             iS = atoi(strS);
             printf(αNum Search Engine: %unα, iS);
             ptrSInfoIni = (SINFO *) malloc(sizeof(SINFO) * iS);
             
             for (iX = 0; iX < iS; ++iX) 
             {
                 ptrSInfo = (ptrSInfoIni + iX);
                 fgets(ptrSInfo->strSearch, 100, pF);
                 ptrSInfo->strSearch[strlen(ptrSInfo->strSearch) - 1] = '0';
                 printf(αt%snα, ptrSInfo->strSearch);                
             }
             
             fgets(strQ, 100, pF);
             iQ = atoi(strQ);
             printf(αNum Queries: %unα, iQ);
             ptrQueriesIni = malloc(101 * iQ);
             for (iY = 0; iY < iQ; ++iY) 
             {
                 ptrQueries = (ptrQueriesIni + (iY *  101)) ;
                 fgets(ptrQueries, 100, pF);
                 ptrQueries[strlen(ptrQueries) - 1] = '0';
                 printf(αtt%snα, ptrQueries);                
             }
             
             fprintf(pOut, αCase #%i: α, (uiCont+1));
 
             iSwitch = -1;
             iLenQ = 0;
             do {
                 
 
                 for (iX = 0; iX < iS; ++iX) 
                 {
                     ptrSInfo = (ptrSInfoIni + iX);
                     ptrSInfo->iNumTo = 0;
                 }
                 
                 
                 for (iX = 0; iX < iS; ++iX) 
                 {
                     ptrSInfo = (ptrSInfoIni + iX);
                     bOk = TRUE;
                     for (iY = iLenQ; iY < iQ && bOk; ++iY) 
                     {
                         ptrQueries = (ptrQueriesIni + (iY *  101)) ;
                         
                         //printf(αS:(%s) Q:(%s)nα, ptrSInfo->strSearch, ptrQueries);
                         if (strcmp(ptrSInfo->strSearch, ptrQueries) == 0) 
                         {
                             ptrSInfo->iNumTo = iY;
                             bOk = FALSE;
                             printf(αnnACHOU iX = %i, iY = %innα, iX, iY);
                         }                    
                     }
                     if (bOk == TRUE) {
                         ptrSInfo->iNumTo = iY;
                     }
                 }
 
                 iMax = 0;
                 for (iX = 0; iX < iS; ++iX) 
                 {
                     ptrSInfo = (ptrSInfoIni + iX);
                     if (ptrSInfo->iNumTo > iMax) {
                         iMax = ptrSInfo->iNumTo;
                     }
                 }
                 printf(αiMax: %inα, iMax);
                 printf(αiLenQ: %inα, iLenQ);
                 printf(αiQ: %inα, iQ);
                 printf(αiSwitch: %inα, iSwitch);
                 
                 //getchar();
                 
                 iLenQ = iMax;
                 iSwitch++;
           
             } while (iMax < iQ);
 
 
 
           
             fprintf(pOut, α%unα, iSwitch);           
            
             free(ptrSInfoIni);
             free(ptrQueriesIni);            
             
         }
         
         
         fclose(pOut);
         
         fclose(pF);    
     }
     // Failures, warning the user
     else {
         fprintf(stderr, αERROR: could not open file %snα, strFileName);
     }
 
     
     return (EXIT_SUCCESS);
 }"
20908,2008,32013,shell.xp,24480,1,main.c,gcj/2008/32013/shell.xp/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int count_switch(int s, char **search_engine, int q, char **query)
 {
 	int i, j, last, count, max_without_switch;
 
 	count = 0;
 	last = max_without_switch = 0;
 	while(1){
 		for(i = 0; i < s; i++){
 			if(strcmp(search_engine[i], query[last])){
 				for(j = last; j < q; j++){
 					if(strcmp(search_engine[i], query[j]) == 0){
 						if(max_without_switch < j){
 							max_without_switch = j;
 						}
 						break;
 					}
 				}
 				if(j == q){
 					return count;
 				}
 			}
 		}
 		last = max_without_switch;
 		count++;
 	}
 }
 
 int geti(FILE *fp, int *n)
 {
 	char buf[256];
 	
 	fgets(buf, sizeof(buf), fp);
 	*n = atoi(buf);
 
 	return *n;
 }
 
 char **salloc(int n, int m)
 {
 	int i;
 	char **ptr;
 
 	ptr = (char **)malloc(sizeof(char *) * (m + 1));
 	for(i = 0; i < m; i++){
 		ptr[i] = (char *)malloc(sizeof(char) * n);
 	}
 	ptr[m] = NULL;
 	return ptr;
 }
 
 void frees(char **ptr)
 {
 	char **p = ptr;
 
 	do{
 		free(*p);
 	} while(*p++);
 
 	free(ptr);
 	return;
 }
 
 void chomp(char *str)
 {
 	char *ptr;
 	
 	ptr = str;
 
 	if(*str == '0') return;
 	while(*(++ptr) != '0');
 	while(str <= (--ptr) && (*ptr == 'r' || *ptr == 'n')){
 		*ptr = '0';
 	}
 	return;
 }
 
 int main()
 {
 	int n, s, q, i, j;
 	char **search_engine, **query;
 	FILE *fp1, *fp2;
 
 	n = s = q = 0;
 
 	search_engine = salloc(101, 100);
 	query = salloc(101, 1000);
 
 	fp1 = fopen(αA-large.inα, αrα);
 	fp2 = fopen(αoutput.txtα, αwα);
 
 	geti(fp1, &n);
 	for(i = 0; i < n; i++){
 		geti(fp1, &s);
 		for(j = 0; j < s; j++){
 			fgets(search_engine[j], 101, fp1);
 			chomp(search_engine[j]);
 		}
 		geti(fp1, &q);
 		for(j = 0; j < q; j++){
 			fgets(query[j], 101, fp1);
 			chomp(query[j]);
 		}
 
 		fprintf(fp2, αCase #%d: %dnα, i + 1, count_switch(s, search_engine, q, query));
 	}
 
 	frees(search_engine);
 	frees(query);
 	return 0;
 }"
20974,2008,32013,ShmoMuffin,24480,1,problem1.c,gcj/2008/32013/ShmoMuffin/24480/1/extracted/problem1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 typedef char maxname[102];
 
 int main(const int argc, const char *const argv[])
 {
 	FILE *input;
 	int cases, engine_num, i, j, k, query_num, *count, solution, temp;
 	maxname *engines, *queries;
 	char *ptr;
 	if (argc < 2)
 	{
 		fprintf(stderr, αenter file name as first argumentnα);
 		return(1);
 	}
 	if (!(input = fopen(argv[1], αrα)))
 	{
 		fprintf(stderr, αenter file name as first argumentnα);
 		return(2);
 	}
 	fscanf(input, α%dnα, &cases);
 	for (i=0; i<cases; i++)
 	{
 		fscanf(input, α%dnα, &engine_num);
 		if (!(engines = (maxname *)malloc(engine_num*sizeof(maxname))))
 		{
 			fprintf(stderr, αmalloc errornα);
 			return(3);
 		}
 		for (j=0; j<engine_num; j++)
 		{
 			fgets(engines[j], 102, input);
 			if ((ptr = strchr(engines[j], 'n')))
 				*ptr = '0';
 		}
 		fscanf(input, α%dnα, &query_num);
 		if (!(queries = (maxname *)malloc(query_num*sizeof(maxname))))
 		{
 			fprintf(stderr, αmalloc errornα);
 			return(4);
 		}
 		for (j=0; j<query_num; j++)
 		{
 			fgets(queries[j], 102, input);
 			if ((ptr = strchr(queries[j], 'n')))
 				*ptr = '0';
 		}
 		count = (int *)malloc(sizeof(int)*engine_num);
 		for (j=0; j<engine_num; j++)
 			count[j] = 0;
 
 		solution = 0;
 		for (j=0; j<query_num; j++)
 		{
 			k = 0;
 			while (strcmp(queries[j], engines[k]))
 				k++;
 			count[k]++;
 			temp = k;
 			for (k=0; k<engine_num; k++)
 			{
 				if (count[k]==0)
 					break;
 			}
 			if (k==engine_num)
 			{
 				solution++;
 				for (k=0; k<engine_num; k++)
 					count[k] = 0;
 				count[temp]++;
 			}
 		}
 
 		printf(αCase #%d: %dnα, i+1, solution);
 		free(count);
 		free(engines);
 		free(queries);
 	}
 	return(0);
 }"
21012,2008,32013,amalober,24480,1,Saving_the_Universe .c,gcj/2008/32013/amalober/24480/1/extracted/Saving_the_Universe .c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 
 #define MAX_N 20
 #define MIN_N 0
 #define MAX_S 100
 #define MIN_S 2
 #define MAX_Q 0
 #define MIN_Q 1000
 #define MAX_LEN 1000
 #define MARKED 1
 #define UNMARKED 0
 #define EMPTY_BUFFER       while((c=fgetc(data_f))!='n'&&c!=EOF)
 
 
 /* 
   Function that empties the board that has the engine-names 
   that have been queried 
 */
 void CleanBoard(int *marked, int se_num);
 int GetEngineID(char* engine, char engines[][MAX_LEN], int se_num);
 
 
 int main(int argc, char** argv)
 {
 	FILE* data_f;
 	FILE* output;
 	char c; /* used to clean buffer */
 	int se_num;
 	int cases;
 	int querie_num;
 	char se[MAX_S][MAX_LEN];
 	char querie[MAX_LEN];
 	int marked[MAX_S]; 
 	int counter=0;
 	int i, j, k; //counters
 	int engineID;
 	int switches;
 	
 
 	if(argc!=3){
 		fprintf(stdout, α%s input_file output_filenα, argv[0]);
 		return 0;
 	}
 	if((data_f=fopen(argv[1], αrα))==NULL){
 		fprintf(stdout, αError opening file %snα, argv[1]);
 		return 0;
 	}
 	if((output=fopen(argv[2], αwα))==NULL){
 		fprintf(stdout, αError opening file %snα, argv[2]);
 		return 0;
 	}
 
 	fscanf(data_f, α%dα, &cases);
 
 	for(i=0; i<cases; i++){
 		switches=0;
 		if(i==12)
 			putchar('0');
 		fscanf(data_f, α%dα, &se_num);
 		EMPTY_BUFFER;
 		for(j=0; j<se_num; j++){
 			fgets(se[j], MAX_LEN, data_f);
 			se[j][strlen(se[j])-1]=0; /* fgets leaves a 'n' at the end */
 		}
 		fscanf(data_f, α%dα, &querie_num);
 		EMPTY_BUFFER;
 		CleanBoard(marked, se_num); 
 		counter=se_num;
 		for(k=0; k<querie_num; k++){
 			if(counter==0){
 				switches++;
 				counter=se_num-1; /* restart coutner of queried engines */
 				CleanBoard(marked, se_num);
 				marked[GetEngineID(querie, se, se_num)]=MARKED; /* The last one goes to the new engine */
 			}
 			//EMPTY_BUFFER;
 			fgets(querie, MAX_LEN, data_f);
 			querie[strlen(querie)-1]=0; /* fgets leaves a 'n' at the end */
 			engineID=GetEngineID(querie, se, se_num);
 			if(marked[engineID]!=MARKED){
 				counter--;
 				marked[engineID]=MARKED;
 			}
 
 		}
 		if(counter==0)
 			switches++;
 		fprintf(output, αCase #%d: %dnα, i+1, switches);
 	}
 	fclose(data_f);
 	fclose(output);
 	
 	return 0;
 }
 
 void 
 CleanBoard(int *marked, int se_num)
 {
 	int i;
 	for(i=0; i<se_num; i++)
 		marked[i]=UNMARKED;
 	return;
 }
 
 int 
 GetEngineID(char* engine, char engines[][MAX_LEN], int se_num)
 {
 	int id=-1;
 	int i;
 	for(i=0; id==-1 && i<se_num; i++){
 		if(strcmp(engine, engines[i])==0)
 			id=i;
 	}
 	return id;
 }"
21022,2008,32013,eld1e6o,24480,1,main.c,gcj/2008/32013/eld1e6o/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define Nmax 20
 #define Smax 100
 #define Qmax 1000
 #define Lmax 101
 
 int main()
 {
     int n,s,q,temp,cuenta,sact,qact,regr,cambio=0,memoria;
     char motores[Smax][Lmax];
     char cadtemp[Lmax];
     int flags[Smax];
     char nums[10];
     FILE *archivo,*salida;
 	char nombre[] = αA-large.in0α;
 	archivo=fopen(nombre,αrα);
 	salida=fopen(αsalida2.txtα,αwα);
 	if(!archivo){
 		printf(αNo se pudo abrir el archivo de entradanα);
 		return 1;
 	}
 
 	if(!salida){
 		printf(αNo se pudo abrir el archivo de salidanα);
 		return 1;
 	}
     n=0;
 //	fscanf(archivo,α%dtα,&n);//maximo de casos
 	fgets(nums,5,archivo);
 	printf(αgets okα);
 	puts(nums);
 	temp=0;
 	printf(αantes %d %dnα,nums[temp],'0');
 	while(nums[temp]<'0' || nums[temp]>'9')temp++;
 	while((nums[temp]>='0') && (nums[temp]<='9')){
 	    n=n*10;n=n+nums[temp]-'0';temp++;//printf(α %dα,temp);
 	    }
 
 	printf(αN: %dα,n);
 	for(cuenta=1;cuenta<=n;cuenta++){ //mete en la matriz los nombres de los buscadores
 	    cambio=0;
     	fgets(nums,7,archivo);
         temp=0;
         s=0;
         while(nums[temp]<'0' || nums[temp]>'9')temp++;
         while((nums[temp]>='0') && (nums[temp]<='9')){
             s=s*10;s=s+nums[temp]-'0';temp++;//printf(α %dα,temp);
             }//obtiene s
 //	    fscanf(archivo,α%dnα,&s);
         printf(αS: %dnα,s);
 	    for(sact=0;sact<s;sact++){
 	        fgets(motores[sact], Lmax, archivo);puts(motores[sact]);
         }
         fgets(nums,7,archivo);
         temp=0;
         q=0;
         while(nums[temp]<'0' || nums[temp]>'9')temp++;
         while((nums[temp]>='0') && (nums[temp]<='9')){
             q=q*10;q=q+nums[temp]-'0';temp++;//printf(α %dα,temp);
             }//obtiene q
         printf(αQ: %dnα,q);
 
         regr=s; //para saber cual es el último en buscar
 
         printf(αEmpieza la busquedanα);
         for(temp=0;temp<Smax;temp++)flags[temp]=0;//borra flags
         for(qact=0;qact<q;qact++){ //por cada consulta verifica si se repite
             fgets(cadtemp,Lmax, archivo);//obtiene consulta
             for(temp=0;temp<s;temp++){
                 if(strcmp(cadtemp,motores[temp])==0 && flags[temp]==0){//si la consulta es igual a un buscador
                     flags[temp]=1;//marca el flag como inutilizable
                     memoria=temp;
                     temp=s+1;//para que deje de comparar esa cadena
                     regr--; //una posibilidad menos
 
                 }
             }
             if(regr==0){
                 cambio++;
                 printf(αEncontrado: α);
                 puts(cadtemp);
                 for(temp=0;temp<Smax;temp++)flags[temp]=0;
                 regr=s-1;//porque hay un server anulado
                 flags[memoria]=1;//modificado para que no pueda usare mismo server 2 veces
             }
 //	}
     }
     printf(αPara N= %d necesitamos %d cambiosnα,cuenta,cambio);
     fprintf(salida,αCase #%d: %dnα,cuenta,cambio);
 
 }
 	/*debug
 
 	printf(αN: %d, S: %dnα,n,s);
 	for(temp=0;temp<s;temp++)puts(motores[temp]);
 */
     return 0;
 }"
21068,2008,32013,chai,24480,1,universe.c,gcj/2008/32013/chai/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXLENGTH 101
 
 FILE *fd;
 char line[MAXLENGTH];
 char names[100][101], search[101];
 int avail[100];
 
 int find(int number, char *string)
 {
 	int m;
 	for (m=0; m<number; m++)
 		if (strcmp(string, names[m])==0)
 			return m;
 }
 
 int noneavail(int number)
 {
 	int m;
 	for (m=0; m<number; m++) {
 		if (avail[m] == 1)
 			return 0;
 	}
 	return 1;
 }
 
 void makeallavail(int number)
 {
 	int m;
 	for (m=0; m<number; m++) 
 		avail[m] = 1;
 }
 
 int main(int argc, char *argv[])
 {
 	int iter, k, ne, ns, i, switches, index; 
 	fd = fopen(argv[1], αrα);
 	fgets(line, MAXLENGTH, fd);
 	sscanf(line, α%dnα, &iter);
 	k = 0;
 	while (k < iter){
 		fgets(line, MAXLENGTH, fd);
 		sscanf(line, α%dnα, &ne);
 		
 		for(i = 0; i < ne; i++) {
 			fgets(line, MAXLENGTH, fd);
 			sscanf(line, α%[a-zA-Z0-9' ']α, names[i]);
 		}
 		fgets(line, MAXLENGTH, fd);
 		sscanf(line, α%dnα, &ns);
 		switches = 0;
 		makeallavail(ne);
 		for(i = 0; i < ns; i++) {
 			fgets(line, MAXLENGTH, fd);
 			sscanf(line, α%[a-zA-Z0-9' ']α, search);
 			index = find(ne, search);
 			if (avail[index]==0)
 				continue;
 			else {
 				avail[index]=0;
 				if (noneavail(ne)) {
 					makeallavail(ne);
 					avail[index]=0;
 					switches++;
 				}	
 			}
 		}
 		printf(αCase #%d: %dnα, ++k, switches);
 	}
 	fclose(fd);
 }"
21147,2008,32013,Maxime,24480,1,qual1.c,gcj/2008/32013/Maxime/24480/1/extracted/qual1.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 /*
  Google Code Jam 2008. Qualification round, Task: Saving the Universe.
  all array boundaries depend on task rules,
  you need add checks in the real world.
 */
 
 typedef struct {
   char *name;
   int num;
 } ENGINE;
 
 
 int cmpEngines(const void *v1, const void *v2) {
   ENGINE *e1 = (ENGINE*)v1, *e2 = (ENGINE*)v2;
   return strcmp(e1->name, e2->name);
 }
 
 int askEngineNum(char *name, ENGINE *base, int numb) {
   ENGINE key, *ind;
   key.name = name;
   ind = bsearch(&key, (void*)base, (size_t)numb, sizeof(*base), &cmpEngines);
   return ind->num;  
 }
 
 main() {
   int MASK[100];
   char str[4096];
   int N, S, Q;
   int iN, i;
   int curEngine;
   int result;
 
   int usedEngines;
   ENGINE dict[100];
 
   fgets(str, sizeof(str), stdin);
   sscanf(str, α%dα, &N);
   fprintf(stderr, αN:%dnα, N);
 
   for (iN = 0; iN < N; iN++) {
 
     result = 0;
     usedEngines = 0;
 
     fgets(str, sizeof(str), stdin);
     sscanf(str, α%dα, &S);
     fprintf(stderr, αCase#%d N:%dnα, (iN+1), S);
     
     bzero(MASK, sizeof(MASK));
 
     for(i = 0; i < S; i++) {
       fgets(str, sizeof(str), stdin);
       dict[i].name = strdup(str);
       fprintf(stderr, α -- SE:%s ==%sα, dict[i].name, str);
       dict[i].num = i;
     }
     qsort(dict, (size_t)S, sizeof(*dict), &cmpEngines);
  
     fgets(str, sizeof(str), stdin);
     sscanf(str, α%dα, &Q);
     fprintf(stderr, αQ:%dnα, Q);
 
     for(i = 0; i < Q; i++) {
       fgets(str, sizeof(str), stdin);
       curEngine = askEngineNum(str, dict, S);
       fprintf(stderr, αcur:%d used:%d  name:%sα, curEngine, usedEngines, str);
       if (MASK[curEngine] == 0) {
  	if (++usedEngines == S) {
 	  result++;
 	  bzero(MASK, sizeof(MASK));
 	  usedEngines = 1;
 	}
  	MASK[curEngine] = 1;
       }
     }
     
     for(i = 0; i < S; i++) free(dict[i].name);
 
     fprintf(stdout, αCase #%d: %dnα, iN + 1, result);
 
   }
   return 0;
 }"
21174,2008,32013,ledia,24480,1,a.c,gcj/2008/32013/ledia/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_QUERY_SIZE   1024
 #define MAX_BUFFER_SIZE   128
 #define MAX_SE_NUM        128
 
 struct range
 {
     int s;
     int t;
 };
 
 int myComp(const void *a, const void *b)
 {
     struct range *x = (struct range *)a,
                  *y = (struct range *)b;
     if(x->s != y->s)
         return x->s - y->s;
     return y->t - x->t;
 }
 
 int main(void)
 {
     int ncase;
     int i, j, k;
     int ans;
     int nSE;
     char SEname[MAX_SE_NUM][MAX_BUFFER_SIZE];
     char buf[MAX_BUFFER_SIZE];
     int lastPos[MAX_SE_NUM];
     int nQuery;
     int nRange;
     struct range rangePool[MAX_QUERY_SIZE + MAX_SE_NUM];
     int curPos;
 
     fgets(buf, MAX_BUFFER_SIZE, stdin);
     sscanf(buf, α%dα, &ncase);
 
     for(i=0;i<ncase;i++)
     {
         fgets(buf, MAX_BUFFER_SIZE, stdin);
         sscanf(buf, α%dα, &nSE);
         for(j=0;j<nSE;j++)
         {
             fgets(SEname[j], MAX_BUFFER_SIZE, stdin);
             lastPos[j] = 1;
         }
         fgets(buf, MAX_BUFFER_SIZE, stdin);
         sscanf(buf, α%dα, &nQuery);
         for(j=1,nRange=0;j<=nQuery;j++)
         {
             char SEbuf[MAX_BUFFER_SIZE];
             fgets(SEbuf, MAX_BUFFER_SIZE, stdin);
             for(k=0;k<nSE;k++)
                 if(strcmp(SEbuf, SEname[k]) == 0)
                 {
                     if(lastPos[k] < j)
                     {
                         rangePool[nRange].s = lastPos[k];
                         rangePool[nRange].t = j-1;
                         nRange++;
                     }
                     lastPos[k] = j+1;
                 }
         }
         for(j=0;j<nSE;j++)
             if(lastPos[j] <= nQuery)
             {
                 rangePool[nRange].s = lastPos[j];
                 rangePool[nRange].t = nQuery;
                 nRange++;
             }
 
         qsort(rangePool, nRange, sizeof(struct range), myComp);
 
         curPos = rangePool[0].t;
         j = 1;
         ans = 1;
         while(curPos < nQuery)
         {
             int max = 0;
             int maxid = 0;
             while(j < nRange)
             {
                 if(max < rangePool[j].t)
                 {
                     max = rangePool[j].t;
                     maxid = j;
                 }
                 if(rangePool[j].s > curPos)
                     break;
                 j++;
             }
             ans += 1;
             curPos = max;
         }
 
         /*
         for(j=0;j<nRange;j++)
             printf(α%d %dnα, rangePool[j].s, rangePool[j].t);
         */
         printf(αCase #%d: %dnα, i+1, ans-1);
     }
     return 0;
 }"
21176,2008,32013,ledia,24481,1,b.c,gcj/2008/32013/ledia/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct schedule
 {
     int s;
     int t;
     int from;
     int to;
 };
 
 struct trainList
 {
     int nextAvail;
     struct trainList *next;
 } myPool[65535];
 int nPool;
 
 int myComp(const void *a, const void *b)
 {
     struct schedule *x = (struct schedule *)a,
                     *y = (struct schedule *)b;
     return x->s - y->s;
 }
 
 struct trainList *InsertTrain(struct trainList *h, int t)
 {
     if(h==NULL)
     {
         h = &myPool[nPool];
         h->next = NULL;
         h->nextAvail = t;
         nPool++;
         return h;
     }
 
     myPool[nPool].next = h;
     myPool[nPool].nextAvail = t; 
     nPool++;
 
     return &myPool[nPool-1];
 }
 
 int PopAvailTrain(struct trainList **h, int t)
 {
     struct trainList *ptr = *h;
     struct trainList *last;
 
     if(ptr == NULL)
         return 0;
 
     if(ptr->nextAvail <= t)
     {
         *h = ptr->next;
         return 1;
     }
 
     for(last=(*h), ptr=(*h)->next; ptr != NULL; ptr=ptr->next, last=last->next)
         if(ptr->nextAvail <= t)
         {
             last->next = ptr->next;
             return 1;
         }
 
     return 0;
 }
 
 int main(void)
 {
     int i, j;
     int ncase;
     int NA, NB;
     int ans[2];
     int T;
     char time[16];
     struct schedule Sche[256];
     int nSche;
     struct trainList *slot[2] = {NULL, NULL};
 
     scanf(α%dα, &ncase);
 
     for(i=0;i<ncase;i++)
     {
         nPool = nSche = ans[0] = ans[1] = 0;
 
         scanf(α%dα, &T);
         scanf(α%d%dα, &NA, &NB);
         for(j=0;j<NA;j++)
         {
             int hr, min;
             scanf(α%sα, time);
             sscanf(&time[0], α%dα, &hr);
             sscanf(&time[3], α%dα, &min);
             Sche[nSche].s = hr*60 + min;
             scanf(α%sα, time);
             sscanf(&time[0], α%dα, &hr);
             sscanf(&time[3], α%dα, &min);
             Sche[nSche].t = hr*60 + min;
             Sche[nSche].from = 0;
             Sche[nSche].to = 1;
             nSche++;
         }
         for(j=0;j<NB;j++)
         {
             int hr, min;
             scanf(α%sα, time);
             sscanf(&time[0], α%dα, &hr);
             sscanf(&time[3], α%dα, &min);
             Sche[nSche].s = hr*60 + min;
             scanf(α%sα, time);
             sscanf(&time[0], α%dα, &hr);
             sscanf(&time[3], α%dα, &min);
             Sche[nSche].t = hr*60 + min;
             Sche[nSche].from = 1;
             Sche[nSche].to = 0;
             nSche++;
         }
 
         qsort(Sche, nSche, sizeof(struct schedule), myComp);
 
         for(j=0;j<nSche;j++)
         {
             if(PopAvailTrain(&slot[Sche[j].from], Sche[j].s) == 0)
             {
                 ans[Sche[j].from]++;
                 slot[Sche[j].to] = InsertTrain(slot[Sche[j].to], Sche[j].t+T);
             }
             else
             {
                 slot[Sche[j].to] = InsertTrain(slot[Sche[j].to], Sche[j].t+T);
             }
         }
         /*
         for(j=0;j<nSche;j++)
             printf(αfrom %c to %c at time %d - %dnα, 'A' + Sche[j].from, 'A' + Sche[j].to, Sche[j].s, Sche[j].t);
         */
         printf(αCase #%d: %d %dnα, i+1, ans[0], ans[1]);
     }
 
 
     return 0;
 }"
21178,2008,32013,twsan,24480,1,savingtheuniverse.c,gcj/2008/32013/twsan/24480/1/extracted/savingtheuniverse.c,"#include <stdio.h>
 #include <map>
 #include <math.h>
 #include <stdlib.h>
 
 #include <iostream>
 #include <vector>
 #include <string>
 
 using namespace std;
 
 map<string, int> lut;
 
 int main(int argc, char **argv) {
 
 int num, nsearch, nquery;
 int k,m, p, q, y;
 char mask[100];
 string s;
 
 cin >> num; cin.ignore();
 
 for(k=1;k<=num;k++) {
 	lut.clear();
 	m = 0;
 	y = 0;
 
 	cin >> nsearch; cin.ignore();
 	//cout << αnsearch:α<< nsearch << endl;
 	for(m=0;m<nsearch;m++) {
 		getline(cin, s);
 		lut[s] = m;
 		//cout << s << endl;
 	}
 	for(m=0;m<100;m++) mask[m] = 0;
 	
 	cin >> nquery; cin.ignore();
 	//cout << αnquery:α << nquery << endl;
 
 	for(m=0;m<nquery;m++) {
 		getline(cin, s);
 		mask[lut[s]] = 1;
 		for(p=0;p<nsearch;p++) {
 			if(mask[p] == 0) break;
 			if(p == nsearch -1) {
 				y++;
 				for(q=0;q<nsearch;q++) {
 					mask[q] = 0;
 				}
 				mask[lut[s]] = 1;
 			}
 		}
 	}
 
 
 	cout << αCase #α << k << α: α << y << endl;
 
 }
 
 } //main"
21180,2008,32013,twsan,24481,1,traintimetable.c,gcj/2008/32013/twsan/24481/1/extracted/traintimetable.c,"#include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
 
 #include <iostream>
 #include <string>
 #include <unistd.h>
 
 #define MAX 26*60
 
 using namespace std;
 
 int compare(const void *a, const void *b) {
 	return ( *(int*)a - *(int*)b);
 }
 
 int main(int argc, char **argv) {
 
 int num, T, NA, NB;
 int k, n, p;
 string s;
 
 scanf(α%dα, &num);
 
 for(k=1;k<=num;k++) {
 
 	scanf(α%dα, &T);
 	scanf(α%d %dα, &NA, &NB);
 
 	int ha, ma, hb, mb;
 	int *fromA, *fromB, *toA, *toB;
 	int fA, tB, fB, tA;
 	int minA, minB, A, B;
 
 	fromA = (int *) malloc(sizeof(int) * (NA+1));
 	toB = (int *) malloc(sizeof(int) * (NA+1));
 	fromB = (int *) malloc(sizeof(int) * (NB+1));
 	toA = (int *) malloc(sizeof(int) * (NB+1));
 
 	for(n=0;n<NA;n++) {
 		scanf(α%d:%d %d:%dα, &ha, &ma, &hb, &mb);
 		//printf(αha:%d,ma:%d to hb:%d,mb:%dnα,ha,ma,hb,mb);
 		fromA[n] = ha * 60 + ma;
 		toB[n] = hb * 60 + mb + T;
 		//printf(αfromA[%d]=%d toB[%d]=%dnα, n,fromA[n],n,toB[n]);
 	}
 	fromA[NA] = toB[NA] = MAX; 
 
 	for(n=0;n<NB;n++) {
 		scanf(α%d:%d %d:%dα, &hb, &mb, &ha, &ma);
 		//printf(αha:%d,ma:%d to hb:%d,mb:%dnα,hb,mb,ha,ma);
 		fromB[n] = hb * 60 + mb;
 		toA[n] = ha * 60 + ma + T;
 		//printf(αfromB[%d]=%d toA[%d]=%dnα,n,fromB[n],n,toA[n]);
 	}
 	fromB[NB] = toA[NB] = MAX; 
 
 	qsort(fromA, NA, sizeof(int), compare);
 	qsort(toB, NA, sizeof(int), compare);
 	qsort(fromB, NB, sizeof(int), compare);
 	qsort(toA, NB, sizeof(int), compare);
 
 	fA=tB=fB=tA=0;
 	minA = minB = A = B = 0;
 
 	while(! (fA==NA && tB==NA && fB==NB && tA==NB)) {
 		//toB, arrived at B, toB is minimum of 4
 		if( toB[tB] <= fromA[fA] && toB[tB] <= fromB[fB] && toB[tB] <= toA[tA]) {
 			tB++;
 			B++;
 			//printf(αtoB[%d] = %d, B is %dnα,tB-1,toB[tB-1], B);
 		} else if (toA[tA] <= fromA[fA] && toA[tA] <= fromB[fB] && toA[tA] <= toB[tB]) {
 			tA++;
 			A++;
 			//printf(αtoA[%d] = %d, A is %dnα,tA-1,toA[tA-1], A);
 		} else if (fromA[fA] <= toB[tB] && fromA[fA] <= fromB[fB] && fromA[fA] <= toA[tA]) {
 			fA++;
 			A--;	
 			if(A < minA) minA = A;
 			//printf(αfromA[%d] = %d, A is %dnα,fA-1,fromA[fA-1], A);
 		} else if (fromB[fB] <= toB[tB] && fromB[fB] <= fromA[fA] && fromB[fB] <= toA[tA]) {
 			fB++;
 			B--;
 			if(B < minB) minB = B;
 			//printf(αfromB[%d] = %d, B is %dnα,fB-1,fromB[fB-1], B);
 		} else {
 
 			printf(αERRORnα);
 			return -1;
 		}
 
 //usleep(400);
 	}
 
 
 
 
 	cout << αCase #α << k << α: α << -minA << α α << -minB << endl;
 }
 
 } //main"
21241,2008,32013,aaditya,24480,1,SE.C,gcj/2008/32013/aaditya/24480/1/extracted/SE.C,"#include<stdio.h>
 #include<stdlib.h>
 int main()
 {
 	FILE *fp1,*fp2;
 	int s,q,qname[1000],i,j,n,se[100]={0},ans=0,nz=0,n1,k;
 	char sname[100][100],qnm[100];
 	fp1=fopen(αabc.inα,αrα);
 	fp2=fopen(αabc.outα,αwα);
 	fscanf(fp1,α%dα,&n);
 	n1=n;
 	while(n--)
 	{
 		ans=0;
 	   fscanf(fp1,α%dα,&s);
 	   for(i=0;i<s;i++)
 	   {
 		fgets(sname[i],100,fp1);
 		if(strcmp(sname[i],αnα)==0)i--;
 	   }
 	   fscanf(fp1,α%dα,&q);
 	   for(i=0;i<q;i++)
 	   {
 		fgets(qnm,100,fp1);
 		if(strcmp(qnm,αnα)==0){i--;continue;}
 		for(j=0;j<s;j++)
 		if(strcmp(qnm,sname[j])==0)
 		{
 			qname[i]=j;
 			break;
 		}
 	   }
 	   for(i=0;i<s;i++)
 	   se[i]=0;
 	   for(i=0;i<q;i++)
 	   {
 		se[qname[i]]=1;
 		nz=0;
 		for(j=0;j<s;j++)
 		if(se[j]==0){nz++;}
 		if(nz==0)
 		{
 			ans++;
 			for(k=0;k<s;k++)
 			se[k]=0;
 			i--;
 		}
 	   }
 	   fprintf(fp2,αCase #%d: %dnα,n1-n,ans);
 	}
 	fclose(fp1);
 	fclose(fp2);
 	return 0;
 }"
21243,2008,32013,aaditya,24481,1,TR.C,gcj/2008/32013/aaditya/24481/1/extracted/TR.C,"#include<stdio.h>
 #include<stdlib.h>
 int conv(char temp[10])
 {
 	int i=0,t=0,j=0;
 	char tmp1[3],tmp2[3];
 	while(temp[i]!=':')
 	{
 		tmp1[j++]=temp[i++];
 	}
 	tmp1[j]='0';
 	i++;
 	j=0;
 	while(temp[i]!='0')
 	{
 		tmp2[j++]=temp[i++];
 	}
 	tmp2[j]='0';
 	t=(atoi(tmp1)*60)+atoi(tmp2);
 	return t;
 }
 void sort(int nd[100][2],int n)
 {
 	int i,j,k,t1,t2;
 	for(i=0;i<n-1;i++)
 	{
 		for(j=0;j<n-i-1;j++)
 		{
 			if(nd[j][0]>nd[j+1][0])
 			{
 				t1=nd[j][0];
 				t2=nd[j][1];
 				nd[j][0]=nd[j+1][0];
 				nd[j][1]=nd[j+1][1];
 				nd[j+1][0]=t1;
 				nd[j+1][1]=t2;
 			}
 		}
 	}
 }
 int main()
 {
 	int n,t,na,nb,i,j,n1;
 	int nad[100][2],nbd[100][2];
 	int ca=0,cb=0;
 	int tna=0,tnb=0;
 	FILE *fp1,*fp2;
 	char temp[10];
 	fp1=fopen(αabc.txtα,αrα);
 	fp2=fopen(αabc.outα,αwα);
 	fscanf(fp1,α%dα,&n);
 	n1=n;
 	while(n--)
 	{       fscanf(fp1,α%d%d%dα,&t,&na,&nb);
 		i=0;
 		while(i!=na)
 		{
 			fscanf(fp1,α%sα,temp);
 			nad[i][0]=conv(temp);
 			fscanf(fp1,α%sα,temp);
 			nad[i][1]=conv(temp);
 			i++;
 		}
 		i=0;
 		while(i!=nb)
 		{
 			fscanf(fp1,α%sα,temp);
 			nbd[i][0]=conv(temp);
 			fscanf(fp1,α%sα,temp);
 			nbd[i][1]=conv(temp);
 			i++;
 		}
 		sort(nad,na);
 		sort(nbd,nb);
 		i=nad[0][0]<nbd[0][0]?nad[0][0]:nbd[0][0];
 		ca=0;cb=0;tna=0;tnb=0;
 		for(;i<24*60;i++)
 		{
 			for(j=0;j<na;j++)
 			{
 				if(nad[j][1]+t==i)
 				cb++;
 			}
 			for(j=0;j<nb;j++)
 			{
 				if(nbd[j][1]+t==i)
 				ca++;
 
 			}
 
 			for(j=0;j<na;j++)
 			{
 				if(nad[j][0]==i)
 				if(ca>=1)
 				ca--;
 				else
 				tna++;
 			}
 			for(j=0;j<nb;j++)
 			{
 				if(nbd[j][0]==i)
 				if(cb>=1)
 				cb--;
 				else
 				tnb++;
 			}
 		}
 		fprintf(fp2,αCase #%d: %d %dnα,n1-n,tna,tnb);
 	}
 	fclose(fp1);
 	fclose(fp2);
 	return 0;
 }"
21254,2008,32013,Valdson,24480,1,SavingTheUniverse.c,gcj/2008/32013/Valdson/24480/1/extracted/SavingTheUniverse.c,"/* Google Code Jam */
 /* Saving the Universe */
 
 #include <stdio.h>
 #include <string.h>
 
 #define MAX_LEN 100
 #define MAX_S 100
 
 int switches(int s, char search_engine[][MAX_LEN + 1], int q, char query[][MAX_LEN + 1]);
 
 int main (void) {
   int i, j, n, s, q;
   char search_engine[MAX_S][MAX_LEN + 1];
   char query[1000][MAX_LEN + 1];
   
   scanf(α%dα, &n);
   for (i = 1; i <= n; i++) {
     scanf(α%dnα, &s);
     for (j = 0; j < s; j++) gets(search_engine[j]);
     scanf(α%dnα, &q);
     for (j = 0; j < q; j++) gets(query[j]);
     printf(αCase #%d: %dnα, i, switches(s, search_engine, q, query));
   }
   return 0;
 }
 
 int switches(int s, char search_engine[][MAX_LEN + 1], int q, char query[][MAX_LEN + 1]) {
   int search_engine_rank[MAX_S];
   int i, j, max;
   
   for (i = 0; i < s; i++) {
     for (j = 0; j < q; j++) if (!strcmp(search_engine[i], query[j])) break;
     search_engine_rank[i] = j;
   }
   max = 0;
   for (i = 0; i < s; i++) {
     if (search_engine_rank[i] > max) max = search_engine_rank[i];
   }
   if (max == q) return 0;
   else return (1 + switches(s, search_engine, q - max, &query[max]));
 }"
21256,2008,32013,Valdson,24481,1,TrainTimetable.c,gcj/2008/32013/Valdson/24481/1/extracted/TrainTimetable.c,"/* Google Code Jam */
 /* Train Timetable */
 
 #include <stdio.h>
 
 int startTrainsAt(int departures, int departureTime[], int arrivals, int arrivalTime[], int t);
 void arraySort(int len, int array[]);
 
 int main (void) {
   int i, j, n, t, na, nb, hh, mm;
   int departureFromA[100];
   int arrivalToB[100];
   int departureFromB[100];
   int arrivalToA[100];
   
   scanf(α%dα, &n);
   for (i = 1; i <= n; i++) {
     scanf(α%d%d%dα, &t, &na, &nb);
     for (j = 0; j < na; j++) {
       scanf(α%d:%dα, &hh, &mm);
       departureFromA[j] = hh*60 + mm;
       scanf(α%d:%dα, &hh, &mm);
       arrivalToB[j] = hh*60 + mm;
     }
     for (j = 0; j < nb; j++) {
       scanf(α%d:%dα, &hh, &mm);
       departureFromB[j] = hh*60 + mm;
       scanf(α%d:%dα, &hh, &mm);
       arrivalToA[j] = hh*60 + mm;
     }
     printf(αCase #%d: %d %dnα,
             i,
             startTrainsAt(na, departureFromA, nb, arrivalToA, t),
             startTrainsAt(nb, departureFromB, na, arrivalToB, t) );
   }
   return 0;
 }
 
 int startTrainsAt(int departures, int departureTime[], int arrivals, int arrivalTime[], int t) {
   int i, j;
   int startTrains = 0;
   int arrivedTrains = 0;
   
   for (i = 0; i < arrivals; i++) arrivalTime[i] += t;
   arraySort(departures, departureTime);
   arraySort(arrivals, arrivalTime);
   j = 0;
   for (i = 0; i < departures; i++) {
     while ((j < arrivals) && (arrivalTime[j] <= departureTime[i])) {
         arrivedTrains++;
         j++;
     }
     if (arrivedTrains) arrivedTrains--;
     else startTrains++;
   }
   return startTrains;
 }
 
 void arraySort(int len, int array[]) {
   int i, j, aux;
   
   for (i = 1; i < len; i++) {
     aux = array[i];
     for (j = i - 1; (j >= 0) && (aux < array[j]); j--) array[j + 1] = array[j];
     array[j + 1] = aux;
   }
 }"
21297,2008,32013,dlisuk,24480,1,main.c,gcj/2008/32013/dlisuk/24480/1/extracted/main.c,"#include <stdio.h>
 #include <strings.h>
 
 struct searchEngine{
 	char id;
 	char name[101];
 	struct searchEngine * next;
 };
 
 void clearlist(struct searchEngine * root)
 {
 	struct searchEngine * curr, * next;
 	curr=root;
 	while(curr->next)
 	{
 		next=curr->next;
 		free(curr);
 		curr=next;
 	}
 }
 int main (int argc, const char * argv[]) {
 	int	N,n,S,s,Q,q,i, switches,t;
 	int * query, * engine;
 	char buff[101];
 	struct searchEngine * root,* curr;
 	FILE	*in;
 	in=fopen(αA-small-attempt0.inα,αrα);
 	fgets(buff,5,in);
 	sscanf(buff,α%dα,&N);
 	for(n=1;n<=N;n++)
 	{
 		switches=0;
 		fgets(buff,5,in);
 		sscanf(buff,α%dα,&S);
 		root=(struct searchEngine *)malloc(sizeof(struct searchEngine));
 		curr=root;
 		engine=(int *)calloc(S,sizeof(int));
 
 		for(s=0;s<S;s++)
 		{
 			engine[s]=-1;
 			curr->id=s;
 			fgets(curr->name,101,in);
 			if(s==S)
 			{
 				curr->next=malloc(sizeof(struct searchEngine));
 			}else{
 			curr->next=malloc(sizeof(struct searchEngine));
 			curr=curr->next;
 			}
 		}
 		fgets(buff,101,in);
 		sscanf(buff,α%dα,&Q);
 		query=(int *)calloc(Q,sizeof(int));
 		for(q=0;q<Q;q++)
 		{
 			curr=root;
 			fgets(buff,101,in);
 			for(s=0;s<S;s++)
 			{
 				if(!strcmp(buff,curr->name))
 				{
 					query[q]=curr->id;
 					s=S+1;
 				}
 				curr=curr->next;
 			}
 		}
 		for(q=0;q<Q;q++)
 		{
 			engine[query[q]]=1;
 			i=0;
 			for(s=0;s<S;s++)
 			{
 				if(engine[s]==-1)
 				{
 					i++;
 					s=S+1;
 				}
 			}	
 			if(i==0)
 			{
 				switches++;
 				for(s=0;s<S;s++)
 				{
 					engine[s]=-1;
 				}
 				q--;
 			}
 		}
 		printf(αCase #%d: %dnα,n,switches);
 		//scanf(α%dα,&t);
 		
 		free(query);
 		//clearlist(root);
 
 	}
 	return 0;
 }"
21400,2008,32013,Baiger,24480,1,a.c,gcj/2008/32013/Baiger/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAXCNT 101
 #define MAXLEN 110
 
 char names[MAXCNT][MAXLEN];
 int hash[1500];
 
 int calc_hash(char s[])
 {
      int sum = 0, i;
      for (i = 0; s[i] != '0'; i++)
 	  sum += s[i];
      return sum % 1000;
 }
 
 int main()
 {
      int n, i;
      scanf(α%dα, &n);
      for (i = 1; i <= n; i++) {
 	  int s, q, j;
 	  scanf(α%dnα, &s);
 	  memset(hash, 0, sizeof(hash));
 	  memset(names, 0, sizeof(names));
 	  for (j = 1; j <= s; j++) {
 	       int k, c;
 	       for (k = 0; (c=getchar()) != 'n'; k++)
 		    names[j][k] = c;
 	       int key = calc_hash(names[j]);
 	       while (hash[key] != 0)
 		    key++;
 	       hash[key] = j;
 	  }
 	  scanf(α%dnα, &q);
 	  int used[MAXCNT], cnt_used = 0, cnt_switch = 0;
 	  char query[MAXLEN];
 	  memset(used, 0, sizeof(used));
 	  for (j = 0; j < q; j++) {
 	       int k, c;
 	       for (k = 0; (c=getchar()) != 'n'; k++)
 		    query[k] = c;
 	       query[k] = '0';
 	       int key = calc_hash(query);
 	       while (hash[key] && strcmp(query, names[hash[key]]))
 		    key++;
 	       if (hash[key]) {
 		    cnt_used += 1-used[hash[key]];
 		    used[hash[key]] = 1;
 		    if (cnt_used == s) {
 			cnt_switch++;
 			cnt_used = 1;
 			memset(used, 0, sizeof(used));
 			used[hash[key]] = 1;
 		    }
 	       }
 	  }
 	  
 	  printf(αCase #%d: %dnα, i, cnt_switch);
      }
      
      return 0;
 }"
21402,2008,32013,Baiger,24481,1,b.c,gcj/2008/32013/Baiger/24481/1/extracted/b.c,"#include <stdio.h>
 
 #define MAXLEN 101
 
 int t, na, nb;
 int queue_a[MAXLEN], queue_b[MAXLEN];  /* queue[]: ready-to-leave time */
 int a, b, tail_a, tail_b, pa, pb;
 int a_dep[MAXLEN], a_arr[MAXLEN], b_dep[MAXLEN], b_arr[MAXLEN];
 
 void qsort(int a1[], int a2[], int p, int r)
 {
      int i = p, j = r;
      int key = a1[(p+r) >> 1];
      do {
 	  while (a1[i] < key) i++;
 	  while (a1[j] > key) j--;
 	  if (i <= j) {
 	       int tmp = a1[i]; a1[i] = a1[j]; a1[j] = tmp;
 	       tmp = a2[i]; a2[i] = a2[j]; a2[j] = tmp;
 	       i++; j--;
 	  }
      } while (i <= j);
      if (p < j) qsort(a1, a2, p, j);
      if (r > i) qsort(a1, a2, i, r);
 }
 
 int found(int queue[], int tail, int limit)
 {
      int i;
      for (i = 0; i <= tail; i++) {
 	  if (queue[i] <= limit)
 	       return i;
      }
      return -1;
 }
 
 void next_train()
 {
      int p;
 /*      if (na == 0) { */
 /* 	  if (tail_b == -1) b++; */
 /* 	  else if ((p=found(queue_b, tail_b, b_dep[pb])) == -1) b++; */
 /* 	  else { */
 /* 	       queue_b[p] = queue_b[tail_b]; */
 /* 	       tail_b--; */
 /* 	  } */
 /* 	  nb--; pb++; */
 /*      } else if (nb == 0) { */
 /* 	  if (tail_a == -1) a++; */
 /* 	  else if ((p=found(queue_a, tail_a, a_dep[pa])) == -1) a++; */
 /* 	  else { */
 /* 	       queue_a[p] = queue_a[tail_a]; */
 /* 	       tail_a--; */
 /* 	  } */
 /* 	  na--; pa++;	   */
 /*      } else { */
 	  if (nb == 0 || a_dep[pa] <= b_dep[pb]) {
 	       if (tail_a == -1 || (p=found(queue_a, tail_a, a_dep[pa])) == -1)
 		    a++;
 	       else {
 		    queue_a[p] = queue_a[tail_a];
 		    tail_a--;
 	       }
 	       tail_b++;
 	       queue_b[tail_b] = a_arr[pa]+t;
 	       na--; pa++;
 	  } else {
 	       if ((tail_b == -1) || ((p=found(queue_b, tail_b, b_dep[pb])) == -1))
 		    b++;
 	       else {
 		    queue_b[p] = queue_b[tail_b];
 		    tail_b--;
 	       }
 	       tail_a++;
 	       queue_a[tail_a] = b_arr[pb]+t;
 	       nb--; pb++;
 	  }
 /*      } */
 }
 
 int main()
 {
      int n, i;
      scanf(α%dα, &n);
      for (i = 1; i <= n; i++) {
 	  scanf(α%dn%d %dα, &t, &na, &nb);
 	  int j;
 	  int dep_h, dep_min, arr_h, arr_min;
 	  for (j = 0; j < na; j++) {
 	       scanf(α%d:%d %d:%dα, &dep_h, &dep_min, &arr_h, &arr_min);
 	       a_dep[j] = dep_h*60 + dep_min;
 	       a_arr[j] = arr_h*60 + arr_min;
 	  }
 	  a_dep[na] = 2400;
 	  for (j = 0; j < nb; j++) {
 	       scanf(α%d:%d %d:%dα, &dep_h, &dep_min, &arr_h, &arr_min);
 	       b_dep[j] = dep_h*60 + dep_min;
 	       b_arr[j] = arr_h*60 + arr_min;
 	  }
 	  b_dep[nb] = 2400;
 	  qsort(a_dep, a_arr, 0, na-1);
 	  qsort(b_dep, b_arr, 0, nb-1);
 	  a = b = pa = pb = 0;
 	  tail_a = tail_b = -1;
 	  for (j = 0; na+nb > 0; j++)
 	       next_train();
 	  printf(αCase #%d: %d %dnα, i, a, b);
      }
      
      return 0;
 }"
21477,2008,32013,rascal2210,24481,1,tt.c,gcj/2008/32013/rascal2210/24481/1/extracted/tt.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define A	0
 #define B	1
 #define STATIONS 2
 
 typedef struct activeTrain* activeTrainPtr;
 typedef struct scheduleEntry* scheduleEntryPtr;
 
 struct activeTrain {
 	int destination; // A or B
 	int arriveMinute; // from 00:00
 	activeTrainPtr next; // in our list
 };
 
 struct scheduleEntry {
 	int origin; // A or B
 	int destination; // A or B
 	int departMinute; // from 00:00
 	int arriveMinute; // from 00:00
 	scheduleEntryPtr next; // in our list
 };
 
 int turnaroundTime;
 int newTrainCounter[STATIONS];
 int idleTrainCounter[STATIONS];
 
 struct activeTrain inRouteListHeader;
 struct activeTrain inTurnaroundListHeader;
 struct scheduleEntry scheduleListHeader;
 
 int readInt(int, int, char*);
 void addTripToScheduleList(int, int);
 
 void
 resetGlobalData()
 {
 	int i;
 	turnaroundTime = 0;
 	for(i = 0; i < STATIONS; i++) {
 		newTrainCounter[i] = 0;
 		idleTrainCounter[i] = 0;
 	}
 	inRouteListHeader.next = 0;
 	inTurnaroundListHeader.next = 0;
 	scheduleListHeader.next = 0;
 }
 
 main()
 {
 	int i;
 	int m;
 	int id;
 	int trip;
 	int N; // number of cases
 	int NA; // number of trips from A to B
 	int NB; // number of trips from B to A
 	activeTrainPtr p;
 	activeTrainPtr t;
 	scheduleEntryPtr e;
 
 	N = readInt(1, 100, αcasesα);
 
 	for(id = 0; id < N; id++) {
 		resetGlobalData();
 		turnaroundTime = readInt(0, 60, αturnaround timeα);
 		NA = readInt(0, 100, αNAα);
 		NB = readInt(0, 100, αNBα);
 		for(trip = 0; trip < NA; trip++) {
 			addTripToScheduleList(A, B); // from A to destination B
 		}
 		for(trip = 0; trip < NB; trip++) {
 			addTripToScheduleList(B, A); // from B to destination A
 		}
 		// process days until stable train count
 		int prevNewTrainCounter[STATIONS];
 		for(;;) {
 
 			// Save previous counts
 			for(i = 0; i < STATIONS; i++) {
 				prevNewTrainCounter[i] = newTrainCounter[i];
 			}
 
 			for(m = 0; m < (24*60); m++) {
 
 				// check for trains arriving at a station
 				p = &inRouteListHeader;
 				while(p->next) {
 					if(p->next->arriveMinute == m) {
 						t = p->next;
 						p->next = t->next;
 						t->arriveMinute = (t->arriveMinute + turnaroundTime) % (24*60);
 						t->next = inTurnaroundListHeader.next;
 						inTurnaroundListHeader.next = t;
 					} else {
 						p = p->next;
 					}
 				}
 
 				// check for trains ready to leave turnaround
 				t = &inTurnaroundListHeader;
 				while(t->next) {
 					if(t->next->arriveMinute == m) {
 						idleTrainCounter[t->next->destination] += 1;
 						t->next = t->next->next; // delete it
 					} else {
 						t = t->next;
 					}
 				}
 
 				// check for trains ready to depart
 				for(e = scheduleListHeader.next; e; e = e->next) {
 					if(e->departMinute == m) {
 						if(idleTrainCounter[e->origin] > 0) {
 							idleTrainCounter[e->origin] -= 1;
 						} else {
 							newTrainCounter[e->origin] += 1;
 						}
 						p = (activeTrainPtr) malloc(sizeof(struct activeTrain));
 						p->destination = e->destination;
 						p->arriveMinute = e->arriveMinute;
 						p->next = inRouteListHeader.next;
 						inRouteListHeader.next = p;
 					}
 				}
 			}
 			// Check previous counts
 			for(i = 0; i < STATIONS; i++) {
 				if(prevNewTrainCounter[i] != newTrainCounter[i]) {
 					break;
 				}
 			}
 			if(i != STATIONS) {
 				break;
 			}
 		}
 		printf(αCase #%d: %d %dnα, id + 1, newTrainCounter[A], newTrainCounter[B]);
 	}
 }
 
 int
 readInt(int lo, int hi, char* what)
 {
 	int n;
 	int c = scanf(α %d nα, &n);
 
 	if(c != 1) {
 		printf(αscanf returned %d instead of 1 for %snα, c, what);
 		exit(1);
 	}
 	if(n < lo) {
 		printf(αscanf read %d, less than %d, for %snα, n, lo, what);
 		exit(1);
 	}
 	if(n > hi) {
 		printf(αscanf read %d, greater than %d, for %snα, n, hi, what);
 		exit(1);
 	}
 	return n;
 }
 
 void
 addTripToScheduleList(int origin, int destination)
 {
 	int c;
 	int departHH;
 	int departMM;
 	int arriveHH;
 	int arriveMM;
 
 	c = scanf(α %d:%d %d:%d nα, &departHH, &departMM, &arriveHH, &arriveMM);
 
 	if(c != 4) {
 		printf(αscanf returned %d instead of 4 for schedule entrynα, c);
 		exit(1);
 	}
 	if(departHH < 0 || departHH > 23) {
 		printf(αscanf return %d for departHHnα, departHH);
 		exit(1);
 	}
 	if(departMM < 0 || departMM > 59) {
 		printf(αscanf return %d for departMMnα, departMM);
 		exit(1);
 	}
 	if(arriveHH < 0 || arriveHH > 23) {
 		printf(αscanf return %d for arriveHHnα, arriveHH);
 		exit(1);
 	}
 	if(arriveMM < 0 || arriveMM > 59) {
 		printf(αscanf return %d for arriveMMnα, arriveMM);
 		exit(1);
 	}
 	if(arriveHH < departHH) {
 		printf(αscanf return arriveHH %d less than departHH %dnα, arriveHH, departHH);
 		exit(1);
 	}
 	if(arriveHH == departHH && arriveMM <= departMM) {
 		printf(αscanf return arriveMM %d is not after departMM %dnα, arriveMM, departMM);
 		exit(1);
 	}
 
 	scheduleEntryPtr trip = (scheduleEntryPtr) malloc(sizeof(struct scheduleEntry));
 	trip->origin = origin;
 	trip->destination = destination;
 	trip->departMinute = (departHH * 60) + departMM;
 	trip->arriveMinute = (arriveHH * 60) + arriveMM;
 	trip->next = scheduleListHeader.next;
 	scheduleListHeader.next = trip;
 }"
21528,2008,32013,Shivani,24480,1,saving_the_universe.c,gcj/2008/32013/Shivani/24480/1/extracted/saving_the_universe.c,"#include <stdio.h>
 
 char **search_engine ;
 char **query;
 int *first_index;
 
 int engines_cnt;
 int queries_cnt;
 FILE * fp_in;
 FILE * fp_out;
 unsigned int case_cnt;
 
 void small_input();
 void large_input();
 void take_input();
 void free_input();
 void create_engines();
 void create_queries();
 int find_first_index(int start_query);
 void compute_switches();
 void initialize_first_index();
 
 int main(int argc, char * argv[])
 {
     if (argc < 2){
 	     printf (αUsage for small input: nameOfExecutable snα);
 	     printf (αUsage for large input: nameOfExecutable lnα);
              printf(α(Help: first argument should be αsα for small inputs and αlα for large inputs)nα);
 	     printf(αnPlease make sure that the input file is in the current directorynα);
 	     printf(αnPlease make sure that the output file can be created in the current directorynα);
              exit(0);
     }
     if ( 's' == argv[1][0] || 'S' == argv[1][0]){
          small_input();
          return 0;
     }
     else if ('l' == argv[1][0] || 'L' == argv[1][0]){
          large_input();
          return 0;
          }         
 }
 void small_input()
 {
         
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./A-small.inα,αrα);
 
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file A-small.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./A-small.outα,αwα);
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file A-small.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute_switches();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
 	 return;
 }
 void large_input()
 {
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./A-large.inα,αrα);
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file A-large.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./A-large.outα,αwα);
 
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file A-large.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute_switches();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
         
 }
 void take_input()
 {
 	int i = 0;
 	size_t size = 0;
 	fscanf(fp_in,α%dα,&engines_cnt);
 	create_engines();
 	fgetc(fp_in);
 	for (i = 0; i < engines_cnt; i++)
 	{
 		fscanf(fp_in,α%[^rn]sα,search_engine[i]);
 	        fgetc(fp_in);
 	}
 	fscanf(fp_in,α%dα,&queries_cnt);
 	create_queries();
 	fgetc(fp_in);
 	for (i = 0; i < queries_cnt; i++)
 	{
 		fscanf(fp_in,α%[^rn]sα,query[i]);
 	        fgetc(fp_in);
 	}
 
      return;
 }
 
 void create_engines()
 {
 	int i = 0;
 	search_engine = (char **)malloc (sizeof(char *) * engines_cnt);
 	for (i = 0; i < engines_cnt; i++)
 	{
 		search_engine[i] = (char *) malloc (101*sizeof(char));
 		memset((void *)search_engine[i],'0', sizeof(char)*101);
 	}
 	first_index = ( int *) malloc(engines_cnt*sizeof(int));
 	initialize_first_index();
 	return;	
 }
 
 void initialize_first_index()
 {
 	int i = 0;
 	for (i = 0; i < engines_cnt; i++)
 	{
 		first_index[i] = -1;
 	}
 	return;
 }
 void create_queries()
 {
 	int i = 0;
 	query = (char **)malloc (sizeof(char *) * queries_cnt);
 	for (i = 0; i < queries_cnt; i++)
 	{
 		query[i] = (char *) malloc (101*sizeof(char));
 		memset((void *)query[i],'0', sizeof(char)*101);
 	}
 }
 void free_input()
 {
 	int i = 0;
 
 	for (i = 0; i < engines_cnt ; i++)
 	{
 		free (search_engine[i]);
 	}
 	free (search_engine);
 	free (first_index);
 
 	for (i = 0; i < queries_cnt; i++)
 	{
 		free (query[i]);
 	}
 	free(query);
 }
 
 void compute_switches()
 {
 	int start_query = 0;
 	int max = 0;
 	unsigned int switches = 0;
 
 	while(1)
 	{
 	max = find_first_index(start_query);
 	start_query = max;
 	if (max == -1)
 	{
 		break;
 	}
 	else 
 	{
 		switches++;
 	}
 	initialize_first_index();
 	}
 	fprintf(fp_out,αCase #%u: %unα,case_cnt,switches);
 	return;
 	
 }
 
 int find_first_index(int start_query)
 {
 	int i = 0;
 	int max = 0;
 	int j = 0;
 
 	for (i  = start_query; i < queries_cnt; i++)
 	{
 	     for (j = 0; j < engines_cnt; j++)
 	     {
 		     if (0 == strcmp(query[i],search_engine[j]))
 		     {
 			     if (-1 == first_index[j])
 			     {
 			     first_index[j] = i;
 			     if (max < i) max = i;
 			     }
 			     break;
 		     }
 	     }	     
 	}
 	
 	for (j = 0; j < engines_cnt; j++)
 	{
 		if (first_index[j] == -1)
 			return -1;
 	}
 	return max;
 }"
21530,2008,32013,Shivani,24481,1,train_timetable.c,gcj/2008/32013/Shivani/24481/1/extracted/train_timetable.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int T;
 int NA;
 int NB;
 
 typedef struct {
 	int hour;
 	int min;
 }time_st;
 
 typedef struct {
 	time_st dep_time;
 	time_st arrv_time;
 	int is_done;
 }trip;
 
 trip * trip_A_B;
 trip * trip_B_A;
 
 typedef struct {
 	int cnt;
 	time_st *earliest_time;
 }avail_trains;
 
 avail_trains avail_trains_A;
 avail_trains avail_trains_B;
 
 FILE * fp_in;
 FILE * fp_out;
 unsigned int case_cnt;
 
 void small_input();
 void large_input();
 void take_input();
 void free_input();
 
 int find_train_avail(avail_trains *avail_train_info, time_st dep_time);
 void update_train_avail(trip * trip_info,avail_trains *avail_train_info);
 int get_earliest_trip (int *p_is_A_B);
 void compute_trains();
 void fill_trip(char *dep_time, char * arr_time,trip* trip_arr,int index);
 void create_fill_trips();
 
 int main(int argc, char * argv[])
 {
     if (argc < 2){
 	     printf (αUsage for small input: nameOfExecutable snα);
 	     printf (αUsage for large input: nameOfExecutable lnα);
              printf(α(Help: first argument should be αsα for small inputs and αlα for large inputs)nα);
 	     printf(αnPlease make sure that the input file is in the current directorynα);
 	     printf(αnPlease make sure that the output file can be created in the current directorynα);
              exit(0);
     }
     if ( 's' == argv[1][0] || 'S' == argv[1][0]){
          small_input();
          return 0;
     }
     else if ('l' == argv[1][0] || 'L' == argv[1][0]){
          large_input();
          return 0;
          }         
 }
 void small_input()
 {
         
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./B-small.inα,αrα);
 
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file B-small.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./B-small.outα,αwα);
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file B-small.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute_trains();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
 	 return;
 }
 void large_input()
 {
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./B-large.inα,αrα);
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file B-large.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./B-large.outα,αwα);
 
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file B-large.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute_trains();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
         
 }
 void take_input()
 {
 	int i = 0;
 	fscanf(fp_in,α%dα,&T);
 	fscanf(fp_in,α%d %dα,&NA, &NB);
 	create_fill_trips();
      return;
 }
 
 void create_fill_trips()
 {
 	int i = 0;
 	char trip_dep_time[6];
 	char trip_arr_time[6];
 	trip_A_B = (trip *) malloc (NA * sizeof(trip));
 	trip_B_A = (trip *) malloc (NB * sizeof(trip));
 
 	for (i = 0; i < NA; i++)
 	{
 		fscanf(fp_in,α%sα,trip_dep_time);
 		fscanf(fp_in,α%sα,trip_arr_time);
 		fill_trip(trip_dep_time,trip_arr_time,trip_A_B, i);
 	}
 	for (i = 0; i < NB; i++)
 	{
 		fscanf(fp_in,α%sα,trip_dep_time);
 		fscanf(fp_in,α%sα,trip_arr_time);
 		fill_trip(trip_dep_time,trip_arr_time,trip_B_A, i);
 	}
 	avail_trains_A.earliest_time = (time_st *)malloc((NA+NB)*sizeof(time_st));
 	avail_trains_B.earliest_time = (time_st *)malloc((NA+NB)*sizeof(time_st));
 	avail_trains_A.cnt = 0;
 	avail_trains_B.cnt = 0;
 
 
 
 }
 void free_input()
 {
 	NA = 0;
 	NB = 0;
 	free(trip_A_B);
 	free(trip_B_A);
 	free(avail_trains_A.earliest_time);
 	free(avail_trains_B.earliest_time);
 	return ;
 }
 
 void fill_trip(char *dep_time, char * arr_time,trip* trip_arr,int index)
 {
 	int ihour = 0, imin = 0;
 	char hour[3],min[3];
 
 	hour[0]= dep_time[0];
 	hour[1]= dep_time[1];
 	hour[2]= '0';
 	min[0]=dep_time[3];
 	min[1]=dep_time[4];
 	min[2]='0';
 	ihour = atoi(hour);
 	imin = atoi(min);
 	trip_arr[index].dep_time.hour = ihour;
 	trip_arr[index].dep_time.min = imin;
 
 	hour[0]= arr_time[0];
 	hour[1]= arr_time[1];
 	hour[2]= '0';
 	min[0]=arr_time[3];
 	min[1]=arr_time[4];
 	min[2]='0';
 	ihour = atoi(hour);
 	imin = atoi(min);
 	trip_arr[index].arrv_time.hour = ihour;
 	trip_arr[index].arrv_time.min = imin;
 	trip_arr[index].is_done = 0;
 
 }
 void compute_trains()
 {	
        int is_A_B = 0;
        int index = 0;       
        int is_avail = 0;
        int train_cnt_A = 0;
        int train_cnt_B = 0;
 
        while(1)
        { 
        index = get_earliest_trip(&is_A_B);
 
        if (-1 == index)
        {
 	       break;
        }
        if (is_A_B == 1)
        {
 	       is_avail = find_train_avail(&avail_trains_A,trip_A_B[index].dep_time);
 	       if (0 == is_avail)
 	       {
 	       train_cnt_A++;
 	       }
 	       trip_A_B[index].is_done = 1;
 	       update_train_avail(&trip_A_B[index],&avail_trains_B);
 
        }
        if (is_A_B == 0)
        {
 	       is_avail = find_train_avail(&avail_trains_B, trip_B_A[index].dep_time);
 	       if (0 == is_avail)
 	       {
 	       train_cnt_B++;
 	       }
 	       trip_B_A[index].is_done = 1;
 	       update_train_avail(&trip_B_A[index],&avail_trains_A);
 
        }
        }
        fprintf(fp_out,αCase #%u: %d %dnα,case_cnt,train_cnt_A,train_cnt_B);
 
 }
 
 int get_earliest_trip (int *p_is_A_B)
 {
 	time_st mintime = {24,60};
 	int min_index = -1;
 	int hour = 0;
 	int min = 0;
 
 	int i = 0;
 
 	for (i = 0; i < NA; i++)
 	{
 		if (trip_A_B[i].is_done == 0)
 		{
 			hour = trip_A_B[i].dep_time.hour;
 			min = trip_A_B[i].dep_time.min;
 			if ((hour < mintime.hour) ||
 			((hour == mintime.hour)&&(min < mintime.min)		))
 			{
 				mintime.hour =  hour;
 				mintime.min = min;
 				min_index =i;
 				*p_is_A_B = 1;
 			}
 		}
 	}
 	for (i = 0; i < NB; i++)
 	{
 		if (trip_B_A[i].is_done == 0)
 		{
 			hour = trip_B_A[i].dep_time.hour;
 			min = trip_B_A[i].dep_time.min;
 			if ((hour < mintime.hour) ||
 			((hour == mintime.hour)&&(min < mintime.min))		)
 			{
 				mintime.hour =  hour;
 				mintime.min = min;
 				min_index =i;
 				*p_is_A_B = 0;
 			}
 		}
 	}
 	return min_index;
 
 }
 
 int find_train_avail(avail_trains *avail_train_info, time_st dep_time)
 {
 	int i = 0,j = 0;
 	int cnt  = avail_train_info->cnt;
 	time_st *earliest_time = avail_train_info->earliest_time;
 	
 	if (0 == cnt )
 		return 0;
 	else 
 	{
 		for (i = 0;i<cnt ; i++)
 		{
 			if ((earliest_time[i].hour < dep_time.hour)||
 			((earliest_time[i].hour==dep_time.hour)&&
 			 (earliest_time[i].min <= dep_time.min)))
 			{
 				avail_train_info->cnt--;
 				for (j = i;j<cnt-1; j++)
 				{
 				earliest_time[j].hour = 
 					earliest_time[j+1].hour;
 				earliest_time[j].min = 
 					earliest_time[j+1].min;
 				}
 				return 1;
 			}
 		}
 		return 0;
 	}
 }
 void update_train_avail(trip * trip_info,avail_trains *avail_train_info)
 {
 	int dep_time_hour = trip_info->arrv_time.hour;
 	int dep_time_min = trip_info->arrv_time.min+T;
 	int q =0,r=0;
 	int cnt = 0;
 	if (dep_time_min >= 60)
 	{
 		q=dep_time_min/60;
 		r=dep_time_min%60;
 		dep_time_hour+=q;
 		dep_time_min=r;
 	}
 	avail_train_info->cnt++;
 	cnt = avail_train_info->cnt;
 	avail_train_info->earliest_time[cnt-1].hour=dep_time_hour;
 	avail_train_info->earliest_time[cnt-1].min=dep_time_min;
 }"
21710,2008,32013,dshashank1,24480,1,universe1.c,gcj/2008/32013/dshashank1/24480/1/extracted/universe1.c,"#include<stdio.h>
 #include<string.h>
 main()
 {
 int tc,i,j,a,c,switches,ori,maxd,maxdi;
 int se[21],q[21],dse[101];
 char sen[101][21][101],qn[1001][21][101];
 scanf(α%dα,&tc);
 for(i=1;i<=tc;i++)
         {
         scanf(α%dα,&se[i]);
         for(j=0;j<=se[i];j++)
                 gets(&sen[j][i]);
         scanf(α%dα,&q[i]);
         for(j=0;j<=q[i];j++)
                 gets(&qn[j][i]);
 	}
 printf(αn6α);
 
 for(a=1;a<=tc;a++)
 {
 	switches=-1;
 	ori=1;
 	while(ori<=q[a])
 	{
 		maxd=0;
 		for(i=1;i<=se[a];i++)
 			{
 			dse[i]=1001;
 			for(j=ori;j<=q[a];j++)
 				if(strcmp(sen[i][a],qn[j][a])==0)
 					{
 					dse[i]=j;
 					break;
 					}
 			if(dse[i]>maxd) 
 				{
 				maxd=dse[i];
 				maxdi=i;
 				}
 			}
 		switches++;
 		ori=maxd;
 	}
 	if(switches==-1) printf(αnCase #%d: %dα,a,switches+1);
 	else printf(αnCase #%d: %dα,a,switches);
 }
 }"
21730,2008,32013,ChachaB,24480,1,problemA.c,gcj/2008/32013/ChachaB/24480/1/extracted/problemA.c,"#include <stdio.h>
 #include <stdlib.h>
 
 
 int main(int argc, char **argv)
 {
 	FILE			*in;
 	FILE			*out;
 	unsigned long	num_cases;
 	unsigned long	num_engines;
 	unsigned long	num_queries;
 	unsigned long	num_switches;
 	unsigned long	cur_case;
 	unsigned long	i;
 	unsigned long	q;
 	char			str[1001];
 	char			*engines[100];
 	unsigned long	queries[1000];
 	char			engines_cflag[100];
 	unsigned long	count_engines;
 
 	if(argc < 3)
 		return 0;
 	
 	in = fopen(argv[1], αrα);
 	out = fopen(argv[2], αwα);
 
 	if(!in || !out)
 	{
 		if(in)
 			fclose(in);
 		if(out)
 			fclose(out);
 		return 0;
 	}
 
 	fscanf(in, α%lunα, &num_cases);
 
 	for(cur_case = 0; cur_case < num_cases; cur_case++)
 	{
 		fscanf(in, α%lunα, &num_engines);
 		for(i = 0; i < num_engines; i++)
 		{
 			fgets(str, 1001, in);
 			engines[i] = (char*)malloc(strlen(str) + 1);
 			strcpy(engines[i], str);
 		}
 
 		fscanf(in, α%lunα, &num_queries);
 		for(i = 0; i < num_queries; i++)
 		{
 			fgets(str, 1001, in);
 			for(q = 0; q < num_engines && strcmp(str, engines[q]); q++);
 			queries[i] = q;
 		}
 	
 		memset(engines_cflag, 0, num_engines);
 		count_engines = 0;
 		num_switches = 0;
 
 		for(i = 0; i < num_queries; i++)
 		{
 			if(queries[i] == num_engines || engines_cflag[queries[i]])
 				continue;
 			count_engines++;
 			if(count_engines == num_engines)
 			{
 				count_engines = 1;
 				num_switches++;
 				memset(engines_cflag, 0, num_engines);
 			}
 			engines_cflag[queries[i]] = 1;
 		}
 
 		fprintf(out, αCase #%lu: %lunα, cur_case + 1, num_switches);
 
 		for(i = 0; i < num_engines; i++)
 			free(engines[i]);
 	}
 
 	fclose(in);
 	fclose(out);
 	return 1;
 }"
21732,2008,32013,ChachaB,24479,1,problemC.c,gcj/2008/32013/ChachaB/24479/1/extracted/problemC.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 #ifndef M_PI_4
 #define M_PI_4      0.785398163397448309116
 #endif
 
 int main(int argc, char **argv)
 {
 	FILE			*in;
 	FILE			*out;
     unsigned int    num_cases;
     unsigned int    cur_case;
     double          f;
     double          R;
     double          R_m;
     double          t;
     double          r;
     double          g;
     double          d;
     double          x;
     double          x_max;
     double          x_max_y;
     double          y;
     double          y_max;
     double          y_max_full;
     double          s;
     double          s_hit;
     double          a;
     double          acosx;
     double          acosy;
 
 	if(argc < 3)
         return 0;
 
 	in = fopen(argv[1], αrα);
 	out = fopen(argv[2], αwα);
 
 	if(!in || !out)
 	{
 		if(in)
 			fclose(in);
 		if(out)
 			fclose(out);
 		return 0;
 	}
 
     fscanf(in, α%unα, &num_cases);
 
 	for(cur_case = 0; cur_case < num_cases; cur_case++)
 	{
         fscanf(in, α%lf %lf %lf %lf %lfnα, &f, &R, &t, &r, &g);
 
         a = g - f * 2;
         if(a <= 0)
         {
             fprintf(out, αCase #%u: %.7fnα, cur_case + 1, (float)1.);
             continue;
         }
 
         s = M_PI_4 * R * R;
         s_hit = s;
         d = g + 2 * r;
         R_m = R - t - f;
         x_max = sqrt(R_m * R_m - (r + f) * (r + f));
 
         for(x = r + f; x < x_max; x += d)
         {
             y_max = sqrt(R_m * R_m - x * x);
             y_max_full = -1.;
             if(x + a < R_m)
                 y_max_full = sqrt(R_m * R_m - (x + a) * (x + a)) - a - r - f + d;
             if(y_max_full >= d)
             {
                 s_hit -= a * a * floor(y_max_full / d);
                 y = r + f + d * floor(y_max_full / d);
             }
             else
                 y = r + f;
 
             acosx = acos(x / R_m);
             for(; y < y_max; y += d)
             {
                 x_max_y = sqrt(R_m * R_m - y * y);
                 acosy = acos(y / R_m);
                 s_hit -= (x * y + ((acosx + acosy) / 2 -  M_PI_4) * R_m * R_m - (y_max * x + x_max_y * y) / 2);
                 if(y + a < y_max)
                     s_hit += (x * (y + a) + ((acosx + acos((y + a) / R_m)) / 2 -  M_PI_4) * R_m * R_m - (y_max * x + sqrt(R_m * R_m - (y + a) * (y + a)) * (y + a)) / 2);
                 if(x + a < x_max_y)
                     s_hit += ((x + a) * y + ((acos((x + a) / R_m) + acosy) / 2 -  M_PI_4) * R_m * R_m - (sqrt(R_m * R_m - (x + a) * (x + a)) * (x + a) + x_max_y * y) / 2);
             }
         }
         fprintf(out, αCase #%u: %.7lfnα, cur_case + 1, s_hit / s);
 	}
 
 	fclose(in);
 	fclose(out);
 	return 1;
 }"
21734,2008,32013,ChachaB,24481,1,problemB.c,gcj/2008/32013/ChachaB/24481/1/extracted/problemB.c,"#include <stdio.h>
 #include <stdlib.h>
 
 
 int main(int argc, char **argv)
 {
 	FILE			*in;
 	FILE			*out;
     unsigned int    num_cases;
     unsigned int    cur_case;
     unsigned int    na;
     unsigned int    nb;
     unsigned int    a;
     unsigned int    b;
     unsigned int    t;
     unsigned int    i;
     unsigned int    hd;
     unsigned int    md;
     unsigned int    ha;
     unsigned int    ma;
     unsigned int    *ad;
     unsigned int    *aa;
     unsigned int    *bd;
     unsigned int    *ba;
     unsigned int    sa;
     unsigned int    sb;
 
 	if(argc < 3)
 		return 0;
 
 	in = fopen(argv[1], αrα);
 	out = fopen(argv[2], αwα);
 
 	if(!in || !out)
 	{
 		if(in)
 			fclose(in);
 		if(out)
 			fclose(out);
 		return 0;
 	}
 
     fscanf(in, α%unα, &num_cases);
 
 	for(cur_case = 0; cur_case < num_cases; cur_case++)
 	{
         fscanf(in, α%unα, &t);
         fscanf(in, α%u %unα, &na, &nb);
 
         ad = (unsigned int*)malloc(na * sizeof(unsigned int));
         aa = (unsigned int*)malloc(na * sizeof(unsigned int));
         bd = (unsigned int*)malloc(nb * sizeof(unsigned int));
         ba = (unsigned int*)malloc(nb * sizeof(unsigned int));
 
         if(!ad || !aa || !bd || !ba)
         {
             printf(αmalloc errornα);
             return 0;
         }
 
         for(a = 0; a < na; a++)
 		{
             fscanf(in, α%u:%u %u:%unα, &hd, &md, &ha, &ma);
             ad[a] = hd * 60 + md;
             aa[a] = ha * 60 + ma;
 		}
 
         for(b = 0; b < nb; b++)
 		{
             fscanf(in, α%u:%u %u:%unα, &hd, &md, &ha, &ma);
             bd[b] = hd * 60 + md;
             ba[b] = ha * 60 + ma;
 		}
 
         for(a = 0; (a + 1) < na; a++)
         {
             md = a;
             ma = a;
             for(i = a + 1; i < na; i++)
             {
                 if(ad[i] < ad[md])
                     md = i;
                 if(aa[i] < aa[ma])
                     ma = i;
             }
             b = aa[a];
             aa[a] = aa[ma];
             aa[ma] = b;
             b = ad[a];
             ad[a] = ad[md];
             ad[md] = b;
         }
 
         for(b = 0; (b + 1) < nb; b++)
         {
             md = b;
             ma = b;
             for(i = b + 1; i < nb; i++)
             {
                 if(bd[i] < bd[md])
                     md = i;
                 if(ba[i] < ba[ma])
                     ma = i;
             }
             a = ba[b];
             ba[b] = ba[ma];
             ba[ma] = a;
             a = bd[b];
             bd[b] = bd[md];
             bd[md] = a;
         }
 
         sa = 0;
         sb = 0;
 
         for(a = b = 0; a < na; a++)
         {
             if(b == nb || ad[a] < (ba[b] + t))
                 sa++;
             else
                 b++;
         }
 
         for(a = b = 0; b < nb; b++)
         {
             if(a == na || bd[b] < (aa[a] + t))
                 sb++;
             else
                 a++;
         }
 
         fprintf(out, αCase #%u: %u %unα, cur_case + 1, sa, sb);
 
         free(ad);
         free(aa);
         free(bd);
         free(ba);
 	}
 
 	fclose(in);
 	fclose(out);
 	return 1;
 }"
21800,2008,32013,iNFINITEi,24480,1,main.c,gcj/2008/32013/iNFINITEi/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int main(int argc, char *argv[])
 {
   int s[30],q[30];
   int i,j,k,n,check;
   char ser[25][110][50];
   int visit[110];
   int switches;
   char qer[25][1010][50];
   
   scanf(α%dα,&n);
   for(j=1;j<=n;j++)
   {
    scanf(α%dα,&s[j]);
    for(i=0;i<=s[j];i++)
    {
     gets(ser[j][i]);
    }
    scanf(α%dα,&q[j]);
    for(i=0;i<=q[j];i++)
    {
     gets(qer[j][i]);
    }
   }
   for(j=1;j<=n;j++)
   {
                   for(i=1;i<=s[j];i++)
                   {
                    visit[i]=0;
                   }
                   k=1;
                   switches=0;
                   while(k<=q[j])
                   {
                                 
                    for(i=1;i<=s[j];i++)
                    {
                                       if(strcmp(qer[j][k],ser[j][i])==0)
                                       {
                                        visit[i]=1;
                                         break;
                                       }
                    }
    
                    check=1;
                    for(i=1;i<=s[j];i++)
                    {
                     if(visit[i]==0)
                     {
                      check=0;
                       break;
                     }
                    }
                    
                    if(check==1)
                    {
                             
                             switches++;
                             for(i=1;i<=s[j];i++)
                             {
                                                visit[i]=0;
                                                
                             }
                    }
                    else
                    {
                     k++;
                    }
                   } 
   printf(αCase #%d: %dnα,j,switches);
   }
   
   return 0;
 }"
21850,2008,32013,ziqi,24481,1,B.c,gcj/2008/32013/ziqi/24481/1/extracted/B.c,"/****************************************************************************************************************/
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 typedef struct 
 {
 	int time;
 	int aToB;
 	int arrivalAtB;
 }tp;
 
 int PARTITION(tp* A, int p, int r)		//ⶨA[p...r]һмֵpivotrearrangeСpivotA[p...q-1]УpivotA[q+1...r]
 {
 	int i = 0;	//ҪֵjA[p...r-1]i¼qӦõλ
 	int j = 0;
 	int pivot = 0;	//洢A[r]
 	tp temp;	//swap
 
 	pivot = A[r].time;
 	i = p - 1;	//pΪ0ʱiΪ-1շصi+1϶ڵ0
 	for(j = p; j < r; j++)
 	{
 		if(A[j].time <= pivot)
 		{
 			i++;
 			
 			memcpy(&temp, &A[j], sizeof(tp));
 			memcpy(&A[j], &A[i], sizeof(tp));
 			memcpy(&A[i], &temp, sizeof(tp));
 		}
 	}
 	i++;	//qλ
 	
 	memcpy(&temp, &A[i], sizeof(tp));
 	memcpy(&A[i], &A[r], sizeof(tp));
 	memcpy(&A[r], &temp, sizeof(tp));
 
 	return i;
 }
 
 void QUICKSORT(tp* A, int p, int r)
 {
 	int q = 0;
 
 	if(p < r)	//p >= rʱ
 	{
 		q = PARTITION(A, p, r);
 		QUICKSORT(A, p, q - 1);
 		QUICKSORT(A, q + 1, r);
 	}
 }
 
 int XOR(int a, int b)
 {
 	if(a == 0 && b == 0)
 		return 0;
 	else if(a == 0 && b == 1)
 		return 1;
 	else if(a == 1 && b == 0)
 		return 1;
 	else
 		return 0;
 }
 
 int PARTITION1(tp* A, int p, int r)		//ⶨA[p...r]һмֵpivotrearrangeСpivotA[p...q-1]УpivotA[q+1...r]
 {
 	int i = 0;	//ҪֵjA[p...r-1]i¼qӦõλ
 	int j = 0;
 	int pivot = 0;	//洢A[r]
 	tp temp;	//swap
 
 	pivot = XOR(A[r].aToB, A[r].arrivalAtB);
 	i = p - 1;	//pΪ0ʱiΪ-1շصi+1϶ڵ0
 	for(j = p; j < r; j++)
 	{
 		if((XOR(A[j].aToB, A[j].arrivalAtB)) <= pivot)
 		{
 			i++;
 			
 			memcpy(&temp, &A[j], sizeof(tp));
 			memcpy(&A[j], &A[i], sizeof(tp));
 			memcpy(&A[i], &temp, sizeof(tp));
 		}
 	}
 	i++;	//qλ
 	
 	memcpy(&temp, &A[i], sizeof(tp));
 	memcpy(&A[i], &A[r], sizeof(tp));
 	memcpy(&A[r], &temp, sizeof(tp));
 
 	return i;
 }
 
 void QUICKSORT1(tp* A, int p, int r)
 {
 	int q = 0;
 
 	if(p < r)	//p >= rʱ
 	{
 		q = PARTITION1(A, p, r);
 		QUICKSORT1(A, p, q - 1);
 		QUICKSORT1(A, q + 1, r);
 	}
 }
 /********
 #define MAX_QUEUE_SIZE	402
 typedef struct
 {
 	tp* Array[MAX_QUEUE_SIZE];
 	int head;
 	int tail;
 }QUEUE_A;
 
 void EnQueue(QUEUE_A* queue, tp* x)
 {
 	if(queue->tail == (queue->head - 1) || ((queue->tail == MAX_QUEUE_SIZE - 1) && (queue->head == 0)))
 	{
 		puts(αoverflownα);
 		return;
 	}
 	queue->Array[queue->tail] = x;
 	if(queue->tail == MAX_QUEUE_SIZE - 1)
 	{
 		queue->tail = 0;
 	}
 	else
 		queue->tail++;
 }
 
 tp* DeQueue(QUEUE_A* queue)
 {
 	if(queue->head == queue->tail)
 	{
 		puts(αunderflownα);
 		return NULL;
 	}
 	tp* res = queue->Array[queue->head];
 	if(queue->head == MAX_QUEUE_SIZE - 1)
 	{
 		queue->head = 0;
 	}
 	else
 		queue->head++;
 
 	return res;
 }
 
 int isEmpty(QUEUE_A* queue)
 {
 	if(queue->head == queue->tail)
 		return 1;
 	else
 		return 0;
 }
 
 tp* peek(QUEUE_A* queue)
 {
 	return queue->Array[queue->head];
 }
 ***************************/
 #define PARENT(i)	((i) / 2)
 #define LEFT(i)		(2 * (i))
 #define RIGHT(i)	((2 * (i)) + 1)
 
 #define MAX_HEAP_SIZE	402
 typedef struct 
 {
 	tp* A[MAX_HEAP_SIZE];		//ָָҪ
 	int heap_size;	//Ԫصĸ
 	int length;		//Ԫصĸ
 }HEAP;
 
 #define MAX_NUM 3000
 void MIN_HEAPIFY(HEAP* h, int i)		//i, l, r, largestΪ
 {
 	int l = 0;
 	int r = 0;
 	int min = 0;		//¼ֵ
 	tp* temp = NULL;
 
 	l = LEFT(i + 1) - 1;	//ܴڵӵ
 	r = RIGHT(i + 1) - 1;	//ܴڵҺӵ
 
 	if(l < h->heap_size && h->A[i]->time > h->A[l]->time)
 		min = l;
 	else
 		min = i;
 	if(r < h->heap_size && h->A[min]->time > h->A[r]->time)
 		min = r;
 
 	if(min != i)
 	{
 		temp = h->A[min];
 		h->A[min] = h->A[i];
 		h->A[i] = temp;
 
 		MIN_HEAPIFY(h, min);	//Զµݹ
 	}
 }
 
 tp* HEAP_EXTRACT_MIN(HEAP* h)
 {
 	tp* min = NULL;
 	
 	if(h->heap_size < 1)
 	{
 		puts(αheap underflownα);
 		return NULL;
 	}
 
 	min = h->A[0];
 	h->A[0] = h->A[h->heap_size - 1];
 	h->heap_size--;
 	MIN_HEAPIFY(h, 0);
 	
 	return min;
 }
 
 void HEAP_DECREASE_KEY(HEAP* h, int i, int key)
 {
 	tp* temp = NULL;
 	
 	if(key > h->A[i]->time)
 	{
 		puts(αnew key is bigger than current keynα);
 		return;
 	}
 
 	h->A[i]->time = key;
 	while(i > 0 && h->A[i]->time < h->A[PARENT(i + 1) - 1]->time)
 	{
 		temp = h->A[i];	//swap
 		h->A[i] = h->A[PARENT(i + 1) - 1];
 		h->A[PARENT(i + 1) - 1] = temp;
 
 		i = PARENT(i + 1) - 1;
 	}
 }
 
 void MIN_HEAP_INSERT(HEAP* h, tp* ele)
 {
 	int key = ele->time;
 	h->heap_size++;
 	h->A[h->heap_size - 1] = ele;
 	h->A[h->heap_size - 1]->time = MAX_NUM;
 	HEAP_DECREASE_KEY(h, h->heap_size - 1, key);
 }
 
 tp* MIN_HEAP_PEEK(HEAP* h)
 {
 	return h->A[0];
 }
 
 int isHeapEmpty(HEAP* h)
 {
 	if(h->heap_size == 0)
 		return 1;
 	else
 		return 0;
 }
 
 int timeSat(tp* comp, tp* qEle, int T)
 {	
 	int x = ((comp->time)%100) - ((qEle->time)%100);
 	if(x < 0)
 	{
 		x = 60 + x%60;
 		x = x + ((comp->time)/100 - (qEle->time)/100) * 60 - 60;
 	}
 	else
 	{
 		x = x + ((comp->time)/100 - (qEle->time)/100) * 60;
 	}
 	
 	if(x >= T)
 		return 1;
 	else
 		return 0;
 }
 
 int main()
 {
 	freopen(αB-large.inα,αrα,stdin);
 	freopen(αoutput.txtα,αwα,stdout);
 	int N = 0;
 	int T = 0;
 	int NA = 0;	//A to B
 	int NB = 0;	//B to A
 	scanf(α%dα, &N);// Will read from the input.in
 	int i = 0;
 	int j = 0;
 	int k = 0;
 	char strFrom[6];
 	char strTo[6];
 	tp A[401];
 	int AIndex = 0;
 	tp tmp;
 
 	int ANum = 0;
 	int BNum = 0;
 
 //	QUEUE_A QA;	//ͣA
 //	QUEUE_A QB;
 	HEAP heapA;
 	HEAP heapB;
 
 	for(k = 0; k < N; k++)
 	{
 		memset(A, 0, sizeof(tp) * 401);
 		AIndex = 0;
 		ANum = 0;
 		BNum = 0;
 //		QA.head = 0;
 //		QA.tail = 0;
 //		QB.head = 0;
 //		QB.tail = 0;
 		heapA.heap_size = 0;
 		heapA.length = 0;
 		heapB.heap_size = 0;
 		heapB.length = 0;
 		scanf(α%dα, &T);
 		scanf(α%d%dα, &NA, &NB);
 		for(j = 0; j < NA; j++)
 		{
 			scanf(α%s%sα, strFrom, strTo);
 			memcpy(&strFrom[2], &strFrom[3], 3);
 			tmp.time = atoi(strFrom);
 			tmp.aToB = 1;
 			tmp.arrivalAtB = 0;
 			memcpy(&A[AIndex], &tmp, sizeof(tp));
 			AIndex++;
 
 			memcpy(&strTo[2], &strTo[3], 3);
 			tmp.time = atoi(strTo);
 			tmp.aToB = 1;
 			tmp.arrivalAtB = 1;
 			memcpy(&A[AIndex], &tmp, sizeof(tp));
 			AIndex++;
 		}
 		for(j = 0; j < NB; j++)
 		{
 			scanf(α%s%sα, strFrom, strTo);
 			memcpy(&strFrom[2], &strFrom[3], 3);
 			tmp.time = atoi(strFrom);
 			tmp.aToB = 0;
 			tmp.arrivalAtB = 1;
 			memcpy(&A[AIndex], &tmp, sizeof(tp));
 			AIndex++;
 
 			memcpy(&strTo[2], &strTo[3], 3);
 			tmp.time = atoi(strTo);
 			tmp.aToB = 0;
 			tmp.arrivalAtB = 0;
 			memcpy(&A[AIndex], &tmp, sizeof(tp));
 			AIndex++;
 		}
 		//2Ԫtuple(time, aToB^arrivalAtB)
 		QUICKSORT(A, 0, --AIndex);
 		for(i = 0; i <= AIndex; i++)
 		{
 			int start = i;
 			int end = 0;
 			while (A[i].time == A[i + 1].time && i < AIndex)
 			{
 				i++;
 			}
 			end = i;
 			if(start < end)
 			{
 				QUICKSORT1(A, start, end);
 			}
 		}
 
 		//ʼɨ
 		for(i = 0; i < AIndex + 1; i++)
 		{
 			if(A[i].aToB && !A[i].arrivalAtB)	//a to b, a
 			{
 				if(isHeapEmpty(&heapA))		//ûavailable
 				{
 					ANum++;
 				}
 				else if(timeSat(&A[i], MIN_HEAP_PEEK(&heapA), T))	//ʱ
 				{
 					HEAP_EXTRACT_MIN(&heapA);
 				}
 				else
 				{
 					ANum++;
 				}
 			}
 			else if(A[i].aToB && A[i].arrivalAtB)	//a to b , b
 			{
 				MIN_HEAP_INSERT(&heapB, &A[i]);	//Ѿпĳˣ¼ͣb
 			}
 			else if(!A[i].aToB && A[i].arrivalAtB)	//b to a, zai b
 			{
 				if(isHeapEmpty(&heapB))
 				{
 					BNum++;
 				}
 				else if(timeSat(&A[i], MIN_HEAP_PEEK(&heapB), T))
 				{
 					HEAP_EXTRACT_MIN(&heapB);
 				}
 				else
 				{
 					BNum++;
 				}
 			}
 			else if(!A[i].aToB && !A[i].arrivalAtB)		//b to a, zai a
 			{
 				MIN_HEAP_INSERT(&heapA, &A[i]);		//пճͣa
 			}
 		}
 
 		printf(αCase #%d: %d %dnα, k + 1, ANum, BNum);
 	}
 	
 	return 0;
 }"
22043,2008,32013,mochikun,24480,1,stu.c,gcj/2008/32013/mochikun/24480/1/extracted/stu.c,"#include<stdio.h>
 #include<string.h>
 
 int main(){
    int n, s, q;
    int i,j,k,l;
    int change;
    int now;
    int count;
    char gomi[10];
 
    scanf(α%dα,&n);
    for(i = 0;i < n;i++){
 	  change = 0;
 	  now = -1;
 	  count = 0;
 
 	  scanf(α%dα,&s);
 	  fgets(gomi,sizeof(gomi),stdin);
 	  char name[120][250];
 	  int match[120];
 	  for(j = 0; j < s; j++){
 		 fgets(name[j],sizeof(name[j]),stdin);
 		 match[j] = 1;
 	  }
 
 	  scanf(α%dα,&q);
 	  fgets(gomi,sizeof(gomi),stdin);
 	  for(k = 0; k < q; k++){
 		 char query[250];
 		 fgets(query,sizeof(query),stdin);
 		 for (l = 0; l < s; l++){
 			if (strcmp(name[l], query) == 0){
 			   if(now == l){
 				  continue;
 			   }
 			   if(match[l] == 1){
 				  match[l] = 0;
 				  ++count;
 				  if(count == s){
 					 now = l;
 					 change++;
 					 count=1;
 					 for(j = 0; j < s; j++){
 						match[j] = 1;
 					 }
 				  }
 				  break;
 			   }
 			}
 		 }
 	  }
 
 	  printf(αCase #%d: %dnα, i+1, change);
    }
 }"
22045,2008,32013,mochikun,24481,1,tt.c,gcj/2008/32013/mochikun/24481/1/extracted/tt.c,"#include<stdio.h>
 
 int getTime(){
    int time;
    time=(getchar()-48)*600;
    time+=(getchar()-48)*60;
    getchar();
    time+=(getchar()-48)*10;
    time+=getchar()-48;
    return time;
 }
 
 int checkTime(int stop, int start){
    return start - stop;
 }
 
 int main(){
    int n,t,na,nb;
    int i,j,k,l;
    int ma,mb;
    int acnt,bcnt;
    int alast,blast;
    int big;
 
    scanf(α%dα,&n);
    
    for(i=0;i<n;i++){
 	  ma=0;mb=0;
 	  alast=0;blast=0;
 
 	  scanf(α%dα,&t);
 	  scanf(α%d %dα,&na, &nb);
 	  getchar();
 
 	  if(na < nb){
 		 big=nb;
 	  }else{
 		 big=na;
 	  }
 
 	  int astart[na];
 	  int astop[na];
 	  int bstart[nb];
 	  int bstop[nb];
 	  int alist[big];
 	  int blist[big];
 
 	  for(j=1;j<=big;j++){
 		 alist[j]=0;
 		 blist[j]=0;
 	  }
 
 	  for(j=0;j<na;j++){
 		 astart[j]=getTime();
 		 getchar();
 		 astop[j]=getTime();
 		 getchar();
 	  }
 
 	  for(k=0;k<nb;k++){
 		 bcnt=0;
 
 		 bstart[k]=getTime();
 		 getchar();
 		 bstop[k]=getTime();
 		 getchar();
 
 		 for(l=0;l<na;l++){
 			if(checkTime(astop[l],bstart[k])>=t){
 			   bcnt++;
 			}
 		 }
 		 if(bcnt > 0){
 			blist[bcnt]++;
 		 }
 	  }
 
 	  for(j=0;j<na;j++){
 		 acnt=0;
 
 		 for(l=0;l<nb;l++){
 			if(checkTime(bstop[l],astart[j])>=t){
 			   acnt++;
 			}
 		 }
 		 if(acnt > 0){
 			alist[acnt]++;
 		 }
 	  }
 
 	  for(j=1;j<=big;j++){
 		 if(alist[j] >= 1){
 			alast = j;
 			if(alist[j] >= j){
 			   ma += j;
 			}else{
 			   ma += alist[j];
 			}
 			if(ma > j){
 			   ma = j;
 			}
 		 }
 		 if(blist[j] >= 1){
 			blast = j;
 			if(blist[j] >= j){
 			   mb += j;
 			}else{
 			   mb += blist[j];
 			}
 			if(mb > j){
 			   mb = j;
 			}
 		 }
 	  }
 
 	  printf(αCase #%d: %d %dnα,i+1,na-ma,nb-mb);
    }
 }"
22105,2008,32013,Bharat.Jain,24480,1,schedule.c,gcj/2008/32013/Bharat.Jain/24480/1/extracted/schedule.c,"#include <stdio.h>
 
 #define MAX_ENGINES     110
 #define MAX_ENGINES_LEN 110
 #define MAX_SEARCH_WORDS 1100
 
 char engines[MAX_ENGINES][MAX_ENGINES_LEN] ;
 char search_words[MAX_SEARCH_WORDS][MAX_ENGINES_LEN] ;
 int  engine_flag[MAX_ENGINES] ;
 
 void print_input(int num_engines, int num_words) 
 {
 	int i=0 ;
 
 	printf(αnnEngines:nα) ;
 	for(i=0; i<num_engines; i++)
 	{
 		printf(α%sα, engines[i]) ;
 	}
 
 	printf(αnnWords:nα) ;
 	for(i=0; i<num_words; i++)
 	{
 		printf(α%sα, search_words[i]) ;
 	}
 
 	return ;
 }
 
 void init_engine_flag(int num_engines)
 {
 	int i=0;
 
 	for(i=0; i<num_engines; i++)
 	{
 		engine_flag[i] = 0 ;
 	}
 
 	return ;
 }
 
 int calculate_num_changes(int num_engines, int num_words)
 {
 	int i=0, j=0;
 	int output=0;
 	int num_engines_marked = 0 ;
 
 	for(i=0; i<num_words; i++)
 	{
 		for(j=0; j<num_engines; j++)
 		{	
 			if(strcmp(search_words[i], engines[j]) == 0)
 			{
 				if(engine_flag[j] == 0)
 				{
 					num_engines_marked++ ;
 					engine_flag[j] = 1 ;
 				}
 				break ;
 			}
 		}
 		if(num_engines_marked == num_engines)
 		{
 			output++ ;
 			init_engine_flag(num_engines) ;
 			engine_flag[j] = 1 ;	
 			num_engines_marked = 1 ;
 		}
 
 	}
 	
 	return output ;	
 }
 
 
 int main()
 {
 	int num_cases = 0 ;
 	int i=0, j=0 ;
 
 	scanf(α%dα, &num_cases) ;
 
 	for(i=0; i<num_cases; i++)
 	{
 		int num_engines=0, num_words=0, output=0;
 
 		scanf(α%dnα, &num_engines) ;
 		for(j=0; j<num_engines; j++)
 		{
 			fgets(engines[j], MAX_ENGINES_LEN-1, stdin) ;
 		}
 
 		scanf(α%dnα, &num_words) ;
 		for(j=0; j<num_words; j++)
 		{
 			fgets(search_words[j], MAX_ENGINES_LEN-1, stdin) ;
 		}
 		// print_input(num_engines, num_words) ;
 
 		init_engine_flag(MAX_ENGINES) ;
 		output = calculate_num_changes(num_engines, num_words) ;
 		printf(αCase #%d: %dnα, i+1, output) ;
 	}
 	return 0 ;
 }"
22107,2008,32013,Bharat.Jain,24481,1,trains.c,gcj/2008/32013/Bharat.Jain/24481/1/extracted/trains.c,"#include <stdio.h>
 
 #define MAX_TRAINS 110
 #define NUM_SECONDS_IN_MINUTE 60
 
 #define POINT_A 0
 #define POINT_B 1
 #define INFINITE_TIME (24*60*60+1000)
 
 typedef struct __schedule__ 
 {
 	int departure ;
 	int arrival ;
 } schedule ;
 
 schedule trains_input[2][MAX_TRAINS] ;
 
 int trains_at_station[2][MAX_TRAINS] ;
 int train_counts[2] = {0,0};
 int output[2] = {0, 0} ;
 
 int init()
 {
 	int i=0;
 	for(i=0; i<MAX_TRAINS; i++)
 	{
 		trains_at_station[0][i] = 0 ; 
 		trains_at_station[1][i] = 0 ; 
 	}
 	train_counts[0] =  0;
 	train_counts[1] =  0;
 
 	return ;
 }
 
 int compare(void *elem1, void *elem2)
 {
 	schedule *x1 = (schedule*) elem1 ; 
 	schedule *x2 = (schedule*) elem2 ; 
 
 	return x1->departure - x2->departure ;
 }
 
 int find_if_already_existing_train(int starting_point, int departure_time)
 {
 	int i=0 ;
 
 	for(i=0; i<train_counts[starting_point]; i++)
 	{
 		if(trains_at_station[starting_point][i] <= departure_time)
 			return i ;
 	}
 	return -1 ;
 }
 
 void calculate_num_trains_starting(int numA, int numB)
 {
 	int total_schedules = numA + numB ;
 	int index[2] = {0, 0} ;
 	int i=0, starting_point=0, ending_point=0, arrival_time=0, departure_time=0;
 	int foundIndex = 0 ;
 
 	qsort(trains_input[0], numA, sizeof(schedule), compare) ;
 	qsort(trains_input[1], numB, sizeof(schedule), compare) ;
 
 	output[0] = 0 ;
 	output[1] = 0 ;
 	for(i=0; i<total_schedules; i++)
 	{
 		if((index[0] < numA && index[1] == numB) || (index[0] < numA && (trains_input[0][index[0]].departure <= trains_input[1][index[1]].departure)))
 		{
 			starting_point = POINT_A ;	
 			ending_point = POINT_B ;
 			departure_time = trains_input[0][index[0]].departure ;
 			arrival_time = trains_input[0][index[0]].arrival ;
 		}
 		else
 		{
 			starting_point = POINT_B ;
 			ending_point = POINT_A ;
 			departure_time = trains_input[1][index[1]].departure ;
 			arrival_time = trains_input[1][index[1]].arrival ;
 		}
 
 		foundIndex = find_if_already_existing_train(starting_point, departure_time) ;
 		if(foundIndex == -1)
 		{
 			output[starting_point] ++ ;
 		}
 		else
 		{
 			trains_at_station[starting_point][foundIndex] = INFINITE_TIME ;
 		}
 
 		trains_at_station[ending_point][train_counts[ending_point]] = arrival_time ;
 		train_counts[ending_point]++ ; 
 		index[starting_point]++ ;
 	}
 
 }
 
 
 int main()
 {
 	int num_cases = 0 ;
 	int i=0, j=0 ;
 
 	scanf(α%dα, &num_cases) ;
 
 	for(i=0; i<num_cases; i++)
 	{
 		int wait_time=0, numA=0, numB=0 ;
 		int start_hour, start_min, end_hour, end_min ;
 
 		init() ;
 
 		scanf(α%dα, &wait_time) ;
 		scanf(α%d %dα, &numA, &numB) ;
 
 		for(j=0; j<numA; j++)
 		{
 			scanf(α%d:%d %d:%dα, &start_hour, &start_min, &end_hour, &end_min) ;
 			trains_input[0][j].departure = (start_hour * NUM_SECONDS_IN_MINUTE) + start_min ;
 			trains_input[0][j].arrival = (end_hour * NUM_SECONDS_IN_MINUTE) + end_min + wait_time ;
 		}
 
 		for(j=0; j<numB; j++)
 		{
 			scanf(α%d:%d %d:%dα, &start_hour, &start_min, &end_hour, &end_min) ;
 			trains_input[1][j].departure = (start_hour * NUM_SECONDS_IN_MINUTE) + start_min ;
 			trains_input[1][j].arrival = (end_hour * NUM_SECONDS_IN_MINUTE) + end_min + wait_time ;
 		}
 
 		// print_input(numA, numB) ;
 		calculate_num_trains_starting(numA, numB) ;
 	
 		printf(αCase #%d: %d %dnα, i+1, output[0], output[1]) ;
 
 	}
 	
 	return 0 ;
 }"
22109,2008,32013,Plaps,24480,1,saving.c,gcj/2008/32013/Plaps/24480/1/extracted/saving.c,"#include <stdio.h>
 #include <stdlib.h>
 
 void switches()
 {
     int S,Q;
     int i,j;
 
     char engines[100][103];
     int searches[1000];
 
     int min[1000][100];
     //    int prev;
 
     scanf(α%dα,&S);
     fgets(engines[0],102,stdin);
 
     for (i = 0; i < S; i++) {
 	fgets(engines[i],102,stdin);
     }
 
     scanf(α%dα,&Q);
     fgets(engines[i],102,stdin);
     for (i = 0; i < Q; i++) {
 	int j;
 	char buf[102];
 	fgets(buf,102,stdin);
 
 	for (j = 0; j < S; j++) {
 	    if (strcmp(buf, engines[j]) == 0) {
 		searches[i] = j;
 		break;
 	    }
 	}
 	if (j == S) printf(αWhat?!nα);
     }
 
     for (i = 0; i < S; i++) {
 	min[0][i] = 0;
     }
     min[0][searches[0]] = 1;
     
     for (j = 1; j < Q; j++) {
 	for (i = 0; i < S; i++) {
 	    if (i == searches[j]) {
 		int m;
 		int lastmin = 1000;
 		for (m = 0; m < S; m++) {
 		    if (i == m) continue;
 
 		    if (lastmin > min[j-1][m])
 			lastmin = min[j-1][m];
 		}
 		min[j][i] = 1 + lastmin;
 	    }
 	    else
 		min[j][i] = min[j-1][i];
 	}
     }
 
     int lastmin = 1000;
     for (i = 0; i < S; i++) {
 	if (lastmin > min[j-1][i])
 	    lastmin = min[j-1][i];
     }
     printf(α%dnα,lastmin);
 }
 
 int main(int argc, char *argv[])
 {
     int cases;
     int i;
 
     scanf(α%dα, &cases);
     for (i = 0; i < cases; i++) {
 	printf(αCase #%d: α,(i+1));
 	switches();
     }
 
     return 0;
 }"
22111,2008,32013,Plaps,24479,1,racket.c,gcj/2008/32013/Plaps/24479/1/extracted/racket.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 // find size of circle segment
 double segment(double xa, double ya, double xb, double yb, double R)
 {
     double aang = atan2(ya, xa);
     double bang = atan2(yb, xb);
 
     double ang = (bang - aang);
 
     double area = R * R / 2 * (ang - sin(ang));
 
     return area;
 }
 
 double rect(double x1, double y1, double x2, double y2,
 	    double R, double g)
 {
     if (x2*x2 + y2*y2 < R*R) {
 	return g*g;
     }
     else {
 	//find intersection
 	double intercept;
 	double xa,ya,xb,yb;
 	int a,b;
 
 	intercept = sqrt(R*R - x2*x2);
 	//	printf(αFirst int: %lfnα,intercept);
 	if (x2 > R || intercept < y1) {
 	    xa = sqrt(R*R - y1*y1);
 	    ya = y1;
 	    a = 0;
 	}
 	else {
 	    xa = x2;
 	    ya = intercept;
 	    a = 1;
 	}
 
 	intercept = sqrt(R*R - y2*y2);
 	//	printf(αSecond int: %lfnα,intercept);
 	if (y2 > R || intercept < x1) {
 	    yb = sqrt(R*R - x1*x1);
 	    xb = x1;
 	    b = 0;
 	}
 	else {
 	    yb = y2;
 	    xb = intercept;
 	    b = 1;
 	}
 
 	//	printf(αIntercepts are (%lf,%lf) and (%lf,%lf)nα,xa,ya,xb,yb);
 	
 	if (a && b) {
 	    //	    printf(αCase 1nα);
 	    return g*g - (y2-ya)*(x2 - xb)/2 + segment(xa,ya,xb,yb,R);
 	}
 	else if (!a && !b) {
 	    //	    printf(αCase 2nα);
 	    return (yb - y1)*(xa - x1)/2 + segment(xa,ya,xb,yb,R);
 	}
 	else if (!a && b) {
 	    //	    printf(αCase 3nα);
 	    return (xa + xb - 2*x1)*(y2-y1)/2 + segment(xa,ya,xb,yb,R);
 	}
 	else if (a && !b) {
 	    //	    printf(αCase 4nα);
 	    return (ya + yb - 2*y1)*(x2-x1)/2 + segment(xa,ya,xb,yb,R);
 	}
     }
 }
 
 void area()
 {
     double f,R,t,r,g;
     double area;
 
     double x1,y1;
     double x2,y2;
 
     double prob;
 
     scanf(α%lf %lf %lf %lf %lfα,&f,&R,&t,&r,&g);
 
     //    printf(α%lf %lf %lf %lf %lfnα,f,R,t,r,g);
 
     // inflate obstacles
     t = t + f;
     r = r + f;
     g = g - 2*f;
 
     //    printf(α%lf %lf %lf %lf %lfnα,f,R,t,r,g);
     //    printf(α%lfnα, R-t);
     if (g <= 0) {
 	printf(α%lfnα,1.0);
 	return;
     }
 
     //    printf(α%lfnα,rect(0,0.5,0.5,2,1,2));
     //    return;
 
     area = M_PI*R*R/4.0;
 
     x1 = r;
     while (x1 < (R - t)) {
 	y1 = r;
 	while (y1 < (R - t)) {
 	    double a;
 	    if (x1*x1 + y1*y1 > (R-t)*(R-t))
 		break;
 	    
 	    x2 = x1 + g;
 	    y2 = y1 + g;
 
 	    a = rect(x1,y1,x2,y2,(R-t),g);
 	    area -= a;
 	    //	    printf(αRect at ((%lf,%lf),(%lf,%lf)) with area %lfnα,x1,x2,y1,y2,a);
 
 	    y1 += g + 2*r;
 	}
 	x1 += g + 2*r;
     }
 
     prob = area/(M_PI*R*R/4.0);
     printf(α%lfnα,prob);
 }
 
 int main(int argc, char *argv[])
 {
     int cases;
     int i;
 
     scanf(α%dα, &cases);
     for (i = 0; i < cases; i++) {
 	printf(αCase #%d: α,(i+1));
 	area();
     }
 
     return 0;
 }"
22113,2008,32013,Plaps,24481,1,train.c,gcj/2008/32013/Plaps/24481/1/extracted/train.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define DEPART_A 3
 #define DEPART_B 4
 #define ARRIVE_A 1
 #define ARRIVE_B 2
 
 void schedule()
 {
     int T;
     int NA, NB;
     int na, nb;
     int ca, cb;
     int i,j;
     
     int *times;
     int *event;
 
     scanf(α%dα,&T);
     scanf(α%d %dα,&NA,&NB);
 
     times = (int *)malloc(2*(NA+NB)*sizeof(int));
     event = (int *)malloc(2*(NA+NB)*sizeof(int));
 
     j = 0;
     for (i = 0; i < NA; i++) {
 	int h,m;
 	
 	scanf(α%d:%dα,&h,&m);
 	times[j] = h*60+m;
 	event[j] = DEPART_A;
 	j++;
 
 	scanf(α%d:%dα,&h,&m);
 	times[j] = h*60+m+T;
 	event[j] = ARRIVE_B;
 	j++;
     }
 
     for (i = 0; i < NB; i++) {
 	int h,m;
 	
 	scanf(α%d:%dα,&h,&m);
 	times[j] = h*60+m;
 	event[j] = DEPART_B;
 	j++;
 
 	scanf(α%d:%dα,&h,&m);
 	times[j] = h*60+m+T;
 	event[j] = ARRIVE_A;
 	j++;
     }
 
     // sort
     for (i = 1; i < 2*(NA+NB); i++) {
 	int t = times[i];
 	int e = event[i];
 
 	for (j = (i-1); j >= 0 && (times[j] > t || (times[j] == t && event[j] > e)); j--) {
 	    times[j+1] = times[j];
 	    event[j+1] = event[j];
 	}
 	times[j+1] = t;
 	event[j+1] = e;
     }
 
     //    for (i = 0; i < 2*(NA+NB); i++)
     //	printf(α%dnα,event[i]);
 
     na = 0; nb = 0;
     ca = 0; cb = 0;
     for (i = 0; i < 2*(NA+NB); i++) {
 	switch (event[i]) {
 	case DEPART_A: if (ca == 0) na++; else ca--; break;
 	case DEPART_B: if (cb == 0) nb++; else cb--; break;
 	case ARRIVE_A: ca++; break;
 	case ARRIVE_B: cb++; break;
 	default: printf(αWhat?nα);
 	}
     }
 
     printf(α%d %dnα,na,nb);
 }
 
 int main(int argc, char *argv[])
 {
     int cases;
     int i;
 
     scanf(α%dα, &cases);
     for (i = 0; i < cases; i++) {
 	printf(αCase #%d: α,(i+1));
 	schedule();
     }
 
     return 0;
 }"
22136,2008,32013,Shadowhhl,24480,1,UNI.C,gcj/2008/32013/Shadowhhl/24480/1/extracted/UNI.C,"#include <stdio.h>
 #include <string.h>
 
 #define EngineName_length 100
 #define EngineName_Number 100
 #define Keyword_Number 1000
 
 char SearchEngineName[EngineName_Number][EngineName_length];
 char Keyword_list[Keyword_Number][EngineName_length];
 int n_EngineName, n_Keyword_list;
 
 int MinTrans(int s)
 {
     int i, max, count, k;
     k=s;
     if (Keyword_list[s][0]=='0') return 0;
     else
     {
         max=0;
         for (i=0;i<n_EngineName;i++)
         {
             count=0;
             s=k;
 			while(strcmp(SearchEngineName[i], Keyword_list[s])!=0 && Keyword_list[s][0]!='0')
             {
                 count++;
                 s++;
             }
 			if (count>max) max=count;
         }
 		if (max==n_Keyword_list-k) return 0;
 		else return 1+MinTrans(k+max);
     }
 }
 
 main()
 {
     int n, i, cond;
     FILE *fp, *out;
     fp=fopen(αc:\tc\codejam\A-large.inα, αrα);
     out=fopen(αc:\tc\codejam\A-large.outα, αwα);
     fscanf(fp,α%dα, &n);
     cond=1;
     while (n-->0)
     {
         fscanf(fp,α%dα, &n_EngineName);
         fgetc(fp);
         for(i=0;i<n_EngineName;i++) fgets(SearchEngineName[i],EngineName_length, fp);
         for (i=n_EngineName;i<EngineName_Number;i++) SearchEngineName[i][0]='0';
         fscanf(fp,α%dα, &n_Keyword_list);
         fgetc(fp);
         for (i=0;i<n_Keyword_list;i++) fgets(Keyword_list[i], EngineName_length, fp);
         for (i=n_Keyword_list;i<Keyword_Number;i++) Keyword_list[i][0]='0';
         fprintf(out, αCase #%d: %dnα, cond++, MinTrans(0));
     }
 }
 "
22138,2008,32013,Shadowhhl,24481,1,c.c,gcj/2008/32013/Shadowhhl/24481/1/extracted/c.c,"#include <stdio.h>
 
 #define TRAINMAX 100
 #define USED 1
 #define NOTUSED 0
 
 struct ttable{
     int leave, arrive;
     int u;
  }AB[TRAINMAX], BA[TRAINMAX];
  
 int na, nb;
 FILE *in, *out;
 
 int HtoM(void)
 {
 	int a, temp;
 	fscanf(in,α%dα, &a);
 	fgetc(in);
 	a*=60;
 	fscanf(in,α%dα, &temp);
 	a+=temp;
 	return a;
 }
 
 void BubbleSort(int n, struct ttable a[TRAINMAX])
 {
     int i, j;
     struct ttable temp;
     for (i=0;i<n;i++)
         for (j=0;j<n;j++)
             if (i<j && a[i].leave>a[j].leave)
             {
                 temp=a[i];
                 a[i]=a[j];
                 a[j]=temp;
             }
 }
     
 int minTrain(struct ttable l[TRAINMAX], struct ttable a[TRAINMAX], int cond, int t)
 {
     int i, j, sa, p,q;
     p=(cond) ? na : nb;
     q=(cond) ? nb : na;
     sa=(cond) ? na : nb;
     for (i=0;i<p;i++)
         for (j=0;j<q;j++)
         {
             if (l[i].leave>=a[j].arrive+t && a[j].u==NOTUSED)
             {
                 sa--;
                 a[j].u=USED;
                 break;
             }
         }
     return sa;
 }
 
 main()
 {
     int n, i, cond;
     int sa, sb, t, temp1, temp2;
     out=fopen(αc:\tc\codejam\B-large.outα, αwα);
     in=fopen(αc:\tc\codejam\B-large.inα, αrα);
     fscanf(in, α%dα, &n);
     cond=1;
     while (n-->0)
     {
     fscanf(in, α%dα, &t);
     fscanf(in, α%d %dα, &na, &nb);
     for (i=0;i<na;i++)
     {
         AB[i].leave=HtoM();
         AB[i].arrive=HtoM();
         AB[i].u=NOTUSED;
     }
     for (i=na;i<TRAINMAX;i++)
         AB[i].leave=AB[i].arrive=AB[i].u=-1;
     for (i=0;i<nb;i++)
     {
         BA[i].leave=HtoM();
         BA[i].arrive=HtoM();
         BA[i].u=NOTUSED;
     }
     for (i=nb;i<TRAINMAX;i++)
         BA[i].leave=BA[i].arrive=BA[i].u=-1;
     BubbleSort(na, AB);
     BubbleSort(nb, BA);
     sa=minTrain(AB, BA, 1, t);
     sb=minTrain(BA, AB, 0, t);
     fprintf(out, αCase #%d: %d %dnα, cond++, sa, sb);
     }
 }"
22177,2008,32013,marciogadelha,24480,1,A.c,gcj/2008/32013/marciogadelha/24480/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 typedef struct mecanismo
 {
     char nome[101];
     bool pode;
 };
 
 int s, q, num;
 char consulta[101];
 mecanismo busca[100];
 
 void read()
 {
     scanf(α%dnα, &s);
     for(int i=0; i<s; i++)
     {
         gets(busca[i].nome);
         busca[i].pode = true;
     }
 }
 
 void process()
 {
     int contador = 0;
     num = 0;
     scanf(α%dnα, &q);
     for(int i=0; i<q; i++)
     {
         gets(consulta);
         for(int j=0; j<s; j++)
         {
             if(!strcmp(consulta, busca[j].nome) && busca[j].pode==true)
             {
                 contador++;
                 if(contador==s)
                 {
                     num++;
                     contador=1;
                     for(int k=0; k<s; k++)
                     {
                         if(k!=j)
                             busca[k].pode = true;
                     }
                 }
                 busca[j].pode = false;
                 break;
             }
         }
     }
     printf(α%dnα, num);
 }
 
 int main()
 {
     freopen(αA-large.inα, αrα, stdin);
     freopen(αA.outα, αwα, stdout);
     int n;
     scanf(α%dα, &n);
     for(int i=1; i<=n; i++)
     {
         printf(αCase #%d: α, i);
         read();
         process();
     }
     return 0;
 }"
22179,2008,32013,marciogadelha,24481,1,B.c,gcj/2008/32013/marciogadelha/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <algorithm>
 
 using namespace std;
 
 typedef struct tabela
 {
     int hp;
     int mp;
     int hc;
     int mc;
     int origem;
     bool operator < (const tabela &temp) const
     {
         if(hp!=temp.hp) return hp<temp.hp;
         if(mp!=temp.mp) return mp<temp.mp;
         if(hc!=temp.hc) return hc<temp.hc;
         if(mc!=temp.mc) return mc<temp.mc;
     }
 };
 
 typedef struct linha
 {
     int h;
     int m;
     int local;
 };
 
 int t, NA, NB, a, b, indice[200], pode, escolhido;
 tabela nab[200];
 linha trem[200];
 
 void read()
 {
     int i, j;
     scanf(α%dα, &t);
     scanf(α%d %dα, &NA, &NB);
     for(i=0; i<NA; i++)
     {
         scanf(α%d:%d %d:%dα, &nab[i].hp, &nab[i].mp, &nab[i].hc, &nab[i].mc);
         nab[i].origem = 1;
     }
     for(j=0; j<NB; j++, i++)
     {
         scanf(α%d:%d %d:%dα, &nab[i].hp, &nab[i].mp, &nab[i].hc, &nab[i].mc);
         nab[i].origem = 2;
     }
 }
 
 void process()
 {
     int i, j;
     a = b = 0;
     sort(&nab[0], &nab[NA+NB]);
     for(i=0; i<NA+NB; i++)
     {
         if(nab[i].origem==1)
         {
             for(j=0, pode=0; j<a+b; j++)
             {
                 if(trem[j].local==1)
                 {
                     if(trem[j].h<nab[i].hp)
                     {
                         indice[pode]=j;
                         pode++;
                     }
                     else if(trem[j].h==nab[i].hp && trem[j].m<=nab[i].mp)
                     {
                         indice[pode]=j;
                         pode++;
                     }
                 }
             }
             if(pode==0)
             {
                 trem[a+b].local=2;
                 trem[a+b].h=nab[i].hc;
                 if(nab[i].mc+t>60)
                 {
                     trem[a+b].h++;
                     trem[a+b].m=(nab[i].mc+t)%60;
                 }
                 else
                     trem[a+b].m=nab[i].mc+t;
                 a++;
             }
             else
             {
                 for(j=1, escolhido=0; j<pode; j++)
                 {
                     if(trem[indice[j]].h>trem[indice[escolhido]].h)
                         escolhido = j;
                     else if(trem[indice[j]].h==trem[indice[escolhido]].h && trem[indice[j]].m>trem[indice[escolhido]].m)
                         escolhido = j;
                 }
                 trem[indice[escolhido]].local = 2;
                 trem[indice[escolhido]].h=nab[i].hc;
                 if(nab[i].mc+t>60)
                 {
                     trem[indice[escolhido]].h++;
                     trem[indice[escolhido]].m=(nab[i].mc+t)%60;
                 }
                 else
                     trem[indice[escolhido]].m=nab[i].mc+t;
             }
         }
         else
         {
             for(j=0, pode=0; j<a+b; j++)
             {
                 if(trem[j].local==2)
                 {
                     if(trem[j].h<nab[i].hp)
                     {
                         indice[pode]=j;
                         pode++;
                     }
                     else if(trem[j].h==nab[i].hp && trem[j].m<=nab[i].mp)
                     {
                         indice[pode]=j;
                         pode++;
                     }
                 }
             }
             if(pode==0)
             {
                 trem[a+b].local=1;
                 trem[a+b].h=nab[i].hc;
                 if(nab[i].mc+t>60)
                 {
                     trem[a+b].h++;
                     trem[a+b].m=(nab[i].mc+t)%60;
                 }
                 else
                     trem[a+b].m=nab[i].mc+t;
                 b++;
             }
             else
             {
                 for(j=1, escolhido=0; j<pode; j++)
                 {
                     if(trem[indice[j]].h>trem[indice[escolhido]].h)
                         escolhido = j;
                     else if(trem[indice[j]].h==trem[indice[escolhido]].h && trem[indice[j]].m>trem[indice[escolhido]].m)
                         escolhido = j;
                 }
                 trem[indice[escolhido]].local = 1;
                 trem[indice[escolhido]].h=nab[i].hc;
                 if(nab[i].mc+t>60)
                 {
                     trem[indice[escolhido]].h++;
                     trem[indice[escolhido]].m=(nab[i].mc+t)%60;
                 }
                 else
                     trem[indice[escolhido]].m=nab[i].mc+t;
             }
         }
     }
     printf(α%d %dnα, a, b);
 }
 
 int main()
 {
     freopen(αB-large.inα, αrα, stdin);
     freopen(αB.outα, αwα, stdout);
     int n;
     scanf(α%dα, &n);
     for(int i=1; i<=n; i++)
     {
         printf(αCase #%d: α, i);
         read();
         process();
     }
     return 0;
 }"
22251,2008,32013,igorfr,24480,1,A.c,gcj/2008/32013/igorfr/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX 128
 
 typedef struct _ENGINE
 {
 	char name[MAX];
 	int query;
 } ENGINE;
 
 ENGINE eng[MAX];
 
 int main (void)
 {
 	int n, i, j, x, s, q, flag, switches, test = 0;
 	char query[MAX];
 	char c;
 
 	scanf (α%dα, &n);
 
 	for ( ; n>0; n--)
 	{
 		test++;
 		switches = 0;
 		scanf (α %dα, &s);
 		while (1)
 		{
 			scanf (α%cα, &c);
 			if (c == 'n') break;
 		}
 
 		for (i=0; i<s; i++)
 		{
 			gets (eng[i].name);
 			eng[i].query = 0;
 		}
 
 		scanf (α %dα, &q);
 		while (1)
 		{
 			scanf (α%cα, &c);
 			if (c == 'n') break;
 		}
 
 		for (i=0; i<q; i++)
 		{
 			gets (query);
 
 			for (j=0; j<s; j++)
 			{
 				if (!strcmp (eng[j].name, query))
 				{
 					eng[j].query++;
 					x = j;
 					break;
 				}
 			}
 
 			flag = 0;
 			for (j=0; j<s; j++)
 			{
 				if (!eng[j].query)
 				{
 					flag++;
 				}
 			}
 
 			if (flag == 0)
 			{
 				switches++;
 				for (j=0; j<s; j++)
 				{
 					eng[j].query = 0;
 				}
 				eng[x].query = 1;
 			}
 		}
 
 		printf (αCase #%d: %dnα, test, switches);
 	}
 	return 0;
 }"
22253,2008,32013,igorfr,24481,1,B.c,gcj/2008/32013/igorfr/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAX 128
 #define MAXN 256
 
 typedef struct _HOUR
 {
 	int h, min;
 } HOUR;
 
 typedef struct _TRIP
 {
 	HOUR start, end;
 	int station;
 } TRIP;
 
 typedef struct _TRAIN
 {
 	HOUR end;
 	int station;
 } TRAIN;
 
 int comp (const void *e1, const void *e2)
 {
 	TRIP a = *((TRIP*)e1);
 	TRIP b = *((TRIP*)e2);
 
 	if (a.start.h < b.start.h) return -1;
 
 	if (a.start.h > b.start.h) return 1;
 
 	if (a.start.min < b.start.min) return -1;
 
 	if (a.start.min > b.start.min) return 1;
 
 	if (a.end.h < b.end.h) return -1;
 
 	if (a.end.h > b.end.h) return 1;
 
 	if (a.end.min < b.end.min) return -1;
 
 	if (a.end.min > b.end.min) return 1;
 
 	return 0;
 }
 
 TRIP trip[MAX];
 TRAIN train[MAXN];
 
 int main (void)
 {
 	int n, i, na, nb, t, ta, tb, j, flag, test = 0;
 
 	scanf (α%dα, &n);
 
 	for ( ; n>0; n--)
 	{
 		test++;
 		scanf (α%dα, &t);
 
 		scanf (α%d %dα, &na, &nb);
 
 		for (i=0; i<(na+nb); i++)
 		{
 			scanf (α%d:%d %d:%dα, &trip[i].start.h, &trip[i].start.min, &trip[i].end.h, &trip[i].end.min);
 			trip[i].end.min += t;
 			if (trip[i].end.min > 60)
 			{
 				trip[i].end.min -= 60;
 				trip[i].end.h++;
 			}
 			if (i < na) trip[i].station = 1;
 			else trip[i].station = 2;
 		}
 
 		qsort (trip, na+nb, sizeof(trip[0]), comp);
 
 		ta = 0;
 		tb = 0;
 
 		if (trip[0].station == 1)
 		{
 			ta++;
 			train[0].end = (HOUR) trip[0].end;
 			train[0].station = 2;
 		}
 		else
 		{
 			tb++;
 			train[0].end = (HOUR) trip[0].end;
 			train[0].station = 1;
 		}
 		for (i=1; i<(na+nb); i++)
 		{
 			flag = 0;
 			for (j=0; j<(ta+tb); j++)
 			{
 				if (train[j].station == trip[i].station && (train[j].end.h < trip[i].start.h || (train[j].end.h == trip[i].start.h && train[j].end.min <= trip[i].start.min)))
 				{
 					flag = 1;
 					if (trip[i].station == 1) train[j].station = 2;
 					else train[j].station = 1;
 					train[j].end = (HOUR) trip[i].end;
 					break;
 				}
 			}
 			j = ta + tb;
 			if (!flag)
 			{
 				if (trip[i].station == 1)
 				{
 					ta++;
 					train[j].station = 2;
 				}
 				else
 				{
 					tb++;
 					train[j].station = 1;
 				}
 				train[j].end = (HOUR) trip[i].end;
 			}
 		}
 		printf (αCase #%d: α, test);
 		printf (α%d %dnα, ta, tb);
 	}
 
 
 	return 0;
 }"
22338,2008,32013,mlingcod,24480,1,problem1.c,gcj/2008/32013/mlingcod/24480/1/extracted/problem1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define BUFSZ 100
 
 int n; // test cases
 int s; // search engines
 int q; // queries
 int matchCount;
 int switches;
 unsigned char searched[100]; // covers 100 entries for search engines
 char **engineNames;
 
 int main(int argc, char *argv[])
 {
     char strBuf[BUFSZ+1];
     FILE *fp;
     int i, j, k;
 
     if (argc != 2)
     {
         printf(αUsage: supply filenamenα);
         exit(0);
     }
 
     fp = fopen(argv[1], αrα);
     if (fp == NULL)
     {
         printf(αUsage: file is no goodnα);
         exit(0);
     }
 
     // Set the number of test cases
     fgets(strBuf, BUFSZ, fp);
     strtok(strBuf, αrnα);
     n = atoi(strBuf);
 
     for (i=0; i<n; i++)
     {
         memset(searched, 0, 100 * sizeof(unsigned char));
         matchCount = 0;
         switches = 0;
 
         // Get the search engine number
         fgets(strBuf, BUFSZ, fp);
         strtok(strBuf, αrnα);
         s = atoi(strBuf);
 
         // Store the search engine names
         engineNames = malloc(sizeof(char *) * s);
         for (j=0; j<s; j++)
         {
             engineNames[j] = malloc(sizeof(char) * (BUFSZ+1));
             fgets(engineNames[j], BUFSZ, fp);
             strtok(engineNames[j], αrnα);
         }
 
         // Get the number of queries
         fgets(strBuf, BUFSZ, fp);
         strtok(strBuf, αrnα);
         q = atoi(strBuf);
 
         // Walk through list of queries
         for (k=0; k<q; k++)
         {
             fgets(strBuf, BUFSZ, fp);
             strtok(strBuf, αrnα);
             for (j=0; j<s; j++)
             {
                 if (strcmp(engineNames[j], strBuf) == 0)
                 {
                     // match
                     if (searched[j] == 0)
                     {
                         if (matchCount == (s - 1))
                         {
                             switches++;
                             memset(searched, 0, 100 * sizeof(unsigned char));
                             matchCount = 0;
                         }
 
                         searched[j] = 1;
                         matchCount++;
                     }
                     break;
                 }
             }
         }
         printf(αCase #%d: %dnα, i+1, switches);
     }
 
     fclose(fp);
     return (0);
 }"
22341,2008,32013,mlingcod,24481,1,problem2.c,gcj/2008/32013/mlingcod/24481/1/extracted/problem2.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define BUFSZ 100
 
 int n; // test cases
 int t; // turnaround time
 int na; // number of trips a->b
 int nb; // number of trips b->a
 int abDep[100];
 int abArr[100];
 int baDep[100];
 int baArr[100];
 
 int minConv(char *timeStr);
 
 int main(int argc, char *argv[])
 {
     char strBuf[BUFSZ+1];
     char *token, *subtoken, *sptr1, *sptr2;
     FILE *fp;
     int i, j, k;
     int aStart, bStart;
     int shortestTime;
     int bestCand;
 
     if (argc != 2)
     {
         printf(αUsage: supply filenamenα);
         exit(0);
     }
 
     fp = fopen(argv[1], αrα);
     if (fp == NULL)
     {
         printf(αUsage: file is no goodnα);
         exit(0);
     }
 
     // Set the number of test cases
     fgets(strBuf, BUFSZ, fp);
     token = strtok_r(strBuf, αrnα, &sptr1);
     n = atoi(token);
 
     for (i=0; i<n; i++)
     {
         // Get the turnaround time
         fgets(strBuf, BUFSZ, fp);
         token = strtok_r(strBuf, αrnα, &sptr1);
         t = atoi(token);
 
         // Get NA and NB
         fgets(strBuf, BUFSZ, fp);
         token = strtok_r(strBuf, αrnα, &sptr1);
         subtoken = strtok_r(token, α α, &sptr2);
         na = atoi(subtoken);
         subtoken = strtok_r(NULL, α α, &sptr2);
         nb = atoi(subtoken);
 
         // collect na schedule
         for (j=0; j<na; j++)
         {
             char *sptr1, *sptr2;
 
             fgets(strBuf, BUFSZ, fp);
             token = strtok_r(strBuf, αrnα, &sptr1);
             subtoken = strtok_r(token, α α, &sptr2);
             abDep[j] = minConv(subtoken);
             subtoken = strtok_r(NULL, α α, &sptr2);
             abArr[j] = minConv(subtoken) + t;  // add on αtα
         }
 
         for (j=0; j<nb; j++)
         {
             fgets(strBuf, BUFSZ, fp);
             token = strtok_r(strBuf, αrnα, &sptr1);
             subtoken = strtok_r(token, α α, &sptr2);
             baDep[j] = minConv(subtoken);
             subtoken = strtok_r(NULL, α α, &sptr2);
             baArr[j] = minConv(subtoken) + t;  // add on αtα
         }
 
         // Start with max
         aStart = na;
         bStart = nb;
 
         // Go through the na trains arriving at B
         for (j=0; j<na; j++)
         {
             shortestTime = 60*24;
             bestCand = nb;
             // Iterate through all the arrivals at station B
             // Hunt for the eariest departure that can be
             // accommodated by this train, and set time to -1
             for (k=0; k<nb; k++)
             {
                 // arrival time at B = abArr[j]
                 // diff = dep - arr
                 // if diff >= 0 and diff < shortestTime
                 // set bestCand to k
                 int diff = baDep[k] - abArr[j];
 
                 if (diff == 0)
                 {
                     bestCand = k;
                     break;
                 }
                 else if (diff > 0 && diff < shortestTime)
                 {
                     shortestTime = diff;
                     bestCand = k;
                 }
             }
 
             // Check that we found a candidate
             if (bestCand < nb)
             {
                 // train j from A can be used for train k from B!
                 baDep[bestCand] = -1; // don't use it again
                 bStart--;
                 if (bStart == 0)
                 {
                     break;
                 }
             }
         }
 
         // Go through the nb trains arriving at A
         for (j=0; j<nb; j++)
         {
             shortestTime = 60*24;
             bestCand = na;
             // Iterate through all the arrivals at station A
             // Hunt for the eariest departure that can be
             // accommodated by this train, and set time to -1
             for (k=0; k<na; k++)
             {
                 // arrival time at A = baArr[j]
                 // diff = dep - arr
                 // if diff >= 0 and diff < shortestTime
                 // set bestCand to k
                 int diff = abDep[k] - baArr[j];
 
                 if (diff == 0)
                 {
                     bestCand = k;
                     break;
                 }
                 else if (diff > 0 && diff < shortestTime)
                 {
                     shortestTime = diff;
                     bestCand = k;
                 }
             }
 
             // Check that we found a candidate
             if (bestCand < na)
             {
                 // train j from B can be used for train k from A!
                 abDep[bestCand] = -1; // don't use it again
                 aStart--;
 
                 if (aStart == 0)
                 {
                     break;
                 }
             }
         }
 
         printf(αCase #%d: %d %dnα, i+1, aStart, bStart);
     }
 
     fclose(fp);
     return (0);
 }
 
 int minConv(char *timeStr)
 {
     char *token, *sptr;
     int hour, min;
 
     token = strtok_r(timeStr, α:α, &sptr);
     hour = atoi(token);
     token = strtok_r(NULL, α:α, &sptr);
     min = atoi(token);
 
     return (hour * 60 + min);
 }"
22419,2008,32013,manu1001,24480,1,SAVUNI.C,gcj/2008/32013/manu1001/24480/1/extracted/SAVUNI.C,"#include <stdio.h>
 #include <string.h>
 
 #define CASE_MAX     20
 #define SE_NAME_MAX 101
 #define SE_MAX      100
 #define QUERY_MAX  1000
 
 int n, ns[CASE_MAX], nq[CASE_MAX];
 char s[CASE_MAX][SE_MAX][SE_NAME_MAX];
 int q[CASE_MAX][QUERY_MAX];
 
 int nextpos(int cas, int se, int from);
 int jmpoptswitch(int cas, int from);
 
 main()
 {
   char tmp[SE_NAME_MAX];
   FILE *fp, *out;
   int i, j, k, l;
   int nswitch[SE_MAX];
 
   fp = fopen(αt.txtα, αrα);
 
   /* read all data */
   fscanf(fp, α%dnα, &n);
   for (i = 0; i < n; i++){
        fscanf(fp, α%dnα, &ns[i]);
        for (j = 0; j < ns[i]; j++)
             fgets(s[i][j], SE_NAME_MAX, fp);
        fscanf(fp, α%dnα, &(nq[i]));
        for (j = 0; j < nq[i]; j++){
             fgets(tmp, SE_NAME_MAX, fp);
             for (k = 0; k < ns[i]; k++)
                  if (strcmp(tmp, s[i][k]) == 0){
                      q[i][j] = k;
                      break;
                  }
        }
   }
   fclose(fp);
 
   fp = fopen(αs.txtα, αwα);
   for (i = 0; i < n; i++){
 
        nswitch[i] = 0;
        for (j = 0; (k = jmpoptswitch(i, j)) != -1; ){
             j += k;
             if (j >= nq[i])
                 break;
             nswitch[i]++;
        }
        fprintf(fp, αCase #%d: %dnα, i + 1, nswitch[i]);
   }
 
   fclose(fp);
 
   return 0;
 }
 
 int jmpoptswitch(int cas, int from)
 {
   int i, c, max = -1;
 
   for (i = 0; i < ns[cas]; i++){
        if ((c = nextpos(cas, i, from)) > max)
            max = c;
   }
   return max;
 }
 
 int nextpos(int cas, int se, int from)
 {
   int i, count = 0;
 
   for (i = from; i < nq[cas]; i++){
        if (se == q[cas][i])
            break;
        count++;
   }
   return count;
 }"
22421,2008,32013,manu1001,24481,1,TRAIN.C,gcj/2008/32013/manu1001/24481/1/extracted/TRAIN.C,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 #define CASE_MAX 100
 #define TRIP_MAX 100
 #define TRAIN_MAX 60
 #define Q_MAX    200
 
 typedef struct queue
 {
   int q[Q_MAX];
   int front, rear;
 } Q;
 
 void init_q(Q *q);
 void add_q(Q *q, int value);
 int get_q(Q *q);
 int peek_q(Q *q);
 int isempty_q(Q *q);
 void sort(int *a, int nmax);
 int minutes(char *timstr);
 
 
 int n, t, na, nb, ta, tb;
 Q depa, arrb, depb, arra;
 int bufa, bufb;
 
 main()
 {
   FILE *fp, *fpout;
   int i, j, u, v;
   char tm[10];
 
   fpout = fopen(αs.txtα, αwα);
   fp = fopen(αt.txtα, αrα);
   fscanf(fp, α%dnα, &n);
   for (i = 0; i < n; i++){
 
        init_q(&arra), init_q(&depb), init_q(&arrb), init_q(&depa);
 
        fscanf(fp, α%dnα, &t);
        fscanf(fp, α%d %dnα, &na, &nb);
        for (j = 0; j < na; j++){
             fscanf(fp, α%s α, tm);
             add_q(&depa, minutes(tm));
             fscanf(fp, α%snα, tm);
             add_q(&arrb, minutes(tm) + t);
        }
        for (j = 0; j < nb; j++){
             fscanf(fp, α%s α, tm);
             add_q(&depb, minutes(tm));
             fscanf(fp, α%snα, tm);
             add_q(&arra, minutes(tm) + t);
        }
        sort(depa.q, na);
        sort(arrb.q, na);
        sort(depb.q, nb);
        sort(arra.q, nb);
 
        bufa = bufb = 0;
        ta = tb = 0;
        v = TRIP_MAX + 2;
        for (u = 0; u < 1440; u += ((v++ % (TRIP_MAX + 1)) == 0)){
 
             if (!isempty_q(&arra) && u == peek_q(&arra)){
                 get_q(&arra);
                 bufa++;
             }
             if (!isempty_q(&arrb) && u == peek_q(&arrb)){
                 get_q(&arrb);
                 bufb++;
             }
             if (!isempty_q(&depa) && u == peek_q(&depa)){
                    if (bufa > 0)
                        bufa--;
                    else
                        ta++;
                    get_q(&depa);
             }
             if (!isempty_q(&depb) && u == peek_q(&depb)){
                    if (bufb > 0)
                        bufb--;
                    else
                        tb++;
                    get_q(&depb);
             }
 
        }
        fprintf(fpout, αCase #%d: %d %dnα, i + 1, ta, tb);
   }
 
   fclose(fp);
   fclose(fpout);
   return 0;
 }
 
 int minutes(char *timstr)
 {
   int mm;
 
   mm = atoi(timstr + 3);
   timstr[2] = '0';
   return (atoi(timstr) * 60 + mm);
 }
 
 void init_q(Q *q)
 {
   int i;
 
   for (i = 0; i < Q_MAX; i++)
        (q->q)[i] = 0;
   q->front = q->rear = 0;
 }
 
 void add_q(Q *q, int value)
 {
   (q->q)[q->rear++] = value;
 }
 
 int get_q(Q *q)
 {
   return (q->q)[q->front++];
 }
 
 int peek_q(Q *q)
 {
   return (q->q)[q->front];
 }
 
 int isempty_q(Q *q)
 {
   return (q->front == q->rear);
 }
 
 void sort(int *a, int nmax)
 {
   int i, j, tmp;
 
   for (i = 0; i < nmax - 1; i++){
        for (j = i + 1; j < nmax; j++){
             if (a[i] > a[j]){
                 tmp = a[i];
                 a[i] = a[j];
                 a[j] = tmp;
             }
        }
   }
 }"
22613,2008,32013,Enya,24480,1,SEQ.c,gcj/2008/32013/Enya/24480/1/extracted/SEQ.c,"#include <stdio.h>
 
 #define SLEN 101
 #define MAX_S 100
 #define MAX_Q 1000
 
 struct srch {
 	char name[101];
 	int index;
 };
 struct srch search[MAX_S];
 char query[MAX_Q][SLEN];
 
 int main(int argc, char**argv)
 {
 	int N, S, Q;
 	int i, j, k;
 	char *input = argv[1];
 	FILE *fp;
 	int switches = 0;
 
 	fp = fopen(input, αrα);
 	fscanf(fp, α%dα, &N);
 	for ( i=0; i < N; i++)
 	{
 		memset(search, 0, sizeof(struct srch)*MAX_S);
 		memset(query, 0, MAX_Q * SLEN);
 		fscanf(fp, α%dnα, &S);
 		for (j=0; j < S; j++)
 			fgets(search[j].name, SLEN, fp);
 
 		fscanf(fp, α%dnα, &Q);
 		for (j=0; j < Q; j++)
 			fgets(query[j], SLEN, fp);
 
 		switches = switchrequired(0, S, Q);
 		printf(αCase #%d: %dnα, i+1, switches);
 	}
 	fclose(fp);
 	return 0;
 }
 
 int switchrequired(int start, int S, int Q)
 {
 	int j, k, max_index;
 
 	for (j=0; j < S; j++)
 	{
 		search[j].index = MAX_Q + 1;;
 		for (k=start; k < Q; k++)
 			if (!strcmp(search[j].name, query[k]))
 			{
 				search[j].index = k;
 				break;
 			}
 	}
 	max_index = 0;
 	for (j=0; j < S; j++)
 	{
 		if ( search[j].index == MAX_Q + 1)
 			return 0;
 		if ( search[j].index > max_index)
 			max_index = search[j].index;
 	}
 /*
 	if (max_index == (Q-1))
 		return 1;
 	else 
 */
 		return (1 + switchrequired(max_index, S, Q));
 	
 }"
22752,2008,32013,lock,24480,1,a.c,gcj/2008/32013/lock/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 struct search_engine{
 	char name[101];
 };
 
 struct search_engine se[100];
 int se_hit[100];
 
 int main(int argc, char *argv[])
 {
 	FILE *input = fopen(argv[1], αrα);
 	int case_index, case_count;
 
 	fscanf(input, α%dnα, &case_count);
 	for(case_index = 0; case_index < case_count; case_index++){
 		int se_index, se_count, query_index, query_count, previous_hit = 101, change = 0;
 		memset(se, 0, 100 * sizeof(struct search_engine));
 		memset(se_hit, 0, 100 * sizeof(int));
 		fscanf(input, α%dnα, &se_count);
 		for(se_index = 0; se_index < se_count; se_index++){
 			fgets(se[se_index].name, 101, input);
 		}
 		fscanf(input, α%dnα, &query_count);
 		for(query_index = 0; query_index < query_count; query_index++){
 			char query[101];
 			fgets(query, 101, input);
 			for(se_index = 0; se_index < se_count; se_index++){
 				if(strcmp(query, se[se_index].name) == 0){
 					if(se_index == previous_hit) break;
 					se_hit[se_index] = 1;
 					previous_hit = se_index;
 					break;
 				}
 			}
 			for(se_index = 0; se_index < se_count; se_index++){
 				if(se_hit[se_index] == 0) break;
 			}
 			if(se_index == se_count){
 				change++;
 				memset(se_hit, 0, 100 * sizeof(int));
 				se_hit[previous_hit] = 1;
 			}
 		}
 		printf(αCase #%d: %dnα, case_index + 1, change);
 	}
 }"
22810,2008,32013,haraken,24480,1,google_q_a.c,gcj/2008/32013/haraken/24480/1/extracted/google_q_a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define STR_MAX 110
 
 char engine[110][STR_MAX];
 char query[1010][STR_MAX];
 
 int main(void)
 {
   int Q, S, N, i, n, s, q, min;
   char str[STR_MAX];
   int count[110], new_count[110];
   
   fgets(str, STR_MAX, stdin);
   sscanf(str, α %dα, &N);
   for(n = 0; n < N; n++)
     {
       fgets(str, STR_MAX, stdin);
       sscanf(str, α %dα, &S);
       for(s = 0; s < S; s++)
         {
           fgets(str, STR_MAX, stdin);
           if(str[strlen(str) - 1] == 'n')
             {
               str[strlen(str) - 1] = 0;
             }
           if(str[strlen(str) - 1] == 'r')
             {
               str[strlen(str) - 1] = 0;
             }
           strcpy(engine[s], str);
         }
       fgets(str, STR_MAX, stdin);
       sscanf(str, α %dα, &Q);
       for(q = 0; q < Q; q++)
         {
           fgets(str, STR_MAX, stdin);
           if(str[strlen(str) - 1] == 'n')
             {
               str[strlen(str) - 1] = 0;
             }
           if(str[strlen(str) - 1] == 'r')
             {
               str[strlen(str) - 1] = 0;
             }
           strcpy(query[q], str);
         }
       
       for(s = 0; s < S; s++)
         {
           count[s] = 0;
         }
       for(q = 0; q < Q; q++)
         {
           for(s = 0; s < S; s++)
             {
               min = Q + 1;
               for(i = 0; i < S; i++)
                 {
                   if(strcmp(query[q], engine[s]) == 0)
                     {
                       
                     }
                   else if(i == s)
                     {
                       if(count[i] < min)
                         {
                           min = count[i];
                         }
                     }
                   else
                     {
                       if(count[i] + 1 < min)
                         {
                           min = count[i] + 1;
                         }
                     }
                 }
               new_count[s] = min;
             }
           for(s = 0; s < S; s++)
             {
               count[s] = new_count[s];
             }
         }
       min = Q + 1;
       for(s = 0; s < S; s++)
         {
           if(count[s] < min)
             {
               min = count[s];
             }
         }
       printf(αCase #%d: %dnα, n + 1, min);
     }
   return 0;
 }"
22897,2008,32013,BMD,24480,1,stu.c,gcj/2008/32013/BMD/24480/1/extracted/stu.c,"#include <stdio.h>
 #include <string.h>
 main()
 {
 	int N,S,Q;
 	int i,j,k,l,m;
 	char st[100][102];
 	char was[100];
 	char cur[102];
 	scanf(α%dnα,&N);
 	for(i=1;i<=N;i++){
 		scanf(α%dnα,&S);
 		for(j=0;j<S;j++) fgets(st[j],102,stdin);
 		scanf(α%dnα,&Q);
 		for(j=0;j<100;was[j++]=0);
 		for(j=0,l=0,m=0;j<Q;j++){
 			fgets(cur,102,stdin);
 			for(k=0;k<S;k++)
 				if(strcmp(cur,st[k])==0){
 					if(!was[k]){
 						was[k]=1;
 						m++;
 						if(m==S){
 							for(m=0;m<100;was[m++]=0);
 							was[k]=1;
 							m=1;
 							l++;
 						}
 					}
 					break;
 				}
 		}
 		printf(αCase #%d: %dnα,i,l);
 		fflush(stdout);
 	}
 }"
22900,2008,32013,BMD,24481,1,tt.c,gcj/2008/32013/BMD/24481/1/extracted/tt.c,"#include <stdio.h>
 #include <string.h>
 main()
 {
 	int N,T,NA,NB;
 	int i,j,k,l,m;
 	int tim[1000];
 	int lt,i1,i2,i3,i4;
 	scanf(α%dnα,&N);
 	for(i=1;i<=N;i++){
 		scanf(α%dnα,&T);
 		scanf(α%d %dnα,&NA,&NB);
 		lt=0;
 		for(j=0;j<NA;j++){
 			scanf(α%d:%d %d:%dnα,&i1,&i2,&i3,&i4);
 			tim[lt++]=i1*600+i2*10+3;
 			tim[lt++]=i3*600+i4*10+1+T*10;
 		}
 			for(j=0;j<NB;j++){
 			scanf(α%d:%d %d:%dnα,&i1,&i2,&i3,&i4);
 			tim[lt++]=i1*600+i2*10+4;
 			tim[lt++]=i3*600+i4*10+2+T*10;
 		}
 		for(l=1;l;)
 			for(j=0,l=0;j<lt-1;j++)
 				if(tim[j]>tim[j+1]){
 					m=tim[j];
 					tim[j]=tim[j+1];
 					tim[j+1]=m;
 					l=1;
 				}
 		i1=0;i2=0;i3=0;i4=0;
 		for(j=0;j<lt;j++){
 			switch(tim[j]%10){
 				case 1: i4++; break;
 				case 2: i3++; break;
 				case 3: if(i3==0)i1++;else i3--; break; 
 				case 4: if(i4==0)i2++;else i4--; break; 
 			}
 		}
 
 		printf(αCase #%d: %d %dnα,i,i1,i2);
 	}
 }"
23011,2008,32013,gm281,24479,1,fly-swatter.c,gcj/2008/32013/gm281/24479/1/extracted/fly-swatter.c,"#include<stdio.h>
 #include<stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 
 double intersection_point(double a, double r)
 {
     double b_square = r*r - a*a;
 
     if(b_square < 0)
         return -1;
 
     return sqrt(b_square);
 }
 
 double arc_area(double r, double xa, double ya, double xb, double yb)
 {
     double base_length = sqrt((xb - xa) * (xb - xa) + (yb - ya)*(yb - ya));
     double sin_alpha = base_length / (2 * r);
     double alpha = asin(sin_alpha); 
     double height = sqrt((r * r) - (base_length/2)*(base_length/2));
     double triangle_area = base_length * height/2;
     double arc_area = (r*r*alpha) - triangle_area;
 
     if(arc_area < 0)
     {
         printf(αError!nα);
         exit(1);
     }
     return arc_area;
 }
 
 double intersect_square(double x1, double y1, double x2, double y2, double r)
 {
     double ix2, iy2, ix1, iy1;
 
     if((x1 > x2) || (y1 > y2))
         return 0;
 
     /* There are TODO cases */
     ix2 = intersection_point(y2, r); 
     iy2 = intersection_point(x2, r); 
     ix1 = intersection_point(y1, r); 
     iy1 = intersection_point(x1, r); 
 
     /* Case 1: Whole square within the circle */
     if(ix2 > x2)
     {
         assert(iy2 >= y2);
         return (y2 - y1) * (x2 - x1);
     }
 
     /* Case 2: Whole square outside the circle */
     if(ix1 < x1)
     {
         assert(iy1 <= y1);
         return 0;
     }
 
     /* Case 3: Circle crosses the two sides running from (x2,y2) corner */
     if( ((x2 >= ix2) && (ix2 > x1)) && 
         ((y2 >= iy2) && (iy2 > y1)) )
     {
         double arc = arc_area(r, x2, iy2, ix2, y2); 
         double rec1 = (x2 - x1) * (iy2 - y1);
         double rec2 = (ix2 - x1) * (y2 - iy2);
         double tri = (x2 - ix2) * (y2 - iy2) / 2;
         assert(arc >= 0);
         assert(rec1 >= 0);
         assert(rec2 >= 0);
         assert(tri >= 0);
 
         return arc + rec1 + rec2 + tri;
     }
     
     /* Case 4: Circle crosses the left and the right side */
     if( ((y2 >= iy1) && (iy1 > y1)) && 
         ((y2 >= iy2) && (iy2 > y1)) )
     {
         double arc = arc_area(r, x1, iy1, x2, iy2); 
         double rec = (x2 - x1) * (iy2 - y1);
         double tri = (x2 - x1) * (iy1 - iy2) / 2;
         assert(arc >= 0);
         assert(rec >= 0);
         assert(tri >= 0);
 
         return arc + rec + tri;
     }
     
     /* Case 5: Circle crosses the top and the bottom side */
     if( ((x2 >= ix1) && (ix1 > x1)) && 
         ((x2 >= ix2) && (ix2 > x1)) )
     {
         double arc = arc_area(r, ix1, y1, ix2, y2);
         double rec = (y2 - y1) * (ix2 - x1);
         double tri = (y2 - y1) * (ix1 - ix2) / 2;
         assert(arc >= 0);
         assert(rec >= 0);
         assert(tri >= 0);
 
         return arc + rec + tri;
     }
     
     /* Case 6: Circle crosses the sides running from (x1, y1) corner */
     if( ((x2 >= ix1) && (ix1 > x1)) && 
         ((y2 >= iy1) && (iy1 > y1)) )
     {
         double arc = arc_area(r, ix1, y1, x1, iy1);
         double tri = (ix1 - x1) * (iy1 - y1) / 2;
         assert(arc >= 0);
         assert(tri >= 0);
         
         return arc + tri;
     }
 
     printf(αERRORnα);
     exit(3);
     return -1;
 }
 
 double process_square(double x1, double y1, double x2, double y2,
                     double f, double R, double t, double r, double g)
 {
 //printf(αprocessing square (%f, %f) (%f %f)nα, x1, y1, x2, y2);
     return intersect_square(x1+f, y1+f, x2-f, y2-f, R-t-f);
 }
 
 
 double start_position(int i, double r, double g)
 {
     return (g + 2*r) * ((double)i) + r;
 }
 
 double end_position(int i, double r, double g)
 {
     return start_position(i, r, g) + g; 
 }
 
 int main(int argc, char *argv[])
 {
     FILE* file;
     char line[1024];
     int nr_cases, i, xi, yi;
     float fr, Rr, tr, rr, gr;
     double f, R, t, r, g, x1, y1, x2, y2;
     double area, prob;
 
     //printf(αFile %snα, argv[1]);
     file = fopen(argv[1], αrα);
     if(!file)
         exit(1);
   
     fgets(line, 1024, file); 
     nr_cases = atoi(line);
 //printf(αNumber of cases = %dnα, nr_cases);
     for(i=0; i<nr_cases; i++)
     {
         fgets(line, 1024, file); 
         sscanf(line, α%f %f %f %f %fα, &fr, &Rr, &tr, &rr, &gr);
         f = fr;
         R = Rr;
         t = tr;
         r = rr;
         g = gr;
 //printf(αGot f=%f R=%f  t=%f  r=%f  g=%fnα, f, R, t, r, g);        
         xi = yi = 0;
         area = 0;
 again:
         x1 = start_position(xi, r, g);
         y1 = start_position(yi, r, g);
         x2 = end_position(xi, r, g);
         y2 = end_position(yi, r, g);
 //printf(α(%d, %d) gives (%f, %f) (%f, %f).nα, xi, yi, x1, y1, x2, y2);
         if(y1 > R)
             goto finish;
 
         if(x1 > R)
         {
             xi = 0;
             yi++;
             goto again;
         }
 
         if( x1*x1 + y1*y1 > R*R)
         {
             xi = 0;
             yi++;
             goto again;
         }
         
         area += process_square(x1, y1, x2, y2, f, R, t, r, g);
         xi++;
         goto again;
 finish:
 //printf(αCase finished.nα);
 
 
         prob = (1.0 - (area / (M_PI * R * R / 4)));
         
         prob *= 1000000;
         prob += 0.5;
         prob = (double)((int)prob);
         prob /= 1000000;
         
 
         printf(αCase #%d: %1.6fnα, (i+1),  prob);
     }
 
 }"
23013,2008,32013,gm281,24481,1,train-timetable.c,gcj/2008/32013/gm281/24481/1/extracted/train-timetable.c,"#include<stdio.h>
 #include<stdlib.h>
 #include <string.h>
 
 void sort_timetable(int timetable[][3], int length)
 {
     int i,j;
 
     for(i=0; i<length; i++)
     {
         for(j=0; j<(length-i-1); j++)
         {
 //printf(α%d %dnα, i, j);        
             if((timetable[j][1] > timetable[j+1][1]) ||
                ((timetable[j][1] == timetable[j+1][1]) && 
                 (timetable[j][2] > timetable[j+1][2]) ))
             {
                 int t1, t2, t3;
 
                 t1 = timetable[j][0];
                 t2 = timetable[j][1];
                 t3 = timetable[j][2];
 
                 timetable[j][0] = timetable[j+1][0];
                 timetable[j][1] = timetable[j+1][1];
                 timetable[j][2] = timetable[j+1][2];
                 
                 timetable[j+1][0] = t1; 
                 timetable[j+1][1] = t2;
                 timetable[j+1][2] = t3;
             }
         }
     }
 for(i=0; i<length; i++)
 {
     //(αDir=%d, dep=%d, arr=%dnα, timetable[i][0], timetable[i][1], timetable[i][2]);
 }    
 }
 
 int enough_trains(int timetable[][3], int length, int ta, int tb)
 {
     int i, j;
     int arrivals_bitmap[length];
 
     for(i=0; i<length; i++)
         arrivals_bitmap[i] = 0;
 
     for(i=0; i<length; i++)
     {   
         int current_time = timetable[i][1];
 //(αChecking %dnα, current_time);
         /* Check for any arrivals */
         for(j=0; j<length; j++)
         {
             if((arrivals_bitmap[j]) &&
                (timetable[j][2] <= current_time))
             {
 //(αTrain %d, %d -> %d arrivednα, timetable[j][0], timetable[j][1], timetable[j][2]);
                 if(timetable[j][0] == 0)
                     tb++;
                 if(timetable[j][0] == 1)
                     ta++;
                 arrivals_bitmap[j] = 0;    
             }
         } 
 
         /* Check if we have enough trains */
         if((timetable[i][0] == 0) && (ta <= 0))
             return 0;
         if((timetable[i][0] == 1) && (tb <= 0))
             return 1;
 
         /* Run the train */
         if(timetable[i][0] == 0)
         {
             arrivals_bitmap[i] = 1;
             ta--;
         } else
         {
             arrivals_bitmap[i] = 1;
             tb--;
         }
     } 
     return -1;
 }
 
 int main(int argc, char *argv[])
 {
     FILE* file;
     char line[1024];
     int nr_cases, i, turnaround_time, na, nb, timetable[202][3], j, k, sim_ret, ta, tb;
 
 //printf(αFile %snα, argv[1]);
     file = fopen(argv[1], αrα);
     if(!file)
         exit(1);
   
     fgets(line, 1024, file); 
     nr_cases = atoi(line);
 //printf(αNumber of cases = %dnα, nr_cases);
     for(i=0; i<nr_cases; i++)
     {
         fgets(line, 1024, file); 
         turnaround_time = atoi(line);
 //(αTurnaround time=%dnα, turnaround_time);        
         fgets(line, 1024, file); 
         na = nb = -1;
         sscanf(line, α%d %dα, &na, &nb);
         if((na < 0) || (nb < 0))
         {
             printf(αErrornα);
             exit(1);
         }
 //(αNA=%d, NB=%dnα, na, nb);        
         k=0;
         for(j=0; j<na; j++) 
         {
             int a1, a2, b1, b2;
 
             fgets(line, 1024, file); 
             sscanf(line, α%d:%d %d:%dα, &a1, &a2, &b1, &b2);
 //(αRead %d:%d -> %d:%dnα, a1, a2, b1, b2);            
             timetable[k][0] = 0;
             timetable[k][1] = a1*60 + a2;
             timetable[k][2] = b1*60 + b2 + turnaround_time;
             k++;
         }
         for(j=0; j<nb; j++) 
         {
             int a1, a2, b1, b2;
 
             fgets(line, 1024, file); 
             sscanf(line, α%d:%d %d:%dα, &a1, &a2, &b1, &b2);
 //(αRead %d:%d -> %d:%dnα, a1, a2, b1, b2);            
             timetable[k][0] = 1;
             timetable[k][1] = a1*60 + a2;
             timetable[k][2] = b1*60 + b2 + turnaround_time;
             k++;
         }
 //(αK=%dnα, k);        
 
         sort_timetable(timetable, k);
         ta=tb=0;
 
         while((sim_ret = enough_trains(timetable, k, ta, tb)) != -1)
         {
 //(α=====================nα);        
             if(sim_ret == 0)
                 ta++;
             if(sim_ret == 1)
                 tb++;
             if((sim_ret != 0) && (sim_ret != 1))
             {
                 (αError2nα);
                 exit(2);
             }
         }
         printf(αCase #%d: %d %dnα, (i+1), ta, tb);
      }
 }"
23151,2008,32013,pranny,24480,1,search.c,gcj/2008/32013/pranny/24480/1/extracted/search.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 #define MAXLINE 100
 
 int main(int argc,char **argv)
 {
 	char buffer[MAXLINE];
 	char **searchEngine;
 	FILE *fp,*out;
 	int *result;
 	int resultCount;
 	int Cases;
 	int SCount;
 	int QCount;
 	int i,j,k;
 	int switchCount=0;
 
 	if(argc!=2)
 	{
 		printf(αUsages : <program name> <input file>nα);
 	}
 
 	fp=fopen(argv[1],αrα);
 	
 	//for each case
 	fgets(buffer,MAXLINE, fp);
 	Cases=atoi(buffer);
 	for(i=0;i<Cases;i++)
 	{
 		//allocate / assign
 		fgets(buffer,MAXLINE, fp);
 		SCount=atoi(buffer);
 		searchEngine = malloc(SCount * sizeof(char*));
 		for(j=0;j<SCount;j++)
 		{
 			searchEngine[j] = malloc((MAXLINE+1) * sizeof(char));
 			fgets(searchEngine[j],MAXLINE, fp);
 		}
 		result=malloc(SCount * sizeof(int));
 		switchCount=0;
 		resultCount=0;
 		for(j=0;j<SCount;j++)
 		{
 			result[j]=0;
 		}
 
 		//run through queries
 		fgets(buffer,MAXLINE, fp);
 		QCount=atoi(buffer);
 		for(k=0;k<QCount;k++)
 		{
 			fgets(buffer,MAXLINE, fp);
 dirty1:
 			for(j=0;j<SCount;j++)
 			{
 				if(strcmp(buffer,searchEngine[j])==0&&result[j]==0)
 				{
 					result[j]=1;
 					resultCount++;
 
 					if(resultCount==SCount)
 					{
 						switchCount++;
 				
 						resultCount=0;
 						//printf(αtBefore %d Switch: %sα,k+1,searchEngine[j]);
 						for(j=0;j<SCount;j++)
 						{
 							result[j]=0;
 						}
 						goto dirty1;
 					}
 					break;
 				}
 			}
 		}
 
 
 
 		//Cleanup
 		for(j=0;j<SCount;j++)
 		{
 			free(searchEngine[j]);
 		}
 		free(searchEngine);
 		free(result);
 
 		//print result
 		//printf(αCase #%d: %dnα,i+1,switchCount);
 		out=fopen(αresult.txtα,αa+α);
 		fprintf(out,αCase #%d: %dnα,i+1,switchCount);
 		fclose(out);
 
 	}
 
 	fclose(fp);
 	return 0;
 }"
23175,2008,32013,vaibhav,24480,1,R1-12.C,gcj/2008/32013/vaibhav/24480/1/extracted/R1-12.C,"#include<stdio.h>
 #include<conio.h>
 #include<io.h>
 #include<string.h>
 #include<stdlib.h>
 
 void main()
 {
 	FILE *fp,*fp1;
 	char engine[100][110],tmp[10],q[100][100];
 	int i,cs,neg,nq,j,n,min1,min2,x=0,y,flg[100],k;
 	int tmp1,p,r;
 	long pos,pos1;
 	clrscr();
 	fp=fopen(αinput.txtα,αrα);
 	fp1=fopen(αoutput.txtα,αwα);
 	fgets(tmp,10,fp);
 	cs=atoi(tmp);
 	//printf(α%dα,cs);
 
 
 	//getch();
 	for(p=0;p<cs;p++)
 	{       x+=1;
 		y=0;
 
 		fgets(tmp,10,fp);//fscanf(fp,α%sα,tmp);
 		neg=atoi(tmp);
 		//printf(α%dα,neg);
 		for(i=0;i<neg;i++)
 		{
 			fgets(engine[i],100,fp);
 			flg[i]=-1;
 			//printf(α%sα,engine[i]);
 		}
 		fgets(tmp,10,fp);
 		nq=atoi(tmp);
 		//printf(α%dα,nq);
 		if(nq>0)
 		{
 		for(j=0;j<nq;j++)
 		{
 			//pos=ftell(fp);
 			//printf(α%ldα,pos);
 			fgets(q[0],100,fp);
 			//printf(α%sα,q[0]);
 			k=0;
 			while(k<neg)
 			{
 				if(strcmp(q[0],engine[k])==0)
 				{
 					flg[k]=1;
 					tmp1=0;
 					for(i=0;i<neg;i++)
 					{
 						if(flg[i]==-1)
 							tmp1=-1;
 					}
 					if(tmp1==0)
 					{
 
 						y+=1;
 						//printf(αheroα);
 						for(i=0;i<neg;i++)
 							flg[i]=-1;
 						flg[k]=1;
 						tmp1=-1;
 
 					}
 
 					k=neg;
 				}
 				k++;
 			}
 		}
 		if(tmp1==-1)
 			y+=1;
 
 
 		y=y-1;
 
 			//printf(α%sα,q[0]);
 		}
 
 
 
 		//printf(αCase #%d: Y,xα);
 		fprintf(fp1,αCase #%d: %dnα,x,y);
 	//getch();
 	}
 	printf(αEnter any key...α);
 	getch();
 
 
 }"
23202,2008,32013,LeHaKo,24480,1,lehako_saving_the_universe.c,gcj/2008/32013/LeHaKo/24480/1/extracted/lehako_saving_the_universe.c,"#include <stdio.h>
 #include <string.h>
 
 #define	MAX_CHAR_LINE		128
 #define	NUM_ENGINE			100
 #define	NUM_QUERY			1000
 
 char	engine_str[NUM_ENGINE][MAX_CHAR_LINE];
 char	engine_flag[NUM_ENGINE];
 int		engine_num;
 char	query_str[NUM_QUERY][MAX_CHAR_LINE];
 int		switch_num;
 
 int		fget_line( FILE *fp, char *buff, int max );
 void	reset_flag( int num );
 
 /* ------------------------------------------------------------------------ */
 /* main function															*/
 /* ------------------------------------------------------------------------ */
 
 int
 main( int argc, char **argv )
 {
 	char	line[MAX_CHAR_LINE];
 	int		i, j, k, n, s, q, ret;
 	FILE	*fp;
 
 	/* --- check argument --- */
 	if( argc != 2 )
 	{
 		printf( αargument errornα );
 		return;
 	}
 
 	/* --- file open --- */
 	fp = fopen( argv[1], αrα );
 	if( fp == NULL )
 	{
 		printf( αfile not foundnα );
 		return;
 	}
 
 	/* --- get N --- */
 	fget_line( fp, line, MAX_CHAR_LINE-1 );
 	n = atoi( line );
 
 	for( i=0 ; i<n ; i++ )
 	{
 		/* -------------------------- */
 		/* --- read engine string --- */
 		/* -------------------------- */
 
 		/* --- get S --- */
 		fget_line( fp, line, MAX_CHAR_LINE-1 );
 		s = atoi( line );
 
 		/* --- read engine --- */
 		for( j=0 ; j<s ; j++ )
 			fget_line( fp, engine_str[j], MAX_CHAR_LINE-1 );
 
 		/* ------------------------- */
 		/* --- read query string --- */
 		/* ------------------------- */
 
 		/* --- get q --- */
 		fget_line( fp, line, MAX_CHAR_LINE-1 );
 		q = atoi( line );
 
 		/* --- read query --- */
 		for( j=q ; j ; j-- )
 			fget_line( fp, query_str[j-1], MAX_CHAR_LINE-1 );
 
 		/* ------------------------ */
 		/* --- calculation loop --- */
 		/* ------------------------ */
 
 		switch_num = 0;
 		reset_flag( s );
 		for( j=0 ; j<q ; j++ )
 		{
 			/* --- find the index of same search engine --- */
 			for( k=0 ; k<s ; k++ )
 			{
 				if( !strcmp( query_str[j], engine_str[k] ) )
 				{
 					/* --- set flag '0', sub number --- */
 					if( engine_flag[k] )
 					{
 						engine_flag[k] = 0;
 						engine_num--;
 					}
 
 					/* --- if engine number is '0', switch engine --- */
 					if( !engine_num )
 					{
 						switch_num++;
 						reset_flag( s );
 						engine_flag[k] = 0;
 						engine_num--;
 					}
 					break;
 				}
 			}
 		}
 
 		/* --- display result --- */
 		printf( αCase #%d: %dnα, i+1, switch_num );
 	}
 
 	fclose( fp );
 
 	return( 0 );
 }
 
 /* ------------------------------------------------------------------------ */
 /* get one line function													*/
 /* ------------------------------------------------------------------------ */
 
 int
 fget_line( FILE *fp, char *buff, int max )
 {
 	int		i, idx = 0;
 
 	for( i=0 ; i<max ; i++ )
 	{
 		if( feof(fp) )		break;
 		buff[i] = fgetc( fp );
 		if( (buff[i]=='n') || (buff[i]=='r') )	break;
 	}
 	buff[i] = 0;
 
 	return( i );
 }
 
 /* ------------------------------------------------------------------------ */
 
 void
 reset_flag( int num )
 {
 	int		i;
 	for( i=0 ; i<num ; i++ )	engine_flag[i] = 1;
 	engine_num = num;
 }
 
 /* ------------------------------------------------------------------------ */
 /* end of this file															*/
 /* ------------------------------------------------------------------------ */"
23205,2008,32013,LeHaKo,24481,1,lehako_train_timetable.c,gcj/2008/32013/LeHaKo/24481/1/extracted/lehako_train_timetable.c,"#include <stdio.h>
 #include <string.h>
 
 #define	MAX_CHAR_LINE		128
 
 int		fget_line( FILE *fp, char *buff, int max );
 void	qsort( int table[][], int left, int right, int base_idx );
 
 /* --- time table in minutes for a->b / b->a --- */
 int		ab[100][2];
 int		ba[100][2];
 int		ab_flag[100];
 int		ba_flag[100];
 
 /* ------------------------------------------------------------------------ */
 /* main function															*/
 /* ------------------------------------------------------------------------ */
 
 int
 main( int argc, char **argv )
 {
 	char	line[MAX_CHAR_LINE], *str1, *str2, *str_h, *str_m;
 	int		i, j, k;
 	int		n, na, nb, nta, ntb, tatime;
 	FILE	*fp;
 
 	/* --- check argument --- */
 	if( argc != 2 )
 	{
 		printf( αargument errornα );
 		return;
 	}
 
 	/* --- file open --- */
 	fp = fopen( argv[1], αrα );
 	if( fp == NULL )
 	{
 		printf( αfile not foundnα );
 		return;
 	}
 
 	/* --- get N --- */
 	fget_line( fp, line, MAX_CHAR_LINE-1 );
 	n = atoi( line );
 
 	for( i=0 ; i<n ; i++ )
 	{
 		/* --- get turnaround time --- */
 		fget_line( fp, line, MAX_CHAR_LINE-1 );
 		tatime = atoi( line );
 
 		/* --- get NA, NB --- */
 		fget_line( fp, line, MAX_CHAR_LINE-1 );
 		str1 = strtok( line, α tα );
 		str2 = strtok( NULL, α tα );
 		na = atoi( str1 );
 		nb = atoi( str2 );
 
 		/* --- get a -> b time --- */
 		for( j=0 ; j<na ; j++ )
 		{
 			fget_line( fp, line, MAX_CHAR_LINE-1 );
 			str1 = strtok( line, α tα );
 			str2 = strtok( NULL, α tα );
 
 			str_h = strtok( str1, α:α );
 			str_m = strtok( NULL, α:α );
 			ab[j][0] = atoi(str_h) * 60 + atoi(str_m);
 
 			str_h = strtok( str2, α:α );
 			str_m = strtok( NULL, α:α );
 			ab[j][1] = atoi(str_h) * 60 + atoi(str_m);
 		}
 
 		/* --- get b -> a time --- */
 		for( j=0 ; j<nb ; j++ )
 		{
 			fget_line( fp, line, MAX_CHAR_LINE-1 );
 			str1 = strtok( line, α tα );
 			str2 = strtok( NULL, α tα );
 
 			str_h = strtok( str1, α:α );
 			str_m = strtok( NULL, α:α );
 			ba[j][0] = atoi(str_h) * 60 + atoi(str_m);
 
 			str_h = strtok( str2, α:α );
 			str_m = strtok( NULL, α:α );
 			ba[j][1] = atoi(str_h) * 60 + atoi(str_m);
 		}
 
 		/* --- sorting a-start, b-end ---- */
 		qsort( ab, 0, na-1, 1 );
 		qsort( ba, 0, nb-1, 0 );
 
 		/* --- clear b flag --- */
 		for( j=0 ; j<nb ; j++ )		ba_flag[j] = 1;
 
 		/* --- calculate ntb --- */
 		ntb = nb;
 		for( j=0 ; j<na ; j++ )
 		{
 			for( k=0 ; k<nb ; k++ )
 			{
 				if( !ba_flag[k] )	continue;
 				if( (ab[j][1]+tatime) <= ba[k][0] )
 				{
 					ba_flag[k] = 0;
 					ntb--;
 					break;
 				}
 			}
 		}
 
 		/* --- sorting b-start, a-end ---- */
 		qsort( ab, 0, na-1, 0 );
 		qsort( ba, 0, nb-1, 1 );
 
 		/* --- clear a flag --- */
 		for( j=0 ; j<na ; j++ )		ab_flag[j] = 1;
 
 		/* --- calculate nta --- */
 		nta = na;
 		for( j=0 ; j<nb ; j++ )
 		{
 			for( k=0 ; k<na ; k++ )
 			{
 				if( !ab_flag[k] )	continue;
 				if( (ba[j][1]+tatime) <= ab[k][0] )
 				{
 					ab_flag[k] = 0;
 					nta--;
 					break;
 				}
 			}
 		}
 
 		/* --- display result --- */
 		printf( αCase #%d: %d %dnα, (i+1), nta, ntb );
 	}
 
 	fclose( fp );
 
 	return( 0 );
 }
 
 /* ------------------------------------------------------------------------ */
 /* get one line function													*/
 /* ------------------------------------------------------------------------ */
 
 int
 fget_line( FILE *fp, char *buff, int max )
 {
 	int		i, idx = 0;
 
 	for( i=0 ; i<max ; i++ )
 	{
 		buff[i] = fgetc( fp );
 		if( (buff[i]=='n') || (buff[i]=='r') )	break;
 	}
 	buff[i] = 0;
 
 	return( i );
 }
 
 /* ------------------------------------------------------------------------ */
 
 void
 qsort( int table[100][2], int left, int right, int base_idx )
 {
 	int		pivot[2], l_hold, r_hold, tmp;
 
 	l_hold = left;
 	r_hold = right;
 	pivot[0] = table[left][0];
 	pivot[1] = table[left][1];
 
 	while( left < right )
 	{
 		while( (table[right][base_idx] >= pivot[base_idx]) && (left < right) )
 			right--;
 		if( left != right )
 		{
 			table[left][0] = table[right][0];
 			table[left][1] = table[right][1];
 			left++;
 		}
 		while( (table[left][base_idx] <= pivot[base_idx]) && (left < right) )
 			left++;
 		if( left != right )
 		{
 			table[right][0] = table[left][0];
 			table[right][1] = table[left][1];
 			right--;
 		}
 	}
 
 	table[left][0] = pivot[0];
 	table[left][1] = pivot[1];
 	tmp = left;
 	left = l_hold;
 	right = r_hold;
 
 	if( left < tmp )		qsort( table, left, tmp-1, base_idx );
 	if( right > tmp )		qsort( table, tmp+1, right, base_idx );
 }
 
 /* ------------------------------------------------------------------------ */
 /* end of this file															*/
 /* ------------------------------------------------------------------------ */"
23282,2008,32013,sergio10barca,24480,1,Saving the Universe.c,gcj/2008/32013/sergio10barca/24480/1/extracted/Saving the Universe.c,"#include <stdio.h>
 #include <string.h>
 #define MAX 101
 #define TAM 102
 
 char browser[MAX][TAM];
 
 int binsearch(char x[], int n)
 {
    int valor, low, high, mid;
    low = 0;
    high = n - 1;
    while (low <= high) 
    {
       mid = (low+high)/2;
       if ((valor = strcmp(x, browser[mid])) < 0)
          high = mid - 1;
       else if (valor > 0)
          low = mid + 1;
       else /* found match */
          return mid;
    }
    return -1; /* no match */
 }
 
 void shellsort(int n)
 {
    int gap, i, j;
    char temp[TAM];
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && strcmp(browser[j], browser[j+gap]) > 0; j-=gap) 
          {
             strcpy(temp, browser[j]);
             strcpy(browser[j], browser[j+gap]);
             strcpy(browser[j+gap], temp);
          }
    return;
 }
 
 int main()
 {
     int i, j, k, casos, s, q, cont, suma, indice, flags[MAX];
     char query[TAM];
     scanf(α%dnα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &s);/*numero de browsers*/
         for(i = 0; i < s; i++){
             for(j = 0; (browser[i][j] = getchar()) != 'n'; j++);
             browser[i][j] = '0';
         }
         shellsort(s);
 /*        for(i = 0; i < s; i++)
             printf(α%s'nα, browser[i]);*/
         suma = cont = 0;
         for(i = 0; i < s; i++)
             flags[i] = 0;
         scanf(α%dnα, &q);/*numero de consultas*/
         for(i = 0; i < q; i++){
             for(j = 0; (query[j] = getchar()) != 'n' && query[j] != EOF; j++);
             query[j] = '0';
             indice = binsearch(query, s);
             if(indice != -1){
                 if(flags[indice] == 0){
                     flags[indice] = 1;
                     suma++;
                 }
                 if(suma == s){
                     for(j = 0; j < s; j++)
                         flags[j] = 0;
                     flags[indice] = 1;
                     cont++;
                     suma = 1;
                 }
             }
 /*            for(j = 0; j < s; j++)
                 printf(α%d α, flags[j]);
             printf(αn%3d suma = %3d indice = %3d %s'nnα, i+1, suma, indice, query);*/
         }
         printf(αCase #%d: %dnα, k, cont);
     }
     return 0;
 }"
23284,2008,32013,sergio10barca,24481,1,Train Timetable.c,gcj/2008/32013/sergio10barca/24481/1/extracted/Train Timetable.c,"#include <stdio.h>
 #define MAX 102
 #define SALE 0
 #define LLEGA 1
 
 int empalma(int llega[], int sale[], int n, int m, int tiempo)
 {
     int i, j, cont = 0;
     for(i = j = 0; i < n && j < m; j++){
         if(sale[j] >= (llega[i]+tiempo))
             i++;
         else
             cont++;
     }
     if(j < m){
         cont += (m-j);
     }
     return cont;
 }
 
 void shellsort(int v[], int n)
 {
    int gap, i, j, temp;
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) 
          {
             temp = v[j];
             v[j] = v[j+gap];
             v[j+gap] = temp;
          }
    return;
 }
 
 void imprime(int m[2][MAX], int n)
 {
     int i;
     printf(α%dnα, n);
     for(i = 0; i < n; i++)
         printf(α%d %dnα, m[SALE][i], m[LLEGA][i]);
     return;
 }
 
 int hmilitar(int horas, int minutos)
 {
     return (horas * 60) + minutos;
 }
 
 int main()
 {
     int a, b, c, d, i, k, salena, salenb, tiempo, casos, na, nb, ab[2][MAX], ba[2][MAX];
     scanf(α%dα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &tiempo);
         scanf(α%d%dnα, &na, &nb);
         for(i = 0; i < na; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ab[SALE][i] = hmilitar(a, b);
             ab[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ab[SALE][i], ab[LLEGA][i]);*/
         }
         for(i = 0; i < nb; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ba[SALE][i] = hmilitar(a, b);
             ba[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ba[SALE][i], ba[LLEGA][i]);*/
         }
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[SALE], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[LLEGA], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salena = empalma(ba[LLEGA], ab[SALE], nb, na, tiempo);
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[LLEGA], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[SALE], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salenb = empalma(ab[LLEGA], ba[SALE], na, nb, tiempo);
         printf(αCase #%d: %d %dnα, k, salena, salenb);
     }
     return 0;
 }"
23369,2008,32013,elvis,24480,1,main.c,gcj/2008/32013/elvis/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 
 int
 main(int argc, char **argv)
 {
 	int n, i, j, k;
 	FILE *fp;
 	FILE *fp_out;
 	char engine[100][101];
 	char query[1000][101];
 	int check[100];
 	int e_num;
 	int q_num;
 	int match, sw;
 	char filename[32];
 
 	sprintf(filename, α%s.txtα, argv[1]);
 
 	fp = fopen(argv[1], αrα);
 	fp_out = fopen(filename, αwα);
 
 	fscanf(fp, α%dnα, &n);
 	printf(α%dnα, n);
 
 	for (i = 0; i < n; i++)
 	{
 		fscanf(fp, α%dnα, &e_num);
 		printf(α%dnα, e_num);
 
 		for (j = 0; j < e_num; j++)
 		{
 			fgets(engine[j], 100, fp);
 			printf(α%sα, engine[j]);
 		}
 
 		fscanf(fp, α%dnα, &q_num);
 		printf(α%dnα, q_num);
 
 		for (k = 0; k < q_num; k++)
 		{
 			fgets(query[k], 100, fp);
 			printf(α%sα, query[k]);
 		}
 
 		memset(check, 0, sizeof(check));
 		match = 0;
 		sw = 0;
 
 		for (k = 0; k < q_num; k++)
 		{
 			for (j = 0; j < e_num; j++)
 			{
 				if (strcmp(engine[j], query[k]) != 0)
 					continue;
 
 				if (check[j] == 1)
 					break;
 
 				check[j] = 1;
 
 				match++;
 
 				break;
 			}
 
 			if (match  != e_num)
 				continue;
 
 			sw++;
 
 			memset(check, 0, sizeof(check));
 			match = 1;
 			check[j] = 1;
 		}
 
 		fprintf(fp_out, αCase #%d: %dnα, i+1, sw);
 	}
 
 	return 0;
 }"
23371,2008,32013,elvis,24481,1,main.c,gcj/2008/32013/elvis/24481/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 #include <time.h>
 
 void
 sort(int *a, int n)
 {
 	int i, j;
 	int temp[100];
  	int count;
 	int same;
 	int s;
 
 	memset(temp, 0, 100);
 
 	for (i = 0; i < n; i++)
 	{
 		count = 0;
 		same = 0;
 
 		for (j = 0; j < n; j++)
 		{
 			if (a[i] > a[j])
 				count++;
 
 			if (a[i] == a[j])
 				same++;
 
 		}
 
 		temp[count] = a[i];
 
 		for (j = 0; j < same; j++)
 		{
 			temp[count + j] = a[i];
 		}
 	}
 
 	memcpy(a, temp, sizeof(int) * n);
 }
 
 
 int
 main(int argc, char **argv)
 {
 	int n, i, j ,k;
 	FILE *fp, *fp_out;
 	char filename[32];
 	int na, nb, t;
 	char t_a[8];
 	char t_d[8];
 	struct tm tm_aa[100];
 	struct tm tm_ad[100];
 	struct tm tm_ba[100];
 	struct tm tm_bd[100];
 	int t_aa[100], t_ad[100], t_ba[100], t_bd[100];
 	int a_train, b_train;
 	int a_count, b_count;
 
 
 	sprintf(filename, α%s.txtα, argv[1]);
 
 	fp = fopen(argv[1], αrα);
 	fp_out = fopen(filename, αwα);
 
 	fscanf(fp, α%dnα, &n);
 	printf(α%dnα, n);
 
 	for (i = 0; i < n; i++)
 	{
 		fscanf(fp, α%dnα, &t);
 		printf(α%dnα, t);
 		fscanf(fp, α%d %dnα, &na, &nb);
 		printf(α%d %dnα, na, nb);
 
 		for (j = 0; j < na; j++)
 		{
 			fscanf(fp, α%s %snα, t_d, t_a);
 			printf(α%s %snα, t_d, t_a);
 			strptime(t_a, α%H:%Mα, &tm_aa[j]);
 			strptime(t_d, α%H:%Mα, &tm_ad[j]);
 			t_aa[j] = tm_aa[j].tm_hour * 60 + tm_aa[j].tm_min;
 			t_ad[j] = tm_ad[j].tm_hour * 60 + tm_ad[j].tm_min;
 			printf(α%d %dnα, t_ad[j], t_aa[j]);
 		}
 
 		sort(t_ad, na);
 		sort(t_aa, na);
 		
 
 		for (j = 0; j < na; j++)
 			printf(α%dnα, t_ad[j]);
 		for (j = 0; j < na; j++)
 			printf(α%dnα, t_aa[j]);
 
 		for (k = 0; k < nb; k++)
 		{
 			fscanf(fp, α%s %snα, t_d, t_a);
 			printf(α%s %snα, t_d, t_a);
 			strptime(t_a, α%H:%Mα, &tm_ba[k]);
 			strptime(t_d, α%H:%Mα, &tm_bd[k]);
 			t_ba[k] = tm_ba[k].tm_hour * 60 + tm_ba[k].tm_min;
 			t_bd[k] = tm_bd[k].tm_hour * 60 + tm_bd[k].tm_min;
 			printf(α%d %dnα, t_bd[k], t_ba[k]);
 		}
 
 		sort(t_bd, nb);
 		sort(t_ba, nb);
 
 		for (j = 0; j < nb; j++)
 			printf(α%dnα, t_bd[j]);
 		for (j = 0; j < nb; j++)
 			printf(α%dnα, t_ba[j]);
 
 
 		a_train = b_train = 0;
 
 		for (j = 0; j < na; j++)
 		{
 			for (k = 0; k < nb; k++)
 			{
 				if (t_ad[j] < (t_ba[k] + t))
 					continue;
 
 				t_ba[k] = 60 * 25;
 				break;
 			}
 
 			if (k != nb)
 				continue;
 
 			a_train++;
 		}
 
 		for (j = 0; j < nb; j++)
 		{
 			for (k = 0; k < na; k++)
 			{
 				if (t_bd[j] < (t_aa[k] + t))
 					continue;
 
 				t_aa[k] = 60 * 25;
 				break;
 			}
 
 			if (k != na)
 				continue;
 
 			b_train++;
 		}
 
 		printf(α%d %dnα, a_train, b_train);
 		fprintf(fp_out, αCase #%d: %d %dnα, i+1, a_train, b_train);
 	}	
 
 
 
 	return 0;
 }"
23439,2008,32013,along,24480,1,as.c,gcj/2008/32013/along/24480/1/extracted/as.c,"#include <iostream>
 #include <string>
 #include <stdio.h>
 #include <map>
 using namespace std;
 int S,Q;
 int query[1001];
 int best[1001][101];
 
 int calc(int p, int s)
 {
 	if (p == Q)
 		return 0;
 	if (best[p][s] >= 0) return best[p][s];
 	int& r = best[p][s];
 	if (s != query[p])
 	{
 		r = calc(p+1, s);
 //		cout << p << ' ' << s << ' ' << r << endl;
 		return r;
 	}
 	r = 1000000;
 	for(int i=0; i<S; i++)
 	{
 		if (i == s) continue;
 		int t = calc(p+1, i) + 1;
 		if (t < r) r = t;
 	}
 //		cout << p << ' ' << s << ' ' << r << endl;
 	return r;
 }
 
 int main()
 {
 	int cc,ca;
 	int i,j,k;
 	cin >> ca;
 	map<string,int> sname;
 	for(cc=1;cc<=ca;cc++)
 	{
 		sname.clear();
 		char buf[1024];
 		scanf(α%dα, &S);
 		fgets(buf, 1024, stdin);
 		for(i=0;i<S;i++)
 		{
 			fgets(buf, 1024, stdin);
 			if (buf[strlen(buf)-1] == 'r' || buf[strlen(buf)-1] == 'n')
 				buf[strlen(buf)-1] = 0;
 			if (buf[strlen(buf)-1] == 'r' || buf[strlen(buf)-1] == 'n')
 				buf[strlen(buf)-1] = 0;
 			sname[buf] = i;
 		}
 		scanf(α%dα, &Q);
 		fgets(buf, 1024, stdin);
 		for(i=0;i<Q;i++)
 		{
 			fgets(buf, 1024, stdin);
 			if (buf[strlen(buf)-1] == 'r' || buf[strlen(buf)-1] == 'n')
 				buf[strlen(buf)-1] = 0;
 			if (buf[strlen(buf)-1] == 'r' || buf[strlen(buf)-1] == 'n')
 				buf[strlen(buf)-1] = 0;
 //			if (sname.find(buf) == sname.end())
 //				cout << αWARNINGα << endl;
 			query[i] = sname[buf];	
 		}
 //		cout << S << ' ' << Q << endl;
 		for(i=0; i<Q; i++) for(j=0; j<S; j++) best[i][j] = -1;
 		int r = 1000000;
 		for(k=0; k<S; k++)
 		{
 			int t = calc(0, k);
 //			cout << k << ' ' << t << endl;
 			if (t < r) r = t;
 		}
 		printf(αCase #%d: %dnα, cc, r);
 	}
 }"
23442,2008,32013,along,24481,1,b.c,gcj/2008/32013/along/24481/1/extracted/b.c,"#include <stdio.h>
 #include <string>
 #include <iostream>
 using namespace std;
 
 struct train{
 	int status;
 	int dest;
 	int time;
 };
 
 train tr[202];
 int turnaround;
 
 int AT[101][2],BT[101][2];
 int NA,NB;
 int ra,rb;
 int ta,tb;
 
 int main()
 {
 	int cc,ca;
 	int i,j,k;
 	scanf(α%dα, &ca);
 	for(cc=1;cc<=ca;cc++)
 	{
 		scanf(α%dα, &turnaround);
 		scanf(α%d %dα, &NA, &NB);
 		char buf[1024];
 		fgets(buf, 1024, stdin);
 		for(i=0; i<NA; i++)
 		{
 			fgets(buf, 1024, stdin);
 			for(j=0; j<strlen(buf); j++)
 				if (buf[j] == ':')
 					buf[j] = ' ';
 			int a,b,c,d;
 			sscanf(buf, α%d %d %d %dα, &a, &b, &c, &d);
 			AT[i][0] = a*60+b;
 			AT[i][1] = c*60+d;
 		}
 		for(i=0; i<NB; i++)
 		{
 			fgets(buf, 1024, stdin);
 			for(j=0; j<strlen(buf); j++)
 				if (buf[j] == ':')
 					buf[j] = ' ';
 			int a,b,c,d;
 			sscanf(buf, α%d %d %d %dα, &a, &b, &c, &d);
 			BT[i][0] = a*60+b;
 			BT[i][1] = c*60+d;
 		}
 /*		for(i=0; i<NA; i++)
 			cout << AT[i][0] << ' ' << AT[i][1] << endl;
 		for(i=0; i<NB; i++)
 			cout << BT[i][0] << ' ' << BT[i][1] << endl;
 */
 		memset(tr, 0, sizeof(tr));
 		ra = 0; rb = 0;
 		ta = 0; tb = 0;
 		for(int time = 0; time<=24*60; time++)
 		{
 			// update train
 			for(i=0; i<200; i++)
 			{
 				if (tr[i].status == 2)
 				{
 					tr[i].time--;
 					if (tr[i].time == 0)
 					{
 						tr[i].time = turnaround;
 						tr[i].status = 1;
 						if (turnaround == 0)
 						{
 							tr[i].status = 0;
 							if (tr[i].dest == 0)
 								ta++;
 							else
 								tb++;
 						}
 					}
 				}
 				else if (tr[i].status == 1)
 				{
 					tr[i].time--;
 					if (tr[i].time == 0)
 					{
 						tr[i].status = 0;
 						if (tr[i].dest == 0)
 							ta++;
 						else
 							tb++;
 					}
 				}
 			}
 
 			for(i=0; i<NA; i++)
 			{
 				if (AT[i][0] == time)
 				{
 					for(j=0; j<200; j++)
 						if (tr[j].status == 0)
 							break;
 					tr[j].status = 2;
 					tr[j].time = AT[i][1] - AT[i][0];
 					tr[j].dest = 1;
 					ta--;
 					if (ta < ra) ra = ta;
 				}
 			}
 			for(i=0; i<NB; i++)
 			{
 				if (BT[i][0] == time)
 				{
 					for(j=0; j<200; j++)
 						if (tr[j].status == 0)
 							break;
 					tr[j].status = 2;
 					tr[j].time = BT[i][1] - BT[i][0];
 					tr[j].dest = 0;
 					tb--;
 					if (tb < rb) rb = tb;
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα, cc, -ra, -rb);
 	}
 }"
23466,2008,32013,JLBoat,24480,1,a.c,gcj/2008/32013/JLBoat/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int numn,i,j,n,s,q,countswitch=0;
 char engine[100][100],query[100];
 int countengine[100]={0};
 
 void reallycleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 }
 
 void cleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 	countengine[j]++;		
 }
 
 void checkarray() {
 	int index,zerocount=0;
 	for(index=0; index<s; index++)
 		if(!countengine[index]) zerocount++;
 	if(zerocount == 0) { 
 		countswitch++;
 		cleararray();
 	}
 }
 
 int main() {
 	scanf(α%dα,&n);
 	for(numn=0; numn<n; numn++) {
 		scanf(α%dα,&s);
 		getchar();
 		for(i=0; i<s; i++) {
 			gets(engine[i]);
 		}
 		scanf(α%dα,&q);
 		getchar();
 		for(i=0; i<q; i++) {
 			gets(query);
 			for(j=0; j<s; j++) {
 				if(!strcmp(query,engine[j])) {
 					countengine[j] += !strcmp(query,engine[j]);
 					break;
 				}	
 			}
 			checkarray();
 		}	
 		reallycleararray();
 		printf(αCase #%d: %dnα,numn+1,countswitch);
 		countswitch = 0;
 	}
 	return 0;
 }"
23468,2008,32013,JLBoat,24481,1,train.c,gcj/2008/32013/JLBoat/24481/1/extracted/train.c,"#include<stdio.h>
 
 int n,a,b,i,j,k,l,t,counta,countb,q;
 int tmp1,tmp2,tmp3,tmp4;
 int tafrom[200],tato[200],tat[200];
 int flag,what;
  
 int route(int index) {
     int m;
     if(flag == 0) {
         flag = 1;
         what = tat[index];
     }
     if(tat[index] == 0) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 1)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     } else
     if(tat[index] == 1) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 0)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     }
     tat[index] = -1;
     return what;
 }
 
 
 
 
 
 
    
 int main() {
     scanf(α%dα,&n);
     for(l=0;l<n;l++) {
         scanf(α%dα,&t);
         scanf(α%d %dα,&a,&b);
         for(j=0; j<a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 0;
         }
         for(; j<b+a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 1;
         }
     
 // Sort
     for(i=0;i<a+b-1;i++)
         for(j=0;j<a+b-1;j++)
             if(tafrom[j] > tafrom[j+1]) {
                 tmp1 = tafrom[j];
                 tafrom[j] = tafrom[j+1];
                 tafrom[j+1] = tmp1;
                 tmp1 = tato[j];
                 tato[j] = tato[j+1];
                 tato[j+1] = tmp1;
                 tmp1 = tat[j];
                 tat[j] = tat[j+1];
                 tat[j+1] = tmp1;
             }
     for(i=0; i<a+b; i++) {
 
       
         q = route(i);
         if(q == 0) {
             counta++;
             flag = 0;
         }
         if(q == 1) {
             countb++;
             flag = 0;
         }
         if(q == -1)
             flag = 0;
     }
 
     printf(αCase #%d: %d %dnα,l+1,counta,countb);
 
 
     for(i=0; i<a+b; i++) {
         tafrom[i] = 0;
         tato[i] = 0;
         tat[i] = 0;
     }
     counta = 0;
     countb = 0;
     flag = 0;
 
     }
 
 return 0;
 }"
23514,2008,32013,album,24481,1,q2.c,gcj/2008/32013/album/24481/1/extracted/q2.c,"#include<stdio.h>
 #include<string.h>
 #define NOTINCHAIN 0  
 #define STARTOFCHAIN 1
 #define MIDDLEOFCHAIN 2
 #define ATOB 0
 #define BTOA 1
 typedef struct aTripStru{
     int directFlag;
     int startTime;
     int arriveTime;
     int chainFlag;
 }atrip;
 int main(){
     int caseNum = 0,caseCount = 0,nNum = 0,nCount = 0,aTripsNum = 0,
     aTripsCount = 0,bTripsNum = 0,bTripsCount = 0,aStartNum = 0,bStartNum = 0,
     sHour,sMin,aHour,aMin,turnaroundTime;
     int i,j,f;
     char tmp[10];
     atrip trips[200],tripTmp;
     int aCarsNum = 0,bCarsNum = 0;
     gets(tmp);
     caseNum = atoi(tmp);
     while(caseCount++ < caseNum){
         nNum = 0,nCount = 0,aTripsNum = 0,aTripsCount = 0,bTripsNum = 0,
         bTripsCount = 0,aStartNum = 0,bStartNum = 0,aCarsNum = 0,bCarsNum = 0;
         gets(tmp);
         turnaroundTime = atoi(tmp);
         scanf(α%d %dα,&aTripsNum,&bTripsNum);
         while(aTripsCount++ < aTripsNum){
             scanf(α%d:%d %d:%dnα,&sHour,&sMin,&aHour,&aMin);
             trips[nCount].directFlag = ATOB;
             trips[nCount].startTime = sHour*60+sMin;
             trips[nCount].arriveTime = aHour*60+aMin;
             trips[nCount].chainFlag = NOTINCHAIN;
             nCount++;
         }
         while(bTripsCount++ < bTripsNum){
             scanf(α%d:%d %d:%dnα,&sHour,&sMin,&aHour,&aMin);
             trips[nCount].directFlag = BTOA;
             trips[nCount].startTime = sHour*60+sMin;
             trips[nCount].arriveTime = aHour*60+aMin;
             trips[nCount].chainFlag = NOTINCHAIN; 
             nCount++;
         }
         //
         i=j=f=0;
         while(i < aTripsNum+bTripsNum){
             j = 0;
             f = 0;
             while(j < aTripsNum+bTripsNum - i - 1){
                 if(trips[j].startTime > trips[j+1].startTime){
                     tripTmp = trips[j];
                     trips[j] = trips[j+1];  
                     trips[j+1] = tripTmp;
                     f =1;
                 }
                 j++;
             }
             if(f = 0){
                 break;
             }
             i++;
         }
         nCount = 0;
         while(nCount < aTripsNum+bTripsNum){
             for(i=0;i<aTripsNum+bTripsNum;i++){
                 if(trips[i].chainFlag == NOTINCHAIN){
                     tripTmp = trips[i];
                     trips[i].chainFlag = MIDDLEOFCHAIN;
                     if(tripTmp.directFlag == ATOB)
                         aCarsNum++;
                     else
                         bCarsNum++;
                     nCount++;
                     break;
                 }
             }
             if(i != aTripsNum+bTripsNum){
                 for(j=i+1;j<aTripsNum+bTripsNum;j++){
                     if(trips[j].chainFlag == NOTINCHAIN && trips[j].directFlag != tripTmp.directFlag){
                         if(tripTmp.arriveTime+turnaroundTime <= trips[j].startTime){
                             tripTmp = trips[j];
                             trips[j].chainFlag = MIDDLEOFCHAIN;
                             nCount++;
                         }
                     }
                 }
             }
             else
                 break;
         }
         printf(αCase #%d: %d %dnα,caseCount,aCarsNum,bCarsNum);
 
     }
 }"
23591,2008,32013,JimmyDong,24480,1,A.c,gcj/2008/32013/JimmyDong/24480/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct {
     char * dat;
     int index;
 } ENTRY;
 
 
 FILE *in,*out;
 int N,S,Q;
 int i,j,k,ii,scnt,cnt;
 ENTRY a[100];
 int b[100];
 char buff[101];
 
 void readline(char buffer[]);
 int search(char *);
 int ENTRYcmp(const void *, const void *);
 
 int main(){
     in = fopen(αA-large.inα,αrα);
     out = fopen(αA-large.outα,αwα);
     fscanf(in,α%dnα,&N);
     for(i=0;i<100;i++)a[i].dat = malloc(101*sizeof(char));
     
     for(k=0;k<N;k++){
         /*printf(αIn CASE %d:nα,k+1);*/
         fprintf(out,αCase #%d: α,k+1);
         fscanf(in,α%dnα,&S);
         /*printf(αWe have %d serversnThey are:nα,S);*/
         for(i=0;i<S;i++){
             readline(a[i].dat);
             a[i].index = i;
             b[i]=0;
             /*printf(α%snα,a[i].dat);*/
         }
         cnt=0;scnt=0;
         qsort(a,S,sizeof(ENTRY),&ENTRYcmp);
         fscanf(in,α%dnα,&Q);
         /*printf(αWe got %d queriesnα,Q);*/
         for(i=0;i<Q;i++){
             readline(buff);
             j = search(buff);
             if(!b[j]){
                 b[j]=1;
                 scnt++;
             }
             if(scnt==S){
                 cnt++;
                 for(ii=0;ii<S;ii++)b[ii]=0;
                 b[j]=1;
                 scnt=1;
             }
         }
         fprintf(out,α%dnα,cnt);
     }
     
     for(i=0;i<100;i++)free(a[i].dat);
     fclose(in);
     fclose(out);
     system(αpauseα);
     return 0;
 }
 
 void readline(char buffer[]){
     char character;
     int i=0;
     character = fgetc(in);
     if(character!='n')buffer[i++]=character;
     do
     {
         character = fgetc(in);
         buffer[i] = character;
         ++i;
     }
     while(character!='n');
     buffer[i-1] = '0';
     /*printf(αString α%sα readnα,buffer);*/
 }
 
 int ENTRYcmp(const void *a, const void *b){
     ENTRY *x,*y;
     x = (ENTRY *)a;
     y = (ENTRY *)b;
     return strcmp(x->dat,y->dat);
 }
 
 int search(char *buffer){
     ENTRY *t;
     ENTRY x;
     x.dat = buffer;
     x.index = -1;
     t = (ENTRY *)bsearch(&x, a, S, sizeof(ENTRY), &ENTRYcmp);
     /*if(t==NULL){
         printf(αsearch of term %snα,buffer);
         printf(αNot foundnα);return 0;}
     else*/ return t->index;
 }"
23593,2008,32013,JimmyDong,24481,1,B.c,gcj/2008/32013/JimmyDong/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define debug
 
 typedef struct {
     int time;
     int dat;
 } table;
 
 int N,Na,Nb,T;
 int i,j,k,x,cnt,maxcnt;
 table a[200],b[200];
 FILE *in,*out;
 
 int gettime(void);
 int tablecmp(const void *, const void *);
 
 int main(){
     in = fopen(αB-large.inα,αrα);
     out = fopen(αB-large.outα,αwα);
     fscanf(in,α%dα,&N);
     for(k=0;k<N;k++){
         fprintf(out, αCase #%d: α,k+1);
         fscanf(in,α%dα,&T);
         fscanf(in,α%d %dα,&Na,&Nb);
         for(i=0;i<Na;i++){
             a[i].time = gettime();
             a[i].dat = -1;
             b[i].time = gettime() + T;
             b[i].dat = 1;
         }
         x = Na + Nb;
         for(i=Na;i<x;i++){
             b[i].time = gettime();
             b[i].dat = -1;
             a[i].time = gettime() + T;
             a[i].dat = 1;
         }
         qsort(a,x,sizeof(table),&tablecmp);
         qsort(b,x,sizeof(table),&tablecmp);
         cnt = 0; maxcnt = 0;
         for(i=0;i<x;i++){
             cnt += a[i].dat;
             maxcnt=cnt<maxcnt?cnt:maxcnt;
         }
         fprintf(out,α%d α,-maxcnt);
         cnt = 0; maxcnt = 0;
         for(i=0;i<x;i++){
             cnt += b[i].dat;
             maxcnt=cnt<maxcnt?cnt:maxcnt;
         }
         fprintf(out,α%dnα,-maxcnt);
     }
     system(αpauseα);
     return 0;
 }
 
 int gettime(void){
     int hh,mm;
     fscanf(in,α%d:%dα,&hh,&mm);
     return hh * 60 + mm;
 }
 
 int tablecmp(const void *a, const void *b){
     int temp;
     temp = ((table *)a)->time - ((table *)b)->time;
     if(temp)return temp;
     return ((table *)b)->dat - ((table *)a)->dat;
 }"
23660,2008,32013,eliezio,24480,1,saving_the_universe.c,gcj/2008/32013/eliezio/24480/1/extracted/saving_the_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_NUM_ENGINES     100
 #define MAX_ENGINE_NAME     100
 #define MAX_QUERIES         1000
 
 static char *   rstrip (char *str, const char *chars);
 static int      get_number (void);
 static void     get_string (char *str, int max_len);
 
 static char  engine_names[MAX_NUM_ENGINES][MAX_ENGINE_NAME + 1];
 
 int
 main (void)
 {
     char    query[MAX_ENGINE_NAME + 1];
     int     i, j, k;
     int     num_cases;
     int     num_engines;
     int     num_queries;
     int     num_switches;
     int     count [MAX_NUM_ENGINES];
     int     n;
 
     num_cases = get_number ();
     for (i = 1; i <= num_cases; i++) {
         num_engines = get_number ();
         for (j = 0; j < num_engines; j++) {
             get_string (engine_names[j], sizeof (engine_names[j]));
             count[j] = 0;
         }
         num_queries = get_number ();
         num_switches = 0;
         n = 0;
         for (k = 0; k < num_queries; k++) {
             get_string (query, sizeof (query));
             for (j = 0; j < num_engines; j++) {
                 if (strcmp (query, engine_names[j]) == 0) {
                     if (count[j] == 0) {
                         count[j] = k + 1;
                         if (++n == num_engines) {
                             ++num_switches;
                             memset (count, 0, sizeof (count));
                             count[j] = k + 1;
                             n = 1;
                         }
                     }
                     break;
                 }
             }
         }
         printf (αCase #%d: %dnα, i, num_switches);
     }
 
     return EXIT_SUCCESS;
 }
 
 static char *
 rstrip (char *str, const char *chars)
 {
     int  i;
 
     for (i = strlen (str);
             (i > 0) && (strchr (chars, str[i - 1]) != NULL);
             i--) {
     }
     str [i] = '0';
 
     return str;
 }
 
 static int
 get_number (void)
 {
     char  line [16];
 
     fgets (line, sizeof (line), stdin);
     return atoi (rstrip (line, αrnα));
 }
 
 static void
 get_string (char *str, int max_len)
 {
     char    line [max_len + 3];
 
     rstrip (fgets (line, sizeof (line), stdin), αrnα);
     strcpy (str, line);
 }"
23668,2008,32013,istan,24480,1,gcj.c,gcj/2008/32013/istan/24480/1/extracted/gcj.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int N;
 
 char engines[105][105];
 int eCount;
 
 char queries[1005][105];
 int qCount;
 
 #define MIN 99999
 
 int findAnswer()
 {
 	int d[1005][105];
 
 	memset( d, 0, sizeof(d) );
 
 	for( int qq=1; qq<=qCount; qq++ )
 		for( int ee=1; ee<=eCount; ee++ )
 			if ( 0 == strcmp( queries[qq], engines[ee] ) )
 				d[qq][ee] = MIN;
 
 
 	for( int q=2; q<=qCount; q++ )
 	{
 		for( int e=1; e<=eCount; e++ )
 		{
 			if ( d[q][e] != MIN )
 			{
 				d[q][e] = d[q-1][e];
 
 				for( int c=1; c<=eCount; c++ )
 					if ( c != e )
 						d[q][e] = min( d[q][e], d[q-1][c] + 1 );
 			}
 		}
 	}
 
 	int m = MIN;
 	for( int e=1; e<=eCount; e++ )
 		m = min( m, d[qCount][e] );
 
 	return m;
 }
 
 int main(int argc,char *argv[])
 {
 	FILE* fin = fopen( αinput.txtα, αrα );
 	FILE* fout = fopen( αoutput.txtα, αwα );
 
 	fscanf( fin, α%dα, &N );
 
 	for( int i=1; i<=N; i++ )
 	{
 		fscanf( fin, α%dα, &eCount );
 		fgets( engines[0], 101, fin );
 
 		for( int j=1; j<=eCount; j++ )
 			fgets( engines[j], 101, fin );
 
 		fscanf( fin, α%dα, &qCount );
 		fgets( queries[0], 101, fin );
 
 		for( int j=1; j<=qCount; j++ )
 			fgets( queries[j], 101, fin  );
 
 		int answer = findAnswer();
 		fprintf( fout, αCase #%d: %dnα, i, answer );
 	}
 
 	fclose( fin );
 	fclose( fout );
 
 	return 0;
 }"
23672,2008,32013,istan,24481,1,b.c,gcj/2008/32013/istan/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int N, T, NA, NB;
 int answerA, answerB;
 
 char routesFromA[100][10];
 char routesFromB[100][10];
 
 char routesToA[100][10];
 char routesToB[100][10];
 
 typedef struct Edge_
 {
 	int from;
 	int to;
 } Edge;
 
 
 Edge ab[105];
 Edge ba[105];
 
 int edgeABUsed[105];
 int edgeBAUsed[105];
 
 int _cmp( const void* aa, const void* bb )
 {
 	const Edge* a = (Edge*)aa;
 	const Edge* b = (Edge*)bb;
 
 	if ( a->from < b->from )
 		return -1;
 	if ( a->from > b->from )
 		return 1;
 
 	if ( a->to < b->to )
 		return -1;
 
 	if ( a->to > b->to )
 		return 1;
 
 	return 0;
 }
 
 int getMinutes( char* time )
 {
 	int h, m;
 
 	sscanf( time, α%d:%dα, &h, &m );
 
 	return h*60 + m;
 }
 
 int findEdgeStartingAfter( Edge* edges, int* usedEdges, int edgesCount, int time )
 {
 	for( int i=1; i<=edgesCount; i++ )
 	{
 		if ( ( usedEdges[i] == 0 ) && ( edges[i].from >= time ) )
 			return i;
 	}
 
 	return -1;
 }
 
 int findAnswer()
 {
 	memset( edgeABUsed, 0, sizeof( edgeABUsed ) );
 	memset( edgeBAUsed, 0, sizeof( edgeBAUsed ) );
 
 	qsort( &ab[1], NA, sizeof(Edge), _cmp );
 	qsort( &ba[1], NB, sizeof(Edge), _cmp );
 
 	int currentTime = -1;
 
 	int eAB = -1;
 	int eBA = -1;
 
 	answerA = 0;
 	answerB = 0;
 
 
 	int ABUsed = 0;
 	int BAUsed = 0;
 
 
 	while( (ABUsed < NA) || (BAUsed < NB) )
 	{
 		int eFromA = findEdgeStartingAfter( ab, edgeABUsed, NA, 0 );
 		int eFromB = findEdgeStartingAfter( ba, edgeBAUsed, NB, 0 );
 
 		int startFromA = 0;
 		int startFromB = 0;
 
 		if ( ( eFromA > 0 ) && ( eFromB > 0 ) )
 		{
 			if( ab[eFromA].from < ba[eFromB].from )
 				startFromA = 1;
 			else
 				startFromB = 1;
 		}
 		else if ( eFromA == -1 )
 		{
 			startFromB = 1;
 		}
 		else if ( eFromB == -1 )
 		{
 			startFromA = 1;
 		}
 
 		if ( startFromA )
 		{
 			answerA++;
 			currentTime = -1;
 
 			while( 1 == 1 )
 			{
 				eAB = findEdgeStartingAfter( ab, edgeABUsed, NA, currentTime );
 				if ( eAB == -1 )
 					break;
 				currentTime = ab[eAB].to;
 				edgeABUsed[ eAB ] = 1;
 				ABUsed++;
 
 				eBA = findEdgeStartingAfter( ba, edgeBAUsed, NB, currentTime );
 				if ( eBA == -1 )
 					break;
 				currentTime = ba[eBA].to;
 				edgeBAUsed[ eBA ] = 1;
 				BAUsed++;
 			}
 		}
 		else
 		{
 			answerB++;
 			currentTime = -1;
 
 			while( 1 == 1 )
 			{
 				eBA = findEdgeStartingAfter( ba, edgeBAUsed, NB, currentTime );
 				if ( eBA == -1 )
 					break;
 				currentTime = ba[eBA].to;
 				edgeBAUsed[ eBA ] = 1;
 				BAUsed++;
 
 				eAB = findEdgeStartingAfter( ab, edgeABUsed, NA, currentTime );
 				if ( eAB == -1 )
 					break;
 				currentTime = ab[eAB].to;
 				edgeABUsed[ eAB ] = 1;
 				ABUsed++;
 			}
 		}
 
 	}
 
 	return 0;
 }
 
 int main(int argc,char *argv[])
 {
 	FILE* fin = fopen( αinput.txtα, αrα );
 	FILE* fout = fopen( αoutput.txtα, αwα );
 
 	fscanf( fin, α%dα, &N );
 
 	char time1[ 10 ];
 	char time2[ 10 ];
 
 	for( int i=1; i<=N; i++ )
 	{
 
 		fscanf( fin, α%dα, &T);
 		fscanf( fin, α%d %dα, &NA, &NB );
 
 		for( int k=1; k<=NA; k++ )
 		{
 			fscanf( fin, α%s %sα, time1, time2 );
 			ab[k].from = getMinutes( time1 );
 			ab[k].to = getMinutes( time2 ) + T;
 		}
 
 		for( int p=1; p<=NB; p++ )
 		{
 			fscanf( fin, α%s %sα, time1, time2 );
 			ba[p].from = getMinutes( time1 );
 			ba[p].to = getMinutes( time2 ) + T;
 		}
 
 		printf( αCase #%d:...nα, i );
 		findAnswer();
 
 		fprintf( fout, αCase #%d: %d %dnα, i, answerA, answerB );
 	}
 
 	fclose( fin );
 	fclose( fout );
 
 	return 0;
 }"
23732,2008,32013,kiransgm,24481,1,KI_TR.C,gcj/2008/32013/kiransgm/24481/1/extracted/KI_TR.C,"#include<stdio.h>
 #include <conio.h>
 #include <dos.h>
 
 typedef struct _time{
 int hours;
 int min;
 }time_t;
 
 //void add_T(time_t *, int);
 
 
 
 
 time_t A_dept[100];
 time_t A_arr[100];
 time_t B_dept[100];
 time_t B_arr[100];
 
 int N;
 int T;
 int NA;
 int NB;
 
 
 
 
 int main(int argc, char argv[])
 {
  int i;
  int j;
  int k;
  int n;
  int na,nb;
  FILE *infp;
  FILE *outfp;
  int int_rd;
  int int_rd_hh;
  int int_rd_mm;
  int temp_hh;
  int temp_mm;
  int tr_st_a;  
  int tr_st_b;
  
  char c_rd;
  char str_rd[100];
  clrscr();
 
  infp = fopen(αe:\tc\bin\ki_in_tr.txtα,αrα);
  if(infp){
   printf(αThe file existsnα);
  }
  else{
   printf(αThe file does not existnα);
   return 0;
  }
  outfp = fopen(αe:\tc\bin\ki_out_tr.txtα,αwα);
  if(outfp){
   printf(αThe file created sucessfully for writingnα);
  }
  else{
   printf(αThe file creation errornα);
   return 0;
  }
 
 // while(!(feof(infp))){
 //  fscanf(infp,α%sα,str_rd);
 //  printf(αREAD : %s nα,str_rd);
 
 //N
   fscanf(infp,α%dα,&N);
 //  printf(αN : %d nα,N);
   
   //For N Test Cases
   for(n=0;n<N;n++){
      tr_st_a = 0;  
      tr_st_b = 0;
   //Reading the Data from the file
     //T
       fscanf(infp,α%dα,&T);
 //      printf(αT : %d nα,T);
     //NA
       fscanf(infp,α%dα,&NA);
 //      printf(αNA : %d nα,NA);
     //NB
       fscanf(infp,α%dα,&NB);
 //      printf(αNB : %d nα,NB);
     
       for(na=0;na<NA;na++){
         //HH:MM (Dept)
           fscanf(infp,α%dα,&A_dept[na].hours);
           fscanf(infp,α%cα,&c_rd);
           fscanf(infp,α%dα,&A_dept[na].min);
 
 
           //add_T(&A_arr[na],T);
 
 
         //HH:MM (Arr)
           fscanf(infp,α%dα,&A_arr[na].hours);
           fscanf(infp,α%cα,&c_rd);
           fscanf(infp,α%dα,&A_arr[na].min);
 
           // T adjust (Addition of T)
           A_arr[na].min += T;
           if (A_arr[na].min >= 60 ){
               A_arr[na].hours = A_arr[na].hours + 1;
               A_arr[na].min = A_arr[na].min - 60;
           }
           
 //          printf(αDept : %d%c%d   α,A_dept[na].hours,c_rd,A_dept[na].min);
 //          printf(αArr  : %d%c%d nα,A_arr[na].hours,c_rd,A_arr[na].min);
           
       }
       for(nb=0;nb<NB;nb++){
         //HH:MM (Dept)
           fscanf(infp,α%dα,&B_dept[nb].hours);
           fscanf(infp,α%cα,&c_rd);
           fscanf(infp,α%dα,&B_dept[nb].min);
 
 
         //HH:MM (Arr)
           fscanf(infp,α%dα,&B_arr[nb].hours);
           fscanf(infp,α%cα,&c_rd);
           fscanf(infp,α%dα,&B_arr[nb].min);
 
           // T adjust (Addition of T)
           B_arr[nb].min += T;
           if (B_arr[nb].min >= 60 ){
               B_arr[nb].hours = B_arr[nb].hours + 1;
               B_arr[nb].min = B_arr[nb].min - 60;
           }
 
 //          printf(αDept : %d%c%d   α,B_dept[nb].hours,c_rd,B_dept[nb].min);
 //          printf(αArr  : %d%c%d nα,B_arr[nb].hours,c_rd,B_arr[nb].min);
           
       }
       //Reading the data set is finished
       
       //if any NA or NB is equal to 0 no need to do any processing
       if( !NA || !NB ){
          tr_st_a = NA;
          tr_st_b = NB;
 //         printf(αnEither of NA or NB is zero No Further Processing....nα);
          fprintf(outfp,αCase #%d: %d %dnα,n+1,tr_st_a,tr_st_b);
 //         printf(αCase #%d: %d %dnα,n+1,tr_st_a,tr_st_b);
          
          continue;
           
       }
 //      printf(αnNeither of NA or NB is zero So Further Processing....nα);
       
       //SORT the all the individual arrays data
       
       //A_dept sort
       for (i=1; i<NA ; i++){
           for (j=0;j<i;j++){
               if(A_dept[i].hours < A_dept[j].hours || (A_dept[i].hours == A_dept[j].hours && A_dept[i].min < A_dept[j].min)){
                    //swap and continue
                    temp_hh = A_dept[i].hours; 
                    temp_mm = A_dept[i].min;
                    for (k = i; k > j ; k --){
                        A_dept[k].hours = A_dept[k-1].hours ; 
                        A_dept[k].min = A_dept[k-1].min ;
                    }
                    
                    A_dept[j].hours = temp_hh; 
                    A_dept[j].min = temp_mm;
                    continue;
               }
           }
       }
 /*      
       printf (αnAfter Sorting NA _Dept : nα);
       for(na=0;na<NA;na++){
           printf(αDept : %d%c%d   α,A_dept[na].hours,c_rd,A_dept[na].min);
           
       }
 */      
       //A_arr sort
       for (i=1; i<NA ; i++){
           for (j=0;j<i;j++){
               if(A_arr[i].hours < A_arr[j].hours || (A_arr[i].hours == A_arr[j].hours && A_arr[i].min < A_arr[j].min)){
                    //swap and continue
                    temp_hh = A_arr[i].hours; 
                    temp_mm = A_arr[i].min;
                    for (k = i; k > j ; k --){
                        A_arr[k].hours = A_arr[k-1].hours ; 
                        A_arr[k].min = A_arr[k-1].min ;
                    }
                    
                    A_arr[j].hours = temp_hh; 
                    A_arr[j].min = temp_mm;
                    continue;
               }
           }
       }
       
 //      printf (αnAfter Sorting A_arr : nα);
 //      for(na=0;na<NA;na++){
 //          printf(αArr  : %d%c%d nα,A_arr[na].hours,c_rd,A_arr[na].min);
 //          
 //      }
 
       //B_dept sort
       for (i=1; i<NB ; i++){
           for (j=0;j<i;j++){
               if(B_dept[i].hours < B_dept[j].hours || (B_dept[i].hours == B_dept[j].hours && B_dept[i].min < B_dept[j].min)){
                    //swap and continue
                    temp_hh = B_dept[i].hours; 
                    temp_mm = B_dept[i].min;
                    for (k = i; k > j ; k --){
                        B_dept[k].hours = B_dept[k-1].hours ; 
                        B_dept[k].min = B_dept[k-1].min ;
                    }
                    
                    B_dept[j].hours = temp_hh; 
                    B_dept[j].min = temp_mm;
                    continue;
               }
           }
       }
 //      printf (αnAfter Sorting B_dept : nα);
 //      for(nb=0;nb<NB;nb++){
 //          printf(αDept : %d%c%d   α,B_dept[nb].hours,c_rd,B_dept[nb].min);
 //          
 //      }
 
       //B_arr sort
       for (i=1; i<NB ; i++){
           for (j=0;j<i;j++){
               if(B_arr[i].hours < B_arr[j].hours || (B_arr[i].hours == B_arr[j].hours && B_arr[i].min < B_arr[j].min)){
                    //swap and continue
                    temp_hh = B_arr[i].hours; 
                    temp_mm = B_arr[i].min;
                    for (k = i; k > j ; k --){
                        B_arr[k].hours = B_arr[k-1].hours ; 
                        B_arr[k].min = B_arr[k-1].min ;
                    }
                    
                    B_arr[j].hours = temp_hh; 
                    B_arr[j].min = temp_mm;
                    continue;
               }
           }
       }
 //      printf (αnAfter Sorting B_arr : nα);
 //      for(nb=0;nb<NB;nb++){
 //          printf(αArr  : %d%c%d nα,B_arr[nb].hours,c_rd,B_arr[nb].min);
 //          
 //      }
 
 
       
       //Start working on the sorted data.
       
       //calcualting A trains
       for(i=0,j=0;i<NA;i++){
           
           if( j< NB && (A_dept[i].hours > B_arr[j].hours || (A_dept[i].hours == B_arr[j].hours && A_dept[i].min >= B_arr[j].min))){
 //              printf (αj: %d,A_dept[i].hours : %d, A_dept[i].min : %d n α,j,A_dept[i].hours,A_dept[i].min);
 //              printf (αi: %d,B_arr [i].hours : %d, B_arr [i].min : %d n α,i,B_arr[i].hours,B_arr[i].min);
               j++;
           }
           else{
               tr_st_a++;  
           }
       }
 
       //calcualting B trains
       for(i=0,j=0;i<NB;i++){
           
           if( j< NA && (B_dept[i].hours > A_arr[j].hours || (B_dept[i].hours == A_arr[j].hours && B_dept[i].min >= A_arr[j].min))){
               j++;
           }
           else{
               tr_st_b++;  
           }
       }
       
       fprintf(outfp,αCase #%d: %d %dnα,n+1,tr_st_a,tr_st_b);
 //      printf(αCase #%d: %d %dnα,n+1,tr_st_a,tr_st_b);
       
       
   }
     
 
  fclose(infp);
  fclose(outfp);
  getch();
 
  return 0;
 }
 
 
 //void add_T(time_t * time, int t){
 //
 //     printf(αMin before T add%dnα,time->min);
 //     time->min = time->min + t;
 //     printf(αMin after T add%dnα,time->min);
 //     
 //     if (time->min >= 60 ){
 //         time->hours = time->hours + 1;
 //         time->min = time->min - 60;
 //     }
 //     printf(αMin after T adjust%dnα,time->min);
 //     
 //     
 //}"
23784,2008,32013,ManojSNegi,24480,1,Saving_the_Universe.c,gcj/2008/32013/ManojSNegi/24480/1/extracted/Saving_the_Universe.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define     MAX_SERVER_NAME 100
 #define     VALID           1
 #define     INVALID         0
 #define     MAX_TEST_CASES  1000
 #define     MAX_SERVER      100
 
 typedef struct server
 {
     int  valid;
     char name[MAX_SERVER_NAME + 1];
     int  index[MAX_TEST_CASES];
     int  i_index;
 }Server;
 
 
 Server  g_server[MAX_SERVER];
 
 int main(void)
 {
     int N = 0, S = 0 , Q = 0, i = 0, j = 0 , k = 0, M = 0, MAX = 0, temp = 0;
     char input[MAX_SERVER_NAME + 1];
     int server_switch = 0;
     int curr_index = 0;
     char line[100];
 
     /* Read the number of test cases */
     gets(line);
     sscanf(line, α%dα, &N);
 
     for (i = 0; i < N ; ++i)
     {
         /* Read the Number of Servers */
         gets(line);
         sscanf(line, α%dα, &S);
 
         memset((void *)&(g_server[0]), 0 , sizeof(g_server));
         server_switch = 0;
 
         for (j = 0 ; j < S; ++j)
         {
             gets(g_server[j].name);
             g_server[j].valid = 1;
             g_server[j].index[0]  = MAX_TEST_CASES;
         }
 
         /* Read the Input */
         gets(line);
         sscanf(line, α%dα, &Q);
         if (Q == 0)
         {
             server_switch = 0;
             goto EXIT_NOW;
         }
 
         for (k = 0; k < Q; ++k)
         {
             gets(input);
 
             for (j = 0 ; j < S; ++j)
             {
                 if (strcmp(g_server[j].name, input) == 0)
                 {
                     g_server[j].index[g_server[j].i_index] = k;
                     g_server[j].i_index += 1;
                     break;
                 }
             }
         }
 
         curr_index = 0;
         MAX =  0;
         server_switch = 0;
 
         while (curr_index < Q)
         {
             /* Got the request */
             for (j = 0; j < S; ++j)
             {
                 if (g_server[j].i_index == 0)
                 {
                     server_switch = 0;
                     goto EXIT_NOW;
                 }
 
                 for (M = 0 ; M < g_server[j].i_index; ++M)
                 {
                     if (g_server[j].index[M] < curr_index)
                     {
                         if ( M == (g_server[j].i_index - 1))
                         {
                             goto EXIT_NOW;
                         }
 
                         continue;
                     }
 
                     if (g_server[j].index[M] == curr_index)
                         break;
 
                     if ((g_server[j].index[M] - curr_index) > MAX)
                     {
                         MAX = g_server[j].index[M] - curr_index;
                     }
                     break;
                 }
             }
             curr_index += MAX;
             server_switch += 1;
             MAX = 0;
             if (curr_index == Q - 1)
             {
                 goto EXIT_NOW;
             }
 
         }
 
 EXIT_NOW :
         printf(αCase #%d: %dnα, i + 1,server_switch); 
     }
 }"
23923,2008,32013,kashyap,24480,1,google.c,gcj/2008/32013/kashyap/24480/1/extracted/google.c,"#include<stdio.h>
 #include<string.h>
 int atoi(char *s)
 {
     int i,n;
     n=0;
     for(i=0;s[i] >= '0' && s[i] <= '9'; ++i)
 	n=10*n +(s[i]-'0');
 	return n;
 }
 void check(int *,int *,int);
 main()
 {
     int n,N;
     int s,S;
     int q,Q;
     int status[101];
     char source[100][101], query[1000][101],l[10];
 //    scanf(α%dα,&N);
     gets(l);
     N=atoi(l);
     for (n=0; n<N; n++)
     {
 	for (s=0;s<101;s++)
 	    status[s] = 0;
 	
 //	scanf(α%dα, &S);printf(αscanned Sn%dnα,S);
 	gets(l);
 	S=atoi(l);
 	for (s=0;s<S;s++)
 	{
 	    gets(source[s]);
 	}
 	
 //	scanf(α%dα,&Q);printf(αscanned Qn%dnα,Q);
 	gets(l);
 	Q=atoi(l);
 	for (q=0;q<Q;q++)
 	{
 	    gets(query[q]);
 	}
 	for (q=0;q<Q;q++)
 	{
 	    for(s=0; s<S;s++)
 	    {
 		if(strcmp(query[q],source[s]) == 0)
 		{
 		    status[s]++;
 		    break;
 		}
 	    }
 	    check(status,&q,S);
 	}
 	printf(αCase #%d: %dnα,n+1,status[S]);
     }
 }
 
 void check(int *status,int *p,int S)
 {
     int s=0;
     while(s<S && status[s] != 0)
 	++s;
     if (s == S)
     {
 	++status[S];
 	for (s=0;s<S;s++)
 	    status[s]=0;
 	*p = *p -1;
     }
 }"
23925,2008,32013,Joker,24480,1,A.c,gcj/2008/32013/Joker/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 #include <time.h>
 #define MAXN 1100
 #define MAXM 110
 
 int main(){
 	int n,s,q,i,j,k,ans,count;
 	char engine[110][MAXM];
 	char query[MAXN][MAXM];
 	int eng[110];
 	FILE *in=fopen(αA-large.inα,αrα);
 	FILE *out=fopen(αA-large.outα,αwα);
 
 
 	fscanf(in,α%dα,&n);
 	for (k=1;k<=n;k++){
 		fscanf(in,α%dα,&s);fgetc(in);
 		for (i=0;i<s;i++){
 			j=0;
 			while ((engine[i][j]=fgetc(in))!='n') j++;
 			engine[i][j]='0';
 		}
 		fscanf(in,α%dα,&q);fgetc(in);
 		for (i=0;i<q;i++){
 			j=0;
 			while ((query[i][j]=fgetc(in))!='n') j++;
 			query[i][j]='0';
 		}
 
 		for (i=0;i<s;i++) eng[i]=0;
 		count=0;ans=0;
 		for (i=0;i<q;i++){
 			for (j=0;j<s;j++) 
 				if (strcmp(query[i],engine[j])==0){
 					if (eng[j]==0) count++;
 					eng[j]++;
 					break;
 				}
 			if (count==s){
 				for (j=0;j<s;j++) eng[j]=0;
 				ans++;
 				i--;
 				count=0;
 			}
 		}
 /*		for (i=0;i<s;i++) printf(α%snα,engine[i]);*/
 		fprintf(out,αCase #%d: %dnα,k,ans);
 	}
 	return 0;
 }"
23927,2008,32013,Joker,24481,1,B.c,gcj/2008/32013/Joker/24481/1/extracted/B.c,"#include <stdio.h>
 #define MAX 110
 
 typedef struct timetable{
 	int l;
 	int a;
 }table;
 
 table a[MAX],b[MAX];
 int na,nb;
 
 void psort(table x[],int l,int r){                                 
 	int i,j,flag;                                                 
 	table temp;
 	
 	flag=1;
 	for(i=l;i<r&&flag;i++){
 		for (j=0;j<r-i;j++)
 			if (x[j].l>x[j+1].l){
 				flag=1;
 				temp=x[j];
 				x[j]=x[j+1];
 				x[j+1]=temp;
 			}
 			else
 				if (x[j].l==x[j+1].l)
 					if (x[j].a>x[j+1].a){
 						flag=1;
 						temp=x[j];
 						x[j]=x[j+1];
 						x[j+1]=temp;
 					}
 		if (flag==0) return;
 	}
 }
 
 int findl(table x[],int len,int p){
 	int i,count=0;
 	for (i=0;i<len;i++){
 		if (x[i].l==p) count++;
 	}
 	return count;
 }
 
 int finda(table x[],int len,int p){
 	int i,count=0;
 	for (i=0;i<len;i++){
 		if (x[i].a==p) count++;
 	}
 	return count;
 }
 
 
 int main(){
 	FILE *in=fopen(αB-large.inα,αrα);
 	FILE *out=fopen(αB-large.outα,αwα);
 	int n,t,i,k,t1,t2;
 	int ansa,ansb,resa,resb,count;
 	char s[10];
 
 
 	fscanf(in,α%dα,&n);
 	for (k=1;k<=n;k++){
 		fscanf(in,α%dα,&t);
 		fscanf(in,α%d %dα,&na,&nb);
 		for (i=0;i<na;i++){
 			fscanf(in,α%sα,s);
 			sscanf(s,α%d:%dα,&t1,&t2);
 			a[i].l=t1*60+t2;
 			fscanf(in,α%sα,s);
 			sscanf(s,α%d:%dα,&t1,&t2);
 			a[i].a=t1*60+t2+t;
 		}
 		for (i=0;i<nb;i++){
 			fscanf(in,α%sα,s);
 			sscanf(s,α%d:%dα,&t1,&t2);
 			b[i].l=t1*60+t2;
 			fscanf(in,α%sα,s);
 			sscanf(s,α%d:%dα,&t1,&t2);
 			b[i].a=t1*60+t2+t;
 		}
 
 //		psort(a,0,na-1);psort(b,0,nb-1);
 /*		for (i=0;i<na;i++) printf(α%d %dnα,a[i].l,a[i].a);
 		for (i=0;i<nb;i++) printf(α%d %dnα,b[i].l,b[i].a);
 		printf(αnα);
 */		ansa=0;ansb=0;resa=0;resb=0;
 		for (i=0;i<1440;i++){
 			if (count=finda(a,na,i))
 				resb+=count;
 			if (count=finda(b,nb,i))
 				resa+=count;
 			if (count=findl(a,na,i)){
 				resa-=count;
 				if (resa<0){
 					ansa-=resa;
 					resa=0;
 				}
 			}
 			if (count=findl(b,nb,i)){
 				resb-=count;
 				if (resb<0){
 					ansb-=resb;
 					resb=0;
 				}
 			}		
 		//	printf(αansa=%d ansb=%d resa=%d resb=%d time=%dnα,ansa,ansb,resa,resb,i);
 		}
 
 	/*	for (i=0,j=0;i<na&&i<nb;i++){
 			if (b[j].a+t<=a[i].l){
 				t1--;j++;
 			}
 			if (j>=nb) break;
 		}
 		for (i=0,j=0;i<nb&&i<na;i++){
 			if (a[j].a+t<=b[i].l){
 				t2--;j++;
 			}
 			if (j>=na) break;
 		}*/
 		fprintf(out,αCase #%d: %d %dnα,k,ansa,ansb);
 	}
 	return 0;
 }"
24221,2008,32013,Praveensingh07,24480,1,universe.c,gcj/2008/32013/Praveensingh07/24480/1/extracted/universe.c,"//Program : Save the Universe
 //Praveen Singh
 
 #include <stdio.h>
 #include <string.h>
 
 #define N 20
 #define S 100
 #define Q 1000
 
 int main(int argc, char **argv)
 {
     FILE *finput;       //File pointer
     FILE *foutput;
     int cases = 0;
     char search_engine[S][100] = {{0}};
     int no_search_engine = 0; 
     int no_query = 0; 
     char query[Q][100] = {{0}};
     int i  = 0;
     int j; 
     int k = 0;
     int l = 0;
     int max = 0;
     int max_temp = 0;
     int not_match[S] = {0};
     int no_switch[N] = {0};
    
    
    
    if(argc == 3) 
    {
       finput = fopen(argv[1], αrα);   //file open
       foutput = fopen(argv[2], αwα);   //file open
       if(finput == NULL)
       {
          printf(αfile open failedα);
          return -1;
       }         
       fscanf(finput, α%dα, &cases);
       fgetc(finput);
       
       for(i = 0; i < cases; i++) 
       {
          fscanf(finput, α%dα, &no_search_engine); //read no. of search engine
          fgetc(finput);
          
          for(j = 0; j < no_search_engine; j++)
          {
             fgets(search_engine[j], 100, finput); //read search engine
          }
          
          fscanf(finput, α%dα, &no_query); //read no. of querys  
          fgetc(finput);         
          
          for(j = 0; j < no_query; j++)
          {
             fgets(query[j], 100, finput);; //read query
          }
          
          while(1)
          {
             for(k = 0; k < no_search_engine; k++)
             {
                for(j = max; j < no_query; j++)
                {
                   if(strcmp(search_engine[k], query[j]) != 0)
                   {
                      not_match[k]++;
                   }
                   else
                   {
                      break;
                   }                     
                } 
                
                 if(max_temp < not_match[k])
                 {
                      max_temp = not_match[k];
                 }     
                
                if((max + max_temp) == no_query)
                {
                   break;
                } 
             }   
             
             max += max_temp;
             max_temp = 0;
             for(l = 0; l < S; l++)
             {
               not_match[l] = 0; 
             }               
                         
             if(max == no_query)
             {
                 break;
             } 
             else
             {   
               no_switch[i]++;
             }   
          }
          
          max = 0;
          max_temp = 0;
          for(l = 0; l < S; l++)
          {
              not_match[l] = 0; 
          }  
       }
 
       for(i = 0; i < cases; i++) 
       {
          fprintf(foutput, αCase #%d: %dnα, (i+1), no_switch[i]);
       }   
 
    }
 
    else
    {
       printf(αERRORα);
    }
 
    return 0;
 
 }"
24276,2008,32013,Parul,24481,1,TRAINS.C,gcj/2008/32013/Parul/24481/1/extracted/TRAINS.C,"#include<stdio.h>
 
 void sort(int* a, int n)
 {
 	int i=1,j=0,temp;
 	if(n == 1)
 		return;
 	for( i =1; i< n;i++)
 	{
 		for(j=0; j<i; j++)
 		{
 			if(a[j] > a[i])
 			{
 				temp = a[i];
 				a[i] = a[j];
 				a[j]=temp;
 			}
 		}
 	}
  }
 
 
 void main()
 {
 int test,na,nb,ta_time,n,tot_a,tot_b,i,i_a,i_b;
 int A_sch[100],B_sch[100],A_av[100],B_av[100];
 char arr[6],dep[6];
 scanf(α%dα,&n);
 
 for(test=1;test <= n; test++)
 {
 	na = nb = i = 0,ta_time=0;
 	tot_a = tot_b = 0;
 	i_a = i_b = 0;
 	scanf(α%dα,&ta_time);
 	scanf(α%d %dα,&na,&nb);
 
 	if(na == 0 || nb == 0)
 	{
 		tot_a = na;
 		tot_b = nb;
 		printf(αCase #%d: %d %dnα,test,tot_a,tot_b);
 		return;
 	}
 
 	for(i=0; i<na; i++)
 	{
 		scanf(α%s %sα,dep,arr);
 
 		A_sch[i] = ((dep[0] - '0')*10 + (dep[1] - '0'))*60 + 10*(dep[3] - '0') + (dep[4] - '0');
 		B_av[i] = ((arr[0] - '0')*10 + (arr[1] - '0'))*60 + 10*(arr[3] - '0') + (arr[4] - '0') + ta_time;
 
 	}
 	for(i=0; i<nb; i++)
 	{
 		scanf(α%s %sα,dep,arr);
 
 		B_sch[i] = ((dep[0] - '0')*10 + (dep[1] - '0'))*60 + 10*(dep[3] - '0')+ (dep[4] - '0');
 		A_av[i] = ((arr[0] - '0')*10 + (arr[1] - '0'))*60 + 10*(arr[3] - '0') + (arr[4] - '0') + ta_time;
 
 	}
 	sort(A_av,nb);
 	sort(A_sch,na);
 
 	sort(B_av,na);
 	sort(B_sch,nb);
 
 	i_a=0;i_b=0;
 	for(i_a = 0; i_a < na && i_b < nb; i_a++)
 	{
 		if(A_av[i_b] <= A_sch[i_a])
 		{
 			i_b++;
 		}
 		else
 		{
 			tot_a++;
 		}
 	}
 	if(i_a < na)
 	{
 		tot_a += (na - i_a);
 	}
 	i_a = 0; i_b = 0;
 	for(i_b = 0; i_b < nb && i_a < na; i_b++)
 	{
 		if(B_av[i_a] <= B_sch[i_b])
 		{
 			i_a++;
 		}
 		else
 		{
 			tot_b++;
 		}
 	}
 	if(i_b < nb)
 	{
 		tot_b += (nb - i_b);
 	}
 
 	printf(αCase #%d: %d %dnα,test,tot_a,tot_b);
 }
 
 }"
24304,2008,32013,Alun.WK,24480,1,save.c,gcj/2008/32013/Alun.WK/24480/1/extracted/save.c,"#include<stdio.h>
 #include<string.h>
 
 enum {
      MAXLEN      = 100,     //max length of engine names
      MAXENGINES  = 100,     //max numbers of engines
      MAXQUERIES  = 1000     //max numbers of queries
 };  
 typedef struct Engine Engine;
 struct Engine {
        char name[MAXLEN+1];   //engine name
        int  queries;          //queries
        int  flag;             //if engine checked
 }; 
    
 int CASES;
 int SWITCHS;
 Engine ENGINES[MAXENGINES];
 char QUERIES[MAXQUERIES][MAXLEN+1];
 int x;
 
 void init();
 void getengine(int, FILE *);
 void getqueries(int , FILE *);
 int  printswitchs(int , int);
 
 main()
 {
       int i, engines, queries;
       int j;
       FILE *fin = fopen(αA.inα,αrα);
       FILE *fout = fopen(αA.outα,αwα);
       fscanf(fin, α%dα, &CASES);
       for (i = 0; i < CASES; i++){
             x = i;
             init();
             fscanf(fin, α%dα, &engines);
             getengine(engines, fin);
             fscanf(fin, α%dα, &queries);
             getqueries(queries, fin);
             
             /*
             for (j = 0; j < engines; j++)
                 printf(α%s:%dnα, ENGINES[j].name, ENGINES[j].queries);
             system(αpauseα);
             */
             
             printswitch(engines, queries);
             fprintf(fout, αCase #%d: %dnα, i+1, SWITCHS);
       }
       system(αPAUSEα);
 }
 
 void init()
 {
      int i;
      for (i = 0; i < MAXENGINES; i++)
          ENGINES[i].queries = 0;
      SWITCHS = 0; 
 }
 void getengine(int s, FILE *fp)
 {
      int i = 0;
      fgets(ENGINES[i].name, MAXLEN+1, fp);   //erase the blank line
      for (i = 0; i < s; i++){
          fgets(ENGINES[i].name, MAXLEN+1, fp);
          strtok(ENGINES[i].name, αnrα);
      }
      
      /*
      for (i = 0; i < s; i ++)
          printf(α%snα, ENGINES[i].name);
      system(αPAUSEα);
      */
      
 }
 
 void addqueries(char *s)
 {
      int i;
      for (i = 0; i < MAXENGINES; i++)
          if (strcmp(s, ENGINES[i].name) == 0) {
             ENGINES[i].queries++;
             break;
          }
          
 }
 
 void getqueries(int q, FILE *fp)
 {
      int i;
      fgets(QUERIES[i], MAXLEN+1, fp);
      for (i = 0; i < q; i++) {
          fgets(QUERIES[i], MAXLEN+1, fp);
          strtok(QUERIES[i], αnrα);
          addqueries(QUERIES[i]);
      }
      
      /*
      for(i = 0; i < q; i++){
            printf(α%snα, QUERIES[i]);
      }
      system(αPAUSEα);
      */
      
 }
 
 int hasengine(int s)
 {
     int i;
     for (i = 0; i < s; i++){
         /*
         if (x == 19){
               printf(α%s:%dnα, ENGINES[i].name, ENGINES[i].queries);
         }
         */
         if (ENGINES[i].queries == 0)
            return 1;
 }
     return 0;   
 }
 
 int findlatestengine(int s, int q)
 {
 
     int i, j, sum = 0;
     i = 0;
     for (j = 0; j < s; j++)
         ENGINES[j].flag = 0;
     while (sum < s && i < q) {
           for (j = 0; j < s; j++)
               if (strcmp(QUERIES[i], ENGINES[j].name) == 0) {
                  if (ENGINES[j].flag == 0) {
                     ENGINES[j].flag = 1;
                     if (++sum < s)
                        ENGINES[j].queries--;
                  }
                  /*
                  if (x == 19) {
                     printf(αs:%d, i:%d, sum:%d, q:%dnα, s,i,sum,q);
                     system(αpauseα);
                  }
                  */
                  break;
               }
           i++;
     }
     if (sum < s)
        q = 0;
     else {
        i--;
        q -= i;
     }
     /*
     if (x == 4){
           printf(αq:%dnα, q);
           system(αpauseα);
     }
     */
     for (j = 0; j < q; j++)
         strcpy(QUERIES[j], QUERIES[j+i]);
     /*
     if (x == 19)
        printf(αreturn q:%dnα, q);
     */
     return q;             
 }
 
 int  printswitch(int s, int q)
 {
      if (hasengine(s))
         return;
  //    printf(α%d %dnα, q, SWITCHS);
  //    system(αPAUSEα);
      q = findlatestengine(s, q);
      if (q == 0)
         return;
      SWITCHS++;
      printswitch(s, q);
 }"
24306,2008,32013,Wombatfreak,24480,1,saving.c,gcj/2008/32013/Wombatfreak/24480/1/extracted/saving.c,"#include <stdio.h>
 #include <string.h>
 
 int main(){
   int T[100],i,j,m,n,N,S,Q;
   char s[100][101], ss[101];
   scanf(α%dα,&N);
   for(n=0;n<N;n++){
     scanf(α%dnα, &S);
     for(i=0;i<S;i++) { gets(s[i]); T[i]=0; }
     scanf(α%dnα, &Q);
     m=0;
     for(i=1;i<=Q;i++) {
       gets(ss);
       for(j=0;j<S;j++) {
 	if(strcmp(s[j],ss)==0) T[j]=1000000;
 	else if(m+1<T[j]) T[j]=m+1;
       }
       m=1000000;
       for(j=0;j<S;j++) if(T[j]<m) m=T[j];
     }
     printf(αCase #%d: %dnα,n+1, m);
   }
   return 0;
 }"
24308,2008,32013,Wombatfreak,24481,1,train.c,gcj/2008/32013/Wombatfreak/24481/1/extracted/train.c,"#include <stdio.h>
 #include <string.h>
 
 int minu(char* s) {
   s[0]-='0';
   s[1]-='0';
   s[3]-='0';
   s[4]-='0';
   return s[0]*600+s[1]*60+s[3]*10+s[4];
 }
 
 int main(){
   int N,NA,NB,T,n,i,t,m[2],c[2],ev[2][1500];
   char b1[10],b2[10];
 
   scanf(α%dα,&N);
   for(n=0;n<N;n++){
     scanf(α%d %d %dα, &T, &NA, &NB);
     for(i=0;i<2;i++) for(t=0;t<1440;t++) ev[i][t]=0;
     for(i=0;i<NA;i++) {
       scanf(α%s %sα, b1,b2);
       ev[0][minu(b1)]--;
       ev[1][minu(b2)+T]++;
     }
     for(i=0;i<NB;i++) {
       scanf(α%s %sα, b1,b2);
       ev[1][minu(b1)]--;
       ev[0][minu(b2)+T]++;
     }
     for(i=0;i<2;i++) {
       m[i]=c[i]=0;
       for(t=0;t<1440;t++) {
 	c[i]+=ev[i][t];
 	if(c[i]<m[i]) m[i]=c[i];
       }
     }
     printf(αCase #%d: %d %dnα,n+1, -m[0], -m[1]);
   }
   return 0;
 }"
24354,2008,32013,kratos,24480,1,main.c,gcj/2008/32013/kratos/24480/1/extracted/main.c,"#include<stdio.h>
 
 void trim_nl(char *str) {
 	while (*str && *str!='r' && *str!='n')
 		str++;
 	*str=0;
 }
 
 int main(int argc, char *argv[])
 {
 	FILE *fp=fopen(argv[1],αrα);
 	char se[101][102];
 	char qy[1001][102];
 
 	int N, Q, S;
 
 	int i,j,k;
 
 	int nr_switch=-1,curr;
 
 	fscanf(fp,α%dα, &N);
 
 	for (i=0; i<N; i++) {
 
 	int se_cnt[101][1001]={{0}};
 
 		fscanf(fp, α%dnα, &S);
 #if DEBUG
 printf(αS=%dnα,S);
 #endif
 		for (j=0; j<S; j++) {
 			fgets(se[j],101,fp);
 			trim_nl(se[j]);
 #if DEBUG
 			printf(α[%s]nα,se[j]);
 #endif
 		}
 		fscanf(fp, α%dnα, &Q);
 #if DEBUG
 printf(αQ=%dnα,Q);
 #endif
 		for (j=0; j<Q; j++) {
 			fgets(qy[j],101,fp);
 			trim_nl(qy[j]);
 #if DEBUG
 			printf(α[%s]nα,qy[j]);
 #endif
 		}
 
 		for (j=Q-1; j>=0; j--) {
 			int optimize=1;
 			for (k=0; k<S; k++) {
 				if (optimize && strcmp(se[k],qy[j])==0) {
 					se_cnt[k][j]=0;
 					optimize=0;
 				} else {
 					se_cnt[k][j]=se_cnt[k][j+1]+1;
 				}
 			}
 		}
 
 		curr = -1;
 		nr_switch=-1;
 		for (j=0; j<Q; j++) {
 			int max=-1;
 
 			if (j==0 || se_cnt[curr][j]==0) {
 				for (k=0; k<S; k++) {
 					if (se_cnt[k][j]>max) {
 						max=se_cnt[k][j];
 						curr=k;
 					}
 				}
 				nr_switch++;
 			}
 #if DEBUG
 			printf(α%d(%d): %st%snα, j, nr_switch, qy[j],se[curr]);
 #endif
 		}
 		if (nr_switch < 0) nr_switch=0;
 		printf(αCase #%0d: %dnα, i+1, nr_switch);
 
 	}
 }"
24386,2008,32013,MurthyP,24480,1,SaveUniverse.C,gcj/2008/32013/MurthyP/24480/1/extracted/SaveUniverse.C,"#include <iostream>
 
 #include <fstream>
 #include <sstream>
 #include <string>
 
 #include <cmath>
  
 #include <qregexp.h>
 #include <qstring.h>
 #include <qstringlist.h>
 #include <qfile.h>
 #include <qtextstream.h>
 
 #include <vector>
 #include <list>
 
 using namespace std;
 
 struct Engine
 {
   QString engineName;
   int count;
   Engine(QString eName)
     {
       engineName = eName;
       count = 999999;
     }
   bool operator<(const Engine& anEngine) const throw()
     {
       return (this->count > anEngine.count);
     }
   bool operator==(const Engine& anEngine) const throw()
     {
       return this->engineName == anEngine.engineName;
     }
 };
 
  
 int main(int argc, char* argv[])
 {
   string smallInputFileName = αA-small.inα;
 
   QString fileName(argv[1]);
 
   QFile inputFile(fileName); 
   QFile outputFile(fileName + α-outputα);
    if(!inputFile.exists())
    {
      cout << αInput file does not exist..α << endl;
    }
    inputFile.open(IO_ReadOnly);
 
    QString line;
    Q_ULONG qUlong = 999;
    if(inputFile.readLine(line, qUlong) == -1)
    {
      cout << αError.. α << endl;
    }
 //   cout << line;
    int caseCount = line.toInt();
    int caseNo = 1;
    for(; caseNo <= caseCount; caseNo++)
    {
      inputFile.readLine(line, qUlong);
      int engineCount = line.toInt();
      vector<Engine> engineList;
      for(int i = 0; i < engineCount; i++)
      {
        inputFile.readLine(line, qUlong);
        Engine engine(line);
        engineList.push_back(engine);
      }
      inputFile.readLine(line, qUlong);
      int queryCount = line.toInt();
      list<Engine> queryList;
      for(; queryCount > 0; queryCount--)
      {
        inputFile.readLine(line, qUlong);
        queryList.push_back(line);
      }
      int switchCount = 0;
      queryCount = queryList.size();
      while(queryList.size() > 0)
      {
 //       cout << αqueryList.size() == α << queryList.size() << endl;
        vector<Engine>::iterator itEL, itELEnd;
        itEL = engineList.begin();
        itELEnd = engineList.end();
        for(; itEL != itELEnd; itEL++)
        {
 	 itEL->count = queryCount+1;
        }
        queryCount = queryList.size();
        for(int i=0; i < engineCount; i++)
        {
 	 list<Engine>::iterator itQL, itQLEnd;
 	 itQL = queryList.begin();
 	 itQLEnd = queryList.end();
 	 int j=0;
 	 for(; itQL != itQLEnd; itQL++)
 	 {
 	   if((*itQL == engineList[i]) && (engineList[i].count > queryCount))
 	   {
 	     engineList[i].count = j;
 //	     cout << αEngine α << i << α - count: α << j << endl;
 	   }
 	   j++;
 	 }
        }
        sort(engineList.begin(), engineList.end());
 //       cout << αFirst Engine Count: α << engineList[0].count << endl;
        if(engineList[0].count <= queryList.size())
        {
 	 for(int i=0; i < engineList.begin()->count; i++)
 	 {
 	   if(queryList.size() != 0)
 	   {
 	     queryList.pop_front();
 	   }
 	 }
 	 switchCount++;
        }
        else
        {
 	 queryList.clear();
        }
        
      }
      cout << αCase #α << caseNo << α: α << switchCount << endl;
 
    }
 
 }"
24469,2008,32013,UCONN.HUSKY,24480,1,search.c,gcj/2008/32013/UCONN.HUSKY/24480/1/extracted/search.c,"#include<stdio.h>
 #include<string.h>
 #include αhash.hα
 unsigned int **DP = NULL;
 unsigned int S; 
 unsigned int Q;
 unsigned int *queries=NULL;
 HASH *my_hash;
 int main(){
 	int testcases;
 	unsigned int sid=0;
 	unsigned int n,s,k;
 	unsigned int current_min;
 	unsigned int local_min;
 	unsigned int i; unsigned int tcount=0;
 	char sname[100];
 	my_hash = hnew();
 	scanf(α%dα,&testcases);
 	while(testcases--){ tcount++;
 		sid=0;
 		scanf(α%uα,&S); getchar();
 		if(queries){ free(queries); }
 		for(i=0;i<S;i++){
 			scanf(α%[^n]α,sname); getchar();
 			hstore(my_hash,sname,(void *)sid++);
 		}
 		scanf(α%uα,&Q); getchar();
 		if(!Q){
 			printf(αCase #%u: 0nα,tcount);
 			continue;
 		}
 		queries = (unsigned int *)malloc(sizeof(unsigned int)*Q);
 		for(i=0;i<Q;i++){
 			scanf(α%[^n]α,sname); getchar();
 			queries[i] = (unsigned int)hfetch(my_hash,sname);
 		}
 		DP = (unsigned int **)malloc(sizeof(unsigned int)*Q);
 		for(i=0;i<Q;i++){
 			DP[i] = (unsigned int *)malloc(sizeof(unsigned int)*S);
 		}
 		for(n=0;n<Q;n++){
 			for(s=0;s<sid;s++){
 				if(n == 0){
 					if(queries[0] != s){
 						DP[0][s] = 0;
 					}else{
 						DP[0][s] = (1<<31);
 					}
 				}else{
 					if(queries[n] == s){
 						DP[n][s] = (1<<31);
 					}else{
 						current_min = (1<<31);
 						for(k=0;k<sid;k++){
 							local_min = DP[n-1][k]; 
 							if(k!=s){
 								local_min++;
 							}
 							if(local_min < current_min){
 								current_min = local_min;
 							}
 						}
 						DP[n][s] = current_min;
 					}
 				}
 			}
 			if(n>0){
 				free(DP[n-1]);
 			}
 		}
 		current_min = (1<<31);
 		for(s=0;s<S;s++){
 			if(DP[n-1][s] < current_min){
 				current_min = DP[n-1][s];
 			}
 		}
 		free(DP[n-1]);
 		printf(αCase #%u: %unα,(tcount),current_min);
 	}
 }"
24471,2008,32013,UCONN.HUSKY,24481,1,train.c,gcj/2008/32013/UCONN.HUSKY/24481/1/extracted/train.c,"#include<stdio.h>
 #include<stdlib.h>
 #include αRandQsort.hα
 unsigned int TT=0;
 typedef struct _trip_{
 	unsigned int depart;
 	unsigned int arrival;
 	/*Starting station*/
 	char station;
 }Trip;
 unsigned char CompareTripDepart(void *t1,void *t2){
 	Trip *trip1 = (Trip *)t1;
 	Trip *trip2 = (Trip *)t2;
 	unsigned int d1 = trip1->depart;
 	unsigned int d2 = trip2->depart;
 	if(d1 <= d2){
 		return 1;
 	}
 	return 0;
 }
 void SwapTrips(void *t1,void *t2){
 	Trip *trip1 = (Trip *)t1;
 	Trip *trip2 = (Trip *)t2;
 	unsigned int temp;
 	char tchar;
 	temp = trip2->depart;
 	trip2->depart = trip1->depart;
 	trip1->depart = temp;
 	temp = trip2->arrival;
 	trip2->arrival = trip1->arrival;
 	trip1->arrival = temp;
 	tchar = trip2->station;
 	trip2->station = trip1->station;
 	trip1->station = tchar;
 }
 Trip *time_table = NULL;
 typedef struct _train_{
 	char start;
 	char dest;
 	unsigned int arrtime;
 }Train;
 unsigned int atrains;
 unsigned int btrains;
 int main(){
 	int tcount; unsigned int tc=0;
 	unsigned int NA,NB;
 	unsigned int i; char dummyc;
 	unsigned hrs,min;
 	unsigned int cdepart;char found=0;
 	Train *trains=NULL;unsigned int train_count=0;
 	unsigned int t;unsigned int avail_time;
 	scanf(α%dα,&tcount);
 	while(tcount--){ tc++;
 		if(trains){
 			free(trains);
 			free(time_table);
 		}
 		atrains=0; btrains=0;
 		scanf(α%uα,&TT);
 		scanf(α%u %uα,&NA,&NB);
 		if(!(NA+NB)){
 			printf(αCase #%u: 0 0nα,tc);
 		}
 		time_table = (Trip *)malloc(sizeof(Trip)*(NA+NB));
 		for(i=0;i<(NA+NB);i++){
 			scanf(α%u%c%uα,&hrs,&dummyc,&min);
 			time_table[i].depart = (hrs)*60+min;
 			scanf(α%u%c%uα,&hrs,&dummyc,&min);
 			time_table[i].arrival = (hrs)*60+min;
 			time_table[i].station = (i < NA)? 'A' : 'B';
 		}
 		RandQsort((void *)time_table,&time_table[NA+NB-1],sizeof(Trip),SwapTrips,
 		CompareTripDepart);
 		trains = (Train *)malloc(sizeof(Train)*(NA+NB));
 		atrains=0;btrains=0; train_count=0;
 		for(i=0;i<(NA+NB);i++){
 			cdepart = time_table[i].depart;
 			found=0;
 			for(t=0;t<train_count;t++){
 				if(time_table[i].station != trains[t].dest){
 					continue;
 				}
 				avail_time = (trains[t].arrtime)+TT;
 				if(avail_time <= cdepart){
 					trains[t].dest = (time_table[i].station == 'A')?'B':'A';
 					trains[t].arrtime = time_table[i].arrival;
 					found=1;break;
 				}
 			}
 			if(!found){
 				trains[train_count].dest = (time_table[i].station == 'A')?'B':'A';
 				trains[t].arrtime = time_table[i].arrival;
 				trains[t].start = time_table[i].station;
 				if(trains[t].start == 'A'){
 					atrains++;
 				}else{
 					btrains++;
 				}
 				train_count++;
 			}
 		}
 		printf(αCase #%u: %u %unα,tc,atrains,btrains);
 	}
 }"
24514,2008,32013,LadyStar,24480,1,switches.c,gcj/2008/32013/LadyStar/24480/1/extracted/switches.c,"#include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 
 #define MAX_SET 100
 #define MAX 1000
 #define MAX_CHARS 101
 #define TRUE 1
 #define FALSE 0
 
 void readSet ( char **pointers, int cases );
 int countSwitches ( char **setPtr, int setCases, char **inputPtr, int inputCases );
 char *newString (void);
 int needToSwitch ( char **setPtr, int setCases, int found );
 
 int main (int argc, char* argv[]) {
 
    int cases = 0;
    scanf(α%dnα, &cases);
    int counter = 1;
 
    while ( counter <= cases ) {
       char *setPtr[MAX_SET*2] = {0};
       int setCases = 0;
       scanf(α%dnα, &setCases);
       readSet(setPtr, setCases);
 
       char *inputPtr[MAX] = {0};
       int inputCases = 0;
       scanf(α%dnα, &inputCases);
       readSet(inputPtr, inputCases);
 
       int switches = countSwitches(setPtr, setCases, inputPtr, inputCases);
 
       printf ( αCase #%d: %dnα, counter, switches );
       counter++;
    }
    return 0;
 }
 
 void readSet ( char **pointers, int cases ) {
 
    int i = 0;
    int strPtr = 0;
    char currentChar;
 
    while ( i < cases ) {
       currentChar = getchar();
       if ( currentChar != EOF && currentChar != 'n' ) {
          pointers[i] = newString();
       }
       while ( strPtr < MAX_CHARS && currentChar != 'n' ) {
          pointers[i][strPtr] = currentChar;
          strPtr++;
          currentChar = getchar();
       }
       pointers[i][strPtr] = '0';
       i++;
       strPtr = 0;
    }
 
 }
 
 int countSwitches ( char **setPtr, int setCases, char **inputPtr, int inputCases ) {
    int setIndex = 0;
    int inputIndex = 0;
    int numSwitches = 0;
    int found = FALSE;
    while ( inputIndex < inputCases ) {
       while ( !found && setIndex < setCases ) {
 
          if ( strcmp( inputPtr[inputIndex], setPtr[setIndex] ) == 0 ) {
             // this stores a count in the set array at setIndex+MAX
             setPtr[setIndex+MAX_SET]++;
             // found will return the position of the counter referring to the current engine
             // sorry for the bad style
             found = setIndex+1;
          }
          setIndex++;
       }
       numSwitches = numSwitches + needToSwitch(setPtr, setCases, found);
 
       // re initialise
       found = FALSE;
       setIndex = 0;
 
       inputIndex++;
    }
    return numSwitches;
 }
 
 int needToSwitch ( char **setPtr, int setCases, int found ) {
    int i = MAX_SET;
    int need = TRUE;
    while ( i < MAX_SET+setCases ) {
       //printf(α%dα, (int) setPtr[i]);
       if ( setPtr[i] == 0 ) {
          need = FALSE;
       }
       i++;
    }
    if ( need == TRUE ) {
       i--;
       while ( i >= MAX_SET ) {
          // reset all counters except current engine
          if ( i != MAX_SET+found-1 ) {
             setPtr[i] = 0;
          }
          i--;
       }
    }
    return need;
 }
 
 
 char *newString (void) {
    return malloc(sizeof(char)*MAX_CHARS);
 }"
24516,2008,32013,LadyStar,24481,1,trains.c,gcj/2008/32013/LadyStar/24481/1/extracted/trains.c,"#include <string.h>
 #include <stdio.h>
 #include <assert.h>
 #include <stdlib.h>
 
 #define TRUE 1
 #define FALSE 0
 
 
 typedef struct node *list;
 
 typedef struct node {
    int arrival;
    int departure;
    list next;
 } node;
 
 
 list readSet (int cases );
 list insertByArrival (list existing, int departure, int arrival);
 list insert (list existing, int departure, int arrival);
 list orderByArrival ( list departureList, int numTrips );
 list removeFirst ( list existing );
 int countNeeded ( list departures, list arrivals, int numTrips, int turnTime );
 
 
 int main (int argc, char* argv[]) {
 
    int cases = 0;
    scanf(α%dnα, &cases);
    int counter = 1;
 
    int turnTime = 0;
    int numTripsA = 0;
    int numTripsB = 0;
    
    list AtoB = NULL;
    list BtoA = NULL;
    list arrivalsA = NULL;
    list arrivalsB = NULL;
    int trainsAToB = 0;
    int trainsBToA = 0;
 
    while ( counter <= cases ) {
 
       scanf(α%dα, &turnTime);
       scanf(α%d %dα, &numTripsA, &numTripsB);
 
       AtoB = readSet(numTripsA);
       BtoA = readSet(numTripsB);
 
       arrivalsA = orderByArrival(BtoA, numTripsB);
       arrivalsB = orderByArrival(AtoB, numTripsA);
 
       trainsAToB = countNeeded(AtoB, arrivalsA, numTripsB, turnTime);
       trainsBToA = countNeeded(BtoA, arrivalsB, numTripsA, turnTime);
 
       printf ( αCase #%d: %d %dnα, counter, trainsAToB, trainsBToA );
 
       counter++;
    }
    return 0;
 }
 
 // produce lists ordered by departure times from standard input. times given in minutes from midnight.
 list readSet ( int cases ) {
    int i = 0;
    int departHours = 0;
    int departMinutes = 0;
    int arriveHours = 0;
    int arriveMinutes = 0;
    list newList = NULL;
    while ( i < cases ) {
       scanf(α%d:%d %d:%dα, &departHours, &departMinutes, &arriveHours, &arriveMinutes);
       //printf(αscanned %d:%d, i %d, cases %dnα, departHours, departMinutes, i, cases);
       newList = insert(newList, departHours*60+departMinutes, arriveHours*60+arriveMinutes);
 
       i++;
    }
    return newList;
 }
 
 list insert (list existing, int departure, int arrival) {
    if ( existing == NULL || existing->departure > departure ) {
       list newNode = malloc(sizeof(node));
       assert (newNode != NULL);
       newNode->departure = departure;
       newNode->arrival = arrival;
       newNode->next = existing;
       existing = newNode;
    } else {
       existing->next = insert(existing->next, departure, arrival);
    }
    return existing;
 }
 
 list orderByArrival ( list departureList, int numTrips ) {
    int i = 0;
    list arrivalList = NULL;
    while ( i < numTrips ) {
       arrivalList = insertByArrival(arrivalList, departureList->departure, departureList->arrival);
       departureList = departureList->next;
       i++;
    }
    return arrivalList;
 }
 
 list insertByArrival (list existing, int departure, int arrival) {
    if ( existing == NULL || existing->arrival > arrival ) {
       list newNode = malloc(sizeof(node));
       newNode->departure = departure;
       newNode->arrival = arrival;
       newNode->next = existing;
       existing = newNode;
    } else {
       existing->next = insertByArrival(existing->next, departure, arrival);
    }
    return existing;
 }
 
 // removes first node from list
 list removeFirst ( list existing ) {
    list newList = existing->next;
    free(existing);
    return newList;
 }
 
 
 // counts trains needed at one station
 int countNeeded ( list departures, list arrivals, int numTrips, int turnTime ) {
    int count = 0;
    while ( departures != NULL ) {
       if ( arrivals != NULL && (arrivals->arrival + turnTime) <= departures->departure ) {
          arrivals = removeFirst(arrivals);
       } else {
          count++;
       }
       departures = removeFirst(departures);
    }
    return count;
 }"
24559,2008,32013,piyapan,24480,1,a.c,gcj/2008/32013/piyapan/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int numn,i,j,n,s,q,countswitch=0;
 char engine[100][100],query[100];
 int countengine[100]={0};
 
 void reallycleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 }
 
 void cleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 	countengine[j]++;		
 }
 
 void checkarray() {
 	int index,zerocount=0;
 	for(index=0; index<s; index++)
 		if(!countengine[index]) zerocount++;
 	if(zerocount == 0) { 
 		countswitch++;
 		cleararray();
 	}
 }
 
 int main() {
 	scanf(α%dα,&n);
 	for(numn=0; numn<n; numn++) {
 		scanf(α%dα,&s);
 		getchar();
 		for(i=0; i<s; i++) {
 			gets(engine[i]);
 		}
 		scanf(α%dα,&q);
 		getchar();
 		for(i=0; i<q; i++) {
 			gets(query);
 			for(j=0; j<s; j++) {
 				if(!strcmp(query,engine[j])) {
 					countengine[j] += !strcmp(query,engine[j]);
 					break;
 				}	
 			}
 			checkarray();
 		}	
 		reallycleararray();
 		printf(αCase #%d: %dnα,numn+1,countswitch);
 		countswitch = 0;
 	}
 	return 0;
 }"
24627,2008,32013,jacogeld,24480,1,se.c,gcj/2008/32013/jacogeld/24480/1/extracted/se.c,"/*==============================================================================
  * se.c
  * Search Engine query optimization.
  * 2008.07.17
  * jacogeld@gmail.com
  * To compile: gcc -O3 -W -Wall -ansi -pedantic se.c -o se
  *============================================================================*/
 
 #include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 /*------------------------------------------------------------------------------
  * Constants.
  *----------------------------------------------------------------------------*/
 
 #define SHOW_SOLUTION (0)
 
 #define MAX_S (100)
 #define MAX_Q (1000)
 
 #define MAX_NAME (100)
 #define MAX_NAME_TABLE ((MAX_NAME + 1) * (MAX_S + MAX_Q))
 
 #define HASH_SIZE (91)
 
 /*------------------------------------------------------------------------------
  * Type definition for hash table entries.
  *----------------------------------------------------------------------------*/
 
 typedef struct HashEntry_struct {
 	char* name;
 	int nr;
 	struct HashEntry_struct* next;
 } HashEntry;
 
 /*------------------------------------------------------------------------------
  * Global variables.
  *----------------------------------------------------------------------------*/
 
 HashEntry* hash[HASH_SIZE]; /* Table of hashed engine names. */
 HashEntry* free_hash; /* List of free hash entries. */
 
 char name_table[MAX_NAME_TABLE]; /* Where the actual strings are stored. */
 char* name_ptr; /* Position in name_table where next character is stored. */
 unsigned int hash_value; /* Hash value of most recent name read. */
 
 int engine_count; /* Number of search engines. */
 int engine[MAX_S]; /* Table of search engines stored as integers. */
 
 int query_count; /* Number of search queries. */
 int query[MAX_Q]; /* Table of search queries stored as integers. */
 int furthest[MAX_Q]; /* Search engine furthest αforwardα from any query. */
 
 int min_cost; /* Minimum cost found. */
 int eng[MAX_Q + 1]; /* Engine used at particular search depth. */
 int cost[MAX_Q + 1]; /* Cost (nr of switches) at particular search depth. */
 int best[MAX_Q + 1]; /* Best recorded solution. */
 
 /*------------------------------------------------------------------------------
  * Clear the hash table and move the entries to the free list.
  *----------------------------------------------------------------------------*/
 
 void clear_hash_table() {
 	int i; /* Iterator over hash table slots. */
 	HashEntry* e; /* Iterator over hash list. */
 
 	for (i = 0; i < HASH_SIZE; i++) {
 		if (hash[i] == NULL) { continue; }
 		e = hash[i];
 		while (e->next != NULL) { e = e->next; }
 		e->next = free_hash;
 		free_hash = hash[i];
 		hash[i] = NULL;
 	}
 }
 
 /*------------------------------------------------------------------------------
  * Read a string consisting of characters αabc..xyzABC..XYZ012..9 α from the
  * standard input, store it in the name table and return a pointer to the
  * start of the string.
  *----------------------------------------------------------------------------*/
 
 char* read_name() {
 	char c; /* Next character read. */
 	char* s; /* Return value. */
 	int len; /* Length of the name read. */
 
 	/* Read characters until we reach the start of the name. */
 	c = getchar();
 	while ((c != ' ') && !isalnum(c)) {
 		c = getchar();
 	}
 	/* Now read and store the name. */
 	s = name_ptr;
 	len = 0;
 	hash_value = 0;
 	while ((isalnum(c) || (c == ' ')) && (len < MAX_NAME)) {
 		*name_ptr++ = c;
 		c = getchar();
 		len++;
 		/* At the same time we compute the hash value for the name. */
 		hash_value ^= (c << (len % 24));
 	}
 	hash_value %= HASH_SIZE;
 	*name_ptr++ = '0';
 	/* Flush extra characters. */
 	while (isalnum(c) || (c == ' ')) {
 		c = getchar();
 	}
 	return s;
 }
 
 /*------------------------------------------------------------------------------
  * Look up a name in the hash table and return it's number.  If it is not
  * found, it is stored along with the supplied default number.  The routine
  * assumes that the hash value of the name is stored in the global variable
  * αhash_valueα.
  *----------------------------------------------------------------------------*/
 
 int lookup(char* name, int default_nr) {
 	HashEntry* e; /* Iterator over hash list; also used for new entry. */
 
 	e = hash[hash_value];
 	while (e != NULL) {
 		if (strcmp(name, e->name) == 0) { return e->nr; }
 		e = e->next;
 	}
 	if (free_hash == NULL) {
 		e = (HashEntry*) malloc(sizeof(HashEntry));
 		if (e == NULL) {
 			fprintf(stderr, αERROR - MEMORY ALLOCATION FAILEDnα);
 			exit(EXIT_FAILURE);
 		}
 	}
 	else {
 		e = free_hash;
 		free_hash = e->next;
 	}
 	e->name = name;
 	e->nr = default_nr;
 	e->next = hash[hash_value];
 	hash[hash_value] = e;
 	return default_nr;
 }
 
 /*------------------------------------------------------------------------------
  * Main function.
  *----------------------------------------------------------------------------*/
 
 int main() {
 	int N; /* Number of cases. */
 	int i, j, k; /* General iterators. */
 	int n; /* Number of engine/query name. */
 	int used[MAX_S]; /* Recently-used search engines. */
 	int seen; /* Number of search engines recently used. */
 	int u; /* Auxiliary variable for storing a best solution. */
 
 	for (i = 0; i < HASH_SIZE; i++) { hash[i] = NULL; }
 	free_hash = NULL;
 
 	scanf(α%dα, &N);
 	for (i = 0; i < N; i++) {
 		name_ptr = name_table;
 		clear_hash_table();
 
 		scanf(α%dα, &engine_count);
 		for (j = 0; j < engine_count; j++) {
 			n = lookup(read_name(), j);
 			if (n != j) {
 				fprintf(stderr, αERROR - DUPLICATE NAMEnα);
 				exit(EXIT_FAILURE);
 			}
 			engine[j] = n;
 		}
 
 		scanf(α%dα, &query_count);
 		for (j = 0; j < query_count; j++) {
 			n = lookup(read_name(), j);
 			if (n == -1) {
 				fprintf(stderr, αERROR - UNKNOWN ENGINEnα);
 				exit(EXIT_FAILURE);
 			}
 			query[j] = n;
 		}
 
 		/* Now explore the engine assignments in depth-first order. */
 		min_cost = 0;
 		for (j = 0; j < engine_count; j++) { used[j] = -1; }
 		seen = 0;
 		u = 0;
 		for (k = 0; k < query_count; k++) {
 			if (used[query[k]] != min_cost) {
 				seen++;
 				if (seen == engine_count) {
 					seen = 1;
 					min_cost++;
 					while (u < k) { best[u++] = query[k]; }
 				}
 			}
 			used[query[k]] = min_cost;
 		}
 		k = 0;
 		while (used[k] == min_cost) { k++; }
 		while (u < query_count) { best[u++] = k; }
 
 		printf(αCase #%d: %dnα, i + 1, min_cost);
 #if (SHOW_SOLUTION != 0)
 		printf(αSolution α);
 		for (k = 0; k < query_count; k++) { printf(α %dα, best[k]); }
 		printf(αnα);
 #endif
 	}
 	exit(EXIT_SUCCESS);
 	return 0;
 }
 
 /*==============================================================================
  * End of se.c
  *============================================================================*/"
24717,2008,32013,asterix01ar,24480,1,savun.c,gcj/2008/32013/asterix01ar/24480/1/extracted/savun.c,"#include <stdio.h>
 #include <string.h>
 /*
 #include <math.h>
 */
 
 /* Used for debug levels */
 /*
 #define	I_DEBUG	1	
 #define	DEBUG	1	
 #define	NDEBUG	1	
 */
 /* #define	O_DEBUG	1		*/
 
 /* Structure to store the train table and the departure arrival schedule */
 /* The time is stored in format HHMM and the conversion from 0060 to 0100 */
 /* will be managed in the program */
 
 struct	savi {
 	char	name[100];
 	int	qty;
 	int	order[1200];
 };
 struct	savi	savi[200];
 
 int	S;	/* number of searchers	*/
 int	Q;	/* number of queries	*/
 char	query[100];		/* query name */
 
 int	get_input();
 
 main(argc, argv)
 {
 int	i, j, k;
 int	result, prev_n, prev_sel, curr_n, src_sel;
 int	set_zero, n;
 char	*qn;
 
 		qn = &query[0];
 
 /* Input function */
 /* Get number of cases */
 	n = get_input(0);
 
 /* Processing function */
 	for(i = 0; i < n; i++) {
 		S = get_input(0);
 		result = 0;
 		for(j = 0; j < S; j++) {
 			if(!get_input(j+1))
 				break;
 			strcpy((char *) savi[j].name, qn);
 			savi[j].qty = 0;
 #ifdef DEBUG
 		printf(αJ %d --> %snα, j, savi[j].name);
 #endif
 		}
 
 		Q = get_input(0);
 		for(j = 0; j < Q; j++) {
 			for(k = 0; k < S; k++)
 				savi[k].order[j] = Q+1;
 		}
 		for(j = 0; j < Q; j++) {
 			if(!get_input(j+1))
 				break;
 			for(k = 0; k < S; k++) {
 				if(strcmp(qn, (char *) savi[k].name) == 0) {
 					savi[k].order[savi[k].qty++] = j+1;
 					break;
 				}
 			}
 		}
 
 /* Processing data */
 #ifdef NDEBUG
 		for(j=0; j < S; j++) {
 			printf(αSRC %s QTY %d α, (char *) savi[j].name, savi[j].qty);
 			for(k=0; k<Q; k++)
 				printf(α%d α, savi[j].order[k]);
 			printf(αnα);
 		}
 #endif
 
 		prev_n = -1;
 		curr_n = -1;
 		src_sel = -1;
 		prev_sel = -1;
 		result = 0;
 		set_zero = 0;
 		do {
 			for(j = 0; j < S; j++) {
 				/* Search the trivial */
 				if(savi[j].qty == 0) {
 					result = 0;
 					set_zero = 1;
 					curr_n = Q+1;
 					break;
 				}
 				for(k = 0; k < Q; k++) {
 					/* first time init	*/
 					if(curr_n == -1) {
 						curr_n = savi[j].order[k];
 						src_sel = j;
 #ifdef DEBUG
 						printf(αCURR -1 J %d CN %dnα, j, curr_n);
 #endif
 						break;
 					}
 					
 					if(savi[j].order[k] > prev_n) {
 						if(j != prev_sel) {
 							if(savi[j].order[k] > curr_n) {
 								curr_n = savi[j].order[k];
 								src_sel = j;
 #ifdef DEBUG
 								printf(αNEW J %d CN %d PS %dnα, j, curr_n, prev_sel);
 #endif
 							}
 						}
 						break;
 					}
 				}
 			}
 			if(prev_n != -1)
 /*
 			if(!set_zero)
 */
 				result++;
 			prev_n = curr_n;
 			prev_sel = src_sel;
 #ifdef DEBUG
 			printf(αCHANGED J %d CN %d PS %dnα, j, curr_n, prev_sel);
 #endif
 		} while (curr_n < Q+1);
 
 /* Printing output */
 	printf(αCase #%d: %dnα, i+1, result);
 
 	}
 }
 
 get_input(int l)
 {
 	extern struct	savi	savi[];
 	extern char	query[];
 
 	int	n;
 	char	c;
 	char 	lptr[80];
 	char	*s;
 	char	*qn;
 
 	
 	n = 0;
 	c = -1;
 	s = &lptr[0];
 	qn = &query[0];
 
 	#ifdef I_DEBUG
 		printf(αL %dnα, l);
 	#endif
 
 	while (c != 'n' && c != '0') {
 		c = getchar();
 		lptr[n++] = c;
 	}
 	lptr[n] = '0';
 	
 	#ifdef I_DEBUG
 		printf(αSTRING %snα, s);
 	#endif
 	if(c == '0')
 		return(0);
 	if(l == 0) {
 	#ifdef I_DEBUG
 		printf(αDEC %dnα, atoi(s));
 	#endif
 		return(atoi(s));
 	}
 	else {
 	#ifdef I_DEBUG
 		printf(αLEN %dnα, strlen(s));
 	#endif
 		strcpy((char *) &query[0], s);
 	#ifdef I_DEBUG
 		printf(αREAD %snα, (char *) &query[0]);
 	#endif
 	}
 	
 	return(strlen(s));
 	
 }"
24719,2008,32013,asterix01ar,24481,1,traint.c,gcj/2008/32013/asterix01ar/24481/1/extracted/traint.c,"#include <stdio.h>
 #include <string.h>
 /*
 #include <math.h>
 */
 
 /* Used for debug levels */
 /*
  #define	I_DEBUG	1
  #define	DEBUG	1
  #define	O_DEBUG	1
 */
 
 /* Structure to store the train table and the departure arrival schedule */
 /* The time is stored in format HHMM and the conversion from 0060 to 0100 */
 /* will be managed in the program */
 
 struct	traint {
 	int	time;
 	int	depart;
 	};
 
 struct	traint	train_a[200];
 struct	traint	train_b[200];
 
 int	travel_a;
 int	travel_b;
 int	total_travel;
 int	turnaround;
 
 int	get_input();
 
 main(argc, argv)
 {
 int	i, j, min, k;
 int	n;
 int max_a, max_b, count;
 
 extern	struct	traint	train_a[];
 extern	struct	traint	train_b[];
 struct	traint	train_t;
 
 /* Input function */
 /* Get number of cases */
 	n = get_input(0);
 
 /* Processing function */
 	for(i = 0; i < n; i++) {
 		turnaround = get_input(0);
 		get_input(1);
 		total_travel = travel_a + travel_b;
 		for(j = 0; j < total_travel; j++) {
 			if(!get_input(j+2))
 			break;
 #ifdef DEBUG
 		printf(αI %d --> J %dnα, i, j);  
 #endif
 		}
 
 /* Sorting structs */
 		for(j=0; j< total_travel; j++) {
 			min=j;
 			for(k=j+1; k<total_travel; k++) {
 				if(train_a[k].time < train_a[min].time) {
 					train_t.time = train_a[min].time;
 					train_t.depart = train_a[min].depart;
 					train_a[min].time = train_a[k].time;
 					train_a[min].depart = train_a[k].depart;
 					train_a[k].time = train_t.time;
 					train_a[k].depart = train_t.depart;
 				}
 				if(train_a[k].time == train_a[min].time) {
 					if(train_a[min].depart){
 						train_t.depart = train_a[min].depart;
 						train_a[min].depart = train_a[k].depart;
 						train_a[k].depart = train_t.depart;
 					}
 				}
 			}
 		}
 
 		max_a = 0;
 		count = 0;
 		for(j = 0; j < total_travel; j++) {
 			if(train_a[j].time >= 2400)
 				continue;
 			if(train_a[j].depart)
 				count++;
 			else
 				count--;
 			if(max_a < count)
 				max_a = count;
 #ifdef O_DEBUG
 			printf(α%d - %d %d ct %d mx %dnα, j, train_a[j].time, train_a[j].depart, count, max_a);
 #endif
 		}
 
 		for(j=0; j< total_travel; j++) {
 			min=j;
 			for(k=j+1; k<total_travel; k++) {
 				if(train_b[k].time < train_b[min].time) {
 					train_t.time = train_b[min].time;
 					train_t.depart = train_b[min].depart;
 					train_b[min].time = train_b[k].time;
 					train_b[min].depart = train_b[k].depart;
 					train_b[k].time = train_t.time;
 					train_b[k].depart = train_t.depart;
 				}
 				if(train_b[k].time == train_b[min].time) {
 					if(train_b[min].depart){
 						train_t.depart = train_b[min].depart;
 						train_b[min].depart = train_b[k].depart;
 						train_b[k].depart = train_t.depart;
 					}
 				}
 			}
 		}
 
 		max_b = 0;
 		count = 0;
 		for(j = 0; j < total_travel; j++) {
 			if(train_b[j].time >= 2400)
 				continue;
 			if(train_b[j].depart)
 				count++;
 			else
 				count--;
 			if(max_b < count)
 				max_b = count;
 			
 #ifdef O_DEBUG
 			printf(α%d - %d %d ct %d mx %dnα, j, train_b[j].time, train_b[j].depart, count, max_b);
 #endif
 		}
 
 /* Output process */
 
 
 /* Printing output */
 
 		printf(αCase #%d: %d %dnα, i+1, max_a, max_b);	
 	}
 }
 
 get_input(int l)
 {
 	int	n;
 	char	c;
 	char 	lptr[30];
 	char	*s;
 	/* hour and minutes */
 	int	h1, h2, m1, m2;
 	int	temp;
 	double x;
 
 	/* train struct reference */
 	struct	traint	*tr_a;
 	struct	traint	*tr_b;
 	extern	struct	traint	train_a[];
 	extern	struct	traint	train_b[];
 	
 	n = 0;
 	c = -1;
 	s = &lptr[0];
 
 	#ifdef I_DEBUG
 		printf(αL %dnα, l);
 	#endif
 
 	while (c != 'n' && c != '0') {
 		c = getchar();
 		lptr[n++] = c;
 	}
 	lptr[n] = '0';
 	
 	#ifdef I_DEBUG
 		printf(αSTRING %snα, s);
 	#endif
 	if(c == '0')
 		return(0);
 	if(l == 0) {
 	#ifdef I_DEBUG
 		printf(αDEC %dnα, atoi(s));
 	#endif
 		return(atoi(s));
 	}
 	else if(l == 1){
 	#ifdef I_DEBUG
 		printf(αLEN %dnα, strlen(s));
 	#endif
 		sscanf(s,α%d %dα, &travel_a, &travel_b);
 	#ifdef I_DEBUG
 		printf(αNA NB %d %dα, travel_a, travel_b);
 	#endif
 	}
 	else {
 	#ifdef I_DEBUG
 		printf(αLEN %dnα, strlen(s));
 	#endif
 		sscanf(s,α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 		if((l-2) < travel_a) {
 			train_a[l-2].time = h1*100+m1;
 			temp = m2+turnaround;
 			if(temp >= 60){
 				temp -= 60;
 				h2++;
 			}
 			train_b[l-2].time = h2*100+temp;
 			train_a[l-2].depart = 1;
 			train_b[l-2].depart = 0;
 		}
 		else {
 			train_b[l-2].time = h1*100+m1;
 			temp = m2+turnaround;
 			if(temp >= 60){
 				temp -= 60;
 				h2++;
 			}
 			train_a[l-2].time = h2*100+temp;
 			train_a[l-2].depart = 0;
 			train_b[l-2].depart = 1;
 		}
 	#ifdef I_DEBUG
 		printf(αSTRUCT %d %dnα, train_a[l-2].time, train_b[l-2].time);
 	#endif
 	}
 	
 	return(strlen(s));
 	
 }"
24738,2008,32013,drcflin,24480,1,a.c,gcj/2008/32013/drcflin/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXLEN 100
 #define MAX_N 20
 #define MAX_S 100
 #define MAX_Q 1000
 
 char s[MAX_N][MAX_S][MAXLEN];
 char q[MAX_N][MAX_Q][MAXLEN];
 int ln, ls[MAX_N], lq[MAX_N];
 
 int findswitch(int start, int n)
 {
 	int i, j;
 	int sw[MAX_S];
 	int iend;
 	iend = ls[n];
 	for (i=0; i<ls[n]; i++) sw[i] = 0;
 	for (j=start; j<lq[n]; j++)
 	{
 		for(i=0; i<ls[n]; i++)
 		{
 			if ((sw[i] == 0) && (strcmp(s[n][i], q[n][j]) == 0))
 			{
 				sw[i] = 1;
 				iend--;
 				if (iend == 0) {
 					return j;
 				}
 			}
 		}
 	}
 	return -1;
 }
 
 int
 main(void)
 {
 	FILE *fpi;
 
 	int n, i, j;
 	fpi = fopen(αa.inα, αrα);
 	if (fpi == NULL)
 	{
 		printf(αFile failed to opennα);
 		exit(EXIT_FAILURE);
 	}
 	fscanf(fpi, α%dα, &ln);
 	for (n=0; n<ln; n++)
 	{
 		fscanf(fpi, α%dα, &ls[n]);
 		fgetc(fpi); // skip new line
 		for (i=0; i<ls[n]; i++)
 		{
 			fgets(s[n][i], MAXLEN, fpi);
 		}
 		fscanf(fpi, α%dα, &lq[n]);
 		fgetc(fpi); // skip new line
 		for (i=0; i<lq[n]; i++)
 		{
 			fgets(q[n][i], MAXLEN, fpi);
 		}
 	}
 	fclose(fpi);
 
 	for (n=0; n<ln; n++)
 	{
 		i = 0, j = 0;
 		while ((i = findswitch(i, n)) >= 0)
 		{
 			j++;
 		}
 		printf(αCase #%d: %dnα, n+1, j); 
 	}
 
 	return EXIT_SUCCESS;
 }"
24740,2008,32013,drcflin,24481,1,b.c,gcj/2008/32013/drcflin/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_N 100
 #define MAX_AB 100
 
 struct TrainData {
 	int station;
 	int timeStart;
 	int timeReady;
 	int trainNumber;
 } s[MAX_AB*2];
 
 int ln, lt, lab[2][2], labn;
 
 int findtrain(int iStart, int iEnd, int iStartTime)
 {
 	int zk, i;
 	zk = -1;
 	for (i=iStart; i<iEnd; i++)
 	{
 		if ((s[i].trainNumber == 0) && (s[i].timeStart >= iStartTime) && ((zk < 0) || (s[i].timeStart < s[zk].timeStart)))
 			zk = i;
 	}
 	return zk;
 }
 
 int
 main(void)
 {
 	FILE *fpi;
 
 	int n, i, j;
 	int i1, i2, i3, i4;
 	int zn, zk[2], zt;
 	fpi = fopen(αb.inα, αrα);
 	if (fpi == NULL)
 	{
 		printf(αFile failed to opennα);
 		exit(EXIT_FAILURE);
 	}
 	fscanf(fpi, α%dα, &ln);
 	for (n=0; n<ln; n++)
 	{
 		fscanf(fpi, α%dα, &lt);
 		fscanf(fpi, α%d %dα, &i1, &i2);
 		labn = i1 + i2;
 		lab[1][0] = 0;
 		lab[1][1] = i1;
 		lab[0][0] = i1;
 		lab[0][1] = labn;
 		for(i=0; i<labn; i++)
 		{
 			fscanf(fpi, α%d:%d %d:%dα, &i1, &i2, &i3, &i4);
 			s[i].station = (i<lab[0][0]) ? 0 : 1;
 			s[i].timeStart = i1*60+i2;
 			s[i].timeReady = i3*60+i4+lt;
 			s[i].trainNumber = 0;
 		}
 		
 		zn = labn;
 		zk[0] = 0;
 		zk[1] = 0;
 		while (zn > 0)
 		{
 			i = findtrain(0, labn, 0);
 			j = s[i].station;
 			zk[j]++;
 			zt = j*MAX_AB + zk[j];
 			s[i].trainNumber = zt;
 			zn--;
 		//	printf(α%d %d %d %dnα, s[i].station, s[i].timeStart, s[i].timeReady, s[i].trainNumber);
 			while ((i = findtrain(lab[j][0], lab[j][1], s[i].timeReady)) >= 0)
 			{
 				j = s[i].station;
 				s[i].trainNumber = zt;
 				zn--;
 		//		printf(α%d %d %d %dnα, s[i].station, s[i].timeStart, s[i].timeReady, s[i].trainNumber);
 			}
 		}
 		printf(αCase #%d: %d %dnα, n+1, zk[0], zk[1]); 
 	}
 
 	fclose(fpi);
 	return EXIT_SUCCESS;
 }"
25051,2008,32013,FelipeSanches,24479,1,fly.c,gcj/2008/32013/FelipeSanches/24479/1/extracted/fly.c,"#include<stdio.h>
 #include<math.h>
 #define EPS 0.0000001
 
 int main(){
 	int N;
 	int case_iterator;
 	scanf(α%dα, &N);
 	for (case_iterator=0;case_iterator<N;case_iterator++){
 		double f,R, t, r, g;
 		scanf(α%lf %lf %lf %lf %lfα, &f, &R, &t, &r, &g);
 
 		//normalizing:
 		f = f/R;
 		t = t/R;
 		r = r/R;
 		g = g/R;
 		R = 1.0;
 
 		//the problem is equilavent to the same problem with a punctual fly and 
 		//strings with radius f larger (and with gaps 2f smaller)
 		r = r + f;
 		g = g - 2.0*f;
 
 
 		if (g<=0){
 			//we have a fat fly!
 			printf(αCase #%d: %06fnα, case_iterator+1, 1.0);
 			continue;
 		}
 
 		//since we have simmety, we can calculate only a forth of the racquet
 		double area = 0.0;
 		double x, y;
 		double R2 = (R-t-f)*(R-t-f);
 		double m,n;
 		y = r;
 		while (y < (R-t-f)){
 			n = floor((y-r)/(2.0*r+g));
 			if ( ((y-r) - n*(2.0*r+g)) < g ){
 				x = sqrt(R2 - y*y);
 				if (x>r){
 					m = floor((x-r)/(2.0*r+g));
 					if ( ((x-r) - m*(2.0*r+g)) < g ){
 						area += (EPS * (x - r - m*2.0*r));
 					} else {
 						area += (EPS * (m+1.0) * g);
 					}
 				}
 			}
 			y+=EPS;
 		}
 
 		//since probability density function is constant, the overall
 		// probability is given by a proportion of areas:
 		double p = 4.0*area / M_PI;
 
 		// we have calculated the probability of the fly not hitting the racquet.
 		// The probability we need is the complement:
 		double P = 1.0 - p;
 
 		printf(αCase #%d: %06lfnα, case_iterator+1, P);
 	}
 	return 0;
 }"
25136,2008,32013,Greggypoo,24480,1,dispatch.c,gcj/2008/32013/Greggypoo/24480/1/extracted/dispatch.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 struct case_rec {
 	int *searches;
 	int num_engines;
 	int num_searches;
 };
 
 int
 read_int(void)
 {
 	char s[1000];
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	return atoi(s);
 }
 
 char *
 read_string(void)
 {
 	char s[1000];
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	s[strcspn(s,αrnα)] = 0;
 	return strdup(s);
 }
 
 /* A test case is string engine names followed by string searches.
  * This is just an obnoxious representation of a list of integers
  * representing the searches.  So just return the list of integers,
  * and the number of engines. */
 struct case_rec *
 read_case(void)
 {
 	int num_engines, num_searches;
 	char **engines;
 	struct case_rec *ret;
 	int *searches;
 	int i;
 	int j;
 
 	num_engines = read_int();
 	engines = malloc(num_engines*sizeof *engines);
 	for (i = 0; i < num_engines; i++) {
 		engines[i] = read_string();
 	}
 	num_searches = read_int();
 	searches = malloc((num_searches+1)*sizeof *searches);
 	for (i = 0; i < num_searches; i++) {
 		char *s = read_string();
 		for (j = 0; j < num_engines; j++) {
 			if (!strcmp(s, engines[j])) {
 				break;
 			}
 		}
 		if (j == num_engines) {
 			fprintf(stderr,αgoodbye worldnα);
 			exit(-1);
 		}
 		searches[i] = j;
 	}
 	searches[i] = -1;
 	ret = malloc(sizeof *ret);
 	ret->searches = searches;
 	ret->num_engines = num_engines;
 	ret->num_searches = num_searches;
 	return ret;
 }
 
 /* Each element of the input list represents a set of acceptable states
  * (defined using the one state in 0..num_states that is not the element).
  * The goal is to find a minimal sequence of state transitions to satisfy
  * these constraints.
  * The obvious solution is recursive but our potential input set could force
  * us into 100^1000 (googol to the tenth, hah hah) possibilities.
  * I think next obvious solution is that the best state to switch to is the
  * one which occurs latest in our future.  I have a truly marvellous proof
  * of this proposition which this margin is too narrow to contain.
  * I think the proof is as simple as noting that reducing the number of
  * statesets that a state must ?subtend? can only decrease the contention,
  * allowing freer selection of the next state. */
 int
 solve_case(struct case_rec *c)
 {
 	int *seen_sets;
 	int num_sets_seen;
 	int i;
 	int ret = 0;
 
 	seen_sets = malloc(c->num_engines*sizeof *seen_sets);
 
 	num_sets_seen = 0;
 	memset(seen_sets, 0, c->num_engines*sizeof *seen_sets);
 
 	i = 0;
 	while (c->searches[i] != -1) {
 		int s = c->searches[i];
 
 		if (!seen_sets[s]) {
 			seen_sets[s] = 1;
 			num_sets_seen++;
 			if (num_sets_seen == c->num_engines) {
 //printf(αSWITCH FROM %dnα,s);
 				/* found the longest-lasting state */
 				ret++;
 
 				/* start over */
 				num_sets_seen = 0;
 				memset(seen_sets, 0, c->num_engines*sizeof *seen_sets);
 				/* but still sawed this one */
 				seen_sets[s] = 1;
 				num_sets_seen++;
 			}
 		}
 //printf(α%d: %dnα, i, s);
 		
 		i++;
 	}
 
 	free(seen_sets);
 
 	return ret;
 }
 
 struct case_rec *
 reverse_case(struct case_rec *c)
 {
 	struct case_rec *ret;
 	int i;
 
 	ret = malloc(sizeof *ret);
 	*ret = *c;
 	ret->searches = malloc((ret->num_searches+1)*sizeof *ret->searches);
 	for (i = 0; i < ret->num_searches; i++) {
 		ret->searches[i] = c->searches[(ret->num_searches-1)-i];
 	}
 	ret->searches[i] = -1;
 	return ret;
 }
 
 int
 main(void)
 {
 	int num_tests;
 	int i;
 	num_tests = read_int();
 	for (i = 0; i < num_tests; i++) {
 		struct case_rec *c = read_case();
 		int y,z;
 		y = solve_case(c);
 		/* the reversal is a hack, my intuition says the only possible
 		 * unknowns are at the ends, so try starting at either end.. */
 		c = reverse_case(c);
 		z = solve_case(c);
 		if (z < y) { y = z; fprintf(stderr,α%d became %dnα,y,z); }
 		printf(αCase #%d: %dnα, i+1, y);
 	}
 
 	return 0;
 }"
25138,2008,32013,Greggypoo,24481,1,trains.c,gcj/2008/32013/Greggypoo/24481/1/extracted/trains.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 struct ll {
 	struct ll *next;
 	int i;
 };
 
 int
 read_int(void)
 {
 	char s[1000];
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	return strtoul(s, NULL, 10);
 }
 
 void
 read_int2(int *x,int *y)
 {
 	char s[1000];
 	char *p;
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	p = s;
 	*x = strtoul(p, &p, 10);
 	p++;
 	*y = strtoul(p, &p, 10);
 }
 
 void
 read_int4(int *x,int *y, int *z, int *a)
 {
 	char s[1000];
 	char *p;
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	p = s;
 	*x = strtoul(p, &p, 10);
 	p++;
 	*y = strtoul(p, &p, 10);
 	p++;
 	*z = strtoul(p, &p, 10);
 	p++;
 	*a = strtoul(p, &p, 10);
 }
 
 void
 ll_insert(struct ll **l, int i)
 {
 	struct ll *n;
 	while (*l && ((*l)->i < i)) {
 		l = &(*l)->next;
 	}
 	n = malloc(sizeof *n);
 	n->i = i;
 	n->next = *l;
 	*l = n;
 }
 
 int
 main(void)
 {
 	int N;
 	int i;
 	N = read_int();
 	for (i = 0; i < N; i++) {
 		int T;
 		int NA,NB;
 		struct ll *abdeps, *abarrs;
 		struct ll *badeps, *baarrs;
 		int j;
 		int t;
 		int at_a = 0;
 		int at_b = 0;
 		int least_a = 0;
 		int least_b = 0;
 		int *pendinga,*pendingb;
 
 		T = read_int();
 
 		pendinga = malloc((T+1)*sizeof *pendinga);
 		memset(pendinga, 0, (T+1)*sizeof *pendinga);
 		pendingb = malloc((T+1)*sizeof *pendingb);
 		memset(pendingb, 0, (T+1)*sizeof *pendingb);
 
 		read_int2(&NA,&NB);
 		for (j = 0; j < NA; j++) {
 			int ha,ma,hd,md;
 			read_int4(&hd,&md,&ha,&ma);
 			ll_insert(&abdeps, hd*60+md);
 			ll_insert(&abarrs, ha*60+ma);
 		}
 		for (j = 0; j < NB; j++) {
 			int ha,ma,hd,md;
 			read_int4(&hd,&md,&ha,&ma);
 			ll_insert(&badeps, hd*60+md);
 			ll_insert(&baarrs, ha*60+ma);
 		}
 		for (t = 0; t < 23*60; t++) {
 			/* apply arrivals first */
 			while (baarrs && baarrs->i == t) {
 				pendinga[T]++;
 				baarrs = baarrs->next;
 			}
 			at_a += pendinga[0];
 			memmove(pendinga, pendinga+1, T*sizeof *pendinga);
 			pendinga[T] = 0;
 			while (abarrs && abarrs->i == t) {
 				pendingb[T]++;
 				abarrs = abarrs->next;
 			}
 			at_b += pendingb[0];
 			memmove(pendingb, pendingb+1, T*sizeof *pendingb);
 			pendingb[T] = 0;
 			/* then apply departures */
 			while (abdeps && abdeps->i == t) {
 				at_a--;
 				if (at_a < least_a) {
 					least_a = at_a;
 				}
 				abdeps = abdeps->next;
 			}
 			while (badeps && badeps->i == t) {
 				at_b--;
 				if (at_b < least_b) {
 					least_b = at_b;
 				}
 				badeps = badeps->next;
 			}
 		}
 		printf(αCase #%d: %d %dnα,i+1,-least_a, -least_b);
 	}
 	return 0;
 }"
25172,2008,32013,prodigyaj,24480,1,trial.c,gcj/2008/32013/prodigyaj/24480/1/extracted/trial.c,"#include<stdio.h>
 
 #include<string.h>
 
 int main()
 {
 int n_s,n_q,i,j,test,in,limit[20],temp,ic,counter=0;
 int switches=0;
 char *s_engine[100],*s_query[1000];
 int count[100];
 
 scanf(α%dα,&test);
 getchar();
 for(in=0;in<test;in++)
 {
 switches=0;
 scanf(α%dα,&n_s);
 getchar();
 //printf(αnEnter Enginesnα);
 for(i=0;i<n_s;i++)
 {
 count[i]=0;
 s_engine[i] = (char *) malloc (50 * sizeof(char));
 fgets(s_engine[i],50,stdin);
 }
 //printf(αnThe Queries numbers are : nα);
 scanf(α%dα,&n_q);
 getchar();
 //printf(αnEnter the queries :nα);
 
 for(i=0;i<n_q;i++)
 {
 s_query[i] = (char *) malloc (50 * sizeof(char));
 fgets(s_query[i],50,stdin);
 }
 
 for(j=0;j<n_q;j++)
 {
                   for(i=0;i<n_s;i++)
                   {
                   if(strcmp(s_query[j],s_engine[i])==0)
                   {
                   count[i]=1;
                   temp=i;
                   break;
                   }
                   }
                   counter=0;
                   for(i=0;i<n_s;i++)
                   {
                   if(count[i]==1)
                   counter++;
                   if(counter==n_s)
                   {
                   switches++;
                    for(ic=0;ic<n_s;ic++)
                   count[ic]=0;
                     count[temp]=1;
                   }
                    }
 
 
 }
 
 
 
 /*temp = count[0];
 for(i=0;i<n_s;i++)
 //printf(αn%s t : %d α,s_engine[i],count[i]);
 {
  if(temp>count[i])
  temp=count[i];
 }*/
 limit[in]=switches;
 }
 for(in=0;in<test;in++)
 printf(αCase #%d: %dnα,in+1,limit[in]);
 return 0;
 
 }"
25178,2008,32013,Calm.Horizons,24481,1,train_timetable.c,gcj/2008/32013/Calm.Horizons/24481/1/extracted/train_timetable.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAX_TRIPS 100
 
 struct test_case
 {
 	unsigned short num_ab;
 	unsigned short ab_trips[ MAX_TRIPS ][ 2 ];
 	
 	unsigned short num_ba;
 	unsigned short ba_trips[ MAX_TRIPS ][ 2 ];
 	
 	unsigned short t;
 };
 
 // Simple bubble-sort
 void sort( struct test_case* tcase )
 {
 	unsigned short temp, i, j;
 	
 	for( i = 0; i < ( tcase->num_ab > tcase->num_ba ? tcase->num_ab : tcase->num_ba ); i++ )
 	{
 		for( j = 0; j < ( tcase->num_ab > tcase->num_ba ? tcase->num_ab : tcase->num_ba ); j++ )
 		{
 			if( j < tcase->num_ab - 1 )
 			{
 				if( tcase->ab_trips[j][0] > tcase->ab_trips[j+1][0] )
 				{
 					temp = tcase->ab_trips[j][0];
 					tcase->ab_trips[j][0] = tcase->ab_trips[j+1][0];
 					tcase->ab_trips[j+1][0] = temp;
 				}
 			}
 			
 			if( j < tcase->num_ba - 1 )
 			{
 				if( tcase->ba_trips[j][0] > tcase->ba_trips[j+1][0] )
 				{
 					temp = tcase->ba_trips[j][0];
 					tcase->ba_trips[j][0] = tcase->ba_trips[j+1][0];
 					tcase->ba_trips[j+1][0] = temp;
 				}
 			}
 		}
 	}
 }
 
 int get_case( FILE* file, struct test_case* tcase )
 {
 	int success = 1;
 
 	if( file != NULL )
 	{
 		if( fscanf( file, α%dα, &( tcase->t ) ) != EOF && fscanf( file, α%d %dα, &( tcase->num_ab ), &( tcase->num_ba ) ) != EOF )
 		{
 			unsigned int j = 0;
 					
 			for( j = 0; j < tcase->num_ab + tcase->num_ba; j++ )
 			{
 				unsigned int d_hours, d_minutes, a_hours, a_minutes;
 				
 				if( fscanf( file, α%d:%d %d:%dα, &d_hours, &d_minutes, &a_hours, &a_minutes ) == EOF )
 				{
 					printf( αAn error occurred while attempting to read engine name %d, aborting...nα, j );
 					success = -1;
 					break;
 				}
 				
 				if( j < tcase->num_ab )
 				{
 					tcase->ab_trips[j][0] = ( ( d_hours + 24 ) * 60 ) + d_minutes;
 					tcase->ab_trips[j][1] = ( ( a_hours + 24 ) * 60 ) + a_minutes;
 				}
 				else
 				{
 					tcase->ba_trips[j-tcase->num_ab][0] = ( ( d_hours + 24 ) * 60 ) + d_minutes;
 					tcase->ba_trips[j-tcase->num_ab][1] = ( ( a_hours + 24 ) * 60 ) + a_minutes;
 				}
 			}
 		}
 		else
 		{
 			success = -1;
 			printf( αAn error occurred while attempting to read the engine count value, aborting...nα );
 		}
 	}
 	else
 	{
 		success = -1;
 	}
 	
 	return success;
 }
 
 int num_trains( struct test_case* tcase, int* a, int* b )
 {
 	int success = 1;
 	unsigned char used_ab[ MAX_TRIPS ], used_ba[ MAX_TRIPS ];
 	unsigned int i = 0, j = 0;
 	int targ;
 	*a = 0;
 	*b = 0;
 	
 	for( i = 0; i < ( tcase->num_ab > tcase->num_ba ? tcase->num_ab : tcase->num_ba ); i++ )
 	{
 		used_ab[i] = used_ba[i] = 0;
 	}
 		
 	for( i = 0; i < ( tcase->num_ab > tcase->num_ba ? tcase->num_ab : tcase->num_ba ); i++ )
 	{		
 		if( i < tcase->num_ab )
 		{
 			targ = -1;
 		
 			for( j = 0; j < tcase->num_ba; j++ )
 			{
 				if( tcase->ba_trips[j][1] <= ( tcase->ab_trips[i][0] - tcase->t ) && used_ba[j] == 0 )
 				{
 					if( targ == -1 )
 					{
 						targ = j;
 					}
 					else if( tcase->ba_trips[j][1] <= ( tcase->ab_trips[i][0] - tcase->t ) && tcase->ba_trips[j][1] <= tcase->ba_trips[targ][1] )
 					{
 						targ = j;
 					}
 				}
 			}
 			
 			if( targ == -1 )
 			{
 				(*a)++;
 			}			
 			else if( tcase->ba_trips[targ][1] <= ( tcase->ab_trips[i][0] - tcase->t ) && used_ba[targ] == 0 )
 			{
 				used_ba[targ] = 1;
 			}
 			else
 			{
 				(*a)++;
 			}
 		}
 		
 		if( i < tcase->num_ba )
 		{
 			targ = -1;
 			
 			for( j = 0; j < tcase->num_ab; j++ )
 			{
 				if( tcase->ab_trips[j][1] <= ( tcase->ba_trips[i][0] - tcase->t ) && used_ab[j] == 0 )
 				{
 					if( targ == -1 )
 					{
 						targ = j;
 					}
 					else if( tcase->ab_trips[j][1] <= ( tcase->ba_trips[i][0] - tcase->t ) && tcase->ab_trips[j][1] <= tcase->ab_trips[targ][1] )
 					{
 						targ = j;
 					}
 				}
 			}
 			
 			if( targ == -1 )
 			{
 				(*b)++;
 			}
 			else if( tcase->ab_trips[targ][1] <= ( tcase->ba_trips[i][0] - tcase->t ) && used_ab[targ] == 0 )
 			{
 				used_ab[targ] = 1;
 			}
 			else
 			{	
 				(*b)++;
 			}
 		}
 	}
 	
 	return success;
 }
 
 int process( char* file_name )
 {
 	int success = 1;
 	FILE* file = fopen( file_name, αrα );
 	unsigned int i = 0;
 	int num_entries;
 	char out_fname[ 1000 ];
 	strcpy( out_fname, file_name );
 	strcat( out_fname, α.outα );
 	FILE* outfile = fopen( out_fname, αwα );
 	
 	if( fscanf( file, α%dα, &num_entries ) != EOF )
 	{
 		for( i = 0; i < num_entries; i++ )
 		{
 			struct test_case tcase;
 			
 			if( get_case( file, &tcase ) != -1 )
 			{
 				sort( &tcase );
 				int a, b;
 				int res = num_trains( &tcase, &a, &b );
 				
 				if( res != -1 )
 				{
 					printf( αCase #%d: %d %dnα, i+1, a, b );
 					fprintf( outfile, αCase #%d: %d %dnα, i+1, a, b );
 				}
 				else
 				{
 					success = -1;
 					break;
 				}
 			}
 			else
 			{
 				printf( αError while processing case %dnα, i );
 				success = -1;
 			}
 		}
 	}
 	else
 	{
 		printf( αError while reading number of entriesnα );
 		success = -1;
 	}
 	
 	return success;
 }
 
 int main( int argc, char* argv[] )
 {
 	if( argc >= 2 )
 	{
 		int i = 1;
 		
 		for( i = 1; i < argc; i++ )
 		{
 			if( process( argv[i] ) == -1 )
 			{
 				printf( αAn error occurred while attempting to process file %s, aborting... nα, argv[i] );
 			}	
 		}
 	}
 	
 	return EXIT_SUCCESS;
 }"
25190,2008,32013,styner32,24480,1,a1.c,gcj/2008/32013/styner32/24480/1/extracted/a1.c,"#include<stdio.h>
 #include<string.h>
 
 char sname[100][110], q[110];
 int s_cnt,q_cnt;
 int check[100];
 
 int get_index(char *str);
 int full_check();
 void clear_check();
 
 int main(void)
 {
 	int cn,switch_cnt,i,case_num;
 	char tmp[1000];
 	scanf(α%dα, &cn);
 
 	case_num = 0;
 	while(cn--)
 	{
 		switch_cnt = 0;
 		scanf(α%dα, &s_cnt);
 		clear_check();
 		gets(tmp);
 		fflush(stdin);
 
 		for(i = 0; i < s_cnt; ++i)
 		{
 			gets(sname[i]);
 			//printf(α%snα, sname[i]);
 		}
 
 		scanf(α%dα, &q_cnt);
 		gets(tmp);
 		fflush(stdin);
 
 		for(i = 0; i < q_cnt; ++i)
 		{
 			int index;
 			gets(q);
 			index = get_index(q);
 			check[index] = 1;
 			if(full_check())
 			{
 				switch_cnt++;
 				//printf(α%snα, q[i]);
 				clear_check();
 				check[index] = 1;
 			}
 		}
 
 		printf(αCase #%d: %dnα,++case_num, switch_cnt);
 	}
 
 	return 0;
 }
 
 int get_index(char *str)
 {
 	int i;
 	for(i = 0;i < s_cnt; ++i)
 		if(strcmp(sname[i], str) == 0)
 			return i;
 	return -100;
 }
 
 int full_check()
 {
 	int i;
 	for(i = 0; i < s_cnt; ++i)
 		if(!check[i])
 			return 0;
 	return 1;
 }
 
 void clear_check()
 {
 	int i;
 	for(i = 0; i < 100; ++i)
 		check[i] = 0;
 }"
25228,2008,32013,sweetyvidhi,24480,1,prg.c,gcj/2008/32013/sweetyvidhi/24480/1/extracted/prg.c,"#include<stdio.h>
 int main()
 {
 	int i,test,j,k,l,n1,n2,tr[1000],count=0,flag=0;
 	char str[1000][100],query[1000][100];
 	//printf(αGet test caseα);
 	scanf(α%dα,&test);
 	for(i=0;i<test;i++)
 	{   count=0;
 		//printf(αGet testα);
 	    scanf(α%dα,&n1);
 	    for(j=0;j<n1;j++)
 	       {fflush(stdin);
 		scanf(α %[^n]α,str[j]);
 		 //gets(str[j]);
 		//printf(α%d/%dα,j,n1);
 		 tr[j]=0;
 	       }
 	       //printf(αGet queryα);
 	    scanf(α%dα,&n2);
 	    for(k=0;k<n2;k++)
 	       { fflush(stdin);
 		 scanf(α %[^n]α,query[k]);
 	       }
 
 	      //gets(query[k]);
 	    for(k=0;k<n2;k++)
 	    { flag=0;
 	      for(j=0;j<n1&&!flag;j++)
 		 if(strcmp(query[k],str[j])==0&&tr[j]==0)
 		    { flag=1;
 		      tr[j]=1;
 
 		   for(l=0;l<n1;l++)
 		     if(tr[l]==0)
 			break;
 		   if(l==n1)
 		       { for(l=0;l<n1;l++)
 			  tr[l]=0;
 			 count++;
 			 tr[j]=1;
 		       }
 		   }
 
 	    }
         printf(αCase #%d: %dnα,i+1,count);
 
 	    }
         return 0;
 
 	}"
25426,2008,32013,vrb,24480,1,a.c,gcj/2008/32013/vrb/24480/1/extracted/a.c,"#include<stdio.h>
 #include<stdlib.h>
 struct str_engines
 {
 char name[100];
 int index;
 };
 
 //search engine data structure: each engine in S engines
 struct str_engines se[101];
 
 //N in problem
 char s_not[4];
 //S in problem
 char s_nose[4];
 //Q in problem
 char s_nostrs[20];
 //  N  ,   S   ,   Q
 int not,nose,nostrs;
 
 char strname[100];
 char temp[100];
 
 int arr[1001];
 
 int seekpos=0,flag = 0;
 
 void gotillnextline(FILE *fp)
 {
 char c;
 do
 {
 c = fgetc(fp);
 }while(c=='n'||c=='0'||c=='r');
 fseek(fp,-1,SEEK_CUR);
 }
 int getindexofengine(char *s)
 {
  int i,n,j;
   for(i=1;i<=nose;i++)
   {
     n = strcmp(s,se[i].name);
 //    printf(αstrlen1=%d(%s)nα,strlen(s),s);
     if(!n)
   	break;
 
   }
 
   return i;
 }
 
 int getpos(int i)
 {
 int j;
  if(i>9)
  	j=2;
  else if(i<=9)
  	j =1;
  return j;
  	
 }
 void copy(char *res,char *src)
 {
   int len = 0,i;
   len = strlen(src);
 
   for(i=0;((i<=(len-1))&&(src[i]!='r')&&(src[i]!='n'));i++)
   {
     res[i] = src[i];
   }
      res[i] = '0';
 }
 int main()
 {
 
 FILE *fp,*fw;
 int i,j,count =0,k,len=0,m;
 int swneeded = 0,t;
 
 for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of test cases
 fp = fopen(αalarge.txtα,αrα);
 fw = fopen(αlarge_out.txtα,αwα);
 
 fgets(s_not,3,fp);
 gotillnextline(fp);
 not = atoi(s_not);
 //printf(αno of test cases= %d nα,not);
 
 for(k = 1;k<=not;k++)
 {
     for(i=1;i<=1000;i++)
 	arr[i]=0;
 
 //to read no of search engines
 fgets(s_nose,5,fp);
 nose = atoi(s_nose);
 //printf(αno of search engines = %d nα,nose);
 gotillnextline(fp);
 
 //to read all engine names 1 by 1
 //printf(αSearch engines are as below:nα);
 for(i=1;i<=nose;i++)
  {
    se[i].index = i;
    fgets(temp,100,fp);
    gotillnextline(fp);
 //  printf(αstring got %snα,temp);
    copy(se[i].name,temp);
    //printf(α%d: %snα,i,se[i].name);
  }
 
 
 //to read search strings names 1 by 1
 fgets(s_nostrs,5,fp);
 gotillnextline(fp);
 nostrs = atoi(s_nostrs);
 //printf(αno of search strings are %d nα,nostrs);
 
  
 //printf(αsearch strings are as below:nα);
  for(i=1;i<=nostrs;i++)
  {
  //reading string name
          fgets(temp,100,fp);
         gotillnextline(fp);
          copy(strname,temp);
         //printf(α%d: %s nα,i,strname);
          for(m=1;m<=100;m++)
          temp[m]='0';
 		 
          j = getindexofengine(strname);
 	  if(arr[j]==0)
 	  {
 	    count++;
 	    arr[j]=1;
 	//    printf(αcount is incremented:%dnα,count);
 	  }
 	  if(count ==  nose)
           {
             for(m=1;m<=1000;m++)
             arr[m]=0;
 	     arr[j]=1;
             swneeded++;
             count = 1;
 	     j =0;
            // printf(αSWITCHEDnα);
           }        
          
  }
 
  fprintf(fw,αCase #%d: %dnα,k,swneeded);
  
   swneeded = 0;
   count = 0;
 
 }
 
 fclose(fp);
 fclose(fw);
 	return 0;
 }"
25467,2008,32013,sungyz,24480,1,SavingTheUnivers.c,gcj/2008/32013/sungyz/24480/1/extracted/SavingTheUnivers.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define	MAXCHAR	    120
 #define	MAXENGINE	100
 #define	MAXQUERY	1000
 
 struct	stu {
 	int		numEngines;
     char	eng[MAXENGINE][MAXCHAR];
 	int		numQueries;
     char	query[MAXQUERY][MAXCHAR];
 };
 
 typedef	struct stu	STU, *pSTU;
 
 int	calcSwitching( pSTU s );
 
 
 int main( int argc, char *argv[] )
 {
 	FILE	*fp;
 	int		numCases, num, i;
 	char	buffer[MAXCHAR];
 	STU		ss;
 
 	if( argc < 2 )
 	{
 		fprintf( stderr, αError : No input file!nα );
 		fprintf( stderr, αUsage : %s input_file [> output_file]nα, argv[0] );
 		return -1;
 	}
 
 	// Read the number of test cases
 	fp = fopen( argv[1], αrtα );
 	if( fgets( buffer, MAXCHAR, fp ) == NULL )
 	{
 		fprintf( stderr, αError : fgets() returns NULL!nα );
 		return -1;
 	}
 
 	numCases = atoi( buffer );
 	if( numCases < 1 || numCases > 20 )
 	{
 		fprintf( stderr, αError : Invaid number of test cases (%d)nα, numCases );
 		return -1;
 	}
 
 	// For each test cases...
 	for( i = 0 ; i < numCases ; i++ )
 	{
 		// Read the number of search engines.
 		if( fgets( buffer, MAXCHAR, fp ) == NULL )
 		{
 			fprintf( stderr, αError : fgets() returns NULL!nα );
 			return -1;
 		}
 		num = atoi(buffer);
 		if( num < 2 || num > MAXENGINE )
 		{
 			fprintf( stderr, αError : Invaid number of search engines (%d)nα, num );
 			return -1;
 		}
 		ss.numEngines = num;
 
 		// Read each search engines...
 		for( num = 0 ; num < ss.numEngines ; num++ )
 		{
 			if( fgets( ss.eng[num], MAXCHAR, fp ) == NULL )
 			{
 				fprintf( stderr, αError : fgets() returns NULL!nα );
 				return -1;
 			}
 		}
 
 		// Read the number of Queries
 		if( fgets( buffer, MAXCHAR, fp ) == NULL )
 		{
 			fprintf( stderr, αError : fgets() returns NULL!nα );
 			return -1;
 		}
 		num = atoi(buffer);
 		if( num < 0 || num > MAXQUERY )
 		{
 			fprintf( stderr, αError : Invaid number of queries (%d)nα, num );
 			return -1;
 		}
 		ss.numQueries = num;
 
 		for( num = 0 ; num < ss.numQueries ; num++ )
 		{
 			if( fgets( ss.query[num], MAXCHAR, fp ) == NULL )
 			{
 				fprintf( stderr, αError : fgets() returns NULL!nα );
 				return -1;
 			}
 		}
 
 		// Function call...
 		num = calcSwitching( &ss );
 		if( num < 0 )
 		{
 			fprintf( stderr, αError : Invaid number of switching (%d)nα, num );
 			return -1;
 		}
 		fprintf( stdout, αCase #%d: %dnα, i+1, num );
 
 	}
 
 	fclose( fp );
 
 	return 0;
 }
 
 
 
 int	calcSwitching( pSTU s )
 {
 	int		engPool[MAXENGINE], engIndex, i, j;
 	int		switching = 0;
 
 	if( s->numQueries == 0 || s->numQueries == 1 )
 		return 0;
 
     memset( engPool, 0, sizeof(int)*MAXENGINE );
 	for( i = 0 ; i < s->numQueries ; i++ )
 	{
 		for( j = 0 ; j < s->numEngines ; j++ )
 		{
 			if( strcmp( s->query[i], s->eng[j] ) == 0 )
 				break;
 		}
 		if( j == s->numEngines )
 			continue;
 
 		engIndex = j;
 		engPool[engIndex] = -1;
 		for( j = 0 ; j < s->numEngines ; j++ )
 		{
 			if( engPool[j] == 0 )
 				break;
 		}
 		if( j == s->numEngines )
 		{
 			memset( engPool, 0, sizeof(int)*MAXENGINE );
 			engPool[engIndex] = -1;
 			switching++;
 		}
 	}
 
 	return switching;
 }"
25469,2008,32013,sungyz,24481,1,TrainTimetable.c,gcj/2008/32013/sungyz/24481/1/extracted/TrainTimetable.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 
 #define	MAXCHAR		20
 #define	MAXTRIPS	100
 #define	MAXTU		60
 
 struct trips {
 	int		tu_time;
 	int		numA;
 	char	startA[MAXTRIPS][6], endA[MAXTRIPS][6];
 	int		numB;
 	char	startB[MAXTRIPS][6], endB[MAXTRIPS][6];
 };
 
 typedef	struct trips	TTS, *pTTS;
 
 int	calcStartNum( pTTS ts, int *numA, int *numB );
 
 
 
 int main( int argc, char *argv[] )
 {
 	FILE	*fp;
 	int		numCases, num, i;
     int     numA, numB;
 	char	buffer[MAXCHAR];
 	TTS		tts;
 
 	if( argc < 2 )
 	{
 		fprintf( stderr, αError : No input file!nα );
 		fprintf( stderr, αUsage : %s input_file [> output_file]nα, argv[0] );
 		return -1;
 	}
 
 	// Read the number of test cases
 	fp = fopen( argv[1], αrtα );
 	if( fgets( buffer, MAXCHAR, fp ) == NULL )
 	{
 		fprintf( stderr, αError : fgets() returns NULL!nα );
 		return -1;
 	}
 
 	numCases = atoi( buffer );
 	if( numCases < 1 || numCases > 100 )
 	{
 		fprintf( stderr, αError : Invaid number of test cases (%d)nα, numCases );
 		return -1;
 	}
 
 	// For each test cases...
 	for( i = 0 ; i < numCases ; i++ )
 	{
 		// Read the turnaround time
 		if( fgets( buffer, MAXCHAR, fp ) == NULL )
 		{
 			fprintf( stderr, αError : fgets() returns NULL!nα );
 			return -1;
 		}
 		num = atoi(buffer);
 		if( num < 0 || num > MAXTU )
 		{
 			fprintf( stderr, αError : Invaid turnaround time (%d)nα, num );
 			return -1;
 		}
         tts.tu_time = num;
 
 		// Read the NA NB
 		if( fgets( buffer, MAXCHAR, fp ) == NULL )
 		{
 			fprintf( stderr, αError : fgets() returns NULL!nα );
 			return -1;
 		}
         if( sscanf( buffer, α%d %dα, &tts.numA, &tts.numB ) != 2 ||
 			(tts.numA < 0 || tts.numA > MAXTRIPS || tts.numB < 0 || tts.numB > MAXTRIPS) )
 		{
 			fprintf( stderr, αError : Invaid NA(%d)&NB(%d)nα, tts.numA, tts.numB );
 			return -1;
 		}
 
 		// Read each Trip Tables from A( to B)
 		for( num = 0 ; num < tts.numA ; num++ )
 		{
 			if( fgets( buffer, MAXCHAR, fp ) == NULL )
 			{
 				fprintf( stderr, αError : fgets() returns NULL!nα );
 				return -1;
 			}
             if( sscanf( buffer, α%s %sα, tts.startA[num], tts.endA[num] ) != 2 )
 			{
 				fprintf( stderr, αError : Invaid trip time(A-B)nα );
 				return -1;
 			}
             if( strcmp(tts.startA[num], tts.endA[num]) >= 0 )
 			{
 				fprintf( stderr, αError : Invaid trip time(%s-%s)nα, tts.startA[num], tts.endA[num] );
 				return -1;
 			}
 		}
 
 		// Read each Trip Tables from B( to A)
 		for( num = 0 ; num < tts.numB ; num++ )
 		{
 			if( fgets( buffer, MAXCHAR, fp ) == NULL )
 			{
 				fprintf( stderr, αError : fgets() returns NULL!nα );
 				return -1;
 			}
             if( sscanf( buffer, α%s %sα, tts.startB[num], tts.endB[num] ) != 2 )
 			{
 				fprintf( stderr, αError : Invaid trip time(B-A)nα );
 				return -1;
 			}
             if( strcmp(tts.startB[num], tts.endB[num]) >= 0 )
 			{
 				fprintf( stderr, αError : Invaid trip time(%s-%s)nα, tts.startB[num], tts.endB[num] );
 				return -1;
 			}
 		}
 
 		// Function call...
 		if( (num=calcStartNum( &tts, &numA, &numB )) < 0 )
 		{
 			fprintf( stderr, αError : Invaid Calculation Result!(%d)nα, num );
 			return -1;
 		}
 		fprintf( stdout, αCase #%d: %d %dnα, i+1, numA, numB );
 	}
 
 	fclose( fp );
 
 	return 0;
 }
 
 
 
 int	calcStartNum( pTTS ts, int *numA, int *numB )
 {
     int     A, B, i, j;
     char    s[6], e[6];
     int     usedFlag[MAXTRIPS];
     struct  tm  tt;
 
     A = ts->numA;
     B = ts->numB;
 
     // For optimaization, sorting the timetable for A-B
     for( i = 0 ; i < ts->numA ; i++ )
     {
         for( j = i+1 ; j < ts->numA ; j++ )
         {
             if( strcmp(ts->startA[i], ts->startA[j]) > 0 )
             {
                 strcpy( s, ts->startA[j] );
                 strcpy( e, ts->endA[j] );
                 strcpy( ts->startA[j], ts->startA[i] );
                 strcpy( ts->endA[j], ts->endA[i] );
                 strcpy( ts->startA[i], s );
                 strcpy( ts->endA[i], e );
             }
         }
     }
     // For optimaization, sorting the timetable for B-A
     for( i = 0 ; i < ts->numB ; i++ )
     {
         for( j = i+1 ; j < ts->numB ; j++ )
         {
             if( strcmp(ts->startB[i], ts->startB[j]) > 0 )
             {
                 strcpy( s, ts->startB[j] );
                 strcpy( e, ts->endB[j] );
                 strcpy( ts->startB[j], ts->startB[i] );
                 strcpy( ts->endB[j], ts->endB[i] );
                 strcpy( ts->startB[i], s );
                 strcpy( ts->endB[i], e );
             }
         }
     }
 
     memset( usedFlag, 0, sizeof(int)*MAXTRIPS );
     for( i = 0 ; i < ts->numA ; i++ )
     {
         for( j = 0 ; j < ts->numB ; j++ )
         {
             if( usedFlag[j] == 0 )
             {
                 sscanf( ts->endB[j], α%d:%dα, &tt.tm_hour, &tt.tm_min );
                 tt.tm_min += ts->tu_time;
                 if( tt.tm_min >= 60 )
                 {
                     tt.tm_hour++;
                     tt.tm_min -= 60;
                 }
                 sprintf( e, α%02d:%02dα, tt.tm_hour, tt.tm_min );
                 if( strcmp( e, ts->startA[i] ) <= 0 )
                 {
                     usedFlag[j] = 1;
                     A--;
                     break;
                 }
             }
         }
     }
 
     memset( usedFlag, 0, sizeof(int)*MAXTRIPS );
     for( i = 0 ; i < ts->numB ; i++ )
     {
         for( j = 0 ; j < ts->numA ; j++ )
         {
             if( usedFlag[j] == 0 && ts->endA[j]+ts->tu_time <= ts->startB[i] )
             {
                 sscanf( ts->endA[j], α%d:%dα, &tt.tm_hour, &tt.tm_min );
                 tt.tm_min += ts->tu_time;
                 if( tt.tm_min >= 60 )
                 {
                     tt.tm_hour++;
                     tt.tm_min -= 60;
                 }
                 sprintf( e, α%02d:%02dα, tt.tm_hour, tt.tm_min );
                 if( strcmp( e, ts->startB[i] ) <= 0 )
                 {
                     usedFlag[j] = 1;
                     B--;
                     break;
                 }
             }
         }
     }
 
     *numA = A;
     *numB = B;
 
     return 0;
 }"
25484,2008,32013,whitebear,24480,1,universe.c,gcj/2008/32013/whitebear/24480/1/extracted/universe.c,"#include <stdio.h>
 
 int main()
 {
 
 	int a, b, c, i, j, k, m, n, p, s, q, cases;
 	int answer=0;
 	int sum;
 	int bucket[1000];
 	char query[102], name[102][102];
 
 	scanf(α%dα, &cases);
 	for (a=0; a<cases; a++){
 
 		answer=0;
 
 		scanf(α%d α, &s);
 		for (k=0; k<s; k++) bucket[k] = 0;
 		for (i=0; i<s; i++){
 			gets(name[i]);
 		}
 		scanf(α%d α, &q);
 
 		sum = 0;
 		for (i=0; i<q; i++){
 
 			gets(query);
 
 			for (j=0; j<s; j++) {
 //				printf(αnQUERY = %s, CHECK = %sα,query,name[j]);
 				if (strcmp(query,name[j])==0) break;
 			}	
 			if (bucket[j] == 0) sum++;
 			bucket[j]++;
 	//		printf(αnBUCKET = %d %d %d %d %d. sum= %dnα, bucket[0], bucket[1], bucket[2], bucket[3], bucket[4], sum);
 			if (sum == s){		
 				sum = 1;
 				answer++;
 				for (k=0; k<s; k++) bucket[k] = 0;
 				bucket[j] = 1;
 			}
 
 		}
 		printf(αCase #%d: %dnα, a+1, answer);
 	}
 	return 0;
 
 
 
 
 }"
25486,2008,32013,whitebear,24481,1,train.c,gcj/2008/32013/whitebear/24481/1/extracted/train.c,"#include <stdio.h>
 
 int main()
 {
 
 	int i, j, k, t, nA, nB, trainA, trainB, numfreeA, numfreeB, ansA, ansB;
 	int freeA[1000][2], freeB[1000][2], A[1000][2], B[1000][2];
 	int hour, min;
 	int numcase, z;
 
 	scanf(α%dα, &numcase);
 	for (z=0; z<numcase; z++){
 
 
 		scanf(α%d %d %dα, &t, &nA, &nB);
 		for (i=0; i<nA; i++)
 			scanf(α%d:%d %d:%dα, &A[i][0], &A[i][1], &freeA[i][0], &freeA[i][1]);
 		for (i=0; i<nB; i++)
 			scanf(α%d:%d %d:%dα, &B[i][0], &B[i][1], &freeB[i][0], &freeB[i][1]);
 
 		for (i=0; i<nA; i++){
 			freeA[i][1] += t;
 			if (freeA[i][1] >= 60){
 				freeA[i][1] -= 60;
 				freeA[i][0]++;
 			}
 		}
 
 		for (i=0; i<nB; i++){
 			freeB[i][1] += t;
 			if (freeB[i][1] >= 60){
 				freeB[i][1] -= 60;
 				freeB[i][0]++;
 			}
 		}	
 
 		trainA = trainB = 0;
 		numfreeA = numfreeB = 0;
 		ansA = ansB = 0;
 
 		for (hour=0; hour<24; hour++){
 			for (min=0; min<60; min++){
 				for (i=0; i<nA; i++){
 
 					if (freeA[i][0] == hour && freeA[i][1] == min){
 						trainB += 1;
 					}
 				}
 
 				for (i=0; i<nB; i++){
 					if (freeB[i][0] == hour && freeB[i][1] == min){
 						trainA += 1;
 					}
 				}
 
 				for (i=0; i<nA; i++){
 					if (A[i][0] == hour && A[i][1] == min){
 						if (trainA > 0) trainA--;
 						else{
 			//				printf(αneed a train at A, %d:%dnα,hour,min);
 							ansA++;
 						}
 					}
 				}
 
 				for (i=0; i<nB; i++){
 					if (B[i][0] == hour && B[i][1] == min){
 						if (trainB > 0) trainB--;
 						else{
 		//					printf(αneed a train at B, %d:%dnα, hour, min);
 							ansB++;
 						}
 					}
 				}
 
 
 
 			}
 		}
 
 
 
 		printf(αCase #%d: %d %dnα, z+1, ansA, ansB);
 	}
 
 
 	return 0;
 }"
25607,2008,32013,lekshmikesavan,24480,1,save_universe.c,gcj/2008/32013/lekshmikesavan/24480/1/extracted/save_universe.c,"#include <stdio.h>
 #include <strings.h>
 
 int S;
 char SE[101][128];
 
 int get_index(char *query)
 {
     int i;
     for(i=0 ; i<S ; i++)
     {
         if(strcmp(query, SE[i]) == 0)
         {
             return i;
         }
     }
     printf(αSorry,Query is not a search engine namenα);
     return 101;
 }
 
 int main()
 {
     int N,Q;
     char queries[1000][128];
 
     int indexofquery, num_SEs_found, switches, flag[100];
 
     int i, j, k;
 
 
     scanf(α%dnα, &N);
     for( i=0; i<N ; i++)
     {
         scanf(α%dnα, &S);
         for(j=0 ; j<S ; j++)
         {
             gets(SE[j]);            
         }
         scanf(α%dnα, &Q);
         for(j=0 ; j<Q ; j++)
         {
             gets(queries[j]);            
         }
         switches = 0;
         for(j=0 ; j<Q ; j++)
         {
             num_SEs_found = 0;
             for( k=0 ; k<S; k++)
             {
                 flag[k] = 0;
             }
             while(num_SEs_found<S && j<Q)
             {
                 indexofquery = get_index(queries[j]);
                 if(flag[indexofquery] == 0)
                 {                    
                     num_SEs_found++;
                     flag[indexofquery] = 1;
                 } 
                 j++;
             }
             if(num_SEs_found == S) 
             {
                 j -= 2;
                 switches++;
             }
         }
         printf(αCase #%d: %dnα, i+1,switches);
     }
     return 0;
 }"
25609,2008,32013,lekshmikesavan,24481,1,traintime.c,gcj/2008/32013/lekshmikesavan/24481/1/extracted/traintime.c,"#include <stdio.h>
 
 enum start_stop_type {StopA, StopB, StartA, StartB};
 
 void sort(int A[], enum start_stop_type B[], int count)
 {
     int min, temp_time;
     enum start_stop_type temp_type;
     int i,j;
 
     for(i=0 ; i<count-1 ; i++)
     {
         min = i;
         for(j=i+1 ; j<count ; j++)
         {
             if(A[j] < A[min] || (A[j] == A[min] && B[j] < B[min]))
             {
                 min = j;
             }
         }
         if(min!=i)
         {
             temp_time = A[i];
             A[i] = A[min];
             A[min] = temp_time;
 
             temp_type = B[i];
             B[i] = B[min];
             B[min] = temp_type;
         }
     }
 }
 
 int main()
 {
     int N, T, NA, NB;
     int numA, numB, availA, availB;
     int count, hr, min, timeinmin[400];
     int i,j;
 
     enum start_stop_type type[400];
 
     scanf(α%dα, &N);
     for( i=0 ; i<N ; i++)
     {
         scanf(α%dα, &T);
         scanf(α%d %dα, &NA, &NB);
         numA = 0;
         numB = 0;
         availA = 0;
         availB = 0;
         count = 0;
         for(j=0 ; j<NA ; j++)
         {
             scanf(α%d:%d α, &hr, &min);
             timeinmin[count] = hr*60 + min ;
             type[count++] = StartA;
 
             scanf(α%d:%dα, &hr, &min);
             timeinmin[count] = hr*60 + min +T;
             type[count++] = StopA;
         }
         for(j=0 ; j<NB ; j++)
         {
             scanf(α%d:%d α, &hr, &min);
             timeinmin[count] = hr*60 + min ;
             type[count++] = StartB;
 
             scanf(α%d:%dα, &hr, &min);
             timeinmin[count] = hr*60 + min +T;
             type[count++] = StopB;
         }
         sort(timeinmin, type, count);
         for( j=0 ; j<count ; j++ )
         {
             if( type[j] == StartA )
             {
                 if(availA == 0)
                 {
                     numA++;
                 }
                 else
                 {
                     availA--;
                 }
             }
  
             else if( type[j] == StopA )
             {
                 availB++;
             }
 
             else if(type[j] == StartB)
             {
                if(availB == 0)
                 {
                     numB++;
                 }
                 else
                 {
                     availB--;
                 }
             } 
 
             else if( type[j] == StopB )
             {
                 availA++;
             }
         }
         printf(αCase #%d: %d %dnα, i+1, numA, numB);
     }
 }"
25615,2008,32013,xxxxx373,24480,1,main.c,gcj/2008/32013/xxxxx373/24480/1/extracted/main.c,"#include <tchar.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 #define FILENAME αC:\temp\data.txtα
 #define RESULT αC:\temp\result.txtα
 
 typedef struct _ENGINE{
 	int cnt;
 	int pos[1000];
 	char name[101];
 }ENGINE, *LPENGINE;
 
 FILE* filepointer(){
 	static FILE *fp = NULL;
 	if( fp == NULL ) fp = fopen(FILENAME, αrα);
 	return fp;
 }
 
 int string_compare( char* c1, char* c2 ){
 	int i, len = strlen(c1);
 	if( len != strlen(c2) ) return 0;
 	for(i=0;i<len;i++){
 		if( c1[i] != c2[i] ) break;
 	}
 	return (i==len);
 }
 
 int func(int start, int size, LPENGINE engines, int *current){
 	int i, j, max=start;
 	int current_l = -1;
 	for(i=0;i<size;i++){
 		if( *current == i ) continue;
 		for(j=0;j<=engines[i].cnt;j++){
 			if( start < engines[i].pos[j]){
 				if( max < engines[i].pos[j] ){
 					max = engines[i].pos[j];
 					current_l = i;
 				}
 				break;
 			}
 		}
 	}
 	*current = current_l;
 	return max;
 }
 
 int switch_count()
 {
 	int ans=0;
 	int i, j;
 	int S, Q;
 	ENGINE engines[100];
 	char queries[101], work[10];
 	FILE *fp = filepointer();
 	
 	// initial
 	memset(queries,0,101);
 	for(i=0;i<100;i++){
 		engines[i].cnt = 0;
 		for(j=0;j<1000;j++){
 			engines[i].pos[j] = 10000;
 		}
 		memset(engines[i].name, 0, 101);
 	}
 
 	// data read
 	fgets(work,sizeof(work),fp);
 	S = atoi(work);
 	for(i=0;i<S;i++){
 		fgets(engines[i].name, 101, fp);
 	}
 	fgets(work,sizeof(work),fp);
 	Q = atoi(work);
 	for(i=0;i<Q;i++){
 		fgets(queries, 101, fp);
 		// count
 		for(j=0;j<S;j++){
 			if( string_compare(queries, engines[j].name) ){
 				engines[j].pos[engines[j].cnt++] = i+1;
 				break;
 			}
 		}
 	}
 
 	// switch count
 	for(i=0;i<S;i++){
 		if( engines[i].cnt == 0 ) return 0;
 	}
 
 	{
 		int current = -1;
 		i = 1;
 		while( (i = func(i-1, S, engines, &current)) <= Q ) ans++;
 	}
 
 	return ans;
 }
 
 int main(int argc, _TCHAR* argv[])
 {
 	int i;
 	int n;
 	char work[10];
 	FILE* fp = filepointer();
 	FILE* fpr = fopen( RESULT, αw+α );
 
 	fgets(work,sizeof(work),fp);
 	n = atoi(work);
 	for(i=0;i<n;i++){
 		int output = switch_count();
 		fprintf(fpr, αCase #%d: %dnα, i+1, output);
 	}
 
 	fclose(fp);
 	fclose(fpr);
 	return 0;
 }"
25664,2008,32013,kanu,24480,1,SWIT.C,gcj/2008/32013/kanu/24480/1/extracted/SWIT.C,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 #include<alloc.h>
 #define MAX1 110
 #define MAX2 1002
 
 
 int check(char *search[],char *keyword[],int i,int j);
 
 void main()
 {
 	 FILE *fp1,*fp2;
 	 char *search[MAX1],*keyword[MAX2],str[MAX1];
 	 int i,j,z=0,k,len,x,y,swit;
 	 clrscr();
 
 	 fp1=fopen(αswitch.txtα,αrα);
 	 if(fp1==NULL)
 	 {
 		  printf(αnCannot open the source file...α);
 	 }
 	 else
 	 {
 		  fp2=fopen(αans.txtα,αwα);
 		  if(fp2==NULL)
 		  {
 				printf(αnCannot open the output fileα);
 		  }
 		  else
 		  {
 				fscanf(fp1,α %[^n]sα,str);
 				fgetc(fp1);
 				len=strlen(str);
 				for(i=0;i<len;i++)
 				{
 					z=z*10+(str[i]-48);
 				}
 				for(k=0;k<z;k++)
 				{
 					x=0;y=0;
 
 					fscanf(fp1,α %[^n]sα,str);
 					fgetc(fp1);
 					len=strlen(str);
 					for(i=0;i<len;i++)
 					{
 						 x=x*10+(str[i]-48);
 					}
 					for(j=0;j<x;j++)
 					{
 						fscanf(fp1,α %[^n]sα,str);
 //						printf(α %sα,str);
 						fgetc(fp1);
 						len=strlen(str);
 						search[j]=(char *)malloc((len+1)*sizeof(char));
 						if(search[j]==NULL)
 						{
 							printf(αndont have enuf memoryα);
 							break;
 						}
 						strcpy(search[j],str);
 //						printf(α %snα,search[j]);
 					}
 					fscanf(fp1,α %[^n]sα,str);
 					fgetc(fp1);
 					len=strlen(str);
 					for(i=0;i<len;i++)
 					{
 						 y=y*10+(str[i]-48);
 					}
 					for(j=0;j<y;j++)
 					{
 						fscanf(fp1,α %[^n]sα,str);
 						fgetc(fp1);
 						len=strlen(str);
 						keyword[j]=(char *)malloc((len+1)*sizeof(char));
 						if(keyword[j]==NULL)
 						{
 							printf(αndont have enuf memoryα);
 							break;
 						}
 						strcpy(keyword[j],str);
 					}
 
 					swit=check(search,keyword,y,x);
 
 					for(i=0;i<x;i++)
 						free(search[i]);
 					for(i=0;i<y;i++)
 						free(keyword[i]);
 
 					printf(αnCase #%d: %dα,k+1,swit);
 					fprintf(fp2,αCase #%d: %dnα,k+1,swit);
 				}
 		  }
 		  fclose(fp2);
 	 }
 	 fclose(fp1);
 	 getch();
 }
 
 int check(char *search[],char *keyword[],int i,int j)
 {
 	int k,l,m,sum=0,swit=0,arr[MAX1]={0};
 
 	for(k=0;k<i;k++)
 	{
 		for(l=0;l<j;l++)
 		{
 			if(!strcmp(search[l],keyword[k]))
 			{
 				if(arr[l]==0)
 				{
 					sum++;
 					arr[l]=1;
 				}
 
 				if(sum==j)
 				{
 					swit++;
 					sum=1;
 					for(m=0;m<j;m++)
 						arr[m]=0;
 
 					arr[l]=1;
 				}
 				break;
 			}
 		}
 	}
 	return swit;
 }"
25674,2008,32013,Mickey.Leen,24480,1,1.c,gcj/2008/32013/Mickey.Leen/24480/1/extracted/1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 typedef struct _search
 {
 	char name[100];
 } Search;
 
 int sum( int* array, int num )
 {
 	int s = 0;
 	int i;
 	for( i = 0; i < num; i++ )
 		s += array[i];
 
 	return s;
 }
 
 int caculateSwitches( int search_nums, int* queryArray, int query_nums )
 {
 	int i,j;
 	int switches = 0;
 	int *flags = (int*)malloc(search_nums * sizeof(int) );
 
 	for( i = 0; i < search_nums; i++ )
 		flags[i] = 0;	
 
 	for( j = 0; j < query_nums; j++ )
 	{
 		flags[ queryArray[j] ] = 1;
 
 		if( sum( flags, search_nums ) == search_nums )
 		{
 			j--;	
 			switches++;
 			for( i = 0; i < search_nums; i++ )
 				flags[i] = 0;	
 		}
 	}
 
 	free(flags);
 
 	return switches;
 
 }
 
 int handleCase()
 {		
 		Search searches[100];
 
 		int search_nums;
 		int query_nums;
 
 		char query[100];
 		int  queryArray[1000];
 
 		int i = 0;
 		int j = 0;
 
 		//Read Search Engines
 		scanf(α%dnα, &search_nums);
 		for( i = 0; i < search_nums; i++ )
 		{
 			gets(searches[i].name);
 		}
 
 		//Read Queries
 		scanf(α%dnα, &query_nums);
 		for( i = 0; i < query_nums; i++ )
 		{
 			gets(query);
 
 			for( j = 0; j < search_nums; j++ )
 			{
 				if( !strcmp(query, searches[j].name) )
 				{
 					queryArray[i] = j;
 					break;
 				}
 			}
 		}
 
 		return caculateSwitches( search_nums, queryArray, query_nums );
 }
 
 int main()
 {
 	int cases;
 	int i = 0;
 	scanf(α%dnα, &cases);
 	
 	for( i = 0; i < cases; i++ )
 		printf(αCase #%d: %dnα, i+1, handleCase() );
 
 }"
25708,2008,32013,flinks,24480,1,savingUniv.c,gcj/2008/32013/flinks/24480/1/extracted/savingUniv.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<ctype.h>
 #include<math.h>
 
 #ifdef DEBUG
 	#define D(x) x
 #else
 	#define D(x)  
 #endif
 
 #define TRUE 1
 #define NN 103
 #define NM 1000
 #define INF 10
 
 int resolve(char query[NM][NN], char search[NN][NN], int s, int q)
 {
 	int i, j = 0, used[NN], k = 1, num = 0;
 
 	while(1){
 		for(i = 0; i < s; i++) used[i] = 0;
 		for(; j < q; j++){
 			if(k == s) break;
 			for(i = 0; i < s; i++)
 				if(!strcmp(query[j], search[i])){
 					if(!used[i]) k++;
 					used[i]++;
 					break;
 				}
 		}
 		if(j == q) return num;
 		for(i = 0 ; i < s; i++) if(!used[i]) break;
 		while(j < q){
 			if(!strcmp(search[i], query[j])) break;
 			j++;
 		}
 		if(j == q) return num;
 		num++;
 		k = 1;
 	}
 	return 0;
 }
 
 int main(void)
 {
 	int n, t = 1, s, q, i;
 	char search[NN][NN], query[NM][NN];
 
 	scanf(α%dα, &n);
 	while(n--){
 		scanf(α%dnα, &s);
 		for(i = 0; i < s; i++) gets(search[i]);
 		scanf(α%dnα, &q);
 		for(i = 0; i < q; i++) gets(query[i]);
 		printf(αCase #%d: %dnα, t++, resolve(query, search, s, q));
 	}
 
 
 
 	return 0;
 }"
25710,2008,32013,flinks,24481,1,trainTime.c,gcj/2008/32013/flinks/24481/1/extracted/trainTime.c,"/* luiz henrique
  * 5626459
  */
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<ctype.h>
 #include<math.h>
 
 #ifdef DEBUG
 	#define D(x) x
 #else
 	#define D(x)  
 #endif
 
 #ifdef DEBUG2
 	#define DD(x) x
 #else
 	#define DD(x) 
 #endif
 
 #define TRUE 1
 #define NN 200
 #define INF 10
 
 typedef struct{
 	int ini[2];
 	int fim[2];
 	} data;
 
 static int used[NN], k1, k2;
 
 int cmp(const void *a, const void *b)
 {
 	data x = *(data *)a;
 	data y = *(data *)b;
 
 	if(x.ini[0] - y.ini[0]) return (x.ini[0] - y.ini[0]);
 	if(x.ini[1] - y.ini[1]) return (x.ini[1] - y.ini[1]);
 	if(x.fim[0] - y.fim[0]) return (x.fim[0] - y.fim[0]);
 	return (x.fim[1] - y.fim[1]);
 }
 
 
 void cycle(data trip[NN], int i, int j, int a, int b, int aux)
 {	
 	int h, min;
 	
 	D(int k;
 	printf(αcycle:nα);
 	for(k = 0; k < b; k++) printf(α%d α, used[k]);
 	printf(αnα));
 
 	if(aux){
 		h = trip[i].fim[0];
 		min = trip[i].fim[1];
 		while (j < b){
 			if (used[j]) j++;
 			else if (trip[j].ini[0] < h) j++;
 			else if (trip[j].ini[0] == h && trip[j].ini[1] < min) j++;
 			else break;
 		}
 		if(j == b) return;
 		used[j]++;
 		cycle(trip, 0, j, a, b, 0);
 	}
 	else{
 		h = trip[j].fim[0];
 		min = trip[j].fim[1]; 
 		D(printf(αi = %d, trem chega as %dh%dnα, i, h, min));
 		while (i < a){
 			if (used[i]) i++;
 			else if (trip[i].ini[0] < h) i++;
 			else if (trip[i].ini[0] == h && trip[i].ini[1] < min) i++;
 			else break;
 		}
 		if(i == a) return;
 		used[i]++;
 		cycle(trip, i, a, a, b, 1);
 	}
 	return;
 }
 
 void resolve(data trip[NN], int a, int b)
 {
 	int i, j, aux;
 
 	for(i = 0; i < b; i++) if(!used[i]) break;
 	if(i == b) return;
 	i = 0; j = a;
 	while(used[i] && i < a) i++;
 	while(used[j] && j < b) j++;
 	if(i == a) while(j < b){
 		if(!used[j]){
 			k2++;
 			used[j]++;
 		}
 		j++;
 		}
 	if(j == b) while(i < a){
 		if(!used[i]){
 			k1++;
 			used[i]++;
 		}
 		i++;
 		}
 	for(i = 0; i < b; i++) if(!used[i]) break;
 	        if(i == b) return;
 	if((trip[i].ini[0] < trip[j].ini[0]) || (trip[i].ini[0] == trip[j].ini[0] && trip[i].ini[1] <= trip[j].ini[1])){
 		k1++;
 		used[i]++;
 		aux = 1;
 	}
 	else {
 		k2++;
 		used[j]++;
 		aux = 0;
 	}
 	D(printf(αk1 = %d, k2 = %dnα, k1, k2));
 	cycle(trip, i, j, a, b, aux);
 	D(printf(αend of cyclennα));
 	for(i = 0; i < b; i++) if(!used[i]) break;
 	        if(i == b) return;
 	resolve(trip, a, b);
 	return;
 }
 
 
 int main(void)
 {
 	int i, n, t = 1, delay, hour, min, a, b;
 	data trip[NN];
 
 	scanf(α%dα, &n);
 	while(n--){
 		k1 = k2 = 0;
 		scanf(α%d %d %dα, &delay, &a, &b);
 		for(i = 0; i < a + b; i++){
 			used[i] = 0;
 			scanf(α%d : %dα, &hour, &min);
 			trip[i].ini[0] = hour;
 			trip[i].ini[1] = min;
 			scanf(α%d : %dα, &hour, &min);
 			min += delay;
 			if(min >= 60) {
 				min %= 60;
 				hour++;
 			}
 			trip[i].fim[0] = hour;
 			trip[i].fim[1] = min;
 		}
 		DD(for(i = 0; i < a+b; i++) printf(α%dh%d -> %dh%dnα, trip[i].ini[0], trip[i].ini[1], trip[i].fim[0], trip[i].fim[1]));
 		qsort(trip, a, sizeof(data), cmp);
 		qsort(trip + a, b, sizeof(data), cmp);
 		DD(for(i = 0; i < a+b; i++) printf(α%dh%d -> %dh%dnα, trip[i].ini[0], trip[i].ini[1], trip[i].fim[0], trip[i].fim[1]));
 		resolve(trip, a, a + b);
 		printf(αCase #%d: %d %dnα, t++, k1, k2);
 	}
 
 
 	return 0;
 }"
25786,2008,32013,Justin8712,24480,1,codejam.c,gcj/2008/32013/Justin8712/24480/1/extracted/codejam.c,"#include αstdlib.hα
 #include αstdio.hα
 #include αiostream.hα
 #include αstring.hα
 
 using namespace std;
 
 int main()
 {
    int test_cases, engines, queries;
    test_cases = engines = queries = 0;
    int i, j, k, count_seen, count_switches;
    i = j = k = count_seen =  count_switches = 0;
    string engine_list[1100];
    string query;
    int* seen = (int*) malloc(1100 * sizeof(int));
    for( i = 0; i < 1100; i++) seen[i] = 0;
 
    cin >> test_cases;
    if(test_cases <= 0)
    { 
       //printf(α0α);
       exit(0);
   }
    string temp;
   for(i = 1; i <= test_cases; i++)
   {
        for(k = 0; k < 1090; k++)
        {   
                  seen[k] = 0; 
        }
        count_switches = count_seen = 0;
 
       cin >>  engines;
       //cout << engines << endl;
       cin.ignore();
       for(j = 0; j < engines; j++)
       {
          getline(cin, temp);
          //cout << αtemp is α << temp << endl;
          engine_list[j] = temp;
          //cout << αj isα << j << α . engline_list[j] is α << engine_list[j] << endl;	
      }
      cin >> queries;
      cin.ignore();
      for(j= 0; j< queries; j++)
      {
          getline(cin, query);
          for(k = 0; k < engines; k++)
           {
              if((query == engine_list[k]) && seen[k] == 0)
              {
                     seen[k] = 1;
                     count_seen++;
              }
          }
          if(count_seen == engines)
          {
 	   count_seen=1;
         
               for(k = 0; k < engines; k++)
               {   
                  seen[k] = 0; 
                  if((query == engine_list[k])) seen[k]=1;
               }
               count_switches++;
          }
       }
       cout << αCase #α << i  <<α: α << count_switches << endl;
     }
    return 0;
 }"
25878,2008,32013,abekdh,24480,1,a.c,gcj/2008/32013/abekdh/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_STR 101
 #define MAX_S 100
 #define MAX_Q 1000
 
 char engine[MAX_S][MAX_STR];
 int query[MAX_Q];
 int flagMap[MAX_S];
 
 int find(int s, char *query)
 {
 	int i;
 	for(i=0;i<s;i++)
 		if(strcmp(query, engine[i])==0)
 			return i;
 }
 
 void initMap(int s)
 {
 	memset(flagMap, 0, sizeof(int) * s);
 }
 
 int isFulled(int s)
 {
 	int i;
 	for(i=0;i<s;i++)
 		if( flagMap[i]==0 )
 			return 0;
 	return 1;
 }
 
 int main()
 {
 	int i;
 	int N, n, s, q;
 	int switchCnt;
 	char buffer[MAX_STR];
 	
 	scanf(α%dnα, &N);
 
 	for(n=1;n<=N;n++)
 	{
 	 	scanf(α%dnα, &s);
 		for(i=0;i<s;i++)
 		{
 			gets(engine[i]);
 		}
 		scanf(α%dnα, &q);
 		
 		initMap(s);
 		switchCnt = 0;
 		for(i=0;i<q;i++)
 		{
 			gets(buffer);
 			flagMap[find(s, buffer)] = 1;
 			if( isFulled(s) )
 			{
 				switchCnt++;
 				initMap(s);
 				flagMap[find(s, buffer)] = 1;
 			}
 		}
 		printf(αCase #%d: %dnα, n, switchCnt);
 	}
 
 
 	return 0;
 }"
25881,2008,32013,abekdh,24481,1,B.c,gcj/2008/32013/abekdh/24481/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_AB 100
 
 typedef struct _train
 {
 	int start;
 	int end;
 	int turnFlag;
 } train;
 
 train AtoB[MAX_AB];
 train BtoA[MAX_AB];
 
 int main()
 {
 	int i, j;
 	int N, n, T, NA, NB, hh, mm;
 	int CA, CB;
 	
 	scanf(α%dnα, &N);
 
 	for(n=1;n<=N;n++)
 	{
 
 		scanf(α%d %d %dα, &T, &NA, &NB);
 		for(i=0;i<NA;i++)
 		{
 			scanf(α%d:%dα, &hh, &mm);
 			AtoB[i].start = hh * 60 + mm;
 			scanf(α%d:%dα, &hh, &mm);
 			AtoB[i].end = hh * 60 + mm;
 			AtoB[i].turnFlag = 0;
 		}
 		for(i=0;i<NB;i++)
 		{
 			scanf(α%d:%dα, &hh, &mm);
 			BtoA[i].start = hh * 60 + mm;
 			scanf(α%d:%dα, &hh, &mm);
 			BtoA[i].end = hh * 60 + mm;
 			BtoA[i].turnFlag = 0;
 		}
 		
 		CA = NA;
 		CB = NB;
 
 		for(i=0;i<NA;i++)
 		{
 			int maxValue = 0;
 			int maxIndex = -1;
 			for(j=0;j<NB;j++)
 			{
 				if( BtoA[j].turnFlag==0 && (BtoA[j].end + T <= AtoB[i].start) )
 				{
 					if( maxValue < BtoA[j].end )
 					{
 						maxValue = BtoA[j].end;
 						maxIndex = j;
 					}
 				}
 			}
 			if( maxIndex!=-1 )
 			{
 				CA--;
 				BtoA[maxIndex].turnFlag = 1;
 			}
 		}
 
 		for(i=0;i<NB;i++)
 		{
 			int maxValue = 0;
 			int maxIndex = -1;
 			for(j=0;j<NA;j++)
 			{
 				if( AtoB[j].turnFlag==0 && (AtoB[j].end + T <= BtoA[i].start) )
 				{
 					if( maxValue < AtoB[j].end )
 					{
 						maxValue = AtoB[j].end;
 						maxIndex = j;
 					}
 				}
 			}
 			if( maxIndex!=-1 )
 			{
 				CB--;
 				AtoB[maxIndex].turnFlag = 1;
 			}
 		}
 		
 		printf(αCase #%d: %d %dnα, n, CA, CB);
 	}
 
 
 	return 0;
 }"
25961,2008,32013,nail2k,24480,1,save.c,gcj/2008/32013/nail2k/24480/1/extracted/save.c,"#include <stdio.h>
 
 char eng[101][110];
 char q[1001][110];
 
 int ne, nq;
 
 int get_way(int e, int start)
 {
 	int i;
 	
 	for (i=start; i < nq; i++) 
 		if (!strcmp(eng[e], q[i]))
 			break;
 
 	return i;
 }
 
 int main()
 {
 	int n, N;
 	int i;
 	char buf[256];
 
 	fgets(buf, sizeof(buf), stdin);
 	n = strtol(buf, NULL, 10);
 	N = n;
 
 	while (n--) {
 		int max, tmp, sw, maxi;
 		char buf[120];
 
 		memset(eng, 0, 110*101);
 		memset(q, 0, 1001*110);
 		
 		/* read engines' names */
 		fgets(buf, sizeof(buf), stdin);
 		ne = strtol(buf, NULL, 10);
 
 		for (i=0; i < ne; i++) 
 			fgets(eng[i], 110, stdin);
 		
 		/* read queries */
 		fgets(buf, sizeof(buf), stdin);
 		nq = strtol(buf, NULL, 10);
 
 		for (i=0; i < nq; i++) 
 			fgets(q[i], 110, stdin);
 		
 		sw=0; maxi=0;
 		while(1) {
 			max=0;
 			for (i=0; i < ne; i++) {
 				tmp = get_way(i, maxi);
 				if (tmp > max) 
 					max = tmp;
 			}
 			if (max == nq) 
 				break;
 			sw++;
 			maxi = max;
 		}
 		
 		printf(αCase #%d: %dnα, N-n, sw);
 	}
 
 	return 0;
 }"
26014,2008,32013,wainguo,24480,1,pro1.C,gcj/2008/32013/wainguo/24480/1/extracted/pro1.C,"#include <stdio.h>
 #include <string.h>
 
 int find( char Se[][101],int S, char *word )
 {
 	int i;
 	for( i=0; i<S; i++ ){
 		if( strcmp(Se[i], word ) == 0 )
 			return i;
 	}
 }
 void resetMark( int mark[], int S )
 {
 	int i;
 	for( i=0; i<S;i++ ){
 		mark[i] = 0;
 	}
 }
 
 int main()
 {
 		int N, S, Q;
 		scanf( α%dα, &N );
 		int i;
 		
 		for( i = 0; i<N; i++ ){
 				scanf( α%dnα, &S );
 				//printf( αS (%d) nα,S );
 				char Se[S][101];
 				int markSe[S];
 				char Query[101];
 				int tc, counter=0;
 				int where;
 				int j;
 				for( j=0; j<S; j++ ){
 						gets(Se[j]);
 						//printf( αSe(%d):%s nα,j, Se[j] );
 				}
 				tc = 0;
 				resetMark( markSe, S );
 				
 				scanf( α%dnα, &Q );
 				//printf( αQ (%d) nα,Q );
 				for( j=0; j<Q; j++ ){
 						//scanf( α%sα, Query );
 						gets( Query );
 						where = find( Se, S, Query );
 						//printf( αj=%d, where (%d) is Query(%s)nα, j, where, Query );
 						if( markSe[where] == 0 ){
 								++tc;
 								if( tc == S ){
 										resetMark( markSe, S );
 										++counter;
 										tc = 1;
 								}
 								markSe[where] = 1;
 						}		
 				}
 				printf( αCase #%d: %dnα, i+1, counter );
 			}
 			return 0;
 }"
26029,2008,32013,SpideySensor,24480,1,CodeJamQ1.c,gcj/2008/32013/SpideySensor/24480/1/extracted/CodeJamQ1.c,"#include <stdio.h>
 #include <string.h>
 #include <malloc.h>
 
 char** engines;
 int N;
 int n, m;
 int** storedMinSwitches;
 
 int computeMinSwitches( char** queries, int currentEngine,  int currentIndex)
 {
 	int currMin;
 	int i;
 	if ( currentIndex == m)
 		return 0;
 		
 	if (storedMinSwitches[currentEngine][currentIndex] != -1) 
 	{
 		return storedMinSwitches[currentEngine][currentIndex];
 	}
 	if (strcmp(engines[currentEngine], queries[currentIndex]) == 0)
 	{ 
 		int minSwitches = 9999;
 		for(i = 0; i < n; i++)
 		{
 			if (strcmp(engines[i], queries[currentIndex]) != 0)
 			{
 				currMin = computeMinSwitches(queries, i, currentIndex + 1 );
 				if ( currMin < minSwitches)
 				{
 					minSwitches = currMin;
 				}
 			}
 		}
 		storedMinSwitches[currentEngine][currentIndex] = 1 + minSwitches;
 		return storedMinSwitches[currentEngine][currentIndex];
 	}
 	
 	if (strcmp(engines[currentEngine], queries[currentIndex]) != 0)
 	{
 		int minSwitches = computeMinSwitches(queries, currentEngine, currentIndex + 1 );
 		storedMinSwitches[currentEngine][currentIndex] = minSwitches;
 		return storedMinSwitches[currentEngine][currentIndex];
 	}
 }
 
 int main() 
 {
 	int i, j, x;
 	char temp;
 	scanf(α%dα, &N);
 	scanf(α%cα, &temp);
 	
 	for (x = 1; x <= N; x++)
 	{
 		char** queries;
 		int minnoOfSwitches = 9999;
 		int noOfSwitches = 0;
 		scanf(α%dα, &n); //no of engines
 		scanf(α%cα, &temp);
 		
 		engines = (char **) malloc(n * sizeof(char*));
 		for(i = 0; i < n; i++) 
 		{
 			engines[i] = (char *) malloc( 100 * sizeof(char));
 			scanf(α%[^n]α, engines[i]);
 			scanf(α%cα, &temp);
 			//printf(αYou entered: %snα, engines[i]);
 		}
 		
 		scanf(α%dα , &m); //no of queries
 		scanf(α%cα, &temp);
 		
 		queries = (char **) malloc(m * sizeof(char*));
 		for(j = 0; j < m; j++) 
 		{
 			queries[j] = (char *) malloc( 100 * sizeof(char));
 			scanf(α%[^n]α, queries[j]);
 			scanf(α%cα, &temp);
 			//printf(αYou entered: %snα, queries[j]);
 		}
 		
 		storedMinSwitches = (int**) malloc(n * sizeof(int));
 		for(i = 0; i < n; i++) 
 		{
 			storedMinSwitches[i] = (int *) malloc( m * sizeof(int));
 		}
 		for(i = 0; i < n; i++)
 		{
 			for(j = 0; j < m; j++)
 			{
 				storedMinSwitches[i][j] = -1;
 			}
 		}
 		
 		for( i =0 ; i < n; i++)
 		{ 
 			noOfSwitches = computeMinSwitches(queries, i, 0);
 			if (noOfSwitches < minnoOfSwitches) 
 			{
 				minnoOfSwitches = noOfSwitches;
 			}
 		}
 		
 		if (minnoOfSwitches == 9999)
 		{
 			minnoOfSwitches = 0;
 		}
 		
 		printf(αCase #%d: %dnα, x, minnoOfSwitches);
 		free(queries);
 		free(engines);
 		free(storedMinSwitches);
 	}
 	return 0;
 }"
26052,2008,32013,nygar120,24480,1,A.c,gcj/2008/32013/nygar120/24480/1/extracted/A.c,"#include <stdio.h>
 
 int S, Q;
 
 struct {
     char nom[101];
     int t;
 } Sd[100];
 
 int nm, cur;
 
 int str_cmp(char * a, char * b)
 {
     int i = 0;
 
 
     
     while ((a[i] == b[i]) && (a[i] != '0'))
         i++;
 
     //printf(αf: %sn %sn %dnα, a, b, (a[i] == b[i]));
     
     return (a[i] == b[i]);
 }
 
 void efface()
 {
     int i;
     for (i=0; i<S; i++)
     {
         Sd[i].t = 0;
     }
 }
 
 int mark(char * nom)
 {
     int i;
     for (i=0; i<S; i++)
     {
         if (str_cmp(nom, Sd[i].nom) == 1)
             {
                 if (Sd[i].t == 0)
                     {Sd[i].t = 1; nm++; if (nm == S) {nm=1; efface(); Sd[i].t = 1; return 1;}}
                 //printf(αssssssssssssssssssss %dnα, nm);
                 return 0;
             }
     }
 }
 
 int test()
 {
     int i, C;
     char nom[101];
 
     //printf(αt : %dnα, Q);
     C = 0;
     
     for (i = 0; i < Q; i++)
     {
         //scanf(α%sα, nom);
         //str_cp(nom);
         gets(nom);
         C+=mark(nom);
 
     }
     
     return C;
 }
 
 int main()
 {
     int i, j, N;
 
     scanf(α%dα, &N);
     for (i=1; i<=N; i++)
     {
         scanf(α%dnα, &S);
         for (j=0; j<S; j++)
         {
             gets(Sd[j].nom);
             Sd[j].t = 0;
         }
             
         scanf(α%dnα, &Q);
         printf(αCase #%d: %dnα, i, test());
         nm = 0;
     }
 
     scanf(α%dα,&i);
 
 return 0;
 }"
26055,2008,32013,SUREN,24480,1,codes.C,gcj/2008/32013/SUREN/24480/1/extracted/codes.C,"#include<stdio.h>
 
 FILE *ifp,*ofp;
 
 struct SearchEng
 {
 char Name[102];
 int checked;
 };
 
 struct SearchEng se[100];
 int s_count=0;
 
 int mark(char * str)
 {
 int i;
 
 for(i=0;i<s_count;i++)
 {
 	if(strcmp(se[i].Name,str)==0)
 	{
 	if(se[i].checked==1)
 	return -1;
 	else
 	se[i].checked=1;
 	return i;
 	}
 }
 return -1;
 }
 
 void clear_set_se(int index)
 {
 int i;
 for(i=0;i<s_count;i++)
 {
 	if(index==i)
 	se[i].checked=1;
 	else
 	se[i].checked=0;
 }
 }
 
 void main()
 {
 int N,i,crt_testcase,q_count;
 char str[102];
 int secount=0,se_index,max_se,cnt_checked,no_of_switch=0;
 
 clrscr();
 
 if ((ifp = fopen(αinput.txtα, αrtα))
     == NULL)
 {
    fprintf(stderr, αCannot open input file.nα);
    return;
 }
 
 if ((ofp = fopen(αoutput.txtα, αwtα))
     == NULL)
 {
    fprintf(stderr, αCannot open output file.nα);
    return;
 }
 
 fscanf(ifp,α%dnα,&N);
 
 crt_testcase=0;
 while(crt_testcase++<N)
 {
 	fprintf(ofp,αCase #%d: α,crt_testcase);
 
 	fscanf(ifp,α%dnα,&s_count);
 
 	for(i=0;i<s_count;i++)
 	{
 		se[secount].checked=0;
 		fgets(se[secount].Name,101,ifp);
 		secount++;
 	}
 
 	fscanf(ifp,α%dnα,&q_count);
 	for(i=0;i<q_count;i++)
 	{
 		fgets(str,101,ifp);
 
 		if((se_index=mark(str))>=0)
 		{
 			max_se = se_index;
 			cnt_checked++;
 		}
 		else
 		{
 			continue;
 		}
 
 		if(cnt_checked == s_count)
 		{
 			no_of_switch++;
 			clear_set_se(max_se);
 			cnt_checked=1;
 		}
 	}
 
 	fprintf(ofp,α%dnα,no_of_switch);
 
 	secount=0;
 	no_of_switch=0;
 	cnt_checked=0;
 }
 }"
26057,2008,32013,SUREN,24481,1,TRAIN.C,gcj/2008/32013/SUREN/24481/1/extracted/TRAIN.C,"//Finding the no. of trains in two stations A and B provided the time schedule
 
 //The program takes the input from αinput.inα file.
 
 #include<stdio.h>
 #include<conio.h>
 #include<malloc.h>
 #include<dos.h>
 
 int i,j,k,l;
 
 int L[100],R[100];
 void Merge(int A[],int p,int q,int r)
 {
 int n1=q-p+1;
 int n2=r-q;
 int i,j,k;
 
 for(i=0;i<n1;i++)
    L[i]=A[p+i];
 
 for(j=0;j<n2;j++)
    R[j]=A[q+j+1];
 
 i=j=0;
 
 for(k=p;k<=r;k++)
    {
    if(L[i] <= R[j])
      {
      A[k]=L[i];
      i++;
      }
    else
      {
      A[k]=R[j];
      j++;
      }
 
      if(i==n1)
      {
      k++;
      for(;j<n2;j++)
 	A[k++]=R[j];
      break;
      }
      if(j==n2)
      {
      k++;
      for(;i<n1;i++)
 	A[k++]=L[i];
      break;
      }
    }
 
 
 }
 
 void Merge_Sort(int A[],int p, int r)
 {
 if(p<r)
   {
   int q=(p+r)/2;
   Merge_Sort(A,p,q);
   Merge_Sort(A,q+1,r);
   Merge(A,p,q,r);
   }
 }
 
 
 
 void main()
 {
 FILE *ifp,*ofp;
 int N,T,NA,NB;
 int hd,md,ha,ma;
 int AA[100],AD[100],BA[100],BD[100];
 
 int countA=0,countB=0;
 
 clrscr();
 
 ifp=fopen(αinput.txtα,αrα);
 if(ifp==NULL)
 	{
 	fprintf(stderr,αError in opening the input fileα);
 	return;
 	}
 
 ofp=fopen(αoutput.txtα,αwα);
 if(ofp==NULL)
 	{
 	fprintf(stderr,αError in opening the output fileα);
 	return;
 	}
 
 fscanf(ifp,α%dnα,&N);
 
 for(i=1;i<=N;i++)
    {
    countA=0;
    countB=0;
 
    fscanf(ifp,α%dnα,&T);
    fscanf(ifp,α%d %dnα,&NA,&NB);
 
    if(NA==0)
      {
      fprintf(ofp,αcase #%d: %d %dα,i,countA,NB);
      continue;
      }
 
    if(NB==0)
      {
      fprintf(ofp,αcase #%d: %d %dα,i,NA,countB);
      continue;
      }
 
    for(j=1;j<=NA;j++)
       {
       fscanf(ifp,α%d:%d %d:%dnα,&hd,&md,&ha,&ma);
       AD[j]=hd*60+md;
       BA[j]=ha*60+ma+T;
       }
 
    for(j=1;j<=NB;j++)
       {
       fscanf(ifp,α%d:%d %d:%dα,&hd,&md,&ha,&ma);
       BD[j]=hd*60+md;
       AA[j]=ha*60+ma+T;
       }
 
    Merge_Sort(AD,1,NA);
    Merge_Sort(BA,1,NA);
    Merge_Sort(BD,1,NB);
    Merge_Sort(AA,1,NB);
 
    j=k=1;
    while(j<=NA && k<=NB)
 	{
 	if(AD[j]<AA[k])
 	  countA++;
 	else
 	  k++;
 	j++;
 	}
    if(k>NB)
      countA+=NA-j+1;
 
 
    j=k=1;
    while(j<=NB && k<=NA)
 	{
 	if(BD[j]<BA[k])
 	  countB++;
 	else
 	  k++;
 	j++;
 	}
    if(k>NA)
      countB+=NB-j+1;
 
    fprintf(ofp,αcase #%d: %d %dnα,i,countA,countB);
 
    }
 fclose(ifp);
 fclose(ofp);
 printf(αn Finished..α);
 getch();
 }"
26130,2008,32013,Icefire,24480,1,q1.c,gcj/2008/32013/Icefire/24480/1/extracted/q1.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int main()
 {
     char se[100][128];
     char query[128];
     int freq[100];
     int num;
     int w, x, y, z;
     int result;
     int skip;
     
     scanf(α%iα, &num);
     for (x = 1; x <= num; x++)
     {
         int nse;
         scanf(α%iα, &nse);
         gets(query);
         for (y = 0; y < nse; y++)
         {
             gets(se[y]);
             freq[y] = 0;
         }
         scanf(α%iα, &y);
         gets(query);
         for (skip = -1, result = 0; y > 0; y--)
         {
             gets(query);
 //            printf(αskipped [%d], result [%d], query[%s]nα,  skip, result, query);
 //            for (z = 0; z < nse; z++) printf(αfreq for %s : %dnα, se[z], freq[z]);
             for (z = 0; z < nse; z++)
             {
                 if (z == skip) continue;
                 if (strcmp(query, se[z]) == 0) freq[z]++;
                 if (freq[z] == 1)
                 {
                     int start = 0;
                     for (w = 0; w < nse; w++)
                     {
                         if (w == z || w == skip) continue;
                         if (freq[w] == 0)
                         {
                             start = 1;
                             break;
                         }
                     }
                     if (start == 0)
                     {
                         result++;
                         skip = z;
                         for (w = 0; w < nse; w++) freq[w] = 0;
                         break;
                     }
                 }
             }
         }
         printf(αCase #%d: %dnα, x, result);
 //        printf(αnnnnnα);
     }
     
     return 0;    
 }"
26132,2008,32013,Icefire,24481,1,q2.c,gcj/2008/32013/Icefire/24481/1/extracted/q2.c,"#define A 0
 #define B 1
 #define ARRIVE 0
 #define DEPART 1
 
 
 int nTrain(int numArrive, int* arrive, int numDepart, int* depart);
 
 int compInt(void* l, void* r)
 {
     return *((int*)l) - *((int*)r);
 }
 
 int main()
 {
     int delay;
     int train[2];
     int tTime[2][2][100];
     int hr, min;
     int w, x, y, z;
     int num;
     int results[2];
     
     scanf(α%iα, &num);
     for (x = 1; x <= num; x++)
     {
         scanf(α%i%i%iα, &delay, &(train[A]), &(train[B]));
 
         for (y = 0; y < 2; y++)
         {
             for (z = 0; z < train[y]; z++)
             {
                 scanf(α%d:%dα, &hr, &min);
                 tTime[y][DEPART][z] = (hr * 60) + min;
                 scanf(α%d:%dα, &hr, &min);
                 tTime[y][ARRIVE][z] = (hr * 60) + min + delay;
             }
         }
         
         for (y = 0; y < 2; y++) for(z = 0; z < 2; z++) qsort(tTime[y][z], train[y], sizeof(int), compInt);
         results[A] = nTrain(train[B], tTime[B][ARRIVE], train[A], tTime[A][DEPART]);
         results[B] = nTrain(train[A], tTime[A][ARRIVE], train[B], tTime[B][DEPART]);
 
         printf(αCase #%i: %i %inα, x, results[A], results[B]);
     }
     return 0;
 }
 
 
 int nTrain(int numArrive, int* arrive, int numDepart, int* depart)
 {
     int x, y;
     int index;
     int result = 0;
     for (x = 0; x < numArrive; x++)
     {
         index = -1;
         if (arrive[x] < 0) continue;
         for (y = numDepart - 1; y >= 0; y--)
         {
             if (depart[y] < 0) continue;
             if (arrive[x] <= depart[y]) index = y;
             else break;      
         }
         if (index >= 0)
         {
             arrive[x] = -1;
             depart[index] = -1;
         }
     }
     
     for (x = 0; x < numDepart; x++) if (depart[x] >= 0) result++;
     return result;
 }"
26155,2008,32013,wakka,24480,1,2.c,gcj/2008/32013/wakka/24480/1/extracted/2.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #if 0
 #define DEBUGL(fmt, ...) printf(fmt αnα, ##__VA_ARGS__)
 #else
 #define DEBUGL(...)
 #endif
 
 #define SEARCH_ENGINE_NAME_LEN 100
 #define SEARCH_ENGINE_NUM 100
 #define BUFFER_SZ (SEARCH_ENGINE_NAME_LEN+1)
 
 char *getline(char *buffer)
 {
 	static char private_buffer[BUFFER_SZ];
 	char *start = buffer ? buffer : private_buffer;
 	char *p = start;
 	int ch;
 
 	while (1)
 	{
 		switch ((ch = getchar()))
 		{
 			case 'r':
 			case 'n':
 				*p = 0;
 				return start;
 			case EOF:
 				return NULL;
 		}
 		*p++ = ch;
 	}
 }
 
 int main(void)
 {
 	static char search_engines[SEARCH_ENGINE_NUM][SEARCH_ENGINE_NAME_LEN+1];
 	static char query[SEARCH_ENGINE_NAME_LEN+1];
 	static int flag[SEARCH_ENGINE_NUM+1];
 
 	int N, S, Q, X, Y;
 	int i, j, k, s;
 
 	N = atoi(getline(NULL));
 	DEBUGL(α%dα, N);
 	for (i = 0; i < N; i++)
 	{
 		X = i + 1;
 		Y = 0;
 
 		S = atoi(getline(NULL));
 		DEBUGL(α%dα, S);
 		for (j = 0; j < S; j++)
 		{
 			getline(search_engines[j]);
 			DEBUGL(α%sα, search_engines[j]);
 		}
 
 		memset(flag, 0, sizeof(flag));
 		s = S;
 
 		Q = atoi(getline(NULL));
 		DEBUGL(α%dα, Q);
 		for (j = 0; j < Q; j++)
 		{
 			getline(query);
 			for (k = 0; k < S; k++)
 			{
 				if (strcmp(query, search_engines[k]) == 0)
 				{
 					if (!flag[k])
 					{
 						if (--s == 0)
 						{
 							DEBUGL(α!α);
 							memset(flag, 0, sizeof(flag));
 							s = S - 1;
 							Y++;
 						}
 						flag[k] = 1;
 					}
 					break;
 				}
 			}
 			DEBUGL(α%sα, query);
 		}
 		printf(αCase #%d: %dnα, X, Y);
 	}
 
 	return 0;
 }"
26188,2008,32013,LogAN,24480,1,p1-aman.c,gcj/2008/32013/LogAN/24480/1/extracted/p1-aman.c,"#include <stdio.h>
 
 int SearchEngineCount;
 char SearchEngine[10000][100];
 int SearchStringCount;
 char SearchString[10000][100];
 
 int farthest(int index, int * searchEngineIndex)
 {
 	int positionOfEngine = 0,i,j;
 	for(i = 0; i < SearchEngineCount; i++)
 	{
 		for(j=index; j < SearchStringCount; j++)
 		{
 			if(strcmp(SearchEngine[i],SearchString[j]) == 0)
 			{
 				if(positionOfEngine < j)
 				{
 					*searchEngineIndex = i;
 					positionOfEngine = j;
 				}
 				break;
 			}
 		}
 		if ( j == SearchStringCount)
 		{
 			*searchEngineIndex = i;
 			positionOfEngine = -1;
 			break;
 		}
 	}
 	return positionOfEngine;
 }
 int main()
 {
 	int searchEngineIndex=0;
 	int whichIndexToSwitch=0, lastIterationSwitchIndex=0;
 	int switchCount[1000];
 	int i,numberOfInput,k;
 	scanf(α%dα,&numberOfInput);
 
 	for(k=1;k<=numberOfInput;k++)
 	{
 		searchEngineIndex=0;
 		whichIndexToSwitch=0; 
 		lastIterationSwitchIndex=0;
 		switchCount[k]=-1;
 		
 		scanf(α%dnα,&SearchEngineCount);
 		//printf(αSearch Engine count = %dnα,SearchEngineCount);
 
 		for(i=0;i<SearchEngineCount;i++)
 		{
 			gets(SearchEngine[i]);
 			//printf(αSearch Engine = %snα,SearchEngine[i]);
 		}
 		scanf(α%dnα,&SearchStringCount);
 
 		for(i=0;i<SearchStringCount;i++)
 			gets(SearchString[i]);
 
 		do
 		{
 			lastIterationSwitchIndex = whichIndexToSwitch;
 			whichIndexToSwitch = farthest(lastIterationSwitchIndex,&searchEngineIndex);
 			switchCount[k]++;
 		}while(whichIndexToSwitch != -1);
 
 	}
 	for(k=1;k<=numberOfInput;k++)
 		printf(αCase #%d: %dnα,k,switchCount[k]);
 
 }"
26192,2008,32013,HubertJ,24480,1,A_universe.c,gcj/2008/32013/HubertJ/24480/1/extracted/A_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define LINESIZE 101
 
 typedef struct node {
 	char *search_term;
 	struct node *next;
 } Node;
 
 void free_list(Node *head)
 {
 	if(head)
 	{
 		if(head->search_term)
 			free(head->search_term);
 		free_list(head->next);
 		free(head);
 	}
 }
 
 int main(int argc, char **argv)
 {
 	int i, j, cases;
 	
 	if(argc != 2)
 	{
 		printf(αUsage: %s input_filenα, argv[0]);
 		return -1;
 	}
 		
 	FILE *file;
 	
 	if(argv[1] && (file = fopen(argv[1], αrα)) );
 	
 	else
 	{
 		printf(αerror opening filenα);
 		return -1;
 	}
 	
 	fscanf(file, α%dα, &cases);
 
 	for(i = 1; i <= cases; i++)
 	{
 		int engines, searches;
 		fscanf(file, α%dnα, &engines);
 
 		char **engine_list;
 		engine_list = malloc(engines * sizeof(char *));
 
 		if(!engine_list)
 		{
 			printf(αfailed engine list malloc on case %dα, i);
 			return;
 		}
 
 		char *line;
 		for(j = 0; j < engines; j++)
 		{
 			line = malloc(LINESIZE);
 			if(!line)
 			{
 				printf(αfailed line malloc on case %dα, i);
 				return;
 			}
 			fgets(line, LINESIZE, file);
 			engine_list[j] = line;
 			//printf(α%sα, line);
 		}
 
 		fscanf(file, α%dnα, &searches);
 		
 		if(searches == 0)
 			printf(αCase #%d: 0nα, i);
 		
 		else
 		{
 			Node *search_list = malloc(sizeof(Node));
 			Node *current = search_list;
 			
 			for(j=0; j<searches; j++)
 			{
 				line = malloc(LINESIZE);
 				fgets(line, LINESIZE, file);
 				current->search_term = line;
 				if(j!=searches-1)
 				{
 					current->next = malloc(sizeof(Node));
 					current = current->next;
 				}
 				else
 					current->next = NULL;
 				//printf(α%sα,line);
 			}
 			//printf(αsearches donenα);
 			
 			int switches = worker(engines, engine_list, search_list) - 1;
 			printf(αCase #%d: %dnα, i, switches);
 			
 			free_list(search_list);
 		}
 		
 		for(j = 0; j < engines; j++)
 		{
 			//printf(α%sα, engine_list[j]);
 			free(engine_list[j]);
 		}
 		free(engine_list);
 	}
 }
 
 int worker(int engines, char **engine_list, Node *search_list)
 {
 	int max = 0;
 	Node *next_search_list;
 	int i;
 	for( i = 0; i  < engines; i++ )
 	{
 		int temp = 0;
 		Node *current = search_list;
 		while(current)
 		{
 			if(strcmp(engine_list[i], current->search_term) == 0)
 			{
 				if(temp > max)
 				{
 					max = temp;
 					next_search_list = current;
 				}
 				break;
 			}
 			current = current->next;
 			temp++;
 		}
 		if(!current)
 			return 1;
 	}
 //	printf(αswitch at %sα, next_search_list->search_term);
 	return 1 + worker(engines, engine_list, next_search_list);
 }"
26194,2008,32013,HubertJ,24481,1,B_train.c,gcj/2008/32013/HubertJ/24481/1/extracted/B_train.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct node
 {
 	int depart;
 	int arrive;
 	struct node *prev;
 	struct node *next;
 }Node;
 
 Node *remove_node(Node *head, Node *n)
 {
 	if(!n)
 		return NULL;
 		
 	if(n->prev)
 	{
 		(n->prev)->next = n->next;
 		(n->next)->prev = n->prev;
 		free(n);
 		return head;
 	}
 	
 	if(n == head)
 	{
 		head = n->next;
 		free(n);
 		return head;
 	}
 	
 	else
 	{
 		printf(αremove gone horribly wrongα);
 		exit(-1);
 	}
 }
 
 Node *insert_by_depart(Node *head, Node *new)
 {
 	if(!head)
 		return new;
 
 	if(head->depart >= new->depart)
 	{
 		new->next = head;
 		new->prev = head->prev;
 		if(head->prev)
 			(head->prev)->next = new;
 		head->prev = new;
 		return new;
 	}
 	
 	else if(!head->next)
 	{
 		head->next = new;
 		new->prev = head;
 		return head;
 	}
 	
 	else
 	{
 		insert_by_depart(head->next, new);
 		return head;
 	}
 }
 
 Node *insert_by_arrive(Node *head, Node *new)
 {
 	if(!head)
 		return new;
 
 	if(head->arrive >= new->arrive)
 	{
 		new->next = head;
 		new->prev = head->prev;
 		if(head->prev)
 			(head->prev)->next = new;
 		head->prev = new;
 		return new;
 	}
 	
 	else if(!head->next)
 	{
 		head->next = new;
 		new->prev = head;
 		return head;
 	}
 	
 	else
 	{
 		insert_by_arrive(head->next, new);
 		return head;
 	}
 }
 
 char *print_node(Node *n)
 {
 	if(n)
 	{
 		char *s = malloc(80);
 		sprintf(s, αDepart: %d:%d tArrive: %d:%dα, (n->depart)/60, (n->depart)%60, (n->arrive)/60, (n->arrive)%60);
 		return s;
 	}
 		
 	else
 		return αNULLα;
 }
 
 void print_list(Node *head)
 {
 	while(head)
 	{
 		printf(αPrev: %snα, print_node(head->prev));
 		printf(αCurrent: %snα, print_node(head));
 		printf(αNext: %snnα, print_node(head->next));
 		head = head->next;
 	}
 }
 
 void free_list(Node *head)
 {
 	if(head)
 		free_list(head->next);
 	free(head);
 }
 
 int main(int argc, char **argv)
 {
 	int i, j, cases;
 	
 	if(argc != 2)
 	{
 		printf(αUsage: %s input_filenα, argv[0]);
 		return -1;
 	}
 		
 	FILE *file;
 	
 	if(argv[1] && (file = fopen(argv[1], αrα)) );
 	
 	else
 	{
 		printf(αerror opening filenα);
 		return -1;
 	}
 	
 	fscanf(file, α%dα, &cases);
 
 	for(i = 1; i <= cases; i++)
 	{
 		int t_time;
 		int atob, btoa;
 		fscanf(file, α%dα, &t_time);
 		fscanf(file, α%d %dα, &atob, &btoa);
 		
 		Node *AB_by_arrive, *AB_by_depart, *BA_by_arrive, *BA_by_depart;
 		AB_by_arrive = AB_by_depart = BA_by_arrive = BA_by_depart = NULL;
 		
 		for(j = 0; j < atob; j++)
 		{
 			int d_hr, d_min, a_hr, a_min;
 			int depart, arrive;
 			fscanf(file, α%d:%d %d:%dnα, &d_hr, &d_min, &a_hr, &a_min);
 			depart = d_hr * 60 + d_min;
 			arrive = a_hr * 60 + a_min;
 //			printf(αdepart: %d:%dtarrive:%d:%dnα, d_hr, d_min, a_hr, a_min);
 //			printf(αdepart: %d tarrive: %dnα, depart, arrive);
 			
 			Node *new1 = malloc(sizeof(Node));
 			Node *new2 = malloc(sizeof(Node));
 			new1->depart = new2->depart = depart;
 			new1->arrive = new2->arrive = arrive;
 			new1->prev = new1->next = new2->prev = new2->next = NULL;
 			AB_by_arrive = insert_by_arrive(AB_by_arrive, new1);
 			AB_by_depart = insert_by_depart(AB_by_depart, new2);
 		}
 		for(j = 0; j < btoa; j++)
 		{
 			int d_hr, d_min, a_hr, a_min;
 			int depart, arrive;
 			fscanf(file, α%d:%d %d:%dnα, &d_hr, &d_min, &a_hr, &a_min);
 //			printf(αdepart: %d:%dtarrive:%d:%dnα, d_hr, d_min, a_hr, a_min);
 			depart = d_hr * 60 + d_min;
 			arrive = a_hr * 60 + a_min;
 			
 			Node *new1 = malloc(sizeof(Node));
 			Node *new2 = malloc(sizeof(Node));
 			new1->depart = new2->depart = depart;
 			new1->arrive = new2->arrive = arrive;
 			new1->prev = new1->next = new2->prev = new2->next = NULL;
 			BA_by_arrive = insert_by_arrive(BA_by_arrive, new1);
 			BA_by_depart = insert_by_depart(BA_by_depart, new2);
 		}
 		/*
 		printf(αttA to B by arrivenα);
 		print_list(AB_by_arrive);
 		printf(αttA to B by departnα);
 		print_list(AB_by_depart);
 		printf(αttB to A by arrivenα);
 		print_list(BA_by_arrive);
 		printf(αttB to A by departnα);
 		print_list(BA_by_depart);
 		*/
 		int connect_ba, connect_ab;
 		connect_ba = connect_ab = 0;
 		
 		Node *ptrA, *ptrB;
 		ptrA = AB_by_arrive;
 		ptrB = BA_by_depart;
 		
 		while(ptrA && ptrB)
 		{
 			if(ptrA->arrive+t_time <= ptrB->depart)
 			{
 				connect_ba++;
 				ptrA=ptrA->next;
 				ptrB=ptrB->next;
 			}
 			else
 				ptrB=ptrB->next;
 		}
 		
 		ptrA = BA_by_arrive;
 		ptrB = AB_by_depart;
 		
 		while(ptrA && ptrB)
 		{
 			if(ptrA->arrive+t_time <= ptrB->depart)
 			{
 				connect_ab++;
 				ptrA=ptrA->next;
 				ptrB=ptrB->next;
 			}
 			else
 				ptrB=ptrB->next;
 		}
 		
 		printf(αCase #%d: %d %dnα, i, atob-connect_ab, btoa-connect_ba);
 	}
 }"
26210,2008,32013,cugbcat,24480,1,a_saving_the_universe.c,gcj/2008/32013/cugbcat/24480/1/extracted/a_saving_the_universe.c,"#include <stdio.h>
 #include <string.h>
 
 char engine[100][101];
 char query[1000][101];
 int main(int argc,char **argv)
 {
 	int n, i, j, k;
 	int s, q, r;
 	char buffer[500];
 	fgets(buffer, sizeof buffer, stdin);
 	sscanf(buffer, α%dα, &n);
 	for (i = 0; i < n; i++) {
 		fgets(buffer, sizeof buffer, stdin);
 		sscanf(buffer, α%dα, &s);
 		for (j = 0; j < s; j++) {
 			fgets(engine[j], sizeof(engine[j]), stdin);
 			if (engine[j][strlen(engine[j]) - 1] == 'n')
 				engine[j][strlen(engine[j]) - 1] = '0';
 		}
 		fgets(buffer, sizeof buffer, stdin);
 		sscanf(buffer, α%dα, &q);
 		for (j = 0; j < q; j++) {
 			fgets(query[j], sizeof(query[j]), stdin);
 			if (query[j][strlen(query[j]) - 1] == 'n')
 				query[j][strlen(query[j]) - 1] = '0';
 		}
 		r = 0;
 		int x = 1, last = 0;
 		for (j = 1; j < q; j++) {
 			for (k = last; k < j; k++) {
 				if (!strcmp(query[k], query[j]))
 					break;
 			}
 			if (k == j) {
 				x++;
 				if (x == s) {
 					r++;
 					last = k;
 					//last += x - 1;
 					x = 1;
 				}
 			}
 		}
 		printf(αCase  #%d:  %dnα, i + 1, r);
 	}
 	return 0;
 }"
26212,2008,32013,cugbcat,24481,1,b_train_timetable.c,gcj/2008/32013/cugbcat/24481/1/extracted/b_train_timetable.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct timetable_t
 {
 	int start;
 	int end;
 	int flag;	//1:execute; 0:not execute
 }TIMETABLE;
 TIMETABLE timetable[200];
 TIMETABLE *NA, *NB;
 void travel(TIMETABLE *t1, int j, int n1, TIMETABLE *t2, int k, int n2);
 int comp(const void *a, const void *b)
 {
 	int t;
 	t = ((TIMETABLE *)a)->start - ((TIMETABLE *)b)->start;
 	if (t == 0)
 		t = ((TIMETABLE *)a)->end - ((TIMETABLE *)b)->end;
 	return t;
 }
 int main(int argc, char **argv)
 {
 	int n, t, i, na, nb, j, k;
 	int t1, t2, t3, t4;
 	char buffer[100];
 	int a, b;
 
 	fgets(buffer, sizeof buffer, stdin);
 	sscanf(buffer, α%dα, &n);
 	NA = timetable;
 	for (i = 0; i < n; i++) {
 		fgets(buffer, sizeof buffer, stdin);
 		sscanf(buffer, α%dα, &t);
 		fgets(buffer, sizeof buffer, stdin);
 		sscanf(buffer, α%d %dα, &na, &nb);
 		a = b = 0;
 		NB = NA + na;
 		for (j = 0; j < na + nb; j++) {
 			fgets(buffer, sizeof buffer, stdin);
 			sscanf(buffer, α%d:%d %d:%dα, &t1, &t2, &t3, &t4);
 			timetable[j].start = t1 * 60 + t2;
 			timetable[j].end = t3 * 60 + t4 + t;
 			timetable[j].flag = 0;
 		}
 		qsort(NA, na, sizeof(TIMETABLE), comp);
 		qsort(NB, nb, sizeof(TIMETABLE), comp);
 		j = k = 0;
 		int count = 0;
 		int num;
 		while (1) {
 			if (j >= na) {
 				num = 0;
 				for (count = k; count < nb; count++) {
 					if (!NB[count].flag)
 						num++;
 				}
 				b += num;
 				break;
 			}
 			if (k >= nb) {
 				num = 0;
 				for (count = j; count < na; count++) {
 					if (!NA[count].flag)
 						num++;
 				}
 				a += num;
 				break;
 			}
 			if (!NA[j].flag && NA[j].start < NB[k].start) {
 				a++;
 				NA[j].flag = 1;
 				travel(NA, j, na, NB, k, nb);
 				j++;
 			}
 			else if (!NB[k].flag && NA[j].start > NB[k].start) {
 				b++;
 				NB[k].flag = 1;
 				travel(NB, k, nb, NA, j, na);
 				k++;
 			}
 			else if (!NA[j].flag && !NB[k].flag && NA[j].start == NB[k].start) {
 				a++;
 				b++;
 				NA[j].flag = 1;
 				NB[k].flag = 1;
 				if (NA[j].end < NB[k].end) {
 					travel(NA, j, na, NB, k, nb);
 					travel(NB, k, nb, NA, j, na);
 				}
 				else {
 					travel(NB, k, nb, NA, j, na);
 					travel(NA, j, na, NB, k, nb);
 				}
 				j++;
 				k++;
 			}
 			else {
 				if (NA[j].flag) {
 					j++;
 				}
 				if (NB[k].flag)
 					k++;
 			}
 		}
 		printf(αCase #%d: %d %dnα, i + 1, a, b);
 	}
 	return 0;
 }
 
 void travel(TIMETABLE *t1, int j, int n1, TIMETABLE *t2, int k, int n2)
 {
 	int i;
 	
 	for (i = k; i < n2; i++) {
 		if (!t2[i].flag && t1[j].end <= t2[i].start) {
 			t2[i].flag = 1;
 			travel(t2, i, n2, t1, j, n1);
 			break;
 		}
 	}
 }"
26252,2008,32013,Ring,24480,1,case1.c,gcj/2008/32013/Ring/24480/1/extracted/case1.c,"#include <stdio.h>
 #include <string.h>
 
 #define min(a,b) (((a)<(b))?(a):(b))
 
 typedef struct
 {
 	int size;
 	char name[101];
 }enginename;
 
 int S;
 enginename searchengine[101];
 int N;
 enginename querylist[1001];
 int queryid[1001];
 
 int data[1001][101];
 
 
 enginename inputaenginename()
 {
 	enginename en;
 	char c;
 	memset(en.name,0,sizeof(en.name));
 
 	while( scanf(α%cα,&c) && (c=='n'||c=='r') );
 
 	en.size = 0;
 	while( (c>='A' && c <= 'Z') || (c>='a' && c <= 'z') || (c>='0' && c <= '9') || (c==' ') )
 	{
 		en.name[en.size++] = c;
 		scanf(α%cα,&c);
 	}
 	return en;
 }
 
 int enginenamecmp(enginename *a,enginename *b)
 {
 	return memcmp(a->name,b->name,sizeof(a->name));
 }
 int enginefind(enginename *a)
 {
 	int i;
 	for(i=0;i<S;i++)
 	if( enginenamecmp(a,&searchengine[i]) == 0 )
 		return i;
 	return i;
 }
 int make()
 {
 	int best;
 	enginename en;
 	int i,j,k;
 
 	scanf(α%dα,&S);
 	for(i=0;i<S;i++)
 	{
 		searchengine[i] = inputaenginename();
 	}
 	scanf(α%dα,&N);
 	for(i=0;i<N;i++)
 	{
 		querylist[i] = inputaenginename();
 		queryid[i] = enginefind(&querylist[i]);
 	}
 
 	memset(data,0,sizeof(data));
 	for(j=0;j<S;j++)
 		data[0][j] = 0;
 	for(i=1;i<N;i++)
 	{
 		for(j=0;j<S;j++)
 		{
 			if( queryid[i-1] == j )
 			{
 				data[i][j] = N+1;
 				for(k=0;k<S;k++)
 				if( k != j )
 				{
 					data[i][j] = min(data[i][j],data[i-1][k]+1);
 				}
 			}
 			else
 			{
 				data[i][j] = data[i-1][j];
 				for(k=0;k<S;k++)
 				if( k != j )
 				{
 					data[i][j] = min(data[i][j],data[i-1][k]+1);
 				}
 			}
 		}
 	}
 
 	best = N+1;
 	for(j=0;j<S;j++)
 	{
 		if( j == queryid[N-1] )
 			best = min(best,data[N-1][j]+1);
 		else
 			best = min(best,data[N-1][j]);
 	}
 	return best;
 }
 int main()
 {
 	int i;
 	int casen;
 	freopen(αoutput.txtα,αwα,stdout);
 	scanf(α%dα,&casen);
 	for(i=1;i<=casen;i++)
 	{
 		int t = make();
 		printf(αCase #%d: %dnα,i,t);
 	}
 	return 0;
 }"
26265,2008,32013,andrefs,24480,1,gcj1.c,gcj/2008/32013/andrefs/24480/1/extracted/gcj1.c,"//Andre Santos
 
 #include <string.h>
 #include <stdio.h>
 
 #define MAXQ 1000
 #define MAXS 300
 #define MAXSTR 120
 
 
 int equals(int n){
 	if (n==0) return 1;
 	else return 0;
 }
 	
 
 int maxDist(char sengs[MAXS][MAXSTR], int s, char querys[][MAXSTR], int q, int index){
 	int i = 0;
 	int j = 0;
 	int dist[MAXS];
 	
 	for(i=0;i<MAXS;i++)
 		dist[i] = -1;
 	
 	for(i=0; i<s; i++){
 		for(j = q-1; j >= index; j--){
 			if (equals(strcmp(sengs[i], querys[j]))){
 				dist[i] = j;
 				}
 			}
 		}
 
 	int distancia = 0;
 /*
 for(i=0;i<s;i++)
 	printf(α%stt%dnα, sengs[i], dist[i]);
 puts(α========================nα);
 */
 	for(i=0; i< s; i++) {
 		if (dist[i] == -1){
 			return q;
 			}
 		if(dist[i] > distancia)
 			distancia = dist[i];
 		}
 	return distancia;
 }
 
 int limpa(){
 	char str[100];
 	fgets(str,20,stdin);
 return 0;
 }
 
 int main(){
 	int i = 0;
 	int j = 0;
 	int n = 0;
 	int s = 0;
 	int q = 0;
 	int index = 0;
 	int change = -1;
 	int temp = 0;
 
 	char sengs[MAXS][MAXSTR];
 	char querys[MAXQ][MAXSTR];
 	
 	scanf (α%dα, &n);
 	limpa();
 	
 	for(i=0;i<n;i++){
 		change = -1;
 		index = 0;
 		temp = 0;
 
 		scanf(α%dα, &s);
 		limpa();
 		for (j=0;j<s;j++){
 			fgets(sengs[j], 115, stdin);
 			}
 
 		scanf(α%dα, &q);
 		limpa();
 		for(j=0; j<q; j++){
 			fgets(querys[j], 115, stdin);
 			}
 
 
 
 		while(index < q){
 			index = maxDist(sengs, s, querys, q,  index);
 			change++;
 			}	
 		if (change == -1)
 			change = 0;
 		printf(αCase #%d: %dnα, i+1, change);
 		}
 		
 return 0;
 }"
26267,2008,32013,andrefs,24481,1,gcj2.c,gcj/2008/32013/andrefs/24481/1/extracted/gcj2.c,"//Andre Santos
 
 #include <string.h>
 #include <stdio.h>
 
 #define PART 0
 #define CHEG 1
 #define TERM_A 0
 #define TERM_B 1
 
 int limpa(){
 	char str[100];
 	fgets(str,20,stdin);
 return 0;
 }
 
 int toMins(int h, int m){
 	return (h*60+m);
 }
 
 
 int toHoras(int min, int *h, int *m){
 	*h = min/60;
 	*m = min%60;
 return 0;
 }
 
 int bsort(int l[1000][3], int max){
 	int i=0, j=0;
 	int tmp1 = 0, tmp2 = 0, tmp0 = 0;
 
 	for(i=0;i<max; i++){
 		for(j=i;j>0;j--)
 			if (l[j-1][0]>l[j][0]	||	(l[j-1][0]==l[j][0]	&&	(l[j-1][2]=='P'		&&	l[j][2]=='C'))){
 				tmp0 = l[j-1][0];
 				tmp1 = l[j-1][1];
 				tmp2 = l[j-1][2];
 				l[j-1][0] = l[j][0];
 				l[j-1][1] = l[j][1];
 				l[j-1][2] = l[j][2];
 				l[j][0] = tmp0;
 				l[j][1] = tmp1;
 				l[j][2] = tmp2;
 			}
 		}
 return 0;
 }
 
 
 
 
 int printL(int l[1000][3], int max){
 	int i = 0;
 	int m, h;
 	for(i=0;i<max;i++){
 		toHoras(l[i][0], &h, &m);
 		printf(α%3d [%02d:%02d]  %c  %cnα,i, h, m, l[i][1], l[i][2]);
 		}
 return 0;
 }
 
 int main(){
 	int n = 0;
 	int i = 0;
 	int casos = 0;
 	int t = 0;
 	int na = 0, nb = 0;
 	int l[1000][3];
 	int lengthA = 0;
 	int lengthT = 0;
 	int tempA1 = 0, tempA2 = 0, tempB1 = 0, tempB2 = 0;
 
 	int startA = 0;
 	int startB = 0;
 	int turnA = 0;
 	int turnB = 0;
 
 		
 
 
 	scanf(α%dα, &n);
 	for(casos=0; casos<n; casos++){
 		startA = 0;
 		startB = 0;
 		turnA = 0;
 		turnB = 0;
 	
 		scanf(α%dα, &t);
 		scanf(α%d %dα, &na, &nb);
 		
 		lengthA = 2*na;
 		lengthT = lengthA + 2*nb;
 		for(i=0; i<lengthA; i+=2){
 			scanf(α%d:%d %d:%dα, &tempA1, &tempA2, &tempB1, &tempB2);
 			l[i][0] = toMins(tempA1, tempA2);
 			l[i][1] = (int) 'A';
 			l[i][2] = (int) 'P';
 			
 			l[i+1][0] = toMins(tempB1, tempB2) + t;
 			l[i+1][1] = (int) 'B';
 			l[i+1][2] = (int) 'C';
 			}
 
 		for(i=lengthA; i<lengthT; i+=2){
 			scanf(α%d:%d %d:%dα, &tempB1, &tempB2, &tempA1, &tempA2);
 			l[i][0] = toMins(tempB1, tempB2);
 			l[i][1] = (int) 'B';
 			l[i][2] = (int) 'P';
 
 			l[i+1][0] = toMins(tempA1, tempA2) + t;
 			l[i+1][1] = (int) 'A' ;
 			l[i+1][2] = (int) 'C';
 			}	
 
 		bsort(l, lengthT);
 
 		for(i=0; i<lengthT; i++){
 			if (l[i][1] == 'A'){
 				if (l[i][2] == 'P'){
 					if (turnA) turnA--;
 					else startA++;
 					}
 				else turnA++;
 				}
 			else {
 				if(l[i][2] == 'P'){
 					if (turnB) turnB--;
 					else startB++;
 					}
 				else turnB++;
 				}
 			}
 
 		printf(αCase #%d: %d %dnα, casos+1, startA, startB);
 		}
 
 	
 return 0;
 }"
26384,2008,32013,RaviM,24480,1,1.c,gcj/2008/32013/RaviM/24480/1/extracted/1.c,"#include<stdio.h>
 
 int main()
 {
     FILE *fpin,*fpout;
     int n,s,q,i,j,k;
     int *cnt,switch_cnt=0,last;
     char **search;
     char temp[100];
     
     fpin=fopen(αC:\codejam\input.INα,αrα);
     fpout=fopen(αC:\codejam\output.txtα,αwα);
     
     fscanf(fpin,α%dα,&n);
     
     for(i=0;i<n;i++)
     {
                     switch_cnt=0;
                     fscanf(fpin,α%d α,&s);
                     search=(char **)malloc(sizeof(char *)*s);
                     for(j=0;j<s;j++)
                     {
                                     search[j]=(char *)malloc(sizeof(char)*101);
                                     fgets(search[j],102,fpin);
                                     search[j][strlen(search[j])-1]='0';
                     }
                     cnt=(int *)malloc(sizeof(int)*s);
                     for(j=0;j<s;j++)
                      cnt[j]=0;
                     
                     fscanf(fpin,α%d α,&q);
                     
                     for(j=0;j<q;j++)
                     {
                                     for(k=0;k<s && cnt[k]!=0; k++);
                                     if(k==s)
                                     {
                                             switch_cnt++;
                                             for(k=0;k<s;k++)
                                              cnt[k]=0;
                                             cnt[last]=1;
                                     } 
                                     
                                     
                                     fgets(temp,102,fpin);
                                     temp[strlen(temp)-1]='0';
                                     
                                     for(k=0;k<s;k++)
                                     {
                                                     if(!strcmp(search[k],temp))
                                                     {
                                                                                cnt[k]++;
                                                                                last=k;
                                                                                break;
                                                     }
                                     }
                     }
                     
                      for(k=0;k<s && cnt[k]!=0; k++);
                      if(k==s)
                      {
                              switch_cnt++;
                      } 
                     fprintf(fpout,αCase #%d: %dnα,i+1,switch_cnt);
                     free(cnt);
                     for(j=0;j<s;j++)
                      free(search[j]);
                     free(search); 
     }
     
     fclose(fpin);
     fclose(fpout);
 }"
26386,2008,32013,RaviM,24481,1,2.c,gcj/2008/32013/RaviM/24481/1/extracted/2.c,"#include<stdio.h>
 
 struct time
 {
        int deph;
        int depmin;
        int arrh;
        int arrmin;
 };
 
 void arrsort(struct time *arr,int size)
 {
      int i,j,chk=1;
      struct time temp;
      for(i=0;i<size-1 && chk==1;i++)
      { chk=0;
       for(j=0;j<size-1-i;j++)
        {
                            if(arr[j].arrh>arr[j+1].arrh)
                            {
                                                         temp=arr[j];
                                                         arr[j]=arr[j+1];
                                                         arr[j+1]=temp;
                                                         chk=1;
                            }
                            else if(arr[j].arrh==arr[j+1].arrh)
                            {
                                 if(arr[j].arrmin>arr[j+1].arrmin)
                                 {
                                                         temp=arr[j];
                                                         arr[j]=arr[j+1];
                                                         arr[j+1]=temp;
                                                         chk=1;
                                 }
                            }
                                 
        }
      }
 }
 
 void depsort(struct time *arr,int size)
 {
      int i,j,chk=1;
      struct time temp;
      for(i=0;i<size-1 && chk==1;i++)
      { chk=0;
       for(j=0;j<size-1-i;j++)
        {
                            if(arr[j].deph>arr[j+1].deph)
                            {
                                                         temp=arr[j];
                                                         arr[j]=arr[j+1];
                                                         arr[j+1]=temp;
                                                         chk=1;
                            }
                            else if(arr[j].deph==arr[j+1].deph)
                            {
                                 if(arr[j].depmin>arr[j+1].depmin)
                                 {
                                                         temp=arr[j];
                                                         arr[j]=arr[j+1];
                                                         arr[j+1]=temp;
                                                         chk=1;
                                 }
                            }
                                 
        }
      }
 }
      
      
      
                                                         
 
 int main()
 {
     int n;
     int  na,nb;
     int turn;
     int i,j,k;
     char temp[10],hr[5],min[5];
     struct time *a, *b;
     int numa,numb,hour,mins;
     FILE *fpin,*fpout;
     
     fpin=fopen(αC:\codejam\input.INα,αrα);
     fpout=fopen(αC:\codejam\output.txtα,αwα);
     
     fscanf(fpin,α%d α,&n);
     
     for(i=0;i<n;i++)
     {
                     numa=0;
                     numb=0;
                     fscanf(fpin,α%d α,&turn);
                     fscanf(fpin,α%d α,&na);
                     fscanf(fpin,α%d α,&nb);
                     a=(struct time*)malloc(sizeof(struct time)*na);
                     b=(struct time*)malloc(sizeof(struct time)*nb);
                     for(j=0;j<na;j++)
                     {
                                      fscanf(fpin,α%s α,temp);
                                      strncpy(hr,temp,2);
                                      hr[2]='0';
                                      a[j].deph=atoi(hr);
                                      strncpy(min,(temp+3),2);
                                      min[2]='0';
                                      a[j].depmin=atoi(min);
                                      
                                      fscanf(fpin,α%s α,temp);
                                      strncpy(hr,temp,2);
                                      hr[2]='0';
                                      a[j].arrh=atoi(hr);
                                      strncpy(min,(temp+3),2);
                                      min[2]='0';
                                      a[j].arrmin=atoi(min);
                     }
                                      
                     for(j=0;j<nb;j++)
                     {
                                      fscanf(fpin,α%s α,temp);
                                      strncpy(hr,temp,2);
                                      hr[2]='0';
                                      b[j].deph=atoi(hr);
                                      strncpy(min,(temp+3),2);
                                      min[2]='0';
                                      b[j].depmin=atoi(min);
                                      
                                      fscanf(fpin,α%s α,temp);
                                      strncpy(hr,temp,2);
                                      hr[2]='0';
                                      b[j].arrh=atoi(hr);
                                      strncpy(min,(temp+3),2);
                                      min[2]='0';
                                      b[j].arrmin=atoi(min);
                     }
                     
                     arrsort(b,nb);
                     depsort(a,na);
                     for(j=0,k=0;j<na && k<nb;j++)
                     {
                                      hour=b[k].arrh;
                                      mins=b[k].arrmin;
                                      mins+=turn;
                                      if(mins>59)
                                       {
                                                 mins=mins%60;
                                                 hour++;
                                       }
                                      if(a[j].deph > hour)
                                       k++;
                                      else if(a[j].deph == hour)
                                       {if(a[j].depmin>=mins)
                                        k++;
                                        else
                                         numa++;
                                        }
                                      else  numa++;
                     }
                     if(j<na)
                      numa+=(na-j);
                      
                     arrsort(a,na);
                     depsort(b,nb);
                     for(j=0,k=0;j<nb && k<na;j++)
                     {
                                      hour=a[k].arrh;
                                      mins=a[k].arrmin;
                                      mins+=turn;
                                      if(mins>59)
                                       {
                                                 mins=mins%60;
                                                 hour++;
                                       }
                                      if(b[j].deph > hour)
                                       k++;
                                      else if(b[j].deph == hour)
                                       {if(b[j].depmin>=mins)
                                        k++;
                                        else
                                         numb++;
                                        }
                                      else  numb++;
                     }
                     if(j<nb)
                      numb+=(nb-j); 
                      
                     fprintf(fpout,αCase #%d: %d %dnα,i+1,numa,numb);
                     free(a);
                     free(b);
     }
                      
     fclose(fpin);
     fclose(fpout);
 }"
26390,2008,32013,Maverick53,24481,1,trains.c,gcj/2008/32013/Maverick53/24481/1/extracted/trains.c,"#include<stdio.h>
 
 
 
 void sort(int a[], int b[], int n){
 
 
 	int i,j,temp1,temp2;
 	
 	for(i=0;i<n;i++)
 	  for(j=i+1;j<n;j++)
 	{
 	if(a[i]>a[j]) {temp1=a[i];a[i]=a[j];a[j]=temp1;
 		       temp2=b[i];b[i]=b[j];b[j]=temp2;
 			}
 	else if((a[i]==a[j]) && (b[i]>b[j]))
 			{temp2=b[i];b[i]=b[j];b[j]=temp2;
 			}
 
 	}
 
 
 }
 
 
 
 
 main() {
 
 int Cases=0,i=0,k=0,j=0,cases=0,ta,na,nb,nta=0,ntb=0;
 
 
 int depa_hrs[100],arrb_hrs[100],depb_hrs[100],arra_hrs[100];
 int depa_mins[100],arrb_mins[100],depb_mins[100],arra_mins[100];
 char colon;
 
 scanf(α%dα,&Cases);
 cases=1;
         while(cases<=Cases) {
 //		printf(αCase %dnα,cases);
 
 		for(i=0;i<100;i++){
 			depa_hrs[i]=0;arrb_hrs[i]=0;depb_hrs[i]=0;arra_hrs[i]=0;
 			depa_mins[i]=0;arrb_mins[i]=0;depb_mins[i]=0;arra_mins[i]=0;
 		}
 		nta=0;ntb=0;
                 scanf(α%dα,&ta);
 		scanf(α%dα,&na);
 		scanf(α%dα,&nb);		
 //		printf(α%d %d %dnα,ta,na,nb);
                 i=0;
                 while(i<na){
                         scanf(α%dα,&depa_hrs[i]);
 			scanf(α%cα,&colon);
 			scanf(α%dα,&depa_mins[i]);
 			scanf(α%dα,&arrb_hrs[i]);
                         scanf(α%cα,&colon);
                         scanf(α%dα,&arrb_mins[i]);
 //			printf(α%d %d %d %dnα,depa_hrs[i],depa_mins[i],arrb_hrs[i],arrb_mins[i]);
                         i++;
                 }
 		
 		i=0;
                 while(i<nb){
                         scanf(α%dα,&depb_hrs[i]);
                         scanf(α%cα,&colon);
                         scanf(α%dα,&depb_mins[i]);
                         scanf(α%dα,&arra_hrs[i]);
                         scanf(α%cα,&colon);
                         scanf(α%dα,&arra_mins[i]);
 //			printf(α%d %d %d %dnα,depb_hrs[i],depb_mins[i],arra_hrs[i],arra_mins[i]);
                         i++;
                 }
 
 
 
 
 		sort(depa_hrs,depa_mins,na);
 	        sort(arrb_hrs,arrb_mins,na);
 		sort(depb_hrs,depb_mins,nb);
                 sort(arra_hrs,arra_mins,nb);
 		
 
 //		for(i=0;i<na;i++) printf(α%d:%d %d:%dnα,depa_hrs[i],depa_mins[i],arrb_hrs[i],arrb_mins[i]);
 //		printf(αnα);
 //		for(i=0;i<nb;i++) printf(α%d:%d %d:%dnα,depb_hrs[i],depb_mins[i],arra_hrs[i],arra_mins[i]);
 
 
 
 		for(j=0;j<nb;j++){
 			arra_mins[j] = arra_mins[j] + ta;
                         if(arra_mins[j]>=60)
                                 {       arra_hrs[j]++;
                                         arra_mins[j]=arra_mins[j]%60;
                                 }
 		}
 
 
 		for(i=0;i<na;i++){
 			 arrb_mins[i] = arrb_mins[i] + ta;
                         if(arrb_mins[i]>=60)
                                 {       arrb_hrs[i]++;
                                         arrb_mins[i]=arrb_mins[i]%60;
                                 }
 		}
 		
 		j=0;i=0;
 		while(i<na&&j<nb){
 			
 //			printf(αi j = %d %dnα,i,j);	
 
 			if(depa_hrs[i]<arra_hrs[j]) {nta++;i++;}
 			else if((depa_hrs[i]==arra_hrs[j] && depa_mins[i]<arra_mins[j])){ nta++;i++;}
 			else if((depa_hrs[i]==arra_hrs[j] && depa_mins[i]==arra_mins[j])) {i++;j++;}
 			else if((depa_hrs[i]==arra_hrs[j] && depa_mins[i]>arra_mins[j])){i++;j++;}
 			else if(depa_hrs[i]>arra_hrs[j]) {i++;j++;}
 			
 
 		}
 		if(i<na) nta = nta + na - i;
 		
 
 		j=0;i=0;
                 while(i<na&&j<nb){
 
 
                         if(depb_hrs[j]<arrb_hrs[i]) {ntb++;j++;}
                         else if((depb_hrs[j]==arrb_hrs[i] && depb_mins[j]<arrb_mins[i])){ ntb++;j++;}
                         else if((depb_hrs[j]==arrb_hrs[i] && depb_mins[j]==arrb_mins[i])) {j++;i++;}
 			else if((depb_hrs[j]==arrb_hrs[i] && depb_mins[j]>arrb_mins[i])){i++;j++;}
                         else if(depb_hrs[j]>arrb_hrs[i]) {i++;j++;}
 
 
                 }
 
 		if(j<nb) ntb = ntb + nb - j;
 		
 
 		
 
 
 		printf(αCase #%d: %d %dnα,cases,nta,ntb);
 
 		cases++;
         }
 
 
 
 
 
 
 
 }"
26424,2008,32013,laxman,24481,1,jamB.c,gcj/2008/32013/laxman/24481/1/extracted/jamB.c,"#include<stdio.h>
 
 struct tripstruct
 {
         int st,end;
         int usingtrip;
         int free;
         int tripid;
 };
 
 
 struct tripstruct ATrips[100],BTrips[100];
 
 #define START 1
 #define END 2
 
 sortit(struct tripstruct *trips,int id, int len)
 {
         int i,j;
         struct tripstruct ttrip;
         for(i=0;i<len;i++)
                 for(j=i+1;j<len;j++)
                 {
                         if(id==START)
                         {
                                 if(trips[i].st > trips[j].st)
                                 {
                                         ttrip=trips[i];
                                         trips[i]=trips[j];
                                         trips[j]=ttrip;
                                 }
                                 if(trips[i].st == trips[j].st)
                                 {
                                         if(trips[i].end > trips[j].end)
                                         {
                                                 ttrip=trips[i];
                                                 trips[i]=trips[j];
                                                 trips[j]=ttrip;
                                         }
                                 }
                         }
                         else
                         {
                                 if(trips[i].end > trips[j].end)
                                 {
                                         ttrip=trips[i];
                                         trips[i]=trips[j];
                                         trips[j]=ttrip;
                                 }
                                 if(trips[i].end == trips[j].end)
                                 {
                                         if(trips[i].st > trips[j].st)
                                         {
                                                 ttrip=trips[i];
                                                 trips[i]=trips[j];
                                                 trips[j]=ttrip;
                                         }
                                 }
 
                         }
                 }
 }
 
 main(int argc, char *argv[])
 {
         FILE *f1,*f2;
         int i,j,tc,t,tt,NA,NB,cnt,cnt1,cnt2;
 
         if(argc < 2) { printf(αInput test data file missingnα); exit(1); }
         if((f1=fopen(argv[1],αrα))==NULL) { printf(αUnable to open data file nα); exit(1); }
 
         f2 = fopen(αoutputα,αwα);
 
         fscanf(f1,α%dnα,&tc);
         for(t=0;t<tc;t++)
         {
                 fscanf(f1,α%dnα, &tt);
                 fscanf(f1,α%d %dnα, &NA,&NB);
                 printf(αTrip time %d NA=%d NB=%dnα,tt,NA,NB);
 
                 for(i=0;i<NA;i++)
                 {
                         int h,m;
                         fscanf(f1,α%d:%dα,&h,&m);
                         ATrips[i].st=h*60 + m;
                         printf(αTRIP A [%d] %d %d α,i,h,m);
                         fscanf(f1,α%d:%dnα,&h,&m);
                         ATrips[i].end=h*60 + m + tt;
                         ATrips[i].free=1;
                         ATrips[i].usingtrip=-1;
                         ATrips[i].tripid=i;
                         printf(α %d %d st=%d end=%dnα,h,m,ATrips[i].st,ATrips[i].end);
 
                 }
 
                 for(i=0;i<NB;i++)
                 {
                         int h,m;
                         fscanf(f1,α%d:%dα,&h,&m);
                         printf(αTRIP B [%d] %d %d α,i,h,m);
                         BTrips[i].st=h*60 + m;
                         fscanf(f1,α%d:%dnα,&h,&m);
                         BTrips[i].end=h*60 + m + tt;
                         BTrips[i].free=1;
                         BTrips[i].usingtrip=-1;
                         BTrips[i].tripid=i;
                         printf(α %d %d st=%d end=%dnα,h,m,BTrips[i].st,BTrips[i].end);
                 }
 
                 sortit(ATrips,END,NA);
                 sortit(BTrips,START,NB);
 
                 for(i=0;i<NB;i++)
                         for(j=0;j<NA;j++)
                                 if( (ATrips[j].free) && (BTrips[i].st >= ATrips[j].end) )
                                 {
                                         ATrips[j].free=0;
                                         BTrips[i].usingtrip=ATrips[j].tripid;
                                         break;
                                 }
 
                 sortit(BTrips,END,NB);
                 sortit(ATrips,START,NA);
 
                 for(i=0;i<NA;i++)
                         for(j=0;j<NB;j++)
                                 if( (BTrips[j].free) && (ATrips[i].st >= BTrips[j].end) )
                                 {
                                         BTrips[j].free=0;
                                         ATrips[i].usingtrip=BTrips[j].tripid;
                                         break;
                                 }
                 cnt1 =0;cnt2=0;
                 for(cnt=0,i=0;i<NA;i++)
                 {
                         printf(αAtrip %d uses B trip %d st=%d end =%dnα,ATrips[i].tripid,ATrips[i].usingtrip,ATrips[i].st,ATrips[i].end);
                         if(ATrips[i].usingtrip == -1)
                                 cnt1++;
                 }
                 for(i=0;i<NB;i++)
                 {
                         printf(αBtrip %d uses A trip %d st=%d end =%dnα,BTrips[i].tripid,BTrips[i].usingtrip,BTrips[i].st,BTrips[i].end);
                         if(BTrips[i].usingtrip == -1)
                                 cnt2++;
                 }
                 printf(αcnt1 = %d cnt2 = %dnα,cnt1,cnt2);
                 fprintf(f2,αCase #%d: %d %dnα,t+1,cnt1,cnt2);
         }
 
         fclose(f1);
         fclose(f2);
 }"
26536,2008,32013,happyking,24480,1,test.c,gcj/2008/32013/happyking/24480/1/extracted/test.c,"#include<stdio.h>
 #include<string.h>
 
 int n;
 int s,q;
 char engine[101][105];
 char query[1001][105];
 int find[101];
 
 int main()
 {
 	int tn;
 	int i,j;
 	int ch,fn;
 //	freopen(αA-large.in.txtα,αrα,stdin);
 //	freopen(αoutput.txtα,αwα,stdout);
 
 	scanf(α%dα,&n);
 	for(tn=0; tn<n;tn++) {
 		scanf(α%dα,&s);
 		gets(engine[0]);
 		for(i=0; i<s; i++) gets(engine[i]);
 		scanf(α%dα,&q);
 		memset(find, 0, sizeof(find));
 		ch = 0; fn = 0;
 		gets(query[0]);
 		for(i=0; i<q; i++) {
 			gets(query[i]);
 			for(j=0; j < s;j++) 
 				if(strcmp(query[i],engine[j]) == 0) break;
 			if(j < s) {
 				if(find[j] == 0) fn++;
 				find[j] = 1;
 			}
 			if(fn >= s) {
 				ch++;
 				fn =1;
 				memset(find,0,sizeof(find));
 				find[j] = 1;
 			}
 		}
 		printf(αCase #%d: %dnα,tn+1,ch);
 	}
 	return 0;
 }"
26538,2008,32013,happyking,24481,1,test.c,gcj/2008/32013/happyking/24481/1/extracted/test.c,"#include<stdio.h>
 #include<stdlib.h>
 
 typedef struct {
 	int ti;
 	char w;
 }tn;
 
 int n;
 int t;
 int na,nb;
 tn a[200],b[200];
 
 int cmp( const void *a ,const void *b) 
 {
 	if((*(tn *)a).ti > (*(tn *)b).ti ) return  1;
 	else if((*(tn *)a).ti < (*(tn *)b).ti ) return -1; 
 	else if((*(tn *)a).w == 'L') return 1;
 	return -1;
 } 
 
 int main()
 {
 	int tn;
 	int i,j;
 	int ta,tb,tc,td;
 //	freopen(αB-large.in.txtα,αrα,stdin);
 //	freopen(αoutput.txtα,αwα,stdout);
 	scanf(α%dα,&n);
 	for(tn=0; tn<n;tn++) {
 		scanf(α%dα,&t);
 		scanf(α%d%dα,&na,&nb);
 		for(i=0,j=0;i<na;i++,j++) {
 			scanf(α%d:%d %d:%dα,&ta,&tb,&tc,&td);
 			a[j].ti=ta*60+tb; a[j].w='L';
 			b[j].ti=tc*60+td+t; b[j].w='A';
 		}
 		for(i=0;i<nb;i++,j++) {
 			scanf(α%d:%d %d:%dα,&ta,&tb,&tc,&td);
 			b[j].ti=ta*60+tb; b[j].w='L';
 			a[j].ti=tc*60+td+t; a[j].w='A';
 		}
 		qsort(a, j, sizeof(a[0]), cmp);
 		qsort(b, j, sizeof(b[0]), cmp);
 		ta = 0; tb = 0; tc = 0; td = 0;
  		for(i=0; i<j;i++) {
 			if(a[i].w == 'A') tc++;
 			else {
 				if(tc >0) tc--;
 				else ta++;
 			}
 			if(b[i].w =='A') td++;
 			else {
 				if(td > 0) td--;
 				else tb++;
 			}
 		}
 		printf(αCase #%d: %d %dnα,tn+1,ta,tb);
 	}
 	return 0;
 }"
26590,2008,32013,LayCurse,24481,1,b.c,gcj/2008/32013/LayCurse/24481/1/extracted/b.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 #define INF 100000
 
 void intSort(int d[],int s){
   int i,j; int key,t;
   if(s<=1) return;
 
   key=(d[0]+d[s-1])/2; i=-1; j=s;
   for(;;){
     while(d[++i] < key); while(d[--j] > key);
     if(i>=j) break; t=d[i]; d[i]=d[j]; d[j]=t;
   }
   intSort(d,i); intSort(d+j+1,s-j-1);
 }
 
 int main(){
   int i,j,k,l,m,n,t;
 
   int a_n, b_n;
   int a_st[200],a_ed[200],b_st[200],b_ed[200];
   int a,b,c,d;
   int a_s, b_s, a_use, b_use;
   
   int size,count=0;
 
   scanf(α%dα,&size);
   while(size--){
     scanf(α%dα,&t);
     scanf(α%d%dα,&a_n,&b_n);
     rep(i,a_n){
       scanf(α%d:%dα,&j,&k); a_st[i]=j*60+k;
       scanf(α%d:%dα,&j,&k); a_ed[i]=j*60+k+t;
     }
     rep(i,b_n){
       scanf(α%d:%dα,&j,&k); b_st[i]=j*60+k;
       scanf(α%d:%dα,&j,&k); b_ed[i]=j*60+k+t;
     }
 
     a_s = b_s = 0; a_use = b_use = 0;
     intSort(a_st,a_n); intSort(a_ed,a_n); intSort(b_st,b_n); intSort(b_ed,b_n);
     a_st[a_n]=a_ed[a_n]=b_st[b_n]=b_ed[b_n]=INF;
     
     a=b=c=d=0;
     for(;;){
       t=INF;
       if(a_st[a]<t) t= a_st[a];
       if(a_ed[b]<t) t= a_ed[b];
       if(b_st[c]<t) t= b_st[c];
       if(b_ed[d]<t) t= b_ed[d];
       if(t==INF) break;
 
       if(a_ed[b]==t){b++; b_s++; continue;}
       if(b_ed[d]==t){d++; a_s++; continue;}
       if(a_st[a]==t){a++; if(a_s) a_s--; else a_use++; continue;}
       if(b_st[c]==t){c++; if(b_s) b_s--; else b_use++; continue;}
     }
 
     printf(αCase #%d: %d %dnα,++count,a_use,b_use);
   }
   
   return 0;
 }"
26799,2008,32013,rafaelim,24480,1,ST.c,gcj/2008/32013/rafaelim/24480/1/extracted/ST.c,"#include <stdlib.h>
 #include αST.hα
 
 static int value;   /* Guarda o indice da string procurada */
 static int N;       /* Usado para indexar as strings */
 static STlink head; /* Raiz da arvore */
 
 /**
  * Inicializa a tabela de simbolos
  */
 void STinit(void)
 {
     head = NULL;
     N = 0;
 }
 
 /**
  * Cria um novo no com caracter 'd' e devolve esse no
  */
 STlink stNEW(int d)
 {
     STlink x = malloc(sizeof *x);
     
     x->index = -1;
     x->d = d;
     x->left = NULL;
     x->right = NULL;
     x->middle = NULL;
 
     return x;
 }
 
 /**
  * Funcao recursiva que percorre a TST do no 'h', de acordo com a string 'v' a partir da posicao 'w'. 
  * Se v[w] for igual a '0', define o 'value' como sendo o indice da string e termina a recursao.
  */
 STlink indexR(STlink h, char* v, int w)
 {
     int i = v[w];
  	
     /* Cria um no com o caracter v[w] */
     if (h == NULL)
  	 	h = stNEW(i);
 
     /* Termino da recursao, define o indice se for preciso */
     /* e devolve o no encontrado                           */
     if (i == '0')
     {
         if (h->index == -1)
             h->index = N++;
 
         value = h->index;
 
         return h;
     }
 
     /* Se o caracter v[w] for menor ao caracter do no 'h' tentar procurar */
     /* em h->left.                                                        */
     /* Se o caracter v[w] for igual ao caracter do no 'h' continua no     */
     /* caminho consumindo esse caracter.                                  */
     /* Se o caracter v[w] for maior ao caracter do no 'h' tentar procurar */
     /* em h->right.                                                       */
 
     if (i < h->d)
         h->left = indexR(h->left, v, w);
     else if (i == h->d)
         h->middle = indexR(h->middle, v, w + 1);
     else 
         h->right = indexR(h->right, v, w);
 
     return h;
 }
 
 /**
  * Recebe uma string como chave e devolve o indice dela
  */ 
 int STindex(char* key)
 {
     head = indexR(head, key, 0);
 
     return value;
 }
 
 /**
  * Devolve o tamanho da tabela de simbolos
  */ 
 int STsize(void)
 {
     return N;
 }"
26800,2008,32013,rafaelim,24480,1,saveTheUniverse.c,gcj/2008/32013/rafaelim/24480/1/extracted/saveTheUniverse.c,"#include <stdio.h>
 #include <stdlib.h>
 #include αST.hα
 #define MAXCHAR 100
 #define TRUE 1
 #define FALSE 0
 #define DEBUG(x) printf(#xα: %dnα, x)
 
 static int cant_use[100];
 
 
 char *readLine()
 {
     char *newString;
     
     newString = malloc(MAXCHAR * sizeof(char));
     scanf(α%[^n]nα, newString);
     
     return newString;
 }
 
 int main(void)
 {
     register int i, j, k;
     int N, S, Q;
     int switches, searchEnginesLeft, index;
 
     scanf(α%dα, &N);
 
     k = 1;
 
     while (N != 0)
     {
         STinit();
         switches = 0;    
         
         scanf(α%dnα, &S);
 
         searchEnginesLeft = S;
         
         for (i = 0; i < S; i++)
             cant_use[STindex(readLine())] = FALSE;
         
         scanf(α%dnα, &Q);
 
         for (i = 0; i < Q; i++)
         {
             index = STindex(readLine());
             if (cant_use[index] == FALSE)
             {
                 searchEnginesLeft--;
                 cant_use[index] = TRUE;
             }
 
             if (searchEnginesLeft == 0)
             {
                 for (j = 0; j < S; j++)
                     if (j != index)
                         cant_use[j] = FALSE;
                 
                 searchEnginesLeft = S - 1;
                 switches++;
             }
         }   
         
         printf(αCase #%d: %dnα, k, switches);
 
         k++;
         N--;
     }
 
     return EXIT_SUCCESS;
 }"
26804,2008,32013,rafaelim,24481,1,trainTimeTable.c,gcj/2008/32013/rafaelim/24481/1/extracted/trainTimeTable.c,"#include <stdio.h>
 #include <stdlib.h>
 #define MAXEVENT 400
 #define TRUE 1
 #define FALSE 0
 #define FROM_A 0
 #define FROM_B 1
 #define DEBUG(x) printf(#xα: %dnα, x);
 
 
 typedef struct _event
 {
     int ticks;
     int leaving;
     int from;
 }Event;
 
 static Event eventTable[MAXEVENT];
 
 int getTicks(int h, int m)
 {
     return h * 60 + m;
 }
 
 int compareEvent(const void *t1, const void *t2)
 {
     Event x, y;
     
     x = *(Event *)t1;
     y = *(Event *)t2;
     
     if (x.ticks == y.ticks)
     {
         if (!x.leaving)
             return -1;
         else 
             return 1;
     }
     
     return x.ticks - y.ticks;
 }
 
 int main (void)
 {
     int N, T, NA, NB;
     register int i, j, k;
     int dh, dm, ah, am;
     int trainsA, trainsB, onA, onB;
     
     scanf(α%dα, &N);
     
     k = 1;
     
     while (N != 0)
     {
         
         trainsA = 0;
         trainsB = 0;
         
         onA = 0;
         onB = 0;
         
         scanf(α%dα, &T);
         scanf(α%d %dα, &NA, &NB);
         
         for (i = 0; i < NA; i++)
         {
             scanf(α%d:%d %d:%dα, &dh, &dm, &ah, &am);
             eventTable[i * 2].ticks = getTicks(dh, dm);
             eventTable[i * 2].leaving = TRUE;
             eventTable[i * 2].from = FROM_A;
             eventTable[i * 2 + 1].ticks = getTicks(ah, am + T);
             eventTable[i * 2 + 1].leaving = FALSE;
             eventTable[i * 2 + 1].from = FROM_A;
         }
         
         for (j = i; j - i < NB; j++)
         {
             scanf(α%d:%d %d:%dα, &dh, &dm, &ah, &am);
             eventTable[j * 2].ticks = getTicks(dh, dm);
             eventTable[j * 2].leaving = TRUE;
             eventTable[j * 2].from = FROM_B;
             eventTable[j * 2 + 1].ticks = getTicks(ah, am + T);
             eventTable[j * 2 + 1].leaving = FALSE;
             eventTable[j * 2 + 1].from = FROM_B;
         }
         
         qsort(eventTable, 2 * NA + 2 * NB, sizeof(Event), compareEvent);
         
         i = 0;
 
         while (2 * NA + 2 * NB > 0)
         {
             if (eventTable[i].leaving)
             {
                 if (eventTable[i].from == FROM_A)
                 {
                     if (onA > 0)
                         onA--;
                     else
                         trainsA++;                    
                 }
                 else
                 {
                     if (onB > 0)
                         onB--;
                     else 
                         trainsB++;
                 }
             }
             else
             {
                 if (eventTable[i].from == FROM_A) 
                 {
                     onB++;
                     NA--;
                 }
                 else
                 {
                     onA++;
                     NB--;
                 }
             }
             i++;
         }
         
         printf(αCase #%d: %d %dnα, k, trainsA, trainsB);
         
         N--;
         k++;
     }
     return EXIT_SUCCESS;
 }"
26883,2008,32013,redemption,24481,1,prob2.c,gcj/2008/32013/redemption/24481/1/extracted/prob2.c,"#include <stdio.h>
     #include <stdlib.h>
     
     
     void quicksort(int arr[], int low, int high) {
      int i = low;
      int j = high;
      int y = 0;
      /* compare value */
      int z = arr[(low + high) / 2];
     
      /* partition */
      do {
       /* find member above ... */
       while(arr[i] < z) i++;
     
       /* find element below ... */
       while(arr[j] > z) j--;
     
       if(i <= j) {
        /* swap two elements */
        y = arr[i];
        arr[i] = arr[j]; 
        arr[j] = y;
        i++; 
        j--;
       }
      } while(i <= j);
     
      /* recurse */
      if(low < j) 
       quicksort(arr, low, j);
     
      if(i < high) 
       quicksort(arr, i, high); 
     }
     
     
     
     
     int main()
     {
     	int *Agoing,*Acoming,*Bgoing,*Bcoming, cases,Acases, Bcases,extraTime,i,j,hr,min,Atrains,Btrains,number;
     	FILE *file,*output;;
     	
     	file = fopen(αC:/Documents and Settings/rohitkumar/workspace/CodeJam/input2_large.txtα, αrα); 
     	output = fopen(αC:/Documents and Settings/rohitkumar/workspace/CodeJam/output2_large.txtα,αwα);
     
     	fscanf(file,α%dα,&cases);
     	number = cases;
     	while(cases)
     	{   
             Atrains = 0;
             Btrains = 0;
             fscanf(file,α%dα,&extraTime);    
     		fscanf(file,α%d %dα,&Acases,&Bcases);
     		Agoing=(int *)malloc(Acases*sizeof(int));
     		Bcoming = (int *)malloc(Acases*sizeof(int));
     		Bgoing = (int *)malloc(Bcases*sizeof(int));
     		Acoming = (int *)malloc(Bcases*sizeof(int));
     
             for(i = 0; i<Acases ;++i)
             {
                   fscanf(file,α%d:%dα,&hr,&min);
                   Agoing[i] = hr*60+min;
                   //printf(α%dtα,Agoing[i]);
                   fscanf(file,α%d:%dα,&hr,&min);
                   Bcoming[i] = hr*60+min+extraTime;
                   }
     
             for(i = 0; i<Bcases ;++i)
             {
                   fscanf(file,α%d:%dα,&hr,&min);
                   Bgoing[i] = hr*60+min;
                   fscanf(file,α%d:%dα,&hr,&min);
                   Acoming[i] = hr*60+min+extraTime;
                   }
             quicksort(Agoing,0,Acases-1);
             quicksort(Acoming,0,Bcases-1);
             quicksort(Bcoming,0,Acases-1);
             quicksort(Bgoing,0,Bcases-1);      
             j= 0;
                 for ( i = 0; i < Acases; ++i) // i = A_Departure
 		        {
 			     if (j < Bcases) {
 				    if (Agoing[i] < Acoming[j]) {
 					   Atrains++;
 				     } else
 					   j++;
 			    } else
 				Atrains++;
 
 		        }        
 		        
 		    j = 0;    
 		         for ( i = 0; i < Bcases; ++i) // i = A_Departure
 		        {
 			     if (j < Acases) {
 				    if (Bgoing[i] < Bcoming[j]) {
 					   Btrains++;
 				     } else
 					   j++;
 			    } else
 				Btrains++;
 
 		        }        
         
                 cases--;
                 fprintf(output,αCase #%d: %d %dnα,(number-cases),Atrains,Btrains);      
         		
         	}
     	
     	
     	return 0;
     }"
26945,2008,32013,yakiguri,24480,1,main.c,gcj/2008/32013/yakiguri/24480/1/extracted/main.c,"/**
  * Google Code Jam Submission
  * Problem 1: Saving the Universe
  * Code by yakiguri
  *
  * This is a dynamic programming solution. We wish to find a minimal weight 
  * path in a a weighted multi-partite graph, with lateral edges having weight 
  * 0 (keeping the same engine) and cross edges having weight (switching 
  * engines)
  **/
 
 #define BUFF_LEN 1000 // max name length
 #define MAX_S 100     // max number of search engines
 #define MAX_Q 1000    // max number of queries
 #define OUT stderr
 #define INC 1;
 
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
 
 int best_found;
 
 #ifdef VERBOSE
 int best_path[MAX_Q];
 #endif
 
 /**
  * our recursive dynamic programming function
  **/
 
  int dp(int* path, int* best, int* queries, int weight, int S, int num_steps_taken, int num_total_steps){
     int i;
     int new_weight;
 
     // if we have gotten this far, the path is the best path we have seen so far
     if(num_steps_taken == num_total_steps){
        best[num_total_steps] = weight;
 #ifdef VERBOSE
        memcpy(best_path, path, num_total_steps*sizeof(int));
 #endif
        best_found = 1;
        return;
     }
 
     // extend path by 1 query, pick a search engine
     for(i=0; i < S; i++){
 
        // don't include the engine specified by this query
        if(queries[num_steps_taken] == i) 
           continue;
 
        path[num_steps_taken] = i;
 
        // calculate new weight
        new_weight = weight + ((num_steps_taken > 0) && (path[num_steps_taken-1] != i));
 
        // recurse if this has the potential to beat current best ( best[num_total_steps] )
        assert(num_total_steps-num_steps_taken-1 >= 0);
        assert(best[0] == 0);
        assert(best[1] == 0);
        if(new_weight + best[num_total_steps - num_steps_taken-1] < best[num_total_steps])
           dp(path, best, queries, new_weight, S, num_steps_taken+1, num_total_steps);
     }
  }
 
 
 /**
  * set up things for our call to our recursive dp function
  * if you don't like recursion, you can do this with
  * tropical matrix multiplication (see αalgebraic statistics 
  * for computational biologyα by Sturmfels, Pachter)
  **/
 
 int min_switches(int S, int Q, int* queries){
    int best[Q+1]; // best[i] = the best (minimal) number of switches for the first i queries
    int path[Q]; // path[i] = the search engine we use for query i
    int path_length; // number of queries we make
    int i;
 
    // initialize best array
    memset(best, 0, (Q+1)*sizeof(int));
 
    // iterate over path length = number of queries to find minimal over (best[0] = best[1] = 0)
    for(path_length = 2; path_length <= Q; path_length++){
       best_found = 0;
       best[path_length] = best[path_length-1];
 
       while(!best_found){
          best[path_length] += INC;
 	 memset(path, 0, Q*sizeof(int));
 	 dp(path, best, queries + (Q-path_length), 0, S, 0, path_length);
       }
 
 #ifdef VERBOSE
       fprintf(stderr, αbest[%d] = %dnα, path_length, best[path_length]);
       for(i=0; i < path_length; i++)
          fprintf(stderr, α%dα, best_path[i]);
       fprintf(stderr, αnα);
       for(i=0; i < path_length; i++)
          fprintf(stderr, α%dα, (queries+(Q-path_length))[i]);
       fprintf(stderr, αnnα);
 #endif
 
    }
 
    return best[Q];
 }
 
 
 int main(int argc, char** argv){
    int N, S, Q;
    int i, j;
    int num_switches;
    char engine_names[MAX_S][BUFF_LEN];
    char query[BUFF_LEN];
    int queries[MAX_Q];
    FILE* fp;
 
    // open file and read # of cases
    fp = fopen(argv[1], αrα);
    fscanf(fp, α%d α, &N);
 
    // read each case
    for(i=0; i < N; i++){
 
       // initialize
       memset(engine_names, 0, MAX_S*BUFF_LEN);
       memset(query, 0, BUFF_LEN);
       memset(queries, 0, MAX_Q*sizeof(int));
 
       // read number of engines and engine names
       fscanf(fp, α%d α, &S);
       for(j=0; j < S; j++){
          fgets((char*)(engine_names+j), BUFF_LEN, fp); 
 #ifdef VERBOSE
 	 fprintf(stderr, α%sα, engine_names[j]);
 #endif
       }
 
       // read in queries, map to number according to engine_name
       fscanf(fp, α%d α, &Q);
       for(j=0; j < Q; j++){
          fgets((char*)query, BUFF_LEN, fp);
 
 	 // find query in engine_names
 	 for(queries[j] = 0; (queries[j] < S) && (strncmp(query, engine_names[queries[j]], BUFF_LEN) != 0) ; queries[j]++);
 	 assert(queries[j] <  S);
       }
 
       num_switches = min_switches(S, Q, queries);
       fprintf(stdout, αCase #%d: %dnα, i+1, num_switches);
    }
 }"
26959,2008,32013,SunQiao,24480,1,a.c,gcj/2008/32013/SunQiao/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXLEN 100
 #define MAXSIZE 1000
 
 typedef struct searchengine{
 	int no;
 	char content[MAXLEN];
 } *SE;
 
 typedef struct query{
 	int no;
 	char content[MAXLEN];
 } *Q;
 
 SE se[MAXLEN];
 Q qy[MAXSIZE];
 int n,s,q;
 int bitmap[MAXSIZE]={0};
 int cases[MAXLEN]= {0};
 
 int se2no(Q qt){
 	int i;
 	for(i=1;i<=s;i++){
 		if(strcmp(qt->content,se[i]->content)==0)
 			return i;
 	}
 	return 0;
 }
 
 int check(){
 	int i;
 	for(i=1;i<=s;i++){
 		if(bitmap[i]==0)
 			return 0;
 	}
 	return 1;
 }
 void clearbitmap(){
 	int i;
 	for(i=0;i<=s;i++){
 		bitmap[i]=0;
 	}
 }
 int computeSwitchs(){
 	int result = 0;
 	int i,index;
 	for(i=1;i<=q;i++){
 		index = se2no(qy[i]);
 		bitmap[index]++;
 		if(check())
 		{
 			result++;
 			clearbitmap();
 			i--;
 		}
 	}
 	clearbitmap();
 	return result;
 }
 
 void getline(char *a,FILE *f){
 	char c;
 	int i = 0;
 	while((c=fgetc(f))!='n' && c != EOF)
 		a[i++] = c;
 	a[i] = '0';
 }
 
 void main(){
 	FILE *f;
 	int i,j;
 	
 	f = fopen(αA-large.inα,αrα);
 	fscanf(f,α%dα,&n);
 	for(i=0;i<n;i++){
 		fscanf(f,α%dα,&s);
 		fgetc(f);
 		for(j=1;j<=s;j++){
 			se[j] = malloc(sizeof(struct searchengine));
 			getline(se[j]->content,f);
 			se[j]->no = j;
 		}
 		fscanf(f,α%dα,&q);
 		fgetc(f);
 		for(j=1;j<=q;j++){
 			qy[j] = malloc(sizeof(struct query));
 			getline(qy[j]->content,f);
 			qy[j]->no = j;
 		}
 		cases[i] = computeSwitchs();
 	}
 	fclose(f);
 	f = fopen(αA-large.outα,αwα);
 	for(i=0;i<n;i++){
 		fprintf(f,αCase #%d: %dnα,i+1,cases[i]);
 	}
 	
 
 };"
26961,2008,32013,SunQiao,24479,1,c.c,gcj/2008/32013/SunQiao/24479/1/extracted/c.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 
 
 #define MAXN 100
 #define MAXSIZE 10000
 #define PI 3.14159265358979323846264
 
 #define QUAD_SQUARE 1
 #define QUAD_ECHELON_V 2
 #define QUAD_ECHELON_H 3
 #define QUAD_TRANGLE 4
 #define QUAD_ANTI_TRANGLE 5
 
 typedef struct quadrange{
 	int type;
 	double rightup[2];
 	double rightdown[2];
 	double leftup[2];
 	double leftdown[2];
 } *Quad;
 
 
 int n;
 double df,R,t,r,g;
 double cases[MAXN] = {0.0};
 Quad quads[MAXN];
 int nq = 0;
 FILE *inf;
 
 double xuanchuang(double height){
 	return sqrt((R-t-df)*(R-t-df)-height*height);
 }
 int check(double x,double y){
 	return sqrt(x*x+y*y) < (R-t-df);
 }
 double arcarea(double x1,double y1,double x2,double y2){
 	double length;
 	double alpha;
 	double sinalgha;
 	length = sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))/2;
 	alpha = asin(length/(R-t-df))*2;
 	sinalgha = sin(alpha);
 	return (R-t-df)*(R-t-df)*(alpha-sinalgha)/2;
 	
 }
 void getQuad(){
 	int yindex = 0;
 	int xindex = 0;
 	double x,y;
 	Quad tmp;
 	for(yindex=0;(2*r+g)*yindex <= R;yindex++){
 		for(xindex=0;(2*r+g)*xindex <= R;xindex++){
 			x = (2*r+g)*xindex;
 			y = (2*r+g)*yindex;
 			if(check(x+r,y+r) && check(x+r+g,y+r) && check(x+r,y+r+g) && check(x+r+g,y+r+g)){
 				tmp = malloc(sizeof(struct quadrange));
 				tmp->type = QUAD_SQUARE;
 				tmp->leftdown[0] = x+r+g;
 				tmp->leftdown[1] = y+r;
 				tmp->leftup[0] = x+r+g;
 				tmp->leftup[1] = y+r+g;
 				tmp->rightdown[0] = x+r;
 				tmp->rightdown[1] = y+r;
 				tmp->rightup[0] = x+r;
 				tmp->rightup[1] = y+r+g;
 				quads[nq++] = tmp;
 			}
 			if(check(x+r,y+r) && !check(x+r+g,y+r) && check(x+r,y+r+g) && !check(x+r+g,y+r+g)){
 				tmp = malloc(sizeof(struct quadrange));
 				tmp->type = QUAD_ECHELON_V;
 				tmp->leftdown[0] = xuanchuang(y+r);
 				tmp->leftdown[1] = y+r;
 				tmp->leftup[0] = xuanchuang(y+r+g);
 				tmp->leftup[1] = y+r+g;
 				tmp->rightdown[0] = x+r;
 				tmp->rightdown[1] = y+r;
 				tmp->rightup[0] = x+r;
 				tmp->rightup[1] = y+r+g;
 				quads[nq++] = tmp;
 			}
 			if(check(x+r,y+r) && check(x+r+g,y+r) && !check(x+r,y+r+g) && !check(x+r+g,y+r+g)){
 				tmp = malloc(sizeof(struct quadrange));
 				tmp->type = QUAD_ECHELON_H;
 				tmp->leftdown[0] = x+r+g;
 				tmp->leftdown[1] = y+r;
 				tmp->leftup[0] = x+r+g;
 				tmp->leftup[1] = xuanchuang(x+r+g);
 				tmp->rightdown[0] = x+r;
 				tmp->rightdown[1] = y+r;
 				tmp->rightup[0] = x+r;
 				tmp->rightup[1] = xuanchuang(x+r);
 				quads[nq++] = tmp;
 			}
 			if(check(x+r,y+r) && check(x+r+g,y+r) && check(x+r,y+r+g) && !check(x+r+g,y+r+g)){
 				tmp = malloc(sizeof(struct quadrange));
 				tmp->type = QUAD_ANTI_TRANGLE;
 				tmp->leftdown[0] = x+r+g;
 				tmp->leftdown[1] = y+r;
 				tmp->leftup[0] = x+r+g;
 				tmp->leftup[1] = xuanchuang(x+r+g);
 				tmp->rightdown[0] = x+r;
 				tmp->rightdown[1] = y+r;
 				tmp->rightup[0] = xuanchuang(y+r+g);
 				tmp->rightup[1] = y+r+g;
 				quads[nq++] = tmp;
 			}
 			if(check(x+r,y+r) && !check(x+r+g,y+r) && !check(x+r,y+r+g) && !check(x+r+g,y+r+g)){
 				tmp = malloc(sizeof(struct quadrange));
 				tmp->type = QUAD_TRANGLE;
 				tmp->leftdown[0] = xuanchuang(y+r);
 				tmp->leftdown[1] = y+r;
 				tmp->leftup[0] = 0;
 				tmp->leftup[1] = 0;
 				tmp->rightdown[0] = x+r;
 				tmp->rightdown[1] = y+r;
 				tmp->rightup[0] = x+r;
 				tmp->rightup[1] = xuanchuang(x+r);
 				quads[nq++] = tmp;
 			}
 		}
 	}	
 }
 
 double quadarea(Quad qu){
 	double arc;
 	double tri;
 	double echelon;
 	if(qu->type == QUAD_SQUARE){
 		return g*g;
 	}else if(qu->type == QUAD_TRANGLE){
 		arc = arcarea(qu->leftdown[0],qu->leftdown[1],qu->rightup[0],qu->rightup[1]);
 		tri = (qu->leftdown[0]-qu->rightdown[0])*(qu->rightup[1]-qu->rightdown[1])/2;
 		return tri+arc;
 	}else if(qu->type == QUAD_ECHELON_H){
 		arc = arcarea(qu->leftup[0],qu->leftup[1],qu->rightup[0],qu->rightup[1]);
 		echelon = ((qu->leftup[1]-qu->leftdown[1])+(qu->rightup[1]-qu->rightdown[1]))*g/2;
 		return arc+echelon;
 	}else if(qu->type == QUAD_ECHELON_V){
 		arc = arcarea(qu->leftdown[0],qu->leftdown[1],qu->leftup[0],qu->leftup[1]);
 		echelon = (qu->leftup[0]-qu->rightup[0]+qu->leftdown[0]-qu->rightdown[0])*g/2;
 		return arc+echelon;
 	}else if(qu->type == QUAD_ANTI_TRANGLE){
 		arc = arcarea(qu->leftup[0],qu->leftup[1],qu->rightup[0],qu->rightup[1]);
 		echelon = g*g-(qu->leftdown[0]-qu->rightup[0])*(qu->rightup[1]-qu->leftup[1])/2;
 		return arc+echelon;
 	}
 	return 0;
 }
 
 double green(){
 	int i;
 	double area = 0.0;
 	double temp = 0.0;
 	if(df>=g/2){
 		area = PI*(R-t-df)*(R-t-df);
 		return area;
 	}else{
 		/*area = (2*index*r+(index-1)*g)*(2*index*r+(index-1)*g) - (index-1)*(index-1)*(g-2*df)*(g-2*df);
 		area1 = PI*(R-t-df)*(R-t-df);
 		area2 = (2*index*r+(index-1)*g)*(2*index*r+(index-1)*g);
 		area = area * area1 / area2;
 		return area;*/
 		g = g - 2 * df;
 		r = r + df;
 		nq = 0;
 		getQuad();
 		for(i=0;i<nq;i++){
 			temp = quadarea(quads[i]);
 			printf(α%lfnα,temp);
 			area +=temp;
 		}
 		g = g + 2 * df;
 		r = r + df;
 		return PI*R*R-area*4;
 		
 		
 	}
 	return 0.0;
 }
 
 double blue(){
 	double area = 0.0;
 	area = PI*((R)*(R)-(R-t-df)*(R-t-df));
 	return area;
 }
 
 double sum(){
 	double area = 0.0;
 	area = PI*(R)*(R);
 	return area;
 }
 
 
 void main(){
 	int i;
 	
 	double greenarea = 0.0;
 	double bluearea = 0.0;
 	double sumarea = 0.0;
 	double p = 0.0;
 	inf = fopen(αC-small.inα,αrα);
 	fscanf(inf,α%dα,&n);
 	for(i=1;i<=n;i++){
 		fscanf(inf,α%lf %lf %lf %lf %lfα,&df,&R,&t,&r,&g);
 		sumarea = sum();
 		greenarea = green();
 		p = greenarea/sumarea;
 		cases[i] = p;
 	}
 
 	inf = fopen(αC-small.outα,αwα);
 	for(i=1;i<=n;i++)
 		fprintf(inf,αCase #%d: %.6fnα,i,cases[i]);
 	fclose(inf);
 	
 }"
26963,2008,32013,SunQiao,24481,1,b.c,gcj/2008/32013/SunQiao/24481/1/extracted/b.c,"#include <stdlib.h>
 #include <stdio.h>
 
 #define MAXNODE 200
 #define STATION_A 1
 #define STATION_B 2
 
 typedef struct node{
 	int station;
 	int time[2];
 } *Node;
 
 Node Anodes[MAXNODE];
 Node Bnodes[MAXNODE];
 int n,t,na,nb;
 int cases[MAXNODE][2] = {0};
 
 void nodesort(Node *nodes,int flag){
 	int i,j;
 	Node p;
 	int nn = na+nb;
 	for(i=1;i<nn;i++){
 		for(j=i+1;j<=nn;j++){
 			if(nodes[j]->time[0]*60+nodes[j]->time[1] < nodes[i]->time[0]*60+nodes[i]->time[1]){
 				p = nodes[j];
 				nodes[j] = nodes[i];
 				nodes[i] = p;
 			}else if(flag == 1 && nodes[j]->time[0]*60+nodes[j]->time[1] == nodes[i]->time[0]*60+nodes[i]->time[1] && nodes[j]->station > nodes[i]->station){
 				p = nodes[j];
 				nodes[j] = nodes[i];
 				nodes[i] = p;
 			}else if(flag == 2 && nodes[j]->time[0]*60+nodes[j]->time[1] == nodes[i]->time[0]*60+nodes[i]->time[1] && nodes[j]->station < nodes[i]->station){
 				p = nodes[j];
 				nodes[j] = nodes[i];
 				nodes[i] = p;
 			}
 		}
 	}
 
 }
 /*int combine1(){
 	int i,j,ok=1;
 	int nn = na+nb;
 	ok = 0;
 	nodesort();
 	for(i=1;i<=nn;i++){
 		if(!nodes[i]->flag){
 			for(j=1;j<=nn;j++){
 				if(!nodes[j]->flag && nodes[i]->station != nodes[j]->station && i != j && nodes[i]->endtime[0]*60+nodes[i]->endtime[1] <= nodes[j]->starttime[0]*60+nodes[j]->starttime[1]){
 					nodes[i]->endtime[1] = nodes[j]->endtime[1];
 					nodes[i]->endtime[0] = nodes[j]->endtime[0];
 					nodes[j]->flag = 1;
 					ok = 1;
 					return ok;
 				}
 			}
 		}
 	}
 	return ok;
 }
 
 void combine(){
 	int ok;
 	while((ok = combine1()));	
 }
 */
 void main(){
 	int i,j,count=0;
 	int t1,t2;
 	FILE * f = fopen(αB-large.inα,αrα);
 	fscanf(f,α%dα,&n);
 	for(i=1;i<=n;i++){
 		fscanf(f,α%dα,&t);
 		fscanf(f,α%d %dα,&na,&nb);
 		for(j=1;j<=na+nb;j++){
 			Anodes[j] = malloc(sizeof(struct node));
 			Bnodes[j] = malloc(sizeof(struct node));
 			Anodes[j]->station = (j <= na) ? STATION_A : STATION_B;
 			Bnodes[j]->station = (j <= na) ? STATION_A : STATION_B;
 			if(j<=na){
 				fscanf(f,α%d:%d %d:%dα,&(Anodes[j]->time[0]),&(Anodes[j]->time[1]),&(Bnodes[j]->time[0]),&(Bnodes[j]->time[1]));
 				t1 = Bnodes[j]->time[1] + t;
 				t2 = Bnodes[j]->time[0] + t1 / 60;
 				Bnodes[j]->time[0] = t2;
 				Bnodes[j]->time[1] = t1%60;
 			}
 			else{
 				fscanf(f,α%d:%d %d:%dα,&(Bnodes[j]->time[0]),&(Bnodes[j]->time[1]),&(Anodes[j]->time[0]),&(Anodes[j]->time[1]));
 				t1 = Anodes[j]->time[1] + t;
 				t2 = Anodes[j]->time[0] + t1 / 60;
 				Anodes[j]->time[0] = t2;
 				Anodes[j]->time[1] = t1%60;
 			}
 		}
 		//combine();
 		nodesort(Anodes,1);
 		nodesort(Bnodes,2);
 		count = 0;
 		for(j=1;j<=na+nb;j++){
 			if(Anodes[j]->station == STATION_A){
 				if(count <= 0)
 					cases[i][0]++;
 				else
 					count = count <= 0 ? 0 : count-1;
 			}
 			else if(Anodes[j]->station == STATION_B)
 				count++;
 		}
 		count = 0;
 		for(j=1;j<=na+nb;j++){
 			if(Bnodes[j]->station == STATION_B){
 				if(count == 0)
 					cases[i][1]++;
 				else
 					count = count <= 0 ? 0 : count-1;
 			}
 			else if(Bnodes[j]->station == STATION_A)
 				count++;
 		}
 
 	}
 	
 	
 	fclose(f);
 	f = fopen(αB-large.outα,αwα);
 	for(i=1;i <= n;i++){
 		fprintf(f,αCase #%d: %d %dnα,i,cases[i][0],cases[i][1]);
 	}
 	fclose(f);
 
 }"
26993,2008,32013,kaman,24480,1,Noname2.c,gcj/2008/32013/kaman/24480/1/extracted/Noname2.c,"#include <stdio.h>
 #include <string.h>
 
 int max_se_p(int * se_p, int l) {
   int i,tmp;
   tmp = se_p[0];
   for(i=1;i<l;i++)
     if(se_p[i] > tmp) tmp = se_p[i];
 
   return tmp;
 }
 
 int main(){
   int SE_P[100];
   char SE_NAME[100][101];
   char Q_NAME[1000][101];
   int l,i,j,length,s,q,s_q,times;
   char buffer[101];
   FILE * src = fopen(αsample.inα, αrα);
 
   fgets(buffer, 101, src);
   length = atoi(buffer);
 
   for(l=0;l<length;l++) {
     times = 0;
     fgets(buffer, 101, src);
     s = atoi(buffer);
     for(i=0;i<s;i++) {
       fgets(SE_NAME[i],101,src);
     }
     fgets(buffer, 101, src);
     q = atoi(buffer);
     if(q==0) {
       printf(αCase #%d: 0nα, (l+1));
       continue;
     }
     for(j=0;j<q;j++) {
       fgets(Q_NAME[j],101,src);
     }
     s_q = 0;
     while(s_q < q) {
       for(i=0;i<s;i++) {
         for(j=s_q;j<q;j++) {
           if(!strcmp(SE_NAME[i], Q_NAME[j])) {
             SE_P[i]=j;
             break;
           }
         }
         if(j==q) {
           s_q = q;
           printf(αCase #%d: %dnα, (l+1), times);
           break;
         }
       }
       if(s_q == q) break;
       s_q = max_se_p(SE_P, s);
       times++;
     }
   }
 
   return 0;
 }"
26995,2008,32013,kaman,24481,1,Noname2.c,gcj/2008/32013/kaman/24481/1/extracted/Noname2.c,"#include <stdio.h>
 #include <string.h>
 
 int int_cmp(const void *a, const void *b)
 {
   const int *ia = (const int *)a; // casting pointer types
   const int *ib = (const int *)b;
   return ia[0]  - ib[0];
 }
 
 
 int format_time(char * buf) {
   int tmp;
   char * i;
   i = strchr(buf, ':');
   *i='0';
   tmp = 60 * atoi(buf) + atoi(i+1);
   return tmp;
 }
 
 int main(){
   int table[200][3];
   int trainA[100], trainA_s, trainA_e;
   int trainB[100], trainB_s, trainB_e;
   int numA,numB;
   int l,i,T,NA,NB,length;
   char * p;
   char buffer[32];
   FILE * src = fopen(αsample.inα, αrα);
 
   fgets(buffer, 32, src);
   length = atoi(buffer);
 
   for(l=0;l<length;l++) {
     fgets(buffer, 32, src);
     T = atoi(buffer);
     fgets(buffer, 32, src);
     p = strchr(buffer, ' ');
     *p='0';
     NA = atoi(buffer);
     NB = atoi(p+1);
     for(i=0;i<NA;i++) {
       fgets(buffer, 32, src);
       p = strchr(buffer, ' ');
       *p='0';
       table[i][0]=format_time(buffer);
       table[i][1]=format_time(p+1);
       table[i][2]=0;
     }
     for(i=0;i<NB;i++) {
       fgets(buffer, 32, src);
       p = strchr(buffer, ' ');
       *p='0';
       table[NA+i][0]=format_time(buffer);
       table[NA+i][1]=format_time(p+1);
       table[NA+i][2]=1;
     }
 
     qsort(table, NA+NB, sizeof(int)*3, int_cmp);
     numA=numB=0;
     trainA_s=trainA_e=trainB_s=trainB_e=0;
     for(i=0;i<NA+NB;i++) {
       if(table[i][2]==0){
         if((trainA_e>trainA_s)&&(trainA[trainA_s]<=table[i][0])) {
           trainA_s++;
         }
         else {
           numA++;
         }
         trainB[trainB_e]=table[i][1]+T;
         trainB_e++;
         qsort(trainB+trainB_s, trainB_e-trainB_s, sizeof(int), int_cmp);
       }
       if(table[i][2]==1){
         if((trainB_e>trainB_s)&&(trainB[trainB_s]<=table[i][0])) {
           trainB_s++;
         }
         else {
           numB++;
         }
         trainA[trainA_e]=table[i][1]+T;
         trainA_e++;
         qsort(trainA+trainA_s, trainA_e-trainA_s, sizeof(int), int_cmp);
       }
     }
 
     //for(i=0;i<NA+NB;i++) {
     //  printf(α%d: %d %dnα,table[i][2],table[i][0],table[i][1]);
     //}
 
     printf(αCase #%d: %d %dnα,(l+1),numA,numB);
   }
   return 0;"
27001,2008,32013,Ctronc,24480,1,main.c,gcj/2008/32013/Ctronc/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 #include <stdbool.h>
 
 typedef unsigned int uint;
 
 char **get_liste(int *nb)
 {
     char taille_mot[101];
     char **moteurs;
     uint nb_se;
 
     scanf(α%uα, &nb_se);
     while(getc(stdin) != 'n');
 
     moteurs = calloc(nb_se, sizeof(char*));
     for(int no_se = 0; no_se < nb_se; no_se++)
         moteurs[no_se] = strdup(gets(taille_mot));
 
     if(nb) *nb = nb_se;
 
     return moteurs;
 }
 
 // recherche de l'offset
 uint get_offset(const char *mot, const char **lst, uint nb_elem)
 {
     for(int i = 0; i < nb_elem; i++)
         if(!strcmp(lst[i], mot))
             return i;
 
     assert(0);
 }
 
 uint get_nb_changes(void)
 {
     int nb_moteurs, nb_mots;
     // les moteurs de recherches
     char **moteurs = get_liste(&nb_moteurs);
     // les recherches effectues
     char **mot = get_liste(&nb_mots);
 
     // cration d'ID
     uint *descr = malloc(sizeof(uint)*nb_mots);
     for(int i = 0; i < nb_mots; i++)
         descr[i] = get_offset(mot[i], (const char**)moteurs, nb_moteurs);
     bool *choisi = calloc(nb_moteurs, sizeof(bool));
 
     unsigned int nb_mot = 0;
     unsigned int nb_c = 0;
     for(int i = 0; i < nb_mots; i++)
     {
         if(!choisi[descr[i]])
             nb_mot++;
         choisi[descr[i]] = true;
 
         if(nb_mot == nb_moteurs)
         {
             nb_mot = 1;
             for(int i = 0; i < nb_moteurs; i++)
                 choisi[i] = false;
             nb_c++;
             choisi[descr[i]] = true;
         }
     }
 
     // libration de la mem.
     free(descr);
     free(choisi);
     for(int i = 0; i < nb_moteurs; i++)
         free(moteurs[i]);
     free(moteurs);
     return nb_c;
 }
 
 int main(void)
 {
     uint nb_tests;
     scanf(α%uα, &nb_tests);
 
     for(int no_cas = 1; no_cas <= nb_tests; no_cas++)
         printf(αCase #%u: %unα, no_cas, get_nb_changes());
 }"
27003,2008,32013,Ctronc,24481,1,main.c,gcj/2008/32013/Ctronc/24481/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
 
 typedef unsigned int uint;
 
 /* les gares */
 #define GARE_A 0
 #define GARE_B 1
 /* les types d'action */
 #define TYPE_DEPART 0
 #define TYPE_ARRIVEE 1
 
 struct s_action
 {
         uint temps;
         // la gare ou a lieu l'action
         uint gare;
         // le type d'action
         uint type;
 };
 
 // chargement des actions trouves par l'utilisateur
 struct s_action *charger_actions(uint nb_t, uint nb_A_to_B, uint nb_B_to_A)
 {
     struct s_action *actions;
     uint heure, min;
 
     actions = malloc(sizeof(struct s_action)*(nb_A_to_B+nb_B_to_A)*2);
     assert(actions);
 
     for(int i = 0; i < nb_A_to_B+nb_B_to_A; i++)
     {
         for(int d = 0; d < 2; d++)
         {
             scanf(α%u:%uα, &heure, &min);
             actions[2*i+d].temps = heure*60+min + d*nb_t;
             actions[2*i+d].gare = i < nb_A_to_B && d || i >= nb_A_to_B && !d;
             actions[2*i+d].type = d;
         }
     }
 
     return actions;
 }
 
 int cmp_gares(const void *ptr1, const void *ptr2)
 {
     const struct s_action p1 = *((struct s_action*)ptr1), p2 = *((struct s_action*)ptr2);
 
     if(p1.temps < p2.temps)
         return -1;
     else if(p1.temps == p2.temps && p1.type != TYPE_DEPART)
         return -1;
     else
         return 1;
 }
 
 void get_nb_trains(uint *nb_train_A, uint *nb_train_B)
 {
     uint nb_t; // le temps d'attente
     uint nb_A_to_B, nb_B_to_A;
     struct s_action *actions;
     // compteur de trains
     uint *nb_trains[] = {nb_train_A, nb_train_B};
     *nb_train_A = *nb_train_B = 0;
     uint nb_trains_act[] = {0, 0};
 
     scanf(α%uα, &nb_t);
     scanf(α%uα, &nb_A_to_B);
     scanf(α%uα, &nb_B_to_A);
 
     // chargement des actions
     actions = charger_actions(nb_t, nb_A_to_B, nb_B_to_A);
     // tri des actions trouves
     qsort(actions, 2*(nb_A_to_B+nb_B_to_A), sizeof(struct s_action), cmp_gares);
 
     // passage en revue des trains (dpart et arrive)
     for(int i = 0; i < 2*(nb_A_to_B+nb_B_to_A); i++)
     {
         if(actions[i].type == TYPE_ARRIVEE)
             nb_trains_act[actions[i].gare]++;
         else if(!nb_trains_act[actions[i].gare])
             (*nb_trains[actions[i].gare])++;
         else
             nb_trains_act[actions[i].gare]--;
     }
 
     free(actions);
 }
 
 int main(void)
 {
     uint nb_cas;
     scanf(α%uα, &nb_cas);
 
     for(int no_cas = 1; no_cas <= nb_cas; no_cas++)
     {
         uint nb_train_A, nb_train_B;
 
         get_nb_trains(&nb_train_A, &nb_train_B);
         printf(αCase #%u: %u %unα, no_cas, nb_train_A, nb_train_B);
     }
 }"
27051,2008,32013,nivea,24480,1,A.c,gcj/2008/32013/nivea/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 #include αA_IO.hα
 
 #define INFINITE -1
 
 #define COMP_LIMIT 32
 
 #define TRUE 1
 #define FALSE 0
 
 typedef int BOOLEAN;
 
 
 //main()
 //{
 //   int decimal;
 //   int i;
 //
 //   //int SE[] = { 0, 1, 2, 3, 4 };
 //   //unsigned Q[] = { 0, 0, 4, 3, 4, 1, 3, 1, 2, 4 };
 //   //unsigned Q[] = { 4, 2, 1, 1, 0, 0, 1 };
 //   //unsigned Q[] = { 3, 1, 2, 1, 4, 2, 0, 1, 3, 2, 4};
 //   
 //   unsigned Q[] = { 3, 0, 4, 1, 2, 0, 3, 1, 2, 0, 4, 1, 1};
 //   unsigned numS = 5;
 //   unsigned numQ = sizeof(Q)/sizeof(unsigned);
 //
 //   unsigned mask = (1 << (numS) ) - 1;
 //   unsigned count = 0;
 //
 //   for ( i = 0 ; i < numQ ; i++ )
 //   {
 //      mask &= ~(1 << Q[i]);
 //      if ( mask == 0 )
 //      {
 //         count++;
 //         mask = (1 << (numS) ) - 1;
 //         mask &= ~(1 << Q[i]);
 //      }
 //   }
 //   
 //   printf(α%uα, count);
 //
 //}
 
 unsigned mask[4];
 
 setMaskBit(unsigned num)
 {
    unsigned i;
    unsigned j;
 
    i = num / 32;
    j = num % 32;
    mask[i] |= (1 << j ) ;
 }
 
 initMask(unsigned numS)
 {  
   unsigned i, j , k;
 
   mask[0] = 0;
   mask[1] = 0;
   mask[2] = 0;
   mask[3] = 0;
 
   // make all shop bits 1  : TODO : optimize
  /* for ( num = 0 ; num < numS ; num++)
      setMaskBit(num);*/
    i = numS / 32;
    j = numS % 32;
    
    if ( i > 0 )
       for ( k = 0 ; k < i ; k++)
          mask[k] = 0xFFFF;
    mask[i] = (1 << j ) - 1 ;
 }
 
 
 resetMaskBit(unsigned num)
 {
    unsigned i;
    unsigned j;
 
    i = num / 32;
    j = num % 32;
    mask[i] &= ~(1 << j ) ;
 }
 
 BOOLEAN isMaskEmpty()
 {
    if ( (mask[0] == 0) && (mask[1] == 0) && (mask[2] == 0) && (mask[3] == 0) )
       return TRUE;
    else
       return FALSE;
 }
 unsigned countSwitch( unsigned numS, unsigned numQ, unsigned Q[] )
 {
    unsigned count = 0;
    unsigned i;
 
    initMask(numS);
 
    for ( i = 0 ; i < numQ ; i++ )
    {
       resetMaskBit(Q[i]);
 
       if ( isMaskEmpty() )
       {
          count++;
          initMask(numS);
          resetMaskBit(Q[i]);
       }
    }
 
    return count;
 }
 
 
 
 main()
 {
    int num, i;
 
 //   checkIO();
 
    num = InitData();
    
    InitResultWrite();
 
    for (i = 0 ; i < num ; i++)
    {
       TypeDataSet data;
       unsigned count;
 
       
       GetData(&data);
 
       count = countSwitch( data.numS, data.numQ, data.Q );
 
      
       printf(αCase #%d: %unα, i+1, count);
       
       writeResult(i+1, count);
    }
 
 
    DeInitResultWrite();
    DeInitData();
 
 }"
27052,2008,32013,nivea,24480,1,A_IO.c,gcj/2008/32013/nivea/24480/1/extracted/A_IO.c,"#include <stdio.h>
 #include <string.h>
 
 #include αA_IO.hα
 
 ///////////////////////////////////
 FILE *writeFd;
 
 void writeResult(int i, unsigned count)
 {
 
       fprintf(writeFd,αCase #%d: %unα, i, count);
 }
 
 void InitResultWrite()
 {
    writeFd = fopen(αdatasetResult.txtα, αwα);
 }
 
 void DeInitResultWrite()
 {
    fclose(writeFd);
 }
 ///////////////////////////////////
 
 ///////////////////////////////////
 
 FILE *staticFd;
 int numDataSet;
 
 int InitData()
 {
      staticFd = fopen(αdataset.txtα, αrα);
 	  fscanf(staticFd,α%dnα,&numDataSet);
 
      return numDataSet;
 }
 
 void GetData(TypeDataSet *pDataSet)
 {
    
    readDataSet(staticFd, pDataSet);
    
 }
 
 void DeInitData()
 {
    fclose(staticFd);
 }
 
 ///////////////////////////////////
 
 void checkIO()
 {
    int numdataset;
    TypeDataSet DataSet[MAX_DATASET];
 
    fileread(&numdataset, DataSet); 
    printf(αn *** checkIO : ReadDataset = %dnα, numdataset);
   	filewrite(numdataset, DataSet);
 }
 
 //main()
 //{
 //   checkIO();
 //
 //   ShopListInput data;
 //   int num = InitData();
 //   int i;
 //   
 //   for (i = 0 ; i < num ; i++)
 //   {
 //      GetData(&data);
 //      
 //   }
 //
 //   DeInitData();
 //}
 
 
 void readDataSet(FILE *fd, TypeDataSet *pDataSet)
 {
    unsigned int i, j;
    char shopStr[MAX_SHOPS][MAX_LINE];
    char Querystr[MAX_LINE];
 
    fscanf(fd,α%unα,&(pDataSet->numS));
 
    for (i = 0; i < pDataSet->numS; i++)
       //fscanf(fd,α%snα, &(shopStr[i]) );
        fgets(shopStr[i],MAX_LINE,fd);
 
    fscanf(fd,α%unα,&(pDataSet->numQ));
 
    for (j = 0; j < pDataSet->numQ; j++)
    {
       fgets(Querystr,MAX_LINE,fd);
       for (i = 0; i < pDataSet->numS; i++)
       {
          if ( !strcmp(Querystr, shopStr[i]) )
          {
             pDataSet->Q[j] = i;
             break;
          }
       }
    }
 		
 }
 
 void fileread(int *pNumDataset, TypeDataSet DataSet[])
 {	
    int num, i;
    FILE *fd = fopen(αdataset.txtα, αrα);
 	
 
 	fscanf(fd,α%dnα,&num);
 	*pNumDataset = num;
 
    for ( i = 0 ; i < num; i++)
       readDataSet(fd, &DataSet[i]);
 
 
    fclose(fd);	
 }
 
 
 
 void writeDataSet(FILE *fd, TypeDataSet *pDataSet)
 {
 	
    //fprintf(fd,αn%s %s %sα, pDataSet->alienNumSrc, pDataSet->srclanguage, pDataSet->dstlanguage );
 		
 	
 		
 }
 
 
 void filewrite(int NumDataset, TypeDataSet DataSet[])
 {	
    int  i;
    FILE *fd = fopen(αdatasetCopy.txtα, αwα);
 	
 
 	fprintf(fd,α%dα,NumDataset);
 
    for ( i = 0 ; i < NumDataset; i++)
       writeDataSet(fd, &DataSet[i]);
 
 
    fclose(fd);	
 }"
27056,2008,32013,nivea,24481,1,B.c,gcj/2008/32013/nivea/24481/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 #include αB_IO.hα
 
 #define INFINITE -1
 
 #define COMP_LIMIT 32
 
 
 
 Typetime addTime(Typetime t1, Typetime t2)
 {
    Typetime t;
 
    t.Min = t1.Min + t2.Min;
    t.Hr = t1.Hr + t2.Hr;
 
    if (t.Min >= 60)
    {
       t.Hr += t.Min / 60;
       t.Min = t.Min % 60;
    }
 
    return t;
 }
 
 int compTime(Typetime t1, Typetime t2)
 {
    int diff = t1.Hr - t2.Hr;
 
    if (diff == 0)
       diff = t1.Min - t2.Min;
 
    return diff;
 }
 
 selSort(Typetime timeArray[], int num)
 {
    int i, j;
 
    for ( i = 0 ; i < num ; i++ )
       for ( j = num - 1 ; j > i ; j-- )
          if ( compTime (timeArray[i], timeArray[j] ) > 0 )
          {
             Typetime temp;
 
             temp = timeArray[i];
             timeArray[i] = timeArray[j];
             timeArray[j] = temp;
          }
 }
 
 schedule( Typetime departure[], int numDep, Typetime arrival[], int numArr, int t)
 {
    int availArrival = 0;
 
    int additions = 0;
    int i;
    
    Typetime temp;
 
    for ( i = 0 ; i < numDep ; i++ )
    {
       if  ( availArrival < numArr ) 
       {
          temp.Hr = 0;
          temp.Min = t;
 
          temp = addTime( arrival[availArrival], temp );   
       }
 
       if (   ( availArrival < numArr ) 
           && ( compTime(departure[i], temp ) >= 0 ) )
          availArrival++;
 
       else
          additions++;
    }
 
    return additions;
 }
 
 //main()
 //{
 //   unsigned trainsA, trainsB;
 //
 // /*  Typetime departureA[] = { {9, 0}, {10, 0}, {11, 0} };    
 //   Typetime arrivalB[] = { {12, 0}, {13, 0}, {12, 30} };
 //   int numA = sizeof(departureA) / sizeof(Typetime);
 //
 //   Typetime departureB[] = { {12, 2}, {9, 0} };  
 //   Typetime arrivalA[] =  { {15, 0}, {10, 30} };
 //   int numB = sizeof(departureB) / sizeof(Typetime);
 //
 //   int t = 5;*/
 //
 //   Typetime departureA[] = { {9, 0}, {12, 0} };    
 //   Typetime arrivalB[] = { {9, 1}, {12, 2} };
 //   int numA = sizeof(departureA) / sizeof(Typetime);
 //
 //   Typetime departureB[1] ;  
 //   Typetime arrivalA[1] ;
 //   //int numB = sizeof(departureB) / sizeof(Typetime);
 //   int numB = 0;
 //
 //   int t = 2;
 //
 //   selSort(departureA, numA);
 //   selSort(arrivalB, numA);
 //   selSort(departureB, numB);
 //   selSort(arrivalA, numB);
 //   
 //   trainsA = schedule( departureA, numA, arrivalA, numB, t);
 //   trainsB = schedule( departureB, numB, arrivalB, numA, t);
 //   
 //  
 //   printf(α%u %uα, trainsA, trainsB);
 //
 //}
 
 main()
 {
    int num, i;
 
    checkIO();
 
    num = InitData();
    
    InitResultWrite();
 
    for (i = 0 ; i < num ; i++)
    {
       TypeDataSet data;
       unsigned trainsA, trainsB;
       
       GetData(&data);
 
       selSort(data.departureA, data.numA);
       selSort(data.arrivalB, data.numA);
       selSort(data.departureB, data.numB);
       selSort(data.arrivalA, data.numB);
       
       trainsA = schedule( data.departureA, data.numA, data.arrivalA, data.numB, data.t);
       trainsB = schedule( data.departureB, data.numB, data.arrivalB, data.numA, data.t);
    
      
       printf(αCase #%d: %u %unα, i+1, trainsA, trainsB);
       
       writeResult(i+1, trainsA, trainsB);
    }
 
 
    DeInitResultWrite();
    DeInitData();
 
 }"
27058,2008,32013,nivea,24481,1,B_IO.c,gcj/2008/32013/nivea/24481/1/extracted/B_IO.c,"#include <stdio.h>
 
 
 #include αB_IO.hα
 
 ///////////////////////////////////
 FILE *writeFd;
 
 void writeResult(int i, unsigned ta, unsigned tb)
 {
 
       fprintf(writeFd,αCase #%d: %u %unα, i, ta, tb);
 }
 
 void InitResultWrite()
 {
    writeFd = fopen(αdatasetResult.txtα, αwα);
 }
 
 void DeInitResultWrite()
 {
    fclose(writeFd);
 }
 ///////////////////////////////////
 
 ///////////////////////////////////
 
 FILE *staticFd;
 int numDataSet;
 
 int InitData()
 {
      staticFd = fopen(αdataset.txtα, αrα);
 	  fscanf(staticFd,α%dnα,&numDataSet);
 
      return numDataSet;
 }
 
 void GetData(TypeDataSet *pDataSet)
 {
    
    readDataSet(staticFd, pDataSet);
    
 }
 
 void DeInitData()
 {
    fclose(staticFd);
 }
 
 ///////////////////////////////////
 
 void checkIO()
 {
    int numdataset;
    TypeDataSet DataSet[MAX_DATASET];
 
    fileread(&numdataset, DataSet); 
    printf(αn *** checkIO : ReadDataset = %dnα, numdataset);
   	filewrite(numdataset, DataSet);
 }
 
 //main()
 //{
 //   checkIO();
 //
 //   ShopListInput data;
 //   int num = InitData();
 //   int i;
 //   
 //   for (i = 0 ; i < num ; i++)
 //   {
 //      GetData(&data);
 //      
 //   }
 //
 //   DeInitData();
 //}
 
 
 
 
 
 
 void readDataSet(FILE *fd, TypeDataSet *pDataSet)
 {
    unsigned  i;
 
    fscanf(fd,α%dnα, &(pDataSet->t));
    fscanf(fd,α%d %dnα, &(pDataSet->numA), &(pDataSet->numB));
 
    for ( i = 0 ; i < pDataSet->numA ; i++)
       fscanf(fd,α%d:%d %d:%dnα, &(pDataSet->departureA[i].Hr), &(pDataSet->departureA[i].Min), &(pDataSet->arrivalB[i].Hr), &(pDataSet->arrivalB[i].Min) );
 
    for ( i = 0 ; i < pDataSet->numB ; i++)
       fscanf(fd,α%d:%d %d:%dnα, &(pDataSet->departureB[i].Hr), &(pDataSet->departureB[i].Min), &(pDataSet->arrivalA[i].Hr), &(pDataSet->arrivalA[i].Min) );
 
 		
 }
 
 void fileread(int *pNumDataset, TypeDataSet DataSet[])
 {	
    int num, i;
    FILE *fd = fopen(αdataset.txtα, αrα);
 	
 
 	fscanf(fd,α%dnα,&num);
 	*pNumDataset = num;
 
    for ( i = 0 ; i < num; i++)
       readDataSet(fd, &DataSet[i]);
 
 
    fclose(fd);	
 }
 
 
 
 void writeDataSet(FILE *fd, TypeDataSet *pDataSet)
 {
 	
 	
 	unsigned  i;
 
    fprintf(fd,α%dnα, (pDataSet->t));
    fprintf(fd,α%d %dnα, (pDataSet->numA), (pDataSet->numB));
 
    for ( i = 0 ; i < pDataSet->numA ; i++)
       fprintf(fd,α%2d:%2d %2d:%2dnα, (pDataSet->departureA[i].Hr), (pDataSet->departureA[i].Min), (pDataSet->arrivalB[i].Hr), (pDataSet->arrivalB[i].Min) );
 
    for ( i = 0 ; i < pDataSet->numB ; i++)
       fprintf(fd,α%2d:%2d %2d:%2dnα, (pDataSet->departureB[i].Hr), (pDataSet->departureB[i].Min), (pDataSet->arrivalA[i].Hr), (pDataSet->arrivalA[i].Min) );
 
 		
 }
 
 
 void filewrite(int NumDataset, TypeDataSet DataSet[])
 {	
    int  i;
    FILE *fd = fopen(αdatasetCopy.txtα, αwα);
 	
 
 	fprintf(fd,α%dα,NumDataset);
 
    for ( i = 0 ; i < NumDataset; i++)
       writeDataSet(fd, &DataSet[i]);
 
 
    fclose(fd);	
 }"
27179,2008,32013,RichardB,24480,1,codejam1.c,gcj/2008/32013/RichardB/24480/1/extracted/codejam1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int N, S, Q, i, j, l;
 char s[100][100],q[1000][100];
 bool bl[100];
 int trocas, k, bc;
 
 int main() {
     FILE *output;
     FILE *input;
     output = fopen(αoutput.outα,αwα);
     input = fopen(αA-large.inα,αrα);
     fscanf(input,α%dα,&N);
     for (i=0;i<N;i++) {
         //ler tudo
         fscanf(input,α%dnα,&S);
         for (j=0;j<S;j++) {
             fgets(s[j],100,input);
             //scanf(α%sα,&s[j]);
         }
         fscanf(input,α%dnα,&Q);
         for (j=0;j<Q;j++) {
             fgets(q[j],1000,input);
             //scanf(α%sα,&q[j]);
         }
         //comear a contar
         //zerar tudo
         trocas = 0;
         k=0;
         for (j=0;j<S;j++) {
             bl[j]=0;
         }
         //comear
         while (k<Q) {
             for (j=0;j<S;j++) {
                 if (bl[j]==0 && strcmp(s[j],q[k])==0) {
                     bl[j]=1;
                 }
             }
             bc = 0;
             for (j = 0;j<S;j++){
                 bc+=bl[j];
             }
             if (bc==S) {
                 trocas++;
                 for (j=0;j<S;j++){
                 if (strcmp(s[j],q[k])==0) {
                     bl[j]=1;
                 }else{bl[j]=0;}
                 }
             }
             k++;
         }
         fprintf(output, αCase #%d: %dnα,i+1,trocas);
 
     }
     fclose(input);
     fclose(output);
     return 0;
 }"
27255,2008,32013,msambinelli,24480,1,codejam-a.c,gcj/2008/32013/msambinelli/24480/1/extracted/codejam-a.c,"#include <stdio.h>
 #include <string.h>
 
 int main(void){
     
     int n, i, q, j, s, k, a, indice, mud, ant, matriz[100][1000];
     char linha[101], vetor[100][101];
 
     scanf (α%dα, &n);
     for (i=0; i<n; i++){
         //le todos os nomes dos sistemas de busca
         for (k=0; k<100; k++){
             for (j=0; j<1000; j++) matriz[k][j]=0;
         }
         scanf (α%dα, &s);
         getchar();
         for (j=0; j<s; j++){
             gets(vetor[j]);
         }
         //se as pesquisas feitas
         scanf(α%dα, &q);
         getchar();
         //marcar a matriz de busca
         for(j=0; j < q; j++){
             gets (linha);
             //compara com todos os sitemas de busca possiveis
             //para achar o indice na matriz
             for (k=0; k<s; k++){
                 if(!strcmp(linha, vetor[k])){
                     matriz[k][j]= 1;
                     break;
                 }
             }
         }
         indice=-1;
         mud= -1;
         ant=-1;
         while(indice<q){
             mud++;
             indice++;
             //calcular pra todos os buscadores
             for (k=0; k< s; k++){
                 a= indice;
                 while (matriz[k][a]!= 1) a++;
                 if (ant< a-1){
                     ant= a-1;
                 }
             }
             indice= ant;
         }
         printf (αCase #%d: %dnα, i+1, mud);
    }
 }"
27257,2008,32013,msambinelli,24481,1,codejam-b.c,gcj/2008/32013/msambinelli/24481/1/extracted/codejam-b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct celula{
 	int iti[4];//itinerario
 }t_c;
 
 int comp(t_c* a, t_c* b){
 	if(!(a->iti[0] - b->iti[0])){
 		return (a->iti[1] - b->iti[1]);	
 	}else{
 		return (a->iti[0] - b->iti[0]);
 	}
 }
 
 void addtime(t_c* a, int b){
 	int cont;
 	a->iti[3]=a->iti[3]+ b;
 	cont= a->iti[3]/60;
 	a->iti[2]+= cont;
 	a->iti[3]= a->iti[3] % 60;
 }
 
 int menor(t_c a, t_c b){
 	if (!(a.iti[0] - b.iti[0])){
 		if ((a.iti[1]- b.iti[1]) > 0){
 			return 0;
 		}else{
 			return 1;
 		}
 	}else{
 		if ((a.iti[0] - b.iti[0]) > 0){
 			return 0;
 		}else{
 			return 1;
 		}
 	}
 }
 
 int main(void){
 	t_c iti_a[100], iti_b[100], reserva_a[100], reserva_b[100];
 	int n, time, i, j, ha, hb, w;
 	int ra, rb, ta, tb, Max_ra, Max_rb;
 	scanf (α%dα, &n);
 	for (w=0; w<n; w++){
 		scanf (α%dα, &time);
 		scanf (α%d %dα, &ha, &hb);
 		for (j=0; j < ha; j++){
 			scanf (α%d:%d %d:%dα, &iti_a[j].iti[0], &iti_a[j].iti[1], &iti_a[j].iti[2], &iti_a[j].iti[3]);	
 		}
 		qsort (iti_a, ha, sizeof(t_c), comp);
 		for (j=0; j < hb; j++){
 			scanf (α%d:%d %d:%dα, &iti_b[j].iti[0], &iti_b[j].iti[1], &iti_b[j].iti[2], &iti_b[j].iti[3]);	
 		}
 		qsort (iti_b, hb, sizeof(t_c), comp);
 
 		ra=rb=ta=tb=i=j=Max_ra=Max_rb=0;
 		while (i<ha && j<hb){
 			if (menor (iti_a[i], iti_b[j])){
 				if (!ra){
 					ta++;
 				}else{
 					qsort(reserva_a, Max_ra, sizeof(t_c), comp);
 					if (menor(reserva_a[0], iti_a[i])){
 						ra--;
 						reserva_a[0].iti[0]= 24;
 						reserva_a[0].iti[1]= 60;
 					}else{
 						ta++;
 					}
 				}
 				rb++;
 				Max_rb++;
 				addtime(&iti_a[i], time);
 				reserva_b[Max_rb-1].iti[0]= iti_a[i].iti[2];
 				reserva_b[Max_rb-1].iti[1]= iti_a[i].iti[3];
 				i++;
 			}else{
 				if (!rb){
 					tb++;
 				}else{
 					qsort(reserva_b, Max_rb, sizeof(t_c), comp);
 					if (menor(reserva_b[0], iti_b[j])){
 						rb--;
 						reserva_b[0].iti[0]= 24;
 						reserva_b[0].iti[1]= 60;
 					}else{
 						tb++;
 					}
 				}
 				ra++;
 				Max_ra++;
 				addtime(&iti_b[j], time);
 				reserva_a[Max_ra-1].iti[0]= iti_b[j].iti[2];
 				reserva_a[Max_ra-1].iti[1]= iti_b[j].iti[3];
 				j++;
 			}
 		}
 		if (i>=ha){
 		while (j<hb){
 			if (!rb){
 					tb++;
 				}else{
 					qsort(reserva_b, Max_rb, sizeof(t_c), comp);
 					if (menor(reserva_b[0], iti_b[j])){
 						rb--;
 						reserva_b[0].iti[0]= 24;
 						reserva_b[0].iti[1]= 60;
 					}else{
 						tb++;
 					}
 				}
 				ra++;
 				Max_ra++;
 				addtime(&iti_b[j], time);
 				reserva_a[Max_ra-1].iti[0]= iti_b[j].iti[2];
 				reserva_a[Max_ra-1].iti[1]= iti_b[j].iti[3];
 				j++;
 		}
 		}else{
 		while (i<ha){
 			if (!ra){
 					ta++;
 				}else{
 					qsort(reserva_a, Max_ra, sizeof(t_c), comp);
 					if (menor(reserva_a[0], iti_a[i])){
 						ra--;
 						reserva_a[0].iti[0]= 24;
 						reserva_a[0].iti[1]= 60;
 					}else{
 						ta++;
 					}
 				}
 				rb++;
 				Max_rb++;
 				addtime(&iti_a[i], time);
 				reserva_b[Max_rb-1].iti[0]= iti_a[i].iti[2];
 				reserva_b[Max_rb-1].iti[1]= iti_a[i].iti[3];
 				i++;
 
 		}
 		}
 		printf (αCase #%d: %d %dnα, w+1,ta, tb);
 	}
 }"
27316,2008,32013,haritab,24480,1,pro1.c,gcj/2008/32013/haritab/24480/1/extracted/pro1.c,"#include<stdio.h>
 #include<stdlib.h>
 int *sn,*qn,*swit;
 void query(int qnum,int snum,int i)
 {
 	int k,countk=snum,swch=0,temp,j;
 	for(k=0;k<qnum;)
 	{
 		countk=snum;
 		while(countk!=0)
 		{	
 			temp=qn[k]-1;
 			if(sn[temp]==0)
 			 {  sn[temp]=1;countk--;}
 			if(countk!=0)
 			k++;
 			if(k==qnum)
 				break;	
 		}
 		for(j=0;j<snum;j++)
 		  sn[j]=0;
 		if(countk==0)
 		swch++;
 	}
 	swit[i]=swch;
 //printf(αCase #%d: %dnα,i,swch);
 
 }
 int input()
 {
 	int num,snum,j,qnum,i,temp,k;
 char **search_engines,*tempc,t;
 		  tempc=(char *)malloc(sizeof(char)*100);
 	scanf(α%dα,&num);
 	swit=(int *)malloc(sizeof(int)*num);
 	for(i=0;i<num;i++)
 	{
 	scanf(α%dα,&snum);
 	search_engines=(char **)malloc(sizeof(char *)*snum);	
 		  sn=(int *)malloc(sizeof(int)*snum);getchar();
 		for(j=0;j<snum;j++)
 		{
 		  sn[j]=0;
 		  search_engines[j]=(char *)malloc(sizeof(char)*100);
 		  scanf(α%[^n]α,search_engines[j]);getchar();
 		  //printf(α%snα,search_engines[j]);
 		}
 	scanf(α%dα,&qnum);getchar();
 		  qn=(int *)malloc(sizeof(int)*qnum);
 		for(j=0;j<qnum;j++)
 		{
 		  scanf(α%[^n]α,tempc);getchar();
 		  for(k=0;k<snum;k++)
 		    if(strcmp(tempc,search_engines[k])==0)	
 			{  qn[j]=k+1;break;}
 		}
 		query(qnum,snum,i);
 	   free(search_engines);free(qn);free(sn);
 	}
 	return num;
 }
 void print(int num)
 {
 	int i;
 	for(i=0;i<num;i++)
 	printf(αCase #%d: %dnα,i+1,swit[i]);
 }
 main()
 {
 int num=input();
 print(num);
 }"
27326,2008,32013,ipats,24481,1,main.c,gcj/2008/32013/ipats/24481/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 
 void dumb(int n, int *data){
 	int i, j, tmp;
 	for(i=0; i<n; i++) {
 		for(j=0;j<n;j++) {
 			if (data[i] < data[j]) {
 				tmp = data[i];
 				data[i] = data[j];
 				data[j] = tmp;
 			}
 		}
 	}
 }
 
 int main(int argc, char *argv[])
 {
 	int *atimea, *atimed, *btimea, *btimed;
 	int na, nb, nc, i, j, k, pt, h1, m1, h2, m2;
 	int aneed, ahas, bneed, bhas;
 	char line[100];
 	
 	fgets(line, 100, stdin);
 	sscanf(line, α%dα, &nc);
 
 	for(k=0;k<nc;k++) {
 					
 				fgets(line, 100, stdin);
 				sscanf(line, α%dα, &pt);
 			
 				fgets(line, 100, stdin);
 				sscanf(line, α%d %dα, &na, &nb);
 				
 				atimed = (int *) malloc (sizeof(int) * na);
 				atimea = (int *) malloc (sizeof(int) * na);
 				btimed = (int *) malloc (sizeof(int) * nb);
 				btimea = (int *) malloc (sizeof(int) * nb);
 				
 				for(i=0;i<na;i++) {
 					fgets(line, 100, stdin);
 					sscanf(line, α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 					atimed[i] = h1 * 60 + m1;
 					atimea[i] = h2 * 60 + m2 + pt;
 				}
 			
 				for(i=0;i<nb;i++) {
 					fgets(line, 100, stdin);
 					sscanf(line, α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 					btimed[i] = h1 * 60 + m1;
 					btimea[i] = h2 * 60 + m2 + pt;
 				}
 				
 			
 				dumb(na, atimed);
 				dumb(na, atimea);
 				dumb(nb, btimed);
 				dumb(nb, btimea);
 			
 				aneed = ahas = bneed = bhas = 0;
 				// cal a need
 				for(i=0,j=0;i<na;i++) {
 					while ((j < nb) && (atimed[i] >= btimea[j])) {
 						ahas++;
 						j++;
 					}
 					if (ahas > 0) {
 						ahas--;
 					} else {
 						aneed++;
 					}
 				}
 				
 				// call b need
 				for(i=0,j=0;i<nb;i++) {
 					while ((j < na) && (btimed[i] >= atimea[j])) {
 						bhas++;
 						j++;
 					}
 					if (bhas > 0) {
 						bhas--;
 					} else {
 						bneed++;
 					}
 				}
 			
 				printf(αCase #%d: %d %dnα, k + 1, aneed, bneed);
 	}	
 	return 0;
 }"
27330,2008,32013,cmdrkeen,24480,1,saving_the_universe.c,gcj/2008/32013/cmdrkeen/24480/1/extracted/saving_the_universe.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
 typedef struct lst_element lstElement;
 struct lst_element {
 	char *name;
 	lstElement *next;
 };
 
 lstElement *first, *now;
 
 int main(int argc, char *argv[]) {
 	FILE *in, *out;
 	in = fopen(argv[1], αrα);
 	out = fopen(αoutput.outα, αwα);
 
 	int N;
 	fscanf(in, α%inα, &N);
 	
 	int n;
 	for (n = 0; n < N; n++) {
 		int S;
 		fscanf(in, α%inα, &S);
 		
 		int s;
 		char *buffer = malloc(sizeof(char) * 100);
 		for (s = 0; s < S; s++) {
 			fgets(buffer, 100, in);
 		}
 		
 		int Q;
 		fscanf(in, α%inα, &Q);
 
 		first = malloc(sizeof(lstElement));
 		first->next = NULL;
 		first->name = malloc(sizeof(char) * 100);
 		fgets(buffer, 100, in);
 		strcpy(first->name, buffer);
 		int anzahl = 1;
 		int wechsel = 0;
 
 //printf(αquery: %sttanzahl: %inα, buffer, anzahl);
 		int q;
 		for (q = 1; q < Q; q++) {
 			fgets(buffer, 100, in);
 
 			lstElement *tmp = first;
 			lstElement *ins = NULL;
 			while (tmp) {
 				if (strcmp(tmp->name, buffer)) {
 					ins = tmp;
 					tmp = tmp->next;
 				} else
 					break;
 			}
 
 			if (tmp == NULL) {
 				ins->next = malloc(sizeof(lstElement));
 				tmp = ins->next;
 				tmp->next = NULL;
 				tmp->name = malloc(sizeof(char) * 100);
 				
 				strcpy(tmp->name, buffer);
 
 				anzahl++;
 			}
 
 			if (anzahl == S) {
 //printf(α---> Wechselnα);
 				wechsel++;
 				anzahl = 1;
 
 				tmp = first;
 				while (tmp) {
 					lstElement *del = tmp;
 					tmp = tmp->next;
 					free(del->name);
 					free(del);
 				}
 
 				first = malloc(sizeof(lstElement));
 				first->next = NULL;
 				first->name = malloc(sizeof(char) * 100);
 				strcpy(first->name, buffer);			
 			}
 //printf(αquery: %sttanzahl: %intt[%i/%i]nα, buffer, anzahl, q+1, Q);
 		}
 
 		lstElement *tmp = first;
 		while (tmp) {
 			lstElement *del = tmp;
 			tmp = tmp->next;
 			free(del->name);
 			free(del);
 		}
 
 		fprintf(out, αCase #%i: %inα, n+1, wechsel);
 	}
 }"
27332,2008,32013,cmdrkeen,24481,1,train_timetable.c,gcj/2008/32013/cmdrkeen/24481/1/extracted/train_timetable.c,"#include <stdlib.h>
 #include <stdio.h>
 
 typedef struct lst_element lstElement;
 struct lst_element {
 	int departure, arrival;
 	int tagged;
 
 	lstElement *next;
 };
 
 #define BAHNHOF_A 0
 #define BAHNHOF_B 1
 
 int main(int argc, char *argv[]) {
 	FILE *in, *out;
 	in = fopen(argv[1], αrα);
 	out = fopen(αoutput.outα, αwα);
 
 	int N;
 	fscanf(in, α%inα, &N);
 	printf(α%inα, N);
 
 	int n;
 	for (n = 0; n < N; n++) {
 		int T;
 		fscanf(in, α%inα, &T);
 
 		int NA, NB;
 		fscanf(in, α%i %inα, &NA, &NB);
 	
 		int d1, d2, a1, a2;
 	
 		lstElement *na_first = NULL;
 		if (NA >= 1) {
 			na_first = malloc(sizeof(lstElement));
 			fscanf(in, α%d:%d %d:%dnα, &d1, &d2, &a1, &a2);
 			na_first->departure = 100*d1+d2;
 			na_first->arrival = 100*a1+a2;
 			na_first->tagged = 0;
 			na_first->next = NULL;
 		}
 		int na;
 		for (na = 1; na < NA; na++) {
 			fscanf(in, α%d:%d %d:%dnα, &d1, &d2, &a1, &a2);
 
 			int d = d1*100+d2,
 			    a = a1*100+a2;
 
 			lstElement *tmp = na_first;
 			lstElement *ins = na_first;
 			while ((tmp) && (tmp->departure < d)) {
 				ins = tmp;
 				tmp = tmp->next;
 			}
 
 			lstElement *new = malloc(sizeof(lstElement));
 			new->departure = d;
 			new->arrival = a;
 			new->tagged = 0;
 			if (tmp == na_first) {
 				new->next = na_first;
 				na_first = new;
 			} else if (tmp == NULL) {
 				new->next = NULL;
 				ins->next = new;
 			} else {
 				new->next = tmp;
 				ins->next = new;
 			}
 
 		}
 
 		lstElement *nb_first = NULL;
 		if (NB >= 1) {
 			nb_first = malloc(sizeof(lstElement));
 			fscanf(in, α%d:%d %d:%dnα, &d1, &d2, &a1, &a2);
 			nb_first->departure = 100*d1+d2;
 			nb_first->arrival = 100*a1+a2;
 			nb_first->tagged = 0;
 			nb_first->next = NULL;
 		}
 		int nb;
 		for (nb = 1; nb < NB; nb++) {
 			fscanf(in, α%d:%d %d:%dnα, &d1, &d2, &a1, &a2);
 
 			int d = d1*100+d2,
 			    a = a1*100+a2;
 
 			lstElement *tmp = nb_first;
 			lstElement *ins = nb_first;
 			while ((tmp) && (tmp->departure < d)) {
 				ins = tmp;
 				tmp = tmp->next;
 			}
 
 			lstElement *new = malloc(sizeof(lstElement));
 			new->departure = d;
 			new->arrival = a;
 			new->tagged = 0;
 			if (tmp == nb_first) {
 				new->next = nb_first;
 				nb_first = new;
 			} else if (tmp == NULL) {
 				new->next = NULL;
 				ins->next = new;
 			} else {
 				new->next = tmp;
 				ins->next = new;
 			}
 		}
 
 /*		lstElement *tmp = na_first;
 		printf(αNA: %inα, NA);
 		while (tmp) {
 			printf(α%i -> %inα, tmp->departure, tmp->arrival);
 			tmp = tmp->next;
 		}
 		printf(α----nα);
 		tmp = nb_first;
 		printf(αNB: %inα, NB);
 		while (tmp) {
 			printf(α%i -> %inα, tmp->departure, tmp->arrival);
 			tmp = tmp->next;
 		}
 */
 		
 		int a_zuege = 0,
 		    b_zuege = 0;
 		int tagged = 0;
 		int bahnhof;
 		while (tagged < NA+NB) {
 			lstElement *e_a = na_first;
 			lstElement *e_b = nb_first;
 			lstElement *zug;
 
 			while ((e_a) && (e_a->tagged))
 				e_a = e_a->next;
 			while ((e_b) && (e_b->tagged))
 				e_b = e_b->next;
 
 			if ((e_a) && (e_b)) {
 				if (e_b->departure < e_a->departure) {
 					zug = e_b;
 					b_zuege++;
 					bahnhof = BAHNHOF_B;
 				} else {
 					zug = e_a;
 					a_zuege++;
 					bahnhof = BAHNHOF_A;
 				}
 			} else if (e_a) {
 				zug = e_a;
 				a_zuege++;
 				bahnhof = BAHNHOF_A;
 			} else if (e_b) {
 				zug = e_b;
 				b_zuege++;
 				bahnhof = BAHNHOF_B;
 			} else {
 				break;
 			}
 
 			while (zug) {
 				zug->tagged = 1;
 				tagged++;
 
 				int abfahrt = zug->arrival;
 				int stunden = (int) trunc((float) abfahrt / 100.0);
 				int minuten = abfahrt - (stunden * 100) + T;
 				if (minuten > 59) {
 					minuten -= 60;
 					stunden++;
 				}
 				abfahrt = stunden*100 + minuten;
 
 				lstElement *tmp;
 				if (bahnhof == BAHNHOF_A) {
 					tmp = nb_first;
 					bahnhof = BAHNHOF_B;
 				} else {
 					tmp = na_first;
 					bahnhof = BAHNHOF_A;
 				}
 				while ((tmp) && ((tmp->departure < abfahrt) || (tmp->tagged))) {
 					tmp = tmp->next;
 				}
 				zug = tmp;
 			}
 		}
 		fprintf(out, αCase #%i: %i %inα, n+1, a_zuege, b_zuege);
 	}
 }"
27350,2008,32013,ivanFTW,24480,1,Saving.c,gcj/2008/32013/ivanFTW/24480/1/extracted/Saving.c,"#include <stdio.h>
 #include <string.h>
 #define LONG_CADENA 105
 
 int N,S,Q,switches,q_s[LONG_CADENA];
 char s[105][LONG_CADENA], q[LONG_CADENA];
 
 void actualiza(void)
 {
 	int i,cont=0;
 	for(i=1;i<=S;i++)
 		if(q_s[i]!=0) cont++;
 	if(cont==S){
 		switches++;
 		for(i=1;i<=S;i++) q_s[i]=0;
 		q_s[busca_cadena(q)]=1;
 	}
 }
 
 int busca_cadena(char cadena[])
 {
 	int i;
 	for(i=1;i<=S;i++)
 		if(strcmp(cadena,s[i])==0) return(i);
 }
 
 void main(void)
 {
 	int i,j;
 	scanf(α%dnα,&N);
 	for(i=1;i<=N;i++){
 		switches=0;
 		scanf(α%dnα,&S);
 		for(j=1;j<=S;j++){
 			scanf(α%[ a-zA-Z0-9]nα,s[j]);	//scanf(α%[^trn]nα,s[j]); Otra manera de leer cadenas con espacio
 			q_s[j]=0;
 		}
 		scanf(α%dnα,&Q);
 		for(j=1;j<=Q;j++){
 			scanf(α%[ a-zA-Z0-9]nα,q);
 			q_s[busca_cadena(q)]=1;
 			actualiza();
 		}
 		printf(αCase #%d: %dnα,i,switches);
 	}
 }"
27352,2008,32013,ivanFTW,24481,1,Train.c,gcj/2008/32013/ivanFTW/24481/1/extracted/Train.c,"#include <stdio.h>
 
 int N,T,NA,NB;
 int tA[205][2],tB[205][2];
 
 void intercambia(int* a,int* b)
 {
 	int temp;
 	temp=*a; *a=*b; *b=temp;
 }
 
 void ordena(int tabla[205][2])
 {
 	int i,j;
 
 	for(i=0;i<NA+NB;i++)
 		for(j=i+1;j<NA+NB;j++)
 			if(tabla[j][0]<tabla[i][0])
 			{
 				intercambia(&tabla[i][0],&tabla[j][0]);
 				intercambia(&tabla[i][1],&tabla[j][1]);
 			}
 }
 
 int calcula(int tabla[205][2]){
 	int i,min=0,trenes=0;
 
 	for(i=0;i<NA+NB;i++){
 		trenes+=tabla[i][1];
 		if(trenes<min) min=trenes;
 	}
 	return(-min);
 }
 
 void main(void)
 {
 	int i,j,k,hA,mA,hB,mB,t,TrainsA,TrainsB;
 
 	scanf(α%dnα,&N);
 	for(i=1;i<=N;i++){
 		k=0;
 		scanf(α%dnα,&T);
 		scanf(α%d %dnα,&NA,&NB);
 		for(j=1;j<=NA;j++){
 			scanf(α%d:%d %d:%dnα,&hA,&mA,&hB,&mB);	
 			t=hA*60+mA; tA[k][0]=2*t;		tA[k][1]=-1;
 			t=hB*60+mB; tB[k][0]=2*(t+T)-1; tB[k][1]=1;
 			k++;
 		}
 		for(j=1;j<=NB;j++){
 			scanf(α%d:%d %d:%dnα,&hB,&mB,&hA,&mA);	
 			t=hB*60+mB; tB[k][0]=2*t;		tB[k][1]=-1;
 			t=hA*60+mA; tA[k][0]=2*(t+T)-1; tA[k][1]=1;
 			k++;
 		}
 		ordena(tA);	
 		ordena(tB);
 		TrainsA=calcula(tA);
 		TrainsB=calcula(tB);
 		printf(αCase #%d: %d %dnα,i,TrainsA,TrainsB);
 	}
 }"
27373,2008,32013,cocofun,24480,1,a.c,gcj/2008/32013/cocofun/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 main()
 {
 	FILE * fp, * outFp;
 	int tryCount, searchEngineCount, queryCount;
 	int tryLoop, searchEngineLoop, searchEngineLoop2, queryLoop;
 	unsigned char ** searchEngineList;
 	int * caseFactor, swapCount, dirty;
 	unsigned char inputBuffer[128];
 
 	fp = fopen(αA-large.inα, αr+α);
 	outFp = fopen(αA-large.outα, αw+α);
 
 	fscanf(fp, α%dα, &tryCount);
 
 	for (tryLoop = 0; tryLoop < tryCount; tryLoop++)
 	{
 		swapCount = 0;
 
 		fscanf(fp, α%dα, &searchEngineCount);
 
 		searchEngineList = (unsigned char **)malloc(searchEngineCount * sizeof(unsigned char *));
 		caseFactor = (int *)malloc(searchEngineCount * sizeof(int));
 
 		memset(caseFactor, 0, searchEngineCount * sizeof(int));
 
 		for (searchEngineLoop = 0; searchEngineLoop < searchEngineCount; searchEngineLoop++)
 		{
 			memset(inputBuffer, 0, sizeof(inputBuffer));
 			fgets(inputBuffer, 101, fp); 
 			if (inputBuffer[0] == 'n') { searchEngineLoop--; continue; }
 			inputBuffer[strlen(inputBuffer) - 1] = 0x00;
 
 			searchEngineList[searchEngineLoop] = (unsigned char *)malloc(strlen(inputBuffer) + 1 * sizeof(unsigned char));
 
 			strncpy(searchEngineList[searchEngineLoop], inputBuffer, strlen(inputBuffer) + 1);
 		}
 
 		fscanf(fp, α%dα, &queryCount);
 
 		for (queryLoop = 0; queryLoop < queryCount; queryLoop++)
 		{
 			memset(inputBuffer, 0, sizeof(inputBuffer));
 			fgets(inputBuffer, 101, fp); 
 			if (inputBuffer[0] == 'n') { queryLoop--; continue; }
 			inputBuffer[strlen(inputBuffer) - 1] = 0x00;
 
 			for (searchEngineLoop = 0; searchEngineLoop < searchEngineCount; searchEngineLoop++)
 			{
 				if (!strcmp(inputBuffer, searchEngineList[searchEngineLoop]))
 				{
 					caseFactor[searchEngineLoop] = caseFactor[searchEngineLoop] + 1;
 
 					dirty = 0;
 					for (searchEngineLoop2 = 0; searchEngineLoop2 < searchEngineCount; searchEngineLoop2++)
 					{
 						if (caseFactor[searchEngineLoop2] == 0) { dirty = 1; break; }
 					}
 
 					if (dirty == 0)
 					{
 						memset(caseFactor, 0, searchEngineCount * sizeof(int));
 						swapCount++;
 
 						caseFactor[searchEngineLoop] = 1;
 
 						break;
 					}
 				}
 			}
 		}
 
 		free(caseFactor);
 		for (searchEngineLoop = 0; searchEngineLoop < searchEngineCount; searchEngineLoop++)
 		{
 			free(searchEngineList[searchEngineLoop]);
 		}
 		free(searchEngineList);
 
 		fprintf(outFp, αCase #%d: %dnα, tryLoop + 1, swapCount);
 	}
 }"
27422,2008,32013,Pramote,24480,1,a.c,gcj/2008/32013/Pramote/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int numn,i,j,n,s,q,countswitch=0;
 char engine[100][100],query[100];
 int countengine[100]={0};
 
 void reallycleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 }
 
 void cleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 	countengine[j]++;		
 }
 
 void checkarray() {
 	int index,zerocount=0;
 	for(index=0; index<s; index++)
 		if(!countengine[index]) zerocount++;
 	if(zerocount == 0) { 
 		countswitch++;
 		cleararray();
 	}
 }
 
 int main() {
 	scanf(α%dα,&n);
 	for(numn=0; numn<n; numn++) {
 		scanf(α%dα,&s);
 		getchar();
 		for(i=0; i<s; i++) {
 			gets(engine[i]);
 		}
 		scanf(α%dα,&q);
 		getchar();
 		for(i=0; i<q; i++) {
 			gets(query);
 			for(j=0; j<s; j++) {
 				if(!strcmp(query,engine[j])) {
 					countengine[j] += !strcmp(query,engine[j]);
 					break;
 				}	
 			}
 			checkarray();
 		}	
 		reallycleararray();
 		printf(αCase #%d: %dnα,numn+1,countswitch);
 		countswitch = 0;
 	}
 	return 0;
 }"
27424,2008,32013,Pramote,24481,1,train.c,gcj/2008/32013/Pramote/24481/1/extracted/train.c,"#include<stdio.h>
 
 int n,a,b,i,j,k,l,t,counta,countb,q;
 int tmp1,tmp2,tmp3,tmp4;
 int tafrom[200],tato[200],tat[200];
 int flag,what;
  
 int route(int index) {
     int m;
     if(flag == 0) {
         flag = 1;
         what = tat[index];
     }
     if(tat[index] == 0) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 1)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     } else
     if(tat[index] == 1) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 0)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     }
     tat[index] = -1;
     return what;
 }
 
 
 
 
 
 
    
 int main() {
     scanf(α%dα,&n);
     for(l=0;l<n;l++) {
         scanf(α%dα,&t);
         scanf(α%d %dα,&a,&b);
         for(j=0; j<a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 0;
         }
         for(; j<b+a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 1;
         }
     
 // Sort
     for(i=0;i<a+b-1;i++)
         for(j=0;j<a+b-1;j++)
             if(tafrom[j] > tafrom[j+1]) {
                 tmp1 = tafrom[j];
                 tafrom[j] = tafrom[j+1];
                 tafrom[j+1] = tmp1;
                 tmp1 = tato[j];
                 tato[j] = tato[j+1];
                 tato[j+1] = tmp1;
                 tmp1 = tat[j];
                 tat[j] = tat[j+1];
                 tat[j+1] = tmp1;
             }
     for(i=0; i<a+b; i++) {
 
       
         q = route(i);
         if(q == 0) {
             counta++;
             flag = 0;
         }
         if(q == 1) {
             countb++;
             flag = 0;
         }
         if(q == -1)
             flag = 0;
     }
 
     printf(αCase #%d: %d %dnα,l+1,counta,countb);
 
 
     for(i=0; i<a+b; i++) {
         tafrom[i] = 0;
         tato[i] = 0;
         tat[i] = 0;
     }
     counta = 0;
     countb = 0;
     flag = 0;
 
     }
 
 return 0;
 }"
27627,2008,32013,AtishAgrawal,24481,1,google_2.c,gcj/2008/32013/AtishAgrawal/24481/1/extracted/google_2.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<conio.h>
 
 class Time{
 public:
 int hr;
 int min;
 Time(int x,int y):hr(x),min(y){}
 Time operator+(const Time &t2)
 {
 int x=t2.min+min;
 int y=x/60;
 int z=x%60;
 return Time(t2.hr+hr+y,z);
 }
 };
 
 
 class Schedule{
 public:
 Time dep;
 Time arr;
 int FLAG;
 int DONE;
 Schedule(int p,int q,int r,int s):dep(p,q),arr(r,s){}
 };
 
 
 
 int operator<(const Time &t1,const Time&t2)
 {
 if(t1.hr<t2.hr)
   return 1;
 if(t1.hr==t2.hr)
   if(t1.min<t2.min)
 	 return 1;
 return 0;
 }
 
 int operator<=(const Time &t1,const Time&t2)
 {
 if(t1.hr<t2.hr)
   return 1;
 if(t1.hr==t2.hr)
   if(t1.min<t2.min)
 	 return 1;
 if((t1.hr==t2.hr)&& (t1.min==t2.min ))
 	return 1;
 return 0;
 }
 
 void sort(Schedule * arr,int size)
 {
 int i,j;
 for(i=1;i<size;i++)
   {
   Schedule temp= arr[i];
   for(j=i-1;j>=0;j--)
 	 {
 	 if(temp.dep<arr[j].dep)
 		arr[j+1]=arr[j];
 	 else
 		 break;
 		}
 	 arr[j+1]=temp;
   }
 }
 
 int select(Schedule *arr,int size)
 {
 int i=0;
 while(i<size)
   if(arr[i].DONE!=0)
 	 i++;
   else
     break;
 if(i==size)
   return -1;
 return i;
 }
 
 int next(Schedule* array,int in,int flag,int size,Time time)
 {
 Time temp=array[in].arr+ time;
 for(int i=0;i<size;i++)
   {
   if(temp<=array[i].dep && array[i].DONE==0 && array[i].FLAG==flag)
 	  return i;
   }
 return -1;
 }
 
 
 
 void main()
 {
 int i,n,na,nb,time,j;
 Schedule *sA;
 Schedule *sB;
 int t1,t2,t3,t4;
 char ch;
 FILE *file1=fopen(αcode2.inα,αrα);
 FILE *file2=fopen(αresult2.inα,αwα);
 fscanf(file1,α%dα,&n);
 for(i=1;i<=n;i++)
   {
   fscanf(file1,α%dα,&time);
   Time getarnd(0,time);
   fscanf(file1,α%d%dα,&na,&nb);
   sA=(Schedule*)malloc(sizeof(Schedule)*na);
   for(j=0;j<na;j++)
 	 {
 	 fscanf(file1,α%dα,&t1);
 	 ch=fgetc(file1);
 	 fscanf(file1,α%dα,&t2);
 	 fscanf(file1,α%dα,&t3);
 	 ch=fgetc(file1);
 	 fscanf(file1,α%dα,&t4);
 	 sA[j].dep.hr=t1;    sA[j].dep.min=t2;
 	 sA[j].arr.hr=t3;    sA[j].arr.min=t4;
 	 sA[j].FLAG=0;       sA[j].DONE=0;
 	 }
   sB=(Schedule*)malloc(sizeof(Schedule)*nb);
 	 for(j=0;j<nb;j++)
 	 {
 	 fscanf(file1,α%dα,&t1);
 	 ch=fgetc(file1);
 	 fscanf(file1,α%dα,&t2);
 	 fscanf(file1,α%dα,&t3);
 	 ch=fgetc(file1);
 	 fscanf(file1,α%dα,&t4);
 	 sB[j].dep.hr=t1;    sB[j].dep.min=t2;
 	 sB[j].arr.hr=t3;    sB[j].arr.min=t4;
 	 sB[j].FLAG=1;       sB[j].DONE=0;
 	 }
   sort(sB,nb);
   sort(sA,na);
   Schedule *combine=(Schedule*)malloc(sizeof(Schedule)*(na+nb));
   int k=0;
   for(j=0;j<na;j++)
 	 combine[k++]=sA[j];
   for(j=0;j<nb;j++)
 	 combine[k++]=sB[j];
 
   sort(combine,na+nb);
   /*for(k=0;k<na+nb;k++)
 	 {
 	 printf(α%d:%d  %d:%dα,combine[k].dep.hr,combine[k].dep.min);
 	 printf(α%d:%d  %d:%dα,combine[k].arr.hr,combine[k].arr.min);
 	 }
     printf(αnα);
     getch();  */
   int cA=0,cB=0,in=0;
   in=select(combine,na+nb);
   while(in!=-1)
   {
   if(combine[in].FLAG==0)
 	 {
 	 cA++;
 	 combine[in].DONE=1;
 	 while(in<na+nb)
 		{
 		if(combine[in].FLAG==0)
 		  {
 		  in=next(combine,in,1,na+nb,getarnd);
 		  if(in==-1)
 			 break;
 		  }
 		else
 		  {
 		  in=next(combine,in,0,na+nb,getarnd);
 		  if(in==-1)
 			 break;
 		  }
 		combine[in].DONE=1;
 		}
 	 }
   else
 	 {
 	 cB++;
 	 combine[in].DONE=1;
 	 while(in<na+nb)
 		{
 		if(combine[in].FLAG==0)
 		  {
 		  in=next(combine,in,1,na+nb,getarnd);
 		  if(in==-1)
 			 break;
 		  }
 		else
 		  {
 		  in=next(combine,in,0,na+nb,getarnd);
 		  if(in==-1)
 			 break;
 		  }
 		combine[in].DONE=1;
 		}
 	 }
 	in=select(combine,na+nb);
   }
   printf(α%d %dnα,cA,cB);
  fprintf(file2,αCase #%d: %d %d%cα,i,cA,cB,10);
 
  free(combine);
  free(sB);
  free(sA);
 
   }
 
 fclose(file1);
 fclose(file2);
 }"
27726,2008,32013,bogdandrutu,24480,1,prob1.c,gcj/2008/32013/bogdandrutu/24480/1/extracted/prob1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define inf 10000000;
 
 int minim (int a , int b)
     {
     return a>b ? b : a;    
     }
     
 int main ()
 {
 
 FILE *f=fopen(αdate.inα,αrα), *g=fopen(αdate.outα,αwα);
 int T,na,nb,i,k,j,min;
 char **x;
 char *s;
 int a[1005][105];
 
 x=(char **) calloc (1001,sizeof (char*));
 s=(char *) calloc (105,sizeof (char));
 fscanf (f,α%dnα,&T);    
 for (k=1;k<=T;k++)
     {
     min=-1;
     fscanf (f,α%dnα,&na); 
     for (i=0;i<na;i++)
            {
            x[i]=(char *) calloc (105,sizeof (char));
            fgets(x[i],105,f);
            }
     fscanf (f,α%dnα,&nb);
     if (nb==0) 
        min=0;
     else
             {
             for (i=0;i<nb;i++)
                {
                fgets(s,105,f);
                for (j=0;j<na;j++)
                    if (strcmp(x[j],s)!=0)
                       a[i+1][j]=minim(a[i][j],min+1);
                    else a[i+1][j]=inf;
                min=inf;    
                for (j=0;j<na;j++)
                    min=minim(min,a[i+1][j]);
                }
             } 
     fprintf(g,αCase #%d: %dnα,k,min);
     }
 }"
27728,2008,32013,bogdandrutu,24481,1,2.c,gcj/2008/32013/bogdandrutu/24481/1/extracted/2.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int digit (char c)     
     {
     return c-'0';    
     }
     
     
 int main ()
 {
 FILE *f=fopen(αdate.inα,αrα), *g=fopen(αdate.outα,αwα);
 int T,t,na,nb,i,p,s,nra,nrb,r,k;
 char *x;
 int *a;
 int *b;
 x=(char *) calloc (100,sizeof (char));
 fscanf (f,α%dnα,&T);    
 for (k=1;k<=T;k++)
     {
     fscanf (f,α%dnα,&t);          
     fscanf (f,α%d %dnα,&na,&nb);     
     a=(int *) calloc (2000,sizeof (int));
     b=(int *) calloc (2000,sizeof (int)); 
     for (i=0;i<na;i++)
            {
            fgets(x,100,f);
            p=(10*digit(x[0])+digit(x[1]))*60+10*digit(x[3])+digit(x[4]);
            s=(10*digit(x[6])+digit(x[7]))*60+10*digit(x[9])+digit(x[10]);
            a[p]+=1;
            b[s+t]-=1;
            }
            
     for (i=0;i<nb;i++)
            {
            fgets(x,100,f);
            p=(10*digit(x[0])+digit(x[1]))*60+10*digit(x[3])+digit(x[4]);
            s=(10*digit(x[6])+digit(x[7]))*60+10*digit(x[9])+digit(x[10]);
            b[p]+=1;
            a[s+t]-=1;
            } 
     r=0;
     nra=0;
     for (i=0;i<24*60+t;i++)
         {
         r+=a[i];
         if (r>0) 
            {
            nra+=r;
            r=0;
            }
         }
     r=0;
     nrb=0;
     for (i=0;i<24*60+t;i++)
         {
         r+=b[i];
         if (r>0) 
            {
            nrb+=r;
            r=0;
            }
         }
     fprintf(g,αCase #%d: %d %dnα,k,nra,nrb);
     }
 }"
27745,2008,32013,whuwinnie,24480,1,md.c,gcj/2008/32013/whuwinnie/24480/1/extracted/md.c,"#include <stdio.h>
 #include <string.h>
 #define N 102
 int main()
 {
 	int i, j, t, n, k, q, tag[N], total, ans, answer[21];
 	char exm[N], s[N][N];
 	scanf(α%dnα,&t);
 	for(i = 0; i < t; i++)
 	{
 		scanf(α%dnα,&n);
 		for(j = 0; j < n; j++)
 			gets(s[j]);
 		scanf(α%dnα,&q);
 		memset(tag, 0 ,sizeof(tag));
 		total = n;
 		ans = 0;
 		for(j = 0; j < q; j++)
 		{
 			gets(exm);
 			for(k = 0; k <n; k++)
 				if(strcmp(s[k], exm) == 0)
 				{
 					if(tag[k] == 0)
 					{
 						tag[k] = 1;
 						total--;
 					}
 					break;
 				}
 			if(total == 0)
 			{
 				ans++;
 				memset(tag, 0, sizeof(tag));
 				total = n - 1;
 				tag[k] = 1;
 			}
 		}
 		answer[i] = ans;
 	}
 	for(i = 0; i < t; i++)
 		printf(αCase #%d: %dnα, i+1, answer[i]);
 	return 0;
 }"
27760,2008,32013,groo,24480,1,cj1.c,gcj/2008/32013/groo/24480/1/extracted/cj1.c,"#include <stdio.h>
 #include <string.h>
 #define MAX_LEN   200
 #define MAX_S     100
 #define MAX_Q     1000
 #define INF       2000
 char se[MAX_S][MAX_LEN];
 char query[MAX_LEN];
 
 int sol[MAX_S][MAX_Q];
 int n, s, q;
 int computeOptimal(int pos, char *q)
 {
     int i, j;
     if(pos == 0)
     {
           for(i=0; i<s; i++)
           {
                    if(!strcmp(q, &se[i][0]))
                    {
                     /* Use any other and switch */
                     sol[i][pos] = 1;
                    }
                    else
                    {
                     sol[i][pos] = 0;
                    }
           } 
           return 0;
     }
     
     for(i=0; i<s; i++)
     {
             if(!strcmp(q, &se[i][0]))
             {
              sol[i][pos] = INF;
              for(j=0; j<s; j++)
              {
               if(j == i)
               {
                   if((sol[j][pos-1]+2)<sol[i][pos])
                   {
                    sol[i][pos] = sol[j][pos-1]+2;
                   }
               }
               else
               {
                   if((sol[j][pos-1]+1)<sol[i][pos])
                   {
                    sol[i][pos] = sol[j][pos-1]+1;
                   }
               }
              }
             }
             else
             {
              /* Previous move is the min    */    
              sol[i][pos] = sol[i][pos-1];
             } 
     }
 }
 int main()
 {
  int i, j, minpos, cs = 0;
  
  scanf(α%dα,&n);
  while(n--)
  {
   cs++;
   scanf(α%dα,&s);
   getchar();
   for(i=0; i<s; i++)
   {
    scanf(α%[^n]α, &se[i][0]);
    getchar();
   }
   scanf(α%dα, &q);
   getchar();
   for(i=0; i<q; i++)
   {
    scanf(α%[^n]α,query);
    getchar();
    computeOptimal(i, query);
   }
   minpos = 0;
   for(i=0; i<s; i++)
   {
    if(sol[i][q-1] < sol[minpos][q-1])
    minpos = i;
   }
  /* for(i=0; i<s; i++)
   {
   for(j=0; j<q; j++)
   printf(α%d α, sol[i][j]);
   printf(αnα);
   }*/
   //printf(αCase #%d: %d (%d %s)nα, cs, sol[minpos][q-1], minpos, &se[minpos][0]);
   printf(αCase #%d: %dnα, cs, sol[minpos][q-1]);
  }
  getchar();
  return 0;
 }"
27762,2008,32013,groo,24479,1,cj3.c,gcj/2008/32013/groo/24479/1/extracted/cj3.c,"#include <stdio.h>
 #include <math.h>
 #define PI (3.14159265f)
 double absol(double x)
 {
        if(x < 0)
        return (-x);
        else
        return x;
 }
 double getStripArea(double R, double t, double pos)
 {
        if(pos > (R-t))
        {
         return 0.0f;
        }
        return absol(pos*sqrt((R-t)*(R-t)-(pos*pos))/2 - (((R-t)*(R-t)*acos(pos/(R-t)))/2));
 }
 double areaOf1Section(double R, double t, double x, double y, double g)
 {
        double tmp;
        double v1, v2;
             
        v1 = getStripArea(R, t, y);
        v2 = getStripArea(R, t, sqrt((R-t)*(R-t)-x*x));
         
        return ((v1-v2)-absol((sqrt((R-t)*(R-t)-x*x))-y)*x);
 }
 double areaOf2Section(double R, double t, double x, double y, double g)
 {
        double tmp;
        double v1, v2;
             
        v1 = getStripArea(R, t, y);
        v2 = getStripArea(R, t, y+g);
             
        return ((v1-v2)-g*x);
 }
 double areaOf3Section(double R, double t, double x, double y, double g)
 {
        double tmp;
        double v1, v2;
             
        v1 = getStripArea(R, t, y+g);
        v2 = getStripArea(R, t, sqrt((R-t)*(R-t)-(x+g)*(x+g)));
             
        return (((v2-v1)-absol(((y+g)-sqrt((R-t)*(R-t)-(x+g)*(x+g)))*x))+g*(sqrt((R-t)*(R-t)-(x+g)*(x+g))-y));
 }
 double subtractSquare(double R, double t, double x, double y, double g)
 {
        if((((x+g)*(x+g)+(y+g)*(y+g))<=((R-t)*(R-t))))
        {
                    /* Completely in            */
                    return (4*(g)*(g));
        }
        
        if(((x+g)*(x+g)+y*y)>(R-t)*(R-t))
        {
          if(((y+g)*(y+g)+x*x)>(R-t)*(R-t))
          {
           //printf(αReturning 1 %lf (%lf %lf %lf)nα, 4*areaOf1Section(R,t,x,y,g), x, y, sqrt(x*x+y*y));
           return (4*areaOf1Section(R,t,x,y,g));
          }
          else
          {
           //printf(αReturning 2 %lf (%lf %lf %lf)nα, 4*areaOf2Section(R,t,x,y,g), x, y, sqrt(x*x+y*y));
           return (4*areaOf2Section(R,t,x,y,g));
          }
        }  
        else
        {
          if(((y+g)*(y+g)+x*x)>(R-t)*(R-t))
          {
           //printf(αReturning 3 %lf (%lf %lf %lf)nα, 4*areaOf2Section(R,t,y,x,g), x, y, sqrt(x*x+y*y));
           return (4*areaOf2Section(R,t,y,x,g));
          }
          else
          {
           //printf(αReturning 4 %lf (%lf %lf %lf)nα, 4*areaOf3Section(R,t,x,y,g), x, y, sqrt(x*x+y*y));
           return (4*areaOf3Section(R,t,x,y,g));
          } 
        }        
 }
 
 int main()
 {
     int n;
     double x, y;
     double f, R, t, r, g;
     double availArea;
     int cs = 0;
     scanf(α%dα, &n);
     while(n--)
     {
      cs++;
      scanf(α%lf%lf%lf%lf%lfα, &f, &R, &t, &r, &g);
 
      if(g < (2*f))
      {
           printf(αCase #%d: %lfnα, cs, 1.0f);
           continue;
      }
 
      availArea = 0.0f;
      /* Now consider each square */
      for(x=(r+f); x<(R-t-f); x+=(g+2*r))
      {
        for(y=(r+f); y<(R-t-f); y+=(g+2*r))
        {
         if((x*x+y*y)<((R-t-f)*(R-t-f)))
         availArea+=subtractSquare(R, t+f, x, y, g-(2*f));
        }
      }  
      printf(αCase #%d: %lfnα, cs, 1.0f-(availArea/(PI*R*R)));  
     }
     getchar();
         getchar();
             getchar();
     return 0;
 }"
27764,2008,32013,groo,24481,1,cj2.c,gcj/2008/32013/groo/24481/1/extracted/cj2.c,"#include <stdio.h>
 #define MAX 200
 #define INF (30*60)
 
 int avail_a[INF], avail_b[INF];
 int dep_a[MAX], arr_b[MAX];
 int dep_b[MAX], arr_a[MAX];
 int n, na, nb, t;
 int sola, solb;
 
 int main()
 {
     int cs = 0;
     int hr, min;
     int i, j, nxt_t, nxt_s, nxt_p;
     scanf(α%dα,&n);
     
     while(n--)
     {
      cs++;
      scanf(α%dα,&t);
      scanf(α%d%dα,&na,&nb);
      for(i=0; i<na; i++)
      {
       scanf(α%02d:%02dα,&hr,&min);
       dep_a[i] = hr*60+min;
       scanf(α%02d:%02dα,&hr,&min);
       arr_b[i] = hr*60+min;
      }
      for(i=0; i<nb; i++)
      {
       scanf(α%02d:%02dα,&hr,&min);
       dep_b[i] = hr*60+min;
       scanf(α%02d:%02dα,&hr,&min);
       arr_a[i] = hr*60+min;
      }
      /*for(i=0; i<na; i++)
      printf(α%d->%dnα, dep_a[i], arr_b[i]);
      for(i=0; i<nb; i++)
      printf(α%d->%dnα, dep_b[i], arr_a[i]);*/
      sola = 0;
      solb = 0;
      for(i=0; i<INF; i++)
      {
       avail_a[i] = avail_b[i] = 0;
      }
      for(i=0; i<(na+nb); i++)
      {
       nxt_t = INF;
       nxt_s = 0;
       nxt_p = 0;
       /* find next train   */
       for(j=0; j<na; j++)
       {
        if(dep_a[j] < nxt_t)
        {
         nxt_t = dep_a[j];
         nxt_s = 0;
         nxt_p = j;
        }
       }
       for(j=0; j<nb; j++)
       {
        if(dep_b[j] < nxt_t)
        {
         nxt_t = dep_b[j];
         nxt_s = 1;
         nxt_p = j;
        }
       }
       /* check if train available */
       for(j=nxt_t; j>=0; j--)
       {
        if(nxt_s == 0)
        {
         if(avail_a[j] > 0)
         {
          avail_a[j]--;
          break;
         }
        }
        else
        {
         if(avail_b[j] > 0)
         {
          avail_b[j]--;
          break;
         }
        }
       }
       if(j<0)
       {
        if(nxt_s == 0)
        sola++;
        else
        solb++;
       }
       /* make it available        */
       if(nxt_s == 0)
       {
        avail_b[arr_b[nxt_p]+t]++;
       }
       else
       {
        avail_a[arr_a[nxt_p]+t]++;
       }
       /* remove train    */
       if(nxt_s == 0)
       {
        dep_a[nxt_p] = INF;
       }
       else
       {
        dep_b[nxt_p] = INF;
       }      
      }
      printf(αCase #%d: %d %dnα, cs, sola, solb);
     }
     return 0;
 }"
27873,2008,32013,emmmanueles,24480,1,a.c,gcj/2008/32013/emmmanueles/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int cstring_cmp(const void *a, const void *b)
 {
     const char **ia = (const char **)a;
     const char **ib = (const char **)b;
     return strcmp(*ia, *ib);
 }
 
 
 int main(int argc, char* argv[]){
 	FILE* input;
 	int testCases;
 	int numeroBuscadores, numeroBusquedas;
 	char** nombresBuscadores;
 	int i, j, k, l;
 	int* contadores;
 	char** aux;
 	char** encontradoAnterior;
 	char* buffer;
 	char* prueba = αHolaα;
 	int contadorConCero;
 	int contadorGeneral;
 
 	buffer = (char*) malloc(sizeof(char)*100);
 
 	if (argc < 2)
 		return -1;
 
 	if ((input = fopen(argv[1],αrα)) == NULL){
 		printf(αError al abrir archivonα);
 		return -1;
 	}
 
 	fscanf(input, α%dnα, &testCases);
 
 	for (i=0; i<testCases; i++){
 		//cargar buscadores
 		fscanf(input, α%dnα, &numeroBuscadores);
 		nombresBuscadores = (char**)malloc(numeroBuscadores*sizeof(char*));
 		contadores = (int*)malloc(numeroBuscadores*sizeof(int));
 
 
 		for (j=0; j< numeroBuscadores; j++){
 			fscanf(input, α%[^n]nα, buffer);
 			nombresBuscadores[j] = (char*)malloc(strlen(buffer) + 1);
 			strcpy(nombresBuscadores[j], buffer);
 		}
 		//Ordenar buscadores
 		qsort(nombresBuscadores, numeroBuscadores, sizeof(char *), cstring_cmp);
 
 		fscanf(input, α%dnα, &numeroBusquedas);
 
 		//reset contadores
 		for (j=0; j< numeroBuscadores; j++){
 			contadores[j] = 0;
 		}		
 
 		encontradoAnterior = NULL;
 		contadorGeneral = 0;
 
 		for(j=0; j<numeroBusquedas; j++){
 			fscanf(input, α%[^n]nα, buffer);
 			aux = (char**) bsearch(&buffer, nombresBuscadores, numeroBuscadores, sizeof(char *), cstring_cmp);
 			if (aux != NULL) {
 				contadores[aux - nombresBuscadores] = contadores[aux - nombresBuscadores] + 1;
 
 				contadorConCero = 0;				
 				for(l=0; l<numeroBuscadores; l++){
 					if (contadores[l] == 0)
 						contadorConCero++;
 				}
 
 				if (contadorConCero == 0){
 					for (k=0; k< numeroBuscadores; k++){
 						contadores[k] = 0;
 					}
 					contadores[aux - nombresBuscadores] = 1;
 
 
 					if (encontradoAnterior == aux){
 	  					contadorGeneral+=2;
 					} else {
 						contadorGeneral++;
 					}
 					encontradoAnterior = aux;
 				}
 
 			} 
 
 		}
 
 		for(j=0; j< numeroBuscadores; j++)
 			free(nombresBuscadores[j]);
 
 		free(nombresBuscadores);
 		printf(αCase #%d: %dnα, i + 1, contadorGeneral);
 	}
 
 
 	free(buffer);
 	return 0;
 }"
27971,2008,32013,Akerfeldt,24480,1,qualify.c,gcj/2008/32013/Akerfeldt/24480/1/extracted/qualify.c,"#define _CRT_SECURE_NO_WARNINGS 1
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #include <string.h>
 
 char *engines[100];
 int queries[100];
 
 int compare(const void *a, const void *b)
 {
 	return strcmp(*(char**)a, *(char**)b);
 }
 
 int scompare (const void * ina, const void * inb)
 {
 	char *tempa, *tempb;
 	
 	tempa = (char*)ina;
 	tempb = *(char**)inb;
 
 	return strcmp(tempa,tempb);
 }
 
 int subsolve(int index, int start, int Q)
 {
 	int j;
 
 	for(j=start; j<Q; j++)
 	{
 		if(queries[j] == index)
 		{
 			return j-start;
 		}
 	}
 
 	return j-start;
 }
 
 int solve(int Q, int S)
 {
 	int i, j, maxSwitches=2147483647, numSwitches=-1, dist, temp;
 
 	j=0;
 	dist=0;
 	while(j < Q)
 	{
 		numSwitches++;
 		for(i=0; i<S; i++)
 		{
 			temp = subsolve(i, j, Q);
 			if(temp > dist)
 			{
 				dist = temp;
 			}
 		}
 		j+=dist;		
 	}
 
 	return numSwitches;
 }
 
 int solver(int index, int start, int Q, int S)
 {
 	int i, j, numSwitches=2147483647, temp;
 
 	j=start;
 	while(j < Q)
 	{
 		if(index == queries[j])
 		{
 			for(i=0; i<S; i++)
 			{
 				if(i != index)
 				{
 					temp = solver(i, j, Q, S) + 1;
 					if(temp < numSwitches)
 					{
 						numSwitches = temp;
 					}
 				}
 			}
 			return numSwitches;
 		}
 		j++;
 	}
 
 	return 0;
 }
 
 int main(int argc, char *argv[])
 {
 	char *tmp;
 	char buf[256], **temp;
 	int N, S, Q, i, j, k, ts, numSwitches;
 
 	for(i=0; i<100; i++)
 	{
 		engines[i] = malloc(101);
 		tmp = engines[i];
 		tmp[0] = '0';
 	}
 
 	gets(buf);
 	sscanf(buf, α%dα, &N);
 	for(i=0; i<N; i++)
 	{
 		numSwitches=0;
 
 		gets(buf);
 		sscanf(buf, α%dα, &S);
 		for(j=0; j<S; j++)
 		{
 			gets(buf);
 			memcpy(engines[j], buf, 101);
 		}
 		qsort(engines, S, sizeof(char *), compare);
 
 		gets(buf);
 		sscanf(buf, α%dα, &Q);
 		for(j=0; j<Q; j++)
 		{
 			gets(buf);
 			temp = (char**)bsearch(buf, engines, S, sizeof(char *), scompare);
 			queries[j]=(int)(temp-engines);
 		}
 
 		if(Q == 0)
 		{
 			printf(αCase #%d: %dnα, i+1, 0);
 		}
 		else
 		{
 			numSwitches=2147483647;
 			for(j=0; j<S; j++)
 			{
 				ts = solver(j, 0, Q, S);
 				if(ts < numSwitches)
 				{
 					numSwitches = ts;
 				}
 			}
 			//numSwitches = solve(Q, S);
 			printf(αCase #%d: %dnα, i+1, numSwitches);
 		}		
 	}
 	for(i=0; i<100; i++)
 	{
 		free(engines[i]);
 	}
 	return 0;
 }"
28031,2008,32013,sacredrealm,24480,1,Salvar.c,gcj/2008/32013/sacredrealm/24480/1/extracted/Salvar.c,"#include <stdio.h>
 #include <string.h>
 #define MAX 101
 #define TAM 102
 
 char browser[MAX][TAM];
 
 int binsearch(char x[], int n)
 {
    int valor, low, high, mid;
    low = 0;
    high = n - 1;
    while (low <= high) 
    {
       mid = (low+high)/2;
       if ((valor = strcmp(x, browser[mid])) < 0)
          high = mid - 1;
       else if (valor > 0)
          low = mid + 1;
       else /* found match */
          return mid;
    }
    return -1; /* no match */
 }
 
 void shellsort(int n)
 {
    int gap, i, j;
    char temp[TAM];
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && strcmp(browser[j], browser[j+gap]) > 0; j-=gap) 
          {
             strcpy(temp, browser[j]);
             strcpy(browser[j], browser[j+gap]);
             strcpy(browser[j+gap], temp);
          }
    return;
 }
 
 int main()
 {
     int i, j, k, casos, s, q, cont, suma, indice, flags[MAX];
     char query[TAM];
     scanf(α%dnα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &s);/*numero de browsers*/
         for(i = 0; i < s; i++){
             for(j = 0; (browser[i][j] = getchar()) != 'n'; j++);
             browser[i][j] = '0';
         }
         shellsort(s);
 /*        for(i = 0; i < s; i++)
             printf(α%s'nα, browser[i]);*/
         suma = cont = 0;
         for(i = 0; i < s; i++)
             flags[i] = 0;
         scanf(α%dnα, &q);/*numero de consultas*/
         for(i = 0; i < q; i++){
             for(j = 0; (query[j] = getchar()) != 'n' && query[j] != EOF; j++);
             query[j] = '0';
             indice = binsearch(query, s);
             if(indice != -1){
                 if(flags[indice] == 0){
                     flags[indice] = 1;
                     suma++;
                 }
                 if(suma == s){
                     for(j = 0; j < s; j++)
                         flags[j] = 0;
                     flags[indice] = 1;
                     cont++;
                     suma = 1;
                 }
             }
 /*            for(j = 0; j < s; j++)
                 printf(α%d α, flags[j]);
             printf(αn%3d suma = %3d indice = %3d %s'nnα, i+1, suma, indice, query);*/
         }
         printf(αCase #%d: %dnα, k, cont);
     }
     return 0;
 }"
28033,2008,32013,sacredrealm,24481,1,Tren.c,gcj/2008/32013/sacredrealm/24481/1/extracted/Tren.c,"#include <stdio.h>
 #define MAX 102
 #define SALE 0
 #define LLEGA 1
 
 int empalma(int llega[], int sale[], int n, int m, int tiempo)
 {
     int i, j, cont = 0;
     for(i = j = 0; i < n && j < m; j++){
         if(sale[j] >= (llega[i]+tiempo))
             i++;
         else
             cont++;
     }
     if(j < m){
         cont += (m-j);
     }
     return cont;
 }
 
 void shellsort(int v[], int n)
 {
    int gap, i, j, temp;
    for (gap = n/2; gap > 0; gap /= 2)
       for (i = gap; i < n; i++)
          for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) 
          {
             temp = v[j];
             v[j] = v[j+gap];
             v[j+gap] = temp;
          }
    return;
 }
 
 void imprime(int m[2][MAX], int n)
 {
     int i;
     printf(α%dnα, n);
     for(i = 0; i < n; i++)
         printf(α%d %dnα, m[SALE][i], m[LLEGA][i]);
     return;
 }
 
 int hmilitar(int horas, int minutos)
 {
     return (horas * 60) + minutos;
 }
 
 int main()
 {
     int a, b, c, d, i, k, salena, salenb, tiempo, casos, na, nb, ab[2][MAX], ba[2][MAX];
     scanf(α%dα, &casos);
     for(k = 1; k <= casos; k++){
         scanf(α%dnα, &tiempo);
         scanf(α%d%dnα, &na, &nb);
         for(i = 0; i < na; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ab[SALE][i] = hmilitar(a, b);
             ab[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ab[SALE][i], ab[LLEGA][i]);*/
         }
         for(i = 0; i < nb; i++){
             scanf(α%d:%d %d:%dnα, &a, &b, &c, &d);
             ba[SALE][i] = hmilitar(a, b);
             ba[LLEGA][i] = hmilitar(c, d);
 /*            printf(α%02d:%02d %02d:%02d %d %dnα, a, b, c, d, ba[SALE][i], ba[LLEGA][i]);*/
         }
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[SALE], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[LLEGA], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salena = empalma(ba[LLEGA], ab[SALE], nb, na, tiempo);
         /*Primero ordeno en base a las salidas de A*/
         shellsort(ab[LLEGA], na);
         /*Por lo que ordeno en base a las llegadas de B*/
         shellsort(ba[SALE], nb);
 /*        imprime(ab, na);
         imprime(ba, nb);*/
         salenb = empalma(ab[LLEGA], ba[SALE], na, nb, tiempo);
         printf(αCase #%d: %d %dnα, k, salena, salenb);
     }
     return 0;
 }"
28119,2008,32013,palas,24480,1,stu.c,gcj/2008/32013/palas/24480/1/extracted/stu.c,"#include <stdio.h>
 #include <string.h>
 
 #define _GNU_SOURCE
 
 struct engine {
   char *name;
   int size;
   int named;
 };
 
 int main(int argc, char *argv)
 {
   int cases, i;
   int nengin;
   scanf(α%dα, &cases);
   for (i = 1; i <= cases; i++)
   {
     int switches = 0;
     struct engine engines[100];
     int j, k, l;
     int numeng, numque;
     int numnamed = 0;
     scanf(α%dnα, &numeng);
     for (j = 0; j < numeng; j++)
     {
       engines[j].name = NULL;
       getline(&(engines[j].name), &(engines[j].size), stdin);
       engines[j].name[engines[j].size] = '0';
       engines[j].named = 0;
     }
     scanf(α%dnα, &numque);
     numnamed = 0;
     for (j = 0; j < numque; j++)
     {
       char *query;
       int qsize;
       query = NULL;
       getline(&(query), &(qsize), stdin);
       query[qsize] = '0';
       k = 0;
       while (strcmp(engines[k].name,query)) k++;
       if (!engines[k].named) numnamed++;
       engines[k].named = 1;
       if (numnamed >= numeng)
       {
 	switches++;
 	numnamed = 1;
 	for (l = 0; l < numeng; l++)
 	  engines[l].named = 0;
       }
       engines[k].named = 1;
     }
     printf(αCase #%d: %dnα, i, switches);    
   }
   return 0;
 }"
28121,2008,32013,palas,24481,1,tt.c,gcj/2008/32013/palas/24481/1/extracted/tt.c,"#include <stdio.h>
 
 struct trayecto {
   int inicio;
   int fin;
 };
 
 int comparador(const void *a, const void *b)
 {
   if ((((struct trayecto *)a)->inicio) < (((struct trayecto *)b)->inicio))
     return -1;
   if ((((struct trayecto *)a)->inicio) == (((struct trayecto *)b)->inicio))
     return 0;
   if ((((struct trayecto *)a)->inicio) > (((struct trayecto *)b)->inicio))
     return 1;
 
 }
 
 int main(int argc, char *argv)
 {
   int i, cases;
   scanf(α%dnα, &cases);
   for (i = 1; i <= cases; i++)
   {
     int T;
     int NA, NB;
     int j, Aa, Ba, tiempo;
     int trenesA = 0;
     int trenesB = 0;
     int tenA[1440];
     int tenB[1440];
     for (j = 0; j < 1440; j++) {
       tenA[j] = 0;
       tenB[j] = 0;
     }
     struct trayecto AB[100], BA[100];
     scanf(α%dnα, &T);
     scanf(α%d %dnα, &NA, &NB);
     for (j = 0; j < NA; j++) {
       int a1, a2, a3, a4;
       scanf(α%d:%d %d:%dnα, &a1, &a2, &a3, &a4);
       AB[j].inicio = a1 * 60 + a2;
       AB[j].fin = a3 * 60 + a4;
     }
     for (j = 0; j < NB; j++) {
       int b1, b2, b3, b4;
       scanf(α%d:%d %d:%dnα, &b1, &b2, &b3, &b4);
       BA[j].inicio = b1 * 60 + b2;
       BA[j].fin = b3 * 60 + b4;
     }
     qsort(AB, NA, sizeof(struct trayecto), comparador);
     qsort(BA, NB, sizeof(struct trayecto), comparador);
     Aa = 0;
     Ba = 0;
     while ((Ba < NB) || (Aa < NA)) {
       int contador;
       if ((Ba >= NB) || ((Aa < NA) && (AB[Aa].inicio < BA[Ba].inicio))) {
 	if (tenA[AB[Aa].inicio] < 0) printf(αERRORR!!!nα);
         if (tenA[AB[Aa].inicio] <= 0) trenesA++;
 	else {
 	  for (contador = AB[Aa].inicio; contador < 1440; contador++) {
 	    tenA[contador]--;
 	  }
 	}
 	for (contador = AB[Aa].fin + T; contador < 1440; contador++) {
 	  tenB[contador]++;
 	}
 	Aa++;
       } else {
 	if (tenB[BA[Ba].inicio] < 0) printf(αERRORR!!!nα);
 	if (tenB[BA[Ba].inicio] <= 0) trenesB++;
 	else {
 	  for (contador = BA[Ba].inicio; contador < 1440; contador++) {
 	    tenB[contador]--;
 	  }
 	}
 	for (contador = BA[Ba].fin + T; contador < 1440; contador++) {
 	  tenA[contador]++;
 	}
 	Ba++;
       }
     }
     printf(αCase #%d: %d %dnα, i, trenesA, trenesB);
   }
   return 0;
 }"
28144,2008,32013,hitesh88,24480,1,jam1.c,gcj/2008/32013/hitesh88/24480/1/extracted/jam1.c,"// Hitesh Gupta
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 
 int compar(const void *a, const void *b) {
 	return strcmp((const char *) a, (const char *)b);
 }
 
 int main() {
 	int t,s,q,i,j,k,l,ans,strike, arr[100];
 	char query[109], engine[109][109];
 	char * tmp;
 	scanf(α%dα,&t);
 	for(j=1;j<=t;j++) {
 		ans = strike = 0;
 		for(l=0;l<100;l++) arr[l] = 0;
 		scanf(α%dα,&s);
 		for(i=0;i<s;i++) {
 			scanf(α %[^n]α,engine[i]);
 		}
 		qsort((void *)engine, s, 109, compar);
 		//for(i=0;i<s;i++) 
 		//	printf(α%snα,engine[i]);
 		scanf(α%dα,&q);
 		for(i=0;i<q;i++) {
 			scanf(α %[^n]α,query);
 			tmp = (char *)bsearch((const void *)query, (const void*) engine, s, 109, compar);
 			//printf(α%dnα,tmp-engine[0]);
 			k = (tmp - engine[0])/109;
 			if(arr[k] == 0) {
 				arr[k] = 1;
 				strike ++;
 			}
 			if(strike == s) {
 				ans++;
 				for(l=0;l<100;l++) arr[l] = 0;
 				arr[k] = 1;
 				strike = 1;
 			}
 			
 		}
 		printf(αCase #%d: %dnα,j,ans);
 	}
 	return 0;
 }"
28146,2008,32013,hitesh88,24481,1,jam2.c,gcj/2008/32013/hitesh88/24481/1/extracted/jam2.c,"// Hitesh Gupta
 
 #include <stdio.h>
 
 typedef struct trips {
 	int start ;
 	int end ;
 	int station;
 }trip;
 
 int compar(const void *a, const void *b) {
 	trip aa = *(trip *)a;
 	trip bb = *(trip *)b;
 	if(aa.start < bb.start)
 		return -1;
 	else if(aa.start == bb.start)
 		return 0;
 	return 1;
 }
 
 void myinsert(int *arr, int a, int size) {
 	int i;
 	for(i=size-1;i>=0;i--) {
 		if(arr[i] > a) {
 			arr[i+1] = arr[i];
 		}
 		else  
 			break;
 	}
 	arr[i+1] = a;
 }
 
 
 int main() {
 	int t,i,j,k,tmp1,tmp2,tmp3,tmp4,tu,na,nb,ticka, tickb, sizea, sizeb, ansa, ansb;
 	int readya[209],readyb[209];
 	trip arr[209];
 	scanf(α%dα,&t);
 	for (k=1;k<=t;k++) {
 		scanf(α%d %d %dα,&tu, &na, &nb);
 		for(i=0;i<na;i++) {
 			scanf(α%d:%d %d:%dα,&tmp1, &tmp2, &tmp3, &tmp4);
 			arr[i].start = tmp1*60+tmp2;
 			arr[i].end = tmp3*60+tmp4;
 			arr[i].station = 1;
 		}
 		for(i=0;i<nb;i++) {
 			scanf(α%d:%d %d:%dα,&tmp1, &tmp2, &tmp3, &tmp4);
 			arr[i+na].start = tmp1*60+tmp2;
 			arr[i+na].end = tmp3*60+tmp4;
 			arr[i+na].station = 2;
 		}
 		qsort((void *)arr,na+nb,sizeof(trip),compar);
 		//for(i=0;i<na+nb;i++)
 		//	printf(α%dnα,arr[i].start);
 		ticka = tickb = sizea = sizeb = ansa = ansb = 0;
 		for(i=0;i<na+nb;i++) {
 			if(arr[i].station == 1) {
 				if(ticka == sizea || arr[i].start < readya[ticka]) {
 					myinsert(readyb,arr[i].end+tu,sizeb++);
 					ansa++;
 				}
 				else {
 					ticka++;
 					myinsert(readyb,arr[i].end+tu,sizeb++);
 				}
 			}
 			if(arr[i].station == 2) {
 				if(tickb == sizeb || arr[i].start < readyb[tickb]) {
 					myinsert(readya,arr[i].end+tu,sizea++);
 					ansb++;
 				}
 				else {
 					tickb++;
 					myinsert(readya,arr[i].end+tu,sizea++);
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα,k,ansa,ansb);
 	}
 	return 0;
 }"
28223,2008,32013,Raim,24481,1,B.c,gcj/2008/32013/Raim/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 typedef struct {
     int time;
     char loc;
     int act;
 } event;
 
 event events[400];
 
 int eventcmp(const void *aa, const void *bb) {
     event *a = (event*) aa;
     event *b = (event*) bb;
 
     if (a->time == b->time) {
         if (a->act < b->act) {
             return 1;
         } else if (a->act > b->act) {
             return -1;
         } else {
             return 0;
         }
     }
 
     return a->time - b->time;
 }
 
 int main() {
     unsigned int cases;
     scanf(α%uα, &cases);
 
     for (unsigned int cas = 1; cas <= cases; cas++) {
         unsigned int t;
         unsigned int starta = 0;
         unsigned int startb = 0;
         int cura = 0;
         int curb = 0;
         unsigned int na, nb;
         unsigned int ne = 0;
 
         scanf(α%uα, &t);
         scanf(α%u %uα, &na, &nb);
 
         for (unsigned int i = 0; i < na; i++) {
             unsigned int hab, mab, han, man;
             unsigned int ab, an;
 
             scanf(α%u:%u %u:%uα, &hab, &mab, &han, &man);
             ab = hab * 60 + mab;
             an = han * 60 + man;
 
             events[ne].time = ab;
             events[ne].loc = 'a';
             events[ne].act = -1;
             ne++;
             events[ne].time = an+t;
             events[ne].loc = 'b';
             events[ne].act = +1;
             ne++;
         }
 
         for (unsigned int i = 0; i < nb; i++) {
             unsigned int hab, mab, han, man;
             unsigned int ab, an;
 
             scanf(α%u:%u %u:%uα, &hab, &mab, &han, &man);
             ab = hab * 60 + mab;
             an = han * 60 + man;
 
             events[ne].time = ab;
             events[ne].loc = 'b';
             events[ne].act = -1;
             ne++;
             events[ne].time = an+t;
             events[ne].loc = 'a';
             events[ne].act = +1;
             ne++;
         }
 
         qsort(events, ne, sizeof(event), eventcmp);
 
         for (unsigned int i = 0; i < ne; i++) {
             switch (events[i].loc) {
                 case 'a':
                     if (events[i].act == -1) {
                         cura--;
                         if (cura < 0) {
                             starta++;
                             cura = 0;
                         }
                     } else {
                         cura++;
                     }
                     break;
                 case 'b':
                     if (events[i].act == -1) {
                         curb--;
                         if (curb < 0) {
                             startb++;
                             curb = 0;
                         }
                     } else {
                         curb++;
                     }
                     break;
                 default:
                     exit(3);
                     break;
             }
         }
 
         printf(αCase #%d: %u %unα, cas, starta, startb);
     }
 
     return 0;
 }"
28317,2008,32013,zfzgodfather,24481,1,2.c,gcj/2008/32013/zfzgodfather/24481/1/extracted/2.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 int convert(char * buff)
 {
 	return (buff[4]-48)+(buff[3]-48)*10+((buff[0]-48)*10+(buff[1]-48))*60;
 }
 void sort(int * a,int beg,int end)
 {
 	int i=beg,j=end;
 	int key,temp;
 
 	key=a[(i+j)/2];
 	do
 	{
 		while(a[i]<key)
 			i++;
 		while(a[j]>key)
 			j--;
 		if(i<=j)
 		{
 			temp=a[i];
 			a[i]=a[j];
 			a[j]=temp;
 			i++;
 			j--;
 		}
 	}while(i<=j);
 	if(beg<j)
 		sort(a,beg,j);
 	if(i<end)
 		sort(a,i,end);
 }
 int main()
 {
 	int cases,i,j,k;
 	int a,b,t;
 	int alea[100];
 	int aarr[100];
 	int blea[100];
 	int barr[100];
 	int ca,cb,ma,mb;
 	char buffl[6],buffa[6];
 
 	scanf(α%dα,&cases);
 	for(i=0;i<cases;i++)
 	{
 		ca=0;cb=0;
 		scanf(α%dα,&t);
 		scanf(α%d%dα,&a,&b);
 		for(j=0;j<a;j++)
 		{
 			scanf(α%s%sα,buffl,buffa);
 			alea[j]=convert(buffl);
 			aarr[j]=convert(buffa)+t;
 		}
 		for(j=0;j<b;j++)
 		{
 			scanf(α%s%sα,buffl,buffa);
 			blea[j]=convert(buffl);
 			barr[j]=convert(buffa)+t;
 		}
 		if(a==0)
 		{
 			printf(αCase #%d: 0 %dnα,i+1,b);
 			continue;
 		}
 		if(b==0)
 		{
 			printf(αCase #%d: %d 0nα,i+1,a);
 			continue;
 		}
 		sort(alea,0,a-1);
 		sort(aarr,0,a-1);
 		sort(blea,0,b-1);
 		sort(barr,0,b-1);
 
 		k=0;j=0;
 		while(k<b&&j<a)
 		{
 			if(alea[j]<barr[k])
 			{
 				j++;
 			}
 			else
 			{
 				ca++;
 				k++;
 				j++;
 			}
 		}
 		k=0;j=0;
 		while(k<a&&j<b)
 		{
 			if(blea[j]<aarr[k])
 			{
 				j++;
 			}
 			else
 			{
 				cb++;
 				k++;
 				j++;
 			}
 		}
 		printf(αCase #%d: %d %dnα,i+1,a-ca,b-cb);
 	}
 	return 0;
 }"
28342,2008,32013,shravas,24480,1,AQ.c,gcj/2008/32013/shravas/24480/1/extracted/AQ.c,"#include <stdio.h>
 
 int N, S, Q, T, A;
 int DP[1005][1005];
 int C[1005];
 char X[1005][105], R[105];
 
 int equals(int at)
 {
 	int i;
 	
 	for(i=0; i<T; i++)
 	{
 		if(X[at][i] != R[i])
 			return 0;	
 	}
 	
 	return 1;
 }
 
 int main()
 {
 	FILE *input;
 	int i, j, k, l, y;
 	char c;	
 
 	input = fopen(αAQ.inα, αrα);
 	fscanf(input, α%dnα, &N);
 	
 	for(i=0; i<N; i++)
 	{
 		fscanf(input, α%dnα, &S);
 		
 		for(j=0; j<S; j++)
 		{
 			c = 0;
 			for(k=0; c != 'n'; k++)
 			{
 				fscanf(input, α%cα, &c);
 				X[j][k] = c;
 			}
 			
 			DP[0][j] = 0;
 		}
 		
 		fscanf(input, α%dnα, &Q);
 		
 		for(j=0; j<Q; j++)
 		{
 			c = 0;
 			for(k=0; c!='n'; k++)
 			{
 				fscanf(input, α%cα, &c);
 				R[k] = c;
 			}
 			
 			T = k;
 			
 			for(k=0; k<S; k++)
 			{
 				if(equals(k))
 					break;
 			}
 			
 			C[j] = k;
 		}
 		
 		A = -1;
 		for(j=1; j<=Q; j++)
 		{
 			for(k=0; k<S; k++)
 			{
 				DP[j][k] = 0;
 				if(k == C[j-1])
 					continue;
 				c = 0;
 				for(l=0; l<S; l++)
 				{
 					if(j != 1 && l == C[j-2])
 						continue;
 					y = 1;
 					if(l == k)
 						y = 0;
 					if(c == 0 || DP[j-1][l]+y < DP[j][k])
 					{
 						DP[j][k] = DP[j-1][l]+y;
 						c = 1;
 					}	
 				}
 				
 				if(j == Q)
 				{
 					if(A == -1 || A > DP[j][k])
 						A = DP[j][k];
 				}
 			}
 		}
 		
 		if(A == -1)
 			A = 0;
 
 		printf(αCase #%d: %dnα, i+1, A);
 	}
 	
 	return 0;
 }"
28355,2008,32013,RodrigoBurgos,24481,1,train.c,gcj/2008/32013/RodrigoBurgos/24481/1/extracted/train.c,"# include <stdio.h>
 # include <string.h>
 
 
 int A[102][2];
 int B[102][2];
 int vis[2][102], tm;
 
 int hash[ 2 ], na, nb;
 int cont;
 
 void revisa( int tiempo, int lado, int position ){
    int nextlado = ( lado + 1) % 2, x;
    vis[ lado ][ position ] = 1;
    int P = (1<<22), T = (1<<22);
    for( x = 0 ; x < ( nextlado == 0 ? na : nb ); x++){
      if( vis[ nextlado ][  x ] == 1) continue;
      if( nextlado == 0){
         if( A[x][ 0 ] >= tiempo && T > A[x][ 0 ]){
           T = A[x][ 0 ];
           P = x;
         } 
      }
      else{
         if( B[x][ 0 ] >= tiempo && T > B[x][ 0 ]){
           T = B[x][ 0 ];
           P = x;
         } 
      }
    }
    if( P == (1<<22)) return;
    if( nextlado == 0 )
      revisa( A[ P ][ 1 ] + tm, nextlado, P);
    else
      revisa( B[ P ][ 1 ] + tm, nextlado, P);
    
 }
 
 main(){
   int h, m, set, casos, x, pos, num, lado;
   freopen(αrata.inα,αrα,stdin);
   freopen(αsalida.outα,αwα, stdout);
   for( scanf(α%dα, &casos) , set = 1 ; casos-- && scanf(α%dα, &tm) != EOF; set++ ){
     scanf(α%d %dα, &na, &nb);
     for( x = 0; x < na; x++){
       scanf(α%d:%dα, &h, &m);
       A[ x ][ 0 ] = ( h * 60) + m;
       scanf(α%d:%dα, &h, &m);
       A[ x ][ 1 ] = ( h * 60) + m;
     }
     for( x = 0; x < nb; x++){
       scanf(α%d:%dα, &h, &m);
       B[ x ][ 0 ] = ( h * 60) + m;
       scanf(α%d:%dα, &h, &m);
       B[ x ][ 1 ] = ( h * 60) + m;
     }
     cont = 0;
     memset( vis, 0, sizeof( vis));
     memset( hash, 0, sizeof( hash));
     while( 1 ){
       pos = -1;
       num = (1<<22);
       lado = -1;
       for( x = 0; x < na; x++)
         if( vis[0][ x ] == 0 && A[x][ 0 ] < num ){
           num = A[ x ][ 0 ];
           lado = 0;
           pos = x;
         }
       for( x = 0; x < nb; x++)
         if( vis[1][ x ] == 0 && B[x][ 0 ] < num ){
           num = B[ x ][ 0 ];
           lado = 1;
           pos = x;
         }
       if( pos == -1) break;
       if( lado == 0)
         revisa( A[ pos ][ 1] + tm, lado, pos );
       else
         revisa( B[ pos ][ 1] + tm, lado, pos );
       hash[ lado ]++;
     }
     printf(αCase #%d: %d %dnα, set, hash[0], hash[1]);
   }
   return 0;   
 }"
28363,2008,32013,blackJack,24480,1,A.c,gcj/2008/32013/blackJack/24480/1/extracted/A.c,"#include <stdio.h>
 
 int N;
 char S[100][100];
 int flag[100];
 char Q[1000][100];
 int numS,numQ;
 int countLeft;
 int posSE;
 
 void initFlag(){
   int j;
   countLeft = numS;
   for(j=0;j<numS;j++)
     flag[j]=1;
 }
 
 int matchWithS(int posQ){
   int j;
   for(j=0;j<numS;j++){
     if((strcmp(S[j],Q[posQ]) == 0) && (flag[j]==1)){
       flag[j] = 0;
       return j;
     }
   }
   return -1;
 }
 
 int matchWithSE(int posQ){
   if(strcmp(S[posSE],Q[posQ]) == 0){
     return posSE;
   }
   else return -1;
 
 }
 int findposSE(){
   int j;
   for(j=0;j<numS;j++){
     if(flag[j] == 1){
       posSE = j;
       return(0);
     }
   }
   printf(αerrornα);
 }
 
 
 int main(){
   int posQ;
   int i,j,numSwitch;
 
   scanf(α%dα,&N);
   for(i=1;i<=N;i++){
     scanf(α%dα,&numS);getchar();
     for(j=0;j<numS;j++){
       fgets(S[j],100,stdin);
     }
     scanf(α%dα,&numQ);getchar();
     for(j=0;j<numQ;j++){
       fgets(Q[j],100,stdin);
     }
     posQ = 0;numSwitch=0;
     initFlag();
     while(posQ < numQ){
       if((matchWithS(posQ)) >= 0){
 	posQ++;
 	countLeft--;
 	//if only one is left
 	if(countLeft == 1){
 	  findposSE();
 	  //printf(α%d %d %dnα,posSE,posQ,numQ);
 	  while(posQ < numQ){
 	    if(matchWithSE(posQ) >= 0){
 	      numSwitch++;
 	      //posQ--;
 	      initFlag();
 	      //flag[posSE] = 0;countLeft--;
 	      break;
 	    }
 	    else posQ++;
 	  }
 	}
       }
       else{
 	posQ++;
       }
     }
     printf(αCase #%d: %dnα,i,numSwitch);
 /*     for(j=1;j<=numS;j++){ */
 /*       printf(α%sα,S[j]); */
 /*     } */
 /*     for(j=1;j<=numQ;j++){ */
 /*       printf(α%sα,Q[j]); */
 /*     } */
 
   }
   return 0;
 }"
28365,2008,32013,blackJack,24481,1,B.c,gcj/2008/32013/blackJack/24481/1/extracted/B.c,"#include <stdio.h>
 
 int N;
 int Turn;
 int numAB,numBA;
 int trA,trB;
 typedef struct tim{
   int hr,min;
 }time;
 char strDepA[100][7],strArrB[100][7],strDepB[100][7],strArrA[100][7];
 time depA[100],depB[100],arrA[100],arrB[100];
 int flagDepA[100],flagDepB[100],flagArrA[100],flagArrB[100];
 
 void convAB(int pos){
   sscanf(strDepA[pos],α%d:%dα,&depA[pos].hr,&depA[pos].min);
   sscanf(strArrB[pos],α%d:%dα,&arrB[pos].hr,&arrB[pos].min);
   arrB[pos].min += Turn;
   if(arrB[pos].min >= 60){arrB[pos].hr++;arrB[pos].min-=60;}
   
 }
 void convBA(int pos){
   sscanf(strDepB[pos],α%d:%dα,&depB[pos].hr,&depB[pos].min);
   sscanf(strArrA[pos],α%d:%dα,&arrA[pos].hr,&arrA[pos].min);
   arrA[pos].min += Turn;
   if(arrA[pos].min >= 60){arrA[pos].hr++;arrA[pos].min-=60;}
 }
 void initFlags(){
   int j;
   for(j=0;j<numAB;j++){
     flagDepA[j]=1;flagArrB[j]=1;}
   for(j=0;j<numBA;j++){
     flagDepB[j]=1;flagArrA[j]=1;}
 }
 int extractTrainDepA(){
   int j,flag=0;
   int minPos=-1,minTime=2359;
   for(j=0;j<numAB;j++){
     if(flagDepA[j]==1 && (minTime>(100*depA[j].hr+depA[j].min))){
       minPos = j;minTime=100*depA[j].hr+depA[j].min;
     }
   }
   if(minPos >= 0)flagDepA[minPos]=0;
   return minPos;
 }
 int findMinArrA(){
   int j,flag=0;
   int minPos=-1,minTime=2359;
   for(j=0;j<numBA;j++){
     if(flagArrA[j]==1 && (minTime>(100*arrA[j].hr+arrA[j].min))){
       minPos = j;minTime=100*arrA[j].hr+arrA[j].min;
     }
   }
   return minPos;  
 }
 
 int extractTrainDepB(){
   int j,flag=0;
   int minPos=-1,minTime=2401;
   for(j=0;j<numBA;j++){
     if(flagDepB[j]==1 && (minTime>(100*depB[j].hr+depB[j].min))){
       minPos = j;minTime=100*depB[j].hr+depB[j].min;
     }
   }
   if(minPos >= 0)flagDepB[minPos]=0;
   return minPos;
 }
 int findMinArrB(){
   int j,flag=0;
   int minPos=-1,minTime=2401;
   for(j=0;j<numAB;j++){
     if(flagArrB[j]==1 && (minTime>(100*arrB[j].hr+arrB[j].min))){
       minPos = j;minTime=100*arrB[j].hr+arrB[j].min;
     }
   }
   return minPos;  
 }
 
 
 int main(){
   int i,j;
   int posDepA,posDepB,posArrA,posArrB;
 
   scanf(α%dα,&N);
   for(i=1;i<=N;i++){
     scanf(α%dα,&Turn);
     scanf(α%d%dα,&numAB,&numBA);
     for(j=0;j<numAB;j++){
       scanf(α%s%sα,strDepA[j],strArrB[j]);
       convAB(j);
     }
     for(j=0;j<numBA;j++){
       scanf(α%s%sα,strDepB[j],strArrA[j]);
       convBA(j);
     }
     trA = trB = 0;
     initFlags();
     while((posDepA = extractTrainDepA()) >= 0){
       posArrA = findMinArrA();
       if(posArrA == -1)trA++;
       else if((arrA[posArrA].hr < depA[posDepA].hr)||(arrA[posArrA].hr==depA[posDepA].hr && arrA[posArrA].min<=depA[posDepA].min)){
 	flagArrA[posArrA]=0;
       }else{
 	//printf(α%snα,strDepA[posDepA]);
 	trA++;
       }
     }
     while((posDepB = extractTrainDepB()) >= 0){
       posArrB = findMinArrB();
       if(posArrB == -1)trB++;
       else if((arrB[posArrB].hr < depB[posDepB].hr)||(arrB[posArrB].hr==depB[posDepB].hr && arrB[posArrB].min<=depB[posDepB].min)){
 	flagArrB[posArrB]=0;
       }else{
 	//printf(α-%snα,strDepB[posDepB]);
 	trB++;
       }
     }
     printf(αCase #%d: %d %dnα,i,trA,trB);
 
 /*     for(j=0;j<numAB;j++){ */
 /*       printf(α%d.%d  %d.%dnα,depA[j].hr,depA[j].min,arrB[j].hr,arrB[j].min); */
 /*     } */
 /*     for(j=0;j<numBA;j++){ */
 /*       printf(α%d.%d  %d.%dnα,depB[j].hr,depB[j].min,arrA[j].hr,arrA[j].min); */
 /*     } */
   }
 
   return 0;
 }"
28550,2008,32013,quarks,24481,1,ttlarge.c,gcj/2008/32013/quarks/24481/1/extracted/ttlarge.c,"#include<stdio.h>
 
 struct entry
 {
        char from ;
        char to ;
        char start[6] ;
        char end[6];
 } ;
 
 struct trains
 {
        char time[6];
        struct trains * next ;
 } ;
 
 struct trains *atrains=NULL, *btrains=NULL;
 
 FILE *fp, *ip, *logg ;
 
 struct entry ae[201] ;
 int na, nb, turn ;
 
 
 
 int great ( char e1[], char e2[] )
 {
     if ( e1[0] > e2[0] )
        return 1 ;
     else if ( e1[0] < e2[0] )
          return 0 ;
     
     if ( e1[1] > e2[1] )
        return 1 ;
     else if ( e1[1] < e2[1] )
          return 0 ;
     
     if ( e1[3] > e2[3] )
        return 1 ;
     else if ( e1[3] < e2[3] )
          return 0 ;
     
     if ( e1[4] > e2[4] )
        return 1 ;
     else if ( e1[4] < e2[4] )
          return 0 ;
     
     return 1 ;
 }
 
 void sort ()
 {
      int tot, i, j ;
      struct entry key ;
      
      tot = na+nb ;
      
      for ( j=1; j<tot; j++ )
      {
          key = ae[j] ;
          i = j-1 ;
          while ( i>=0 && great(ae[i].start, key.start) )
          {
                ae[i+1] = ae[i] ;
                i-- ;
          }
          ae[i+1] = key ;
      }
 }
 
 struct trains* available ( char fr, char ti[] )
 {
        struct trains *root ;
        if ( fr == 'a' )
           root = atrains ;
        else if ( fr == 'b' )
             root = btrains ;
        
        while ( root->next != NULL )
        {
              if ( great (ti, root->next->time) )
                 {
                 fprintf ( logg, αnwanted=%s at %cα, ti, fr ) ;
                 fprintf ( logg, αnpresent=%s at %cα, root->next->time, fr ) ;
                 return root->next ;
                 }
              root = root->next ;
        }
        
        return root->next ;
 }
 
 void removet ( char fr, struct trains* torem )
 {
      struct trains *root ;
      if ( fr == 'a' )
           root = atrains;
        else if ( fr == 'b' )
             root = btrains;
 
      while ( root->next != NULL )
      {
            if ( root->next == torem )
            {
               root->next = root->next->next ;
               return ;
            }
               
            root = root->next ;
      }
 }
 
 void add ( char to, char ti[] )
 {
      struct trains *root, *temp ;
      char added[6], carry ;
      int ttt, hr, min ;
      
      if ( to == 'a' )
           root = atrains ;
        else if ( to == 'b' )
             root = btrains ;
      
      added[5] = '0' ;
      added[2] = ':' ;
      
      ttt = turn + (ti[4]-'0') + (ti[3]-'0')*10 + ( ((ti[1]-'0') + (ti[0]-'0')*10)*60 ) ;
      
      min = ttt % 60 ;
      hr = ttt / 60 ;
      
      fprintf ( logg, αninserted at %cnhr=%dtmin=%dnα, to, hr, min ) ;
      
      if ( hr > 23 )
         return ;
         
      added[0] = (hr / 10) + '0' ;
      added[1] = (hr % 10) + '0' ;
      added[3] = (min / 10) + '0' ;
      added[4] = (min % 10) + '0' ;
      
      while ( root->next != NULL )
      {
            if ( great (root->next->time, added ) )
               break ;
            root = root->next ;
      }
        
      temp = ( struct trains * ) malloc ( sizeof ( struct trains ) ) ;
      strcpy ( temp->time, added ) ;
      temp->time[5] = '0' ;
      temp->next = root->next ;
      root->next = temp ;
 }
 
 
 
 int main ()
 {
     int testcases, i, j ;
     int results[101][2] ;
     struct trains *trainstemp ;
 
     ip = fopen ( αB-large.inα, αrα ) ;
     fp = fopen ( αttlargeo.txtα, αwα ) ;    
     logg = fopen ( αttsmalllog.txtα, αwα ) ;    
     
     fscanf ( ip, α%dα, &testcases ) ;
     
     atrains = (struct trains *) malloc ( sizeof ( struct trains ) ) ;
     btrains = (struct trains *) malloc ( sizeof ( struct trains ) ) ;
     
     for ( i=0; i<testcases; i++ )
     {
         results[i][0] = results[i][1] = 0 ;
         
         trainstemp = NULL ;
 
         atrains->next = btrains->next = NULL ;
         
         fscanf ( ip, α%dα, &turn ) ;
         
         fscanf ( ip, α%dα, &na ) ;
         fscanf ( ip, α%dα, &nb ) ;
         
         for ( j=0; j<na; j++ )
         {
             fscanf ( ip, α%sα, ae[j].start ) ;
             fscanf ( ip, α%sα, ae[j].end ) ;
             ae[j].from = 'a' ;
             ae[j].to = 'b' ;
         }
         
         for ( j=0; j<nb; j++ )
         {
             fscanf ( ip, α%sα, ae[na+j].start ) ;
             fscanf ( ip, α%sα, ae[na+j].end ) ;
             ae[na+j].from = 'b' ;
             ae[na+j].to = 'a' ;
         }
         
         sort () ;
         
         for ( j=0; j<na+nb; j++ )
         {
             trainstemp = available ( ae[j].from, ae[j].start ) ;
             if ( trainstemp == NULL )
                results[i][ae[j].from - 'a']++ ;
             else
                 removet ( ae[j].from, trainstemp ) ;
             add ( ae[j].to, ae[j].end ) ;
         }
         
         fprintf ( fp, αCase #%d: %d %dnα, i+1, results[i][0], results[i][1] ) ;
         
     }
     
     fclose ( fp ) ;
     fclose ( ip ) ;
     
     return 0 ;
 }"
28601,2008,32013,Polaris,24481,1,train.c,gcj/2008/32013/Polaris/24481/1/extracted/train.c,"#include <stdio.h>
 
 struct time_t{
 	int hour;
 	int minute;
 };
 
 typedef struct time_t time;
 
 int timecmp(void *a, void *b){
 	return ((*(time *)a).hour - (*(time *)b).hour) * 60 + (*(time *)a).minute - (*(time *)b).minute;
 }
 
 int main(){
 	int n;
 	scanf(α%dnα, &n);
 	int index;
 	for (index = 0; index < n; index++){
 		time froma[100],tob[100],fromb[100],toa[100];
 		int t;
 		int a,b;
 		scanf(α%dnα, &t);
 		scanf(α%d %dnα, &a, &b);
 		int i;
 		for (i = 0; i < a; i++){
 			scanf(α%d:%d %d:%dnα, &(froma[i].hour),&(froma[i].minute), &(tob[i].hour), &(tob[i].minute));
 			tob[i].hour += (tob[i].minute + t) / 60;
 			tob[i].minute = (tob[i].minute + t) % 60;
 		}
 		for (i = 0; i < b; i++){
 			scanf(α%d:%d %d:%dnα, &(fromb[i].hour),&(fromb[i].minute), &(toa[i].hour), &(toa[i].minute));
 			toa[i].hour += (toa[i].minute + t) / 60;
 			toa[i].minute = (toa[i].minute + t) % 60;
 		}
 		qsort(froma, a, sizeof(time), timecmp);
 		qsort(tob, a, sizeof(time), timecmp);
 		qsort(fromb, b, sizeof(time), timecmp);
 		qsort(toa, b, sizeof(time), timecmp);
 		
 		int j;
 		int saveb;
 		i = 0;
 		j = 0;
 		while (j < b && i < a){
 			if (timecmp(&tob[i], &fromb[j]) <= 0){
 				i++;
 				j++;
 			}
 			else{
 				j++;
 			}
 		}
 		saveb = i;
 		
 		int savea;
 		i = 0;
 		j = 0;
 		while (j < a && i < b){
 			if (timecmp(&toa[i], &froma[j]) <= 0){
 				i++;
 				j++;
 			}
 			else{
 				j++;
 			}
 		}
 		savea = i;
 		printf(αCase #%d: %d %dnα, index + 1, a - savea, b - saveb);
 	}
 	return 0;
 }"
28637,2008,32013,Shubham,24480,1,Saving.c,gcj/2008/32013/Shubham/24480/1/extracted/Saving.c,"/* Header Files */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 /* Typedefs */
 #define U8 unsigned char
 #define S8 signed char
 #define U16 unsigned short
 #define S16 signed short
 #define U32 unsigned long
 #define S32 signed long
 #define FLT unsigned float
 #define DBL unsigned double
 
 /* Constants */
 #define MAXS 100
 #define MAXQ 1000
 
 /* Global Data */
 U8 z_SearchQueries[MAXQ];
 
 /* Local Function Declaration */
 S16 process(S8 *, S8 *);
 U8 fgetline(FILE *, S8 *);
 void GetTestParams(FILE *, U8 *, U16 *, U8 *);
 U32 AllocateSearch(U8 , U16 , U8 *);
 
 void main(int argc, char *argv[])
 {
 
 	U8 u_i;
 	S8 z_InputFile[100], z_OutputFile[100];
 
 	for(u_i = 1; u_i < argc; u_i++)
 	{
 
 		if(strncmp(argv[u_i], α-iα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-i%sα, z_InputFile);
 			
 		}
 		else if(strncmp(argv[u_i], α-oα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-o%sα, z_OutputFile);
 			
 		}
 		else
 			printf(αUnsupported input switchnα);
 	}
 
 	if(process(z_InputFile, z_OutputFile) == -1)
 		printf(αFile Errorsnα);
 }
 
 /* Function Definitions */
 S16 process(S8 *p_FileInput, S8 *p_FileOutput)
 {
 	FILE *p_Input;
 	FILE *p_Output;
 	S8 p_InputLine[256];
 	U8 u_NumTests;
 	U8 u_Counter;
 	U8 u_TestRun;
 
 	u_Counter = 1;
 
 	if( (p_Input = fopen(p_FileInput, αrα)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileInput);
 		return -1;
 	}
 
 	if( (p_Output = fopen(p_FileOutput, αw+α)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileOutput);
 		return -1;
 	}
 
 
 	/* Get Number of tests */
 	fgetline(p_Input, p_InputLine);
 	sscanf(p_InputLine, α%uα, &u_NumTests);
 
 	u_TestRun = u_NumTests;
 
 	while(u_TestRun--)
 	{
 		U8 u_S;
 		U16 w_Q;
 		U32 q_NumSwitch;
 
 		q_NumSwitch = 0;
 
 		/* Search Engines are represented by indexes in the Search Queries */
 		GetTestParams(p_Input, &u_S, &w_Q, z_SearchQueries);
 
 		/* Redistribute the queries in the order receievd */
 		q_NumSwitch = AllocateSearch(u_S, w_Q, z_SearchQueries);
 
 		/* Output the result */
 		printf(αCase #%d: %dα, u_Counter, q_NumSwitch);
 		fprintf(p_Output, αCase #%d: %dα, u_Counter, q_NumSwitch);
 
 		if(u_Counter++ != u_NumTests)
 			fprintf(p_Output, αnα);
 	}
 
 	/* Close the files */
 	fclose(p_Input);
 	fclose(p_Output);
 
 	return 0;
 }
 
 U8 fgetline(FILE *p_File, S8 *p_Buffer)
 {
 	S32 x_chr;
 
 	while( (x_chr = fgetc(p_File)) != EOF)
 	{
 		if(x_chr == 'n')
 			break;
 		
 		*p_Buffer++ = (U8)x_chr;
 		
 	}
 
 	*p_Buffer = '0';
 
 	if(x_chr == EOF)
 			return 0;
 	else
 		return 1;
 
 
 }
 
 /* No checks on input file errors are handled */
 void GetTestParams(FILE *p_FileName, U8 *pu_NumEngines, U16 *pw_NumQueries, U8 *pu_QueryNames)
 {
 	S8 *z_SearchEngines[MAXS];
 	S8 p_InputLine[256];
 	U16 w_i;
 
 	/* Next line has the total number of search engines */
 	fgetline(p_FileName, p_InputLine);
 	sscanf(p_InputLine, α%uα, pu_NumEngines);
 
 	/* Extract the engine names */
 	for(w_i = 0; w_i < *pu_NumEngines; w_i++)
 	{
 		fgetline(p_FileName, p_InputLine);
 
 		z_SearchEngines[w_i] = (S8 *) malloc(strlen(p_InputLine) + 1);
 
 		strcpy(z_SearchEngines[w_i], p_InputLine);
 	}
 
 	/* Next line has number of search queries */
 	fgetline(p_FileName, p_InputLine);
 	sscanf(p_InputLine, α%dα, pw_NumQueries);
 
 	/* Extract the search engines to be re-directed to. Stored as indices */
 	for(w_i = 0; w_i < *pw_NumQueries; w_i++)
 	{
 		U8 u_i;
 
 		fgetline(p_FileName, p_InputLine);
 
 		for(u_i = 0; u_i < *pu_NumEngines; u_i++)
 		{
 			if(strcmp(z_SearchEngines[u_i], p_InputLine) == 0)
 				pu_QueryNames[w_i] = u_i;
 		}
 	}
 
 	/* No need to remember search engine names - free up */
 	for(w_i = 0; w_i < *pu_NumEngines; w_i++)
 		free(z_SearchEngines[w_i]);
 }
 
 /* Look for the longest distance from source engine to all other engines */
 U32 AllocateSearch(U8 u_S, U16 w_Q, U8 *pu_SearchQueries)
 {
 	U16 w_i;
 	U8 z_Arr[MAXS];
 	U32 q_Switch;
 
 	q_Switch = 0;
 
 	/* Look for trivial case - if one of the search engines is missing, all of
 	 * the queries can be re-directed to it */
 	for(w_i = 0; w_i < w_Q; w_i++)
 	{
 		z_Arr[pu_SearchQueries[w_i]] = 0xFA;
 	}
 
 	for(w_i = 0; w_i < u_S; w_i++)
 	{
 		if(z_Arr[w_i] != 0xFA)
 			return q_Switch;
 	}
 
 	w_i = 0;
 
 	do
 	{
 		U8 u_EngineIndex;
 		U16 w_j, w_k;
 		U16 w_Longest;
 		U16 w_Length;
 
 		w_Longest = 0;
 
 		u_EngineIndex = pu_SearchQueries[w_i];
 
 		for(w_j = 0, w_k = w_i + 1; ((w_j < u_S) && (w_k < w_Q)); w_j++)
 		{
 			w_k = w_i + 1;
 			w_Length = 1;
 
 			if(w_j == u_EngineIndex)
 				continue;
 
 			while((pu_SearchQueries[w_k] != w_j) && (w_k < w_Q))
 			{
 				w_Length++;
 				w_k++;
 			}
 
 			if(w_Length > w_Longest)
 				w_Longest = w_Length;
 		}
 
 		w_i += w_Longest;
 
 		if(w_i < w_Q)
 			q_Switch++;
 		
 	} while(w_i < (w_Q - 1));
 
 	return q_Switch;
 }"
28639,2008,32013,Shubham,24481,1,train.c,gcj/2008/32013/Shubham/24481/1/extracted/train.c,"/* Header Files */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 /* Typedefs */
 #define U8 unsigned char
 #define S8 signed char
 #define U16 unsigned short
 #define S16 signed short
 #define U32 unsigned long
 #define S32 signed long
 #define FLT unsigned float
 #define DBL unsigned double
 
 /* Constants */
 
 
 /* Global Data */
 U8 u_TurnAroundTime;	/* Minutes */
 U16 z_DepartureTimeFromA[100];	/* Minutes */
 U16 z_ReadyForDepartureFromB[100];
 U16 z_DepartureTimeFromB[100];	/* Minutes */
 U16 z_ReadyForDepartureFromA[100];
 U8 u_NA, u_NB;
 
 
 /* Local Function Declaration */
 S16 process(S8 *, S8 *);
 U8 fgetline(FILE *, S8 *);
 void GetTestParams(FILE *);
 U8 FindArrivingTrain(U16 * ,U16, U8 );
 U32 compare_int(void *, void *);
 
 void main(int argc, char *argv[])
 {
 
 	U8 u_i;
 	S8 z_InputFile[100], z_OutputFile[100];
 
 	for(u_i = 1; u_i < argc; u_i++)
 	{
 
 		if(strncmp(argv[u_i], α-iα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-i%sα, z_InputFile);
 			
 		}
 		else if(strncmp(argv[u_i], α-oα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-o%sα, z_OutputFile);
 			
 		}
 		else
 			printf(αUnsupported input switchnα);
 	}
 
 	if(process(z_InputFile, z_OutputFile) == -1)
 		printf(αFile Errorsnα);
 }
 
 /* Function Definitions */
 S16 process(S8 *p_FileInput, S8 *p_FileOutput)
 {
 	FILE *p_Input;
 	FILE *p_Output;
 	S8 p_InputLine[256];
 	U8 u_NumTests;
 	U8 u_Counter;
 	U8 u_TestRun;
 	U16 w_i;
 	U16 w_NumTrainA, w_NumTrainB;
 
 	u_Counter = 1;
 
 	if( (p_Input = fopen(p_FileInput, αrα)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileInput);
 		return -1;
 	}
 
 	if( (p_Output = fopen(p_FileOutput, αw+α)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileOutput);
 		return -1;
 	}
 
 
 	/* Get Number of tests */
 	fgetline(p_Input, p_InputLine);
 	sscanf(p_InputLine, α%uα, &u_NumTests);
 
 	u_TestRun = u_NumTests;
 
 	while(u_TestRun--)
 	{
 		w_NumTrainA = 0;
 		w_NumTrainB = 0;
 
 		/* Extract Test Params */
 		GetTestParams(p_Input);
 
 		for(w_i = 0; w_i < u_NA; w_i++)
 		{
 			U16 w_DepTime;
 
 			w_DepTime = z_DepartureTimeFromA[w_i];
 
 			if(FindArrivingTrain(z_ReadyForDepartureFromA ,w_DepTime, u_NB) == 0)
 				w_NumTrainA++;
 		}
 
 		for(w_i = 0; w_i < u_NB; w_i++)
 		{
 			U16 w_DepTime;
 
 			w_DepTime = z_DepartureTimeFromB[w_i];
 
 			if(FindArrivingTrain(z_ReadyForDepartureFromB ,w_DepTime, u_NA) == 0)
 				w_NumTrainB++;
 		}
 
 		/* Output the result */
 		printf(αCase #%d: %d %dα, u_Counter, w_NumTrainA, w_NumTrainB);
 		fprintf(p_Output, αCase #%d: %d %dα, u_Counter, w_NumTrainA, w_NumTrainB);
 
 		if(u_Counter++ != u_NumTests)
 			fprintf(p_Output, αnα);
 	}
 
 	/* Close the files */
 	fclose(p_Input);
 	fclose(p_Output);
 
 	return 0;
 }
 
 U8 fgetline(FILE *p_File, S8 *p_Buffer)
 {
 	S32 x_chr;
 
 	while( (x_chr = fgetc(p_File)) != EOF)
 	{
 		if(x_chr == 'n')
 			break;
 		
 		*p_Buffer++ = (U8)x_chr;
 		
 	}
 
 	*p_Buffer = '0';
 
 	if(x_chr == EOF)
 			return 0;
 	else
 		return 1;
 
 
 }
 
 /* No checks on input file errors are handled */
 void GetTestParams(FILE *p_FileName)
 {
 	
 	S8 p_InputLine[256];
 	U16 w_i;
 	U32 q_Temp;
 	U32 q_Temp1;
 
 	fgetline(p_FileName, p_InputLine);;
 	sscanf(p_InputLine, α%udα, &q_Temp);
 
 	u_TurnAroundTime = (U8)q_Temp;
 
 	/* Next line has departure numbers */
 	fgetline(p_FileName, p_InputLine);
 	sscanf(p_InputLine, α%u %uα, &q_Temp, &q_Temp1);
 
 	u_NA = (U8)q_Temp;
 	u_NB = (U8)q_Temp1;
 
 	/* Extract the arrival & departure timings */
 	for(w_i = 0; w_i < u_NA; w_i++)
 	{
 		S8 s_Departure[10];
 		S8 s_Arrival[10];
 		U8 u_Hour, u_Min;
 
 		fgetline(p_FileName, p_InputLine);
 		sscanf(p_InputLine, α%s %sα, s_Departure, s_Arrival);
 		
 		sscanf(s_Departure, α%d:%dα, &u_Hour, &u_Min);
 		z_DepartureTimeFromA[w_i] = u_Hour * 60 + u_Min;
 	
 		sscanf(s_Arrival, α%d:%dα, &u_Hour, &u_Min);
 		z_ReadyForDepartureFromB[w_i] = u_Hour * 60 + u_Min + u_TurnAroundTime;
 	}
 
 	qsort(z_DepartureTimeFromA, u_NA, sizeof(U16), compare_int);
 	qsort(z_ReadyForDepartureFromB, u_NA, sizeof(U16), compare_int);
 
 	/* Extract the arrival & departure timings */
 	for(w_i = 0; w_i < u_NB; w_i++)
 	{
 		S8 s_Departure[10];
 		S8 s_Arrival[10];
 		U8 u_Hour, u_Min;
 
 		fgetline(p_FileName, p_InputLine);
 		sscanf(p_InputLine, α%s %sα, s_Departure, s_Arrival);
 		
 		sscanf(s_Departure, α%d:%dα, &u_Hour, &u_Min);
 		z_DepartureTimeFromB[w_i] = u_Hour * 60 + u_Min;
 	
 		sscanf(s_Arrival, α%d:%dα, &u_Hour, &u_Min);
 		z_ReadyForDepartureFromA[w_i] = u_Hour * 60 + u_Min + u_TurnAroundTime;
 	}
 
 	qsort(z_DepartureTimeFromB, u_NB, sizeof(U16), compare_int);
 	qsort(z_ReadyForDepartureFromA, u_NB, sizeof(U16), compare_int);
 }
 
 U8 FindArrivingTrain(U16 *pw_ReadyTimes ,U16 w_DepartureTime, U8 w_NumEntry)
 {
 	U16 w_i;
 
 	for(w_i = 0; w_i < w_NumEntry; w_i++)
 	{
 		if(pw_ReadyTimes[w_i] <= w_DepartureTime)
 		{
 			pw_ReadyTimes[w_i] = 0xABCD;
 			return 1;
 		}
 	}
 
 	return 0;
 }
 
 U32 compare_int(void *pw_Num1, void *pw_Num2)
 {
 	U16 w_Word1;
 	U16 w_Word2;
 
 	w_Word1 = *(U16 *)(pw_Num1);
 	w_Word2 = *(U16 *)(pw_Num2);
 
 	if(w_Word1 < w_Word2)
 		return -1;
 	else if(w_Word1 > w_Word2)
 		return 1;
 
 	return 0;
 	
 }"
28708,2008,32013,Schief,24480,1,main.c,gcj/2008/32013/Schief/24480/1/extracted/main.c,"/*
  * main.c
  *
  *  Created on: Jul 16, 2008
  *      Author: dfreeman
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 char **engines, **queries;
 int numEngines, numQueries;
 
 int proceed(int, int, int);
 
 int main(int argc, char *argv[])
 {
 	int i, j, caseNo, numCases;
 
 	FILE *in = fopen(αinput.inα, αrα);
 	char buffer[2048];
 	fgets(buffer, 2048, in);
 	sscanf(buffer, α%dα, &numCases);
 
 	for (caseNo=0; caseNo<numCases; caseNo++)
 	{
 		fgets(buffer, 2048, in);
 		sscanf(buffer, α%dα, &numEngines);
 		engines = (char **) malloc(numEngines*sizeof(char *));
 
 		for (i=0; i<numEngines; i++)
 		{
 			fgets(buffer, 2048, in);
 			engines[i] = (char *) malloc((strlen(buffer)+1)*sizeof(char));
 			sscanf(buffer, α%[^rn]α, engines[i]);
 		}
 
 		fgets(buffer, 2048, in);
 		sscanf(buffer, α%dα, &numQueries);
 
 		if (numQueries == 0)
 		{
 			free(engines);
 			printf(αCase #%d: 0nα, caseNo+1);
 		}
 		else
 		{
 			queries = (char **) malloc(numQueries*sizeof(char *));
 
 			for (i=0; i<numQueries; i++)
 			{
 				fgets(buffer, 2048, in);
 				queries[i] = (char *) malloc((strlen(buffer)+1)*sizeof(char));
 				sscanf(buffer, α%[^rn]α, queries[i]);
 			}
 
 
 			int qIndex = 0;
 			int switches = -1;
 			int longest = 0;
 			while (qIndex < numQueries)
 			{
 				for (i=0; i<numEngines; i++)
 				{
 					j=qIndex;
 					while (j < numQueries && strcmp(queries[j], engines[i]) != 0)
 						j++;
 					if (j>longest)
 						longest = j;
 				}
 				switches++;
 				qIndex = longest;
 			}
 
 			printf(αCase #%d: %dnα, caseNo+1, switches);
 			fflush(stdout);
 			free(queries);
 			free(engines);
 		}
 	}
 
 	return 0;
 }"
28862,2008,32013,gregdulli,24481,1,prob2.c,gcj/2008/32013/gregdulli/24481/1/extracted/prob2.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
 
 typedef struct time_s
 {
 	int	hours;
 	int	minutes;
 }sTime;
 
 static int getDifference(sTime lhs, sTime rhs)
 {
 	int result;
 
 	result = (lhs.hours - rhs.hours) * 60;
 
 	result += (lhs.minutes - rhs.minutes);
 
 	return result;
 }
 
 static void getLine(FILE *fp, char *str)
 {
 	int i;
 	char	ch;
 
 	i = 0;
 
 	// skip the possible line
 	ch = fgetc(fp);
 	if( ch != 'n' )
 	{
 		str[i] = ch;
 		i++;
 	}
 
 	while( (ch = fgetc(fp)) != 'n' )
 	{
 		str[i] = ch;
 		i++;
 	}
 	str[i] = '0';
 }
 
 static void addMinutes(sTime *st, int addMin)
 {
 	st->minutes += addMin;
 
 	while( st->minutes >= 60 )
 	{
 		st->minutes -= 60;
 		st->hours += 1;
 	}
 }
 
 static int howManyNonZero(sTime *sArray, int sizeArray)
 {
 	int i, nonZero;
 
 	nonZero = 0;
 
 	for( i = 0; i < sizeArray; i++ )
 	{
 		if( sArray[i].hours != -1 )
 			nonZero++;
 	}
 
 	return nonZero;
 }
 
 int main(int argc, char *argv[])
 {
 	int 	i, j, k;
 	int		dHours, dMinutes, aHours, aMinutes;
 	int		nInputs, nTurnaround, nFromA, nFromB, trainsA, trainsB;
 	sTime	*departuresA, *departuresB, *arrivalsA, *arrivalsB;
 	char	*strFloat;
 	int		currDiff, minDiff;
 	int		currIndex;
 
 	FILE	*fpIn, *fpOut;
 
 	if( argc != 3 )
 	{
 		printf(αERROR: Input and output filenames must be providednα);
 		exit(1);
 	}
 
 	// Opening input file
 	fpIn = fopen(argv[1], αrα);
 	if( !fpIn )
 	{
 		printf(αERROR: Could not open file %snα, argv[1]);
 		exit(2);
 	}
 
 	// Opening output file
 	fpOut = fopen(argv[2], αwα);
 	if( !fpOut )
 	{
 		printf(αERROR: Could not open file %snα, argv[2]);
 		exit(2);
 	}
 
 	// Read the number of inputs
 	fscanf(fpIn, α%dα, &nInputs);
 
 	// Main loop
 	for( i  = 0; i < nInputs; i++)
 	{
 		departuresA	= (sTime *) malloc (100 * sizeof(sTime));
 		departuresB	= (sTime *) malloc (100 * sizeof(sTime));
 		arrivalsA 	= (sTime *) malloc (100 * sizeof(sTime));
 		arrivalsB 	= (sTime *) malloc (100 * sizeof(sTime));
 
 		fscanf(fpIn, α%dα, &nTurnaround);
 		fscanf(fpIn, α%dα, &nFromA);
 		fscanf(fpIn, α%dα, &nFromB);
 
 		for( j = 0; j < nFromA; j++ )
 		{
 			fscanf(fpIn, α%d:%d %d:%dnα, &(departuresA[j].hours), &(departuresA[j].minutes), 
 										  &(arrivalsB[j].hours), &(arrivalsB[j].minutes));
 			addMinutes(&(arrivalsB[j]), nTurnaround);
 		}
 
 		for( j = 0; j < nFromB; j++ )
 		{
 			fscanf(fpIn, α%d:%d %d:%dnα, &(departuresB[j].hours), &(departuresB[j].minutes), 
 										  &(arrivalsA[j].hours), &(arrivalsA[j].minutes));
 			addMinutes(&(arrivalsA[j]), nTurnaround);
 		}
 		
 		for( j = 0; j < nFromB; j++ )
 		{
 			minDiff = -3600;
 			currIndex = -1;
 
 			for( k = 0; k < nFromA; k++ )
 			{
 				currDiff = getDifference( arrivalsA[j], departuresA[k] );
 				if( currDiff <= 0 && currDiff > minDiff )
 				{
 					currIndex = k;
 					minDiff = currDiff;
 				}
 			}
 			if( currIndex >= 0 )
 				departuresA[currIndex].hours = -1;
 		}
 
 		for( j = 0; j < nFromA; j++ )
 		{
 			minDiff = -3600;
 			currIndex = -1;
 
 			for( k = 0; k < nFromB; k++ )
 			{
 				currDiff = getDifference( arrivalsB[j], departuresB[k] );
 				if( currDiff <= 0 && currDiff > minDiff )
 				{
 					currIndex = k;
 					minDiff = currDiff;
 				}
 			}
 			if( currIndex >= 0 )
 				departuresB[currIndex].hours = -1;
 		}
 
 	
 		trainsA = howManyNonZero( departuresA, nFromA );
 		trainsB = howManyNonZero( departuresB, nFromB );
 
 		fprintf(fpOut, αCase #%d: %d %dnα, i + 1, trainsA, trainsB);
 
 		free(departuresA);
 		free(departuresB);
 		free(arrivalsA);
 		free(arrivalsB);
 	}
 
 	fclose(fpOut);
 	fclose(fpIn);
 }"
28996,2008,32013,tayeh10,24480,1,saving_the_universe_large.c,gcj/2008/32013/tayeh10/24480/1/extracted/saving_the_universe_large.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<malloc.h>
 #include<string.h>
 #include<assert.h>
 void main()
 {
 FILE *input,*output;int N,i,j,k,s_num,q_num,sw=0,count=0,max=0,arrive=0,arrive_temp;
 char s[100][100],q[1000][100],temp;
 input=fopen(αA-large.in.txtα,αrα);
 output=fopen(αA-large.out.txtα,αwα);
 if((!input) || (!output))
 {
 	printf(αCan't open filenα);
 	exit(1);
 }
 fscanf(input,α%dα,&N);
 if(!((N>0)&&(N<=20)))
 {
 	fprintf(output,αN is out of boundrynα);
 	exit(1);
 }
 for(i=0;i<N;i++)
 {
 	fscanf(input,α%dα,&s_num);
 	if(!((s_num>=2)&&(s_num<=100)))
 	{
 	fprintf(output,αS is out of boundrynα);
 	exit(1);
 	}
 	fscanf(input,α%cα,&temp);
 	for(j=0;j<s_num;j++)
 		for(k=0;k<100;k++)
 		{
 				fscanf(input,α%cα,&s[j][k]);
 				if(s[j][k]=='n')
 				{
 					s[j][k]=0;
 					break;
 				}
 		}
 	fscanf(input,α%dα,&q_num);
 	if(!((q_num>=0)&&(q_num<=1000)))
 	{
 	fprintf(output,αQ is out of boundrynα);
 	exit(1);
 	}
 	fscanf(input,α%cα,&temp);
 	for(j=0;j<q_num;j++)
 		
 		for(k=0;k<100;k++)
 		{
 				fscanf(input,α%cα,&q[j][k]);
 				if(q[j][k]=='n')
 				{
 					q[j][k]=0;
 					break;
 				}
 		}
 		k=0;
 		while(arrive!=q_num)
 		{
 			for(j=0;j<s_num;j++)
 			{
 				for(;k<q_num;k++)
 				{
 					if(strcmp(s[j],q[k]))
 					{
 						count++;
 						if(count>max)
 							max=count;
 					}
 					else
 						break;
 				}
 				k=arrive;
 				count=0;
 			}
 			arrive+=max;
 			k=arrive;
 			if(arrive!=q_num)
 				sw++;
 			max=0;
 		}
 		fprintf(output,αCase #%d: %dnα,i+1,sw);
 		arrive=0;
 		sw=0;
 }
 fclose(input);
 fclose(output);
 }"
29020,2008,32013,drewbenn,24480,1,a.c,gcj/2008/32013/drewbenn/24480/1/extracted/a.c,"#include <string.h>
 #include <stdio.h>
 #include αa.hα
 
 int main()
 {
   int loop = 0;
   int num_cases = 0;
   int result = 0;
 
   num_cases = getInteger();
   //printf(αnum_cases = %inα, num_cases);
 
   for (loop = 0; loop < num_cases; loop++)
     {
       result = caseInput();
       //printf(αexited caseInput()nα);
       printf(αCase #%i: %inα, loop + 1, result);
     }
   
   return 0;
 }
 
 int caseInput()
 {
   int num_switches = 0;  /* the result! */
   char temp_input[10];
   int loop = 0, loop_inside = 0;
   int num_engines = 0;
   int engines_used = 0;
   int loc = 0;           /* temp result of binary search */
   struct allEngines engine_list;
   struct allQueries query_list;
   memset(&engine_list, 0, sizeof(struct allEngines));
   
   engine_list.num_engines = getInteger();
   //printf(αNum engines: %inα, engine_list.num_engines);
 
   for (loop = 0; loop < engine_list.num_engines; loop++)
     {
       getString(engine_list.engine[loop].name);
       //printf(α%snα, engine_list.engine[loop].name);
     }
   
   query_list.num_queries = getInteger();
   //printf(αNum queries: %inα, query_list.num_queries);
   
   for (loop = 0; loop < query_list.num_queries; loop++)
     {
       getString(query_list.query[loop].name);
       //printf(α%snα, query_list.query[loop].name);
       query_list.query[loop].loc_in_engine_list = findInList(engine_list, query_list.query[loop].name);
     }
 
   // now do the fun stuff!
   
   num_switches = 0;
 
   num_engines = engine_list.num_engines;
   for (loop = query_list.num_queries - 1; loop >= 0; loop--)
     {
       loc = query_list.query[loop].loc_in_engine_list;
       if (engine_list.engine[loc].is_used == 0)
 	{
 	  engine_list.engine[loc].is_used = 1;
 	  engines_used++;
 	  if (engines_used == num_engines)
 	    {
 	      for (loop_inside = 0; loop_inside < engine_list.num_engines; loop_inside++)
 		{
 		  engine_list.engine[loop_inside].is_used = 0;
 		}
 	      engines_used = 1;
 	      engine_list.engine[loc].is_used = 1;
 	      num_switches++;
 	    }
 	}
     }
 
   //printf(αnum_switches = %inα, num_switches);
   return num_switches;
 }
 
 
 void getString(char* ret_string)
 {
   int string_length = 0;
   getStringNoStrip(ret_string);
   string_length = strlen(ret_string);
   ret_string[string_length - 1] = '0';
   return;
 }
 
 int getInteger()
 {
   int ret_integer;
   char temp_string[MAX_NAME_SIZE];
   getString(temp_string);
   sscanf(temp_string, α%iα, &ret_integer);
   return ret_integer;
 }
 
 void getStringNoStrip(char* ret_string)
 {
   fgets(ret_string, MAX_NAME_SIZE, stdin);
   return;
 }
 
 
 int findInList(struct allEngines list, char* search_string)
 {
   int ret_val = -1;
   int loop;
   for (loop = 0; (loop < list.num_engines) && (ret_val == -1); loop++)
     {
       if (!(strcmp(list.engine[loop].name, search_string)))
 	{
 	  ret_val = loop;
 	}
     }
   if (ret_val == -1)
     {
       printf(αFAIL!nα);
     }
   return ret_val;
 }"
29024,2008,32013,drewbenn,24481,1,b.c,gcj/2008/32013/drewbenn/24481/1/extracted/b.c,"/* compile with gcc on Ubuntu 8.10 */
 
 /***********************************************************
  * Plan of attack:
  * - construct an array for each of the two train stations
  * - the array covers each minute from 00:00 to 23:59
  * - fill up the array with the values from the input file
  * - +1 every time a train leaves
  * - -1 every time a train has arrived and turned around
  * - then count through the array:
  *   - start at 00:00
  *   - walk through until 23:59
  *   - the max value is the answer
  * Suggestions to speed things up:
  */
 
 #include <string.h>
 #include <stdio.h>
 #include αb.hα
 
 int main()
 {
   int loop = 0;
   int num_cases = 0;
   int result1 = 0, result2 = 0;
 
   num_cases = getInteger();
 
   for (loop = 0; loop < num_cases; loop++)
     {
       result1 = 0; result2 = 0;
       caseInput(&result1, &result2);
       printf(αCase #%i: %i %inα, loop + 1, result1, result2);
     }
   
   return 0;
 }
 
 void caseInput(int *ret_a, int *ret_b)
 {
   int loop = 0, outloop = 0, inloop = 0;
   int cur_a_trains = 0, cur_b_trains = 0;
   int turnaround_time = 0;
   int num_a_b = 0, num_b_a = 0;
   int out_hours = 0, out_minutes = 0;
   int in_hours = 0, in_minutes = 0;
   char num_a_b_string[10]; /* sufficient size for 2, 3-digit numbers separated by a space */
   char time_string[20]; /* sufficient size for HH:MM */
 
   memset(station_a_io, 0, sizeof(station_a_io));
   memset(station_b_io, 0, sizeof(station_b_io));
 
   turnaround_time = getInteger();
 
   getString(num_a_b_string);
   sscanf(num_a_b_string, α%i %iα, &num_a_b, &num_b_a);
 
   char who_cares[50];
   for (loop = 0; loop < num_a_b; loop++)
     {
       getString(time_string);
       /*
       sscanf(time_string, α%02i:%02i %02i:%02iα,
 	     &out_hours, &out_minutes,
 	     &in_hours, &in_minutes);
       */
       /* sscanf isn't working on the _first_ pass through this loop, only. Don't know why. So manually pulling out the time here: */
       out_hours = (time_string[0] - 0x30) * 10 + time_string[1] - 0x30;
       out_minutes = (time_string[3] - 0x30) * 10 + time_string[4] - 0x30;
       in_hours = (time_string[6] - 0x30) * 10 + time_string[7] - 0x30;
       in_minutes = (time_string[9] - 0x30) * 10 + time_string[10] - 0x30;
       
       //printf(α%s -- %02i:%02i %02i:%02inα, time_string, out_hours, out_minutes, in_hours, in_minutes);
 
       station_a_io[out_hours][out_minutes] += 1;
       in_minutes += turnaround_time;
       if (in_minutes >= MAX_MINUTES)
 	{
 	  in_minutes -= MAX_MINUTES;
 	  in_hours++;
 	}
       /* If the train arrives after midnight, we don't care about it. */
       if (in_hours < MAX_HOURS)
 	{
 	  station_b_io[in_hours][in_minutes] = station_b_io[in_hours][in_minutes] - 1;
 	}
     }
 
   /* repeat but going the other way. If I really cared I'd use a utility function here. But, this file is really one-time use so I'm not concerned about maintainability. */
   for (loop = 0; loop < num_b_a; loop++)
     {
       getString(time_string);
       out_hours = (time_string[0] - 0x30) * 10 + time_string[1] - 0x30;
       out_minutes = (time_string[3] - 0x30) * 10 + time_string[4] - 0x30;
       in_hours = (time_string[6] - 0x30) * 10 + time_string[7] - 0x30;
       in_minutes = (time_string[9] - 0x30) * 10 + time_string[10] - 0x30;
       station_b_io[out_hours][out_minutes] += 1;
       in_minutes += turnaround_time;
       if (in_minutes >= MAX_MINUTES)
 	{
 	  in_minutes -= MAX_MINUTES;
 	  in_hours++;
 	}
       /* If the train arrives after midnight, we don't care about it. */
       if (in_hours < MAX_HOURS)
 	{
 	  station_a_io[in_hours][in_minutes] = station_a_io[in_hours][in_minutes] - 1;
 	}
     }
   
 
   /* Okay the arrays are full.  Now step through them to determine how many trains are needed at each station at the beginning of the day. */
 
   for (outloop = 0; outloop < MAX_HOURS; outloop++)
     {
       //printf(α%i,%i  α, station_a_io[outloop][0], station_b_io[outloop][0]);
       for (inloop = 0; inloop < MAX_MINUTES; inloop++)
 	{
 	  cur_a_trains += station_a_io[outloop][inloop];
 	  *ret_a = (*ret_a > cur_a_trains ? *ret_a : cur_a_trains);
 	  cur_b_trains += station_b_io[outloop][inloop];
 	  *ret_b = (*ret_b > cur_b_trains ? *ret_b : cur_b_trains);
 	}
     }
   //printf(αnα);
   return;
 }
 
 
 
 
 
 
 
 void getString(char* ret_string)
 {
   int string_length = 0;
   getStringNoStrip(ret_string);
   string_length = strlen(ret_string);
   ret_string[string_length - 1] = '0';
   return;
 }
 
 int getInteger()
 {
   int ret_integer;
   char temp_string[MAX_STRING_SIZE];
   getString(temp_string);
   sscanf(temp_string, α%iα, &ret_integer);
   return ret_integer;
 }
 
 void getStringNoStrip(char* ret_string)
 {
   fgets(ret_string, MAX_STRING_SIZE, stdin);
   return;
 }"
29075,2008,32013,chunkyguy,24480,1,googlebig.c,gcj/2008/32013/chunkyguy/24480/1/extracted/googlebig.c,"#include<stdio.h>
 
 int n,s,q;
 char engine[100][100];
 char querry[1000][100];
 
 main(int argc, char *argv[])
 {
  int swt,use,count;
  int tcase,engno,qur;
  char ch;
  FILE *fr;
  char line[100];
  char cureng[100];
 
  fr = fopen(argv[1],αrα);
  readline(fr,line);
  n = strtoi(line);
  for(tcase=0;tcase<n;tcase++)
  {
   swt = 0;
   readline(fr,line);
   s = strtoi(line);
   for(engno=0;engno<s;engno++)
   {
    readline(fr,line);
    strcpy(engine[engno],line);
   }
   readline(fr,line);
   q = strtoi(line);
   //printf(αquerries = %dnα,q);
   for(qur = 0;qur<q; qur++)
   {
    readline(fr,line);
     strcpy(querry[qur],line);
   }//end copying querries
   //printf(αquerries copied...nα);
 /*  for(engno=0;engno<s;engno++)
   {
    for(qur=0,count=0;qur<q;qur++)
    {
     if(!strcmp(engine[engno],querry[qur]))  
      break;
     count++;
    }
     counteng[engno]=count;
   }//fill distances of each engine
   for(engno=0,use=0; engno<s; engno++)
   {
    //printf(α%d α,counteng[engno]);
    use = (counteng[engno]<counteng[use])?use:engno;
   }//find engine to be used
 */
   use = fillcount(0);
   //printf(αengine used = %snα,engine[use]);
   strcpy(cureng,engine[use]);
   for(swt=0,qur=0 ;qur<q;qur++)
   {
    while(!strcmp(cureng,querry[qur]))
    {
     swt++;
  //   printf(αswitching...nα);
     //use = (use<s)?use+1:0;
     use = fillcount(qur);
     strcpy(cureng,engine[use]);
    }//switch engine 
   }//end finding total switches
    
  printf(αCase #%d: %dnα,tcase+1,swt);
  }//end test cases 
   //printf(α%snα,line);
 }//end main
 
 int readline(FILE *f, char *l)
 {
  int i=0;
  int c;
  while((c=fgetc(f))!='n')
   if(c==-1)
    return 0;
   else
   l[i++]=c;
  l[i]='0';
 return i; 
 }
 
 int strtoi(char *l)
 {
  int num =0 ;
  char ch; 
  while(ch=*l++)
   if(isprint(ch))
    num = (num*10)+(ch - '0');
 return num;
 }
 
 int fillcount(int pos)
 {
  int use,engno,qur,count;
  int counteng[100]={0};
  for(engno=0;engno<s;engno++)
  {
   for(qur=pos,count=0;qur<q;qur++)
   {
    if(!strcmp(engine[engno],querry[qur]))  
     break;
    count++;
   }
    counteng[engno]=count;
  }//fill distances of each engine
  for(engno=0,use=0; engno<s; engno++)
  {
   //printf(α%d α,counteng[engno]);
   use = (counteng[engno]<counteng[use])?use:engno;
  }//find engine to be used
  return use;
 }"
29088,2008,32013,Ishida,24480,1,a.c,gcj/2008/32013/Ishida/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int numn,i,j,n,s,q,countswitch=0;
 char engine[100][100],query[100];
 int countengine[100]={0};
 
 void reallycleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 }
 
 void cleararray() {
 	int index;
 	for(index=0; index<s; index++)
 		countengine[index] = 0;
 	countengine[j]++;		
 }
 
 void checkarray() {
 	int index,zerocount=0;
 	for(index=0; index<s; index++)
 		if(!countengine[index]) zerocount++;
 	if(zerocount == 0) { 
 		countswitch++;
 		cleararray();
 	}
 }
 
 int main() {
 	scanf(α%dα,&n);
 	for(numn=0; numn<n; numn++) {
 		scanf(α%dα,&s);
 		getchar();
 		for(i=0; i<s; i++) {
 			gets(engine[i]);
 		}
 		scanf(α%dα,&q);
 		getchar();
 		for(i=0; i<q; i++) {
 			gets(query);
 			for(j=0; j<s; j++) {
 				if(!strcmp(query,engine[j])) {
 					countengine[j] += !strcmp(query,engine[j]);
 					break;
 				}	
 			}
 			checkarray();
 		}	
 		reallycleararray();
 		printf(αCase #%d: %dnα,numn+1,countswitch);
 		countswitch = 0;
 	}
 	return 0;
 }"
29090,2008,32013,Ishida,24481,1,traintimetable.c,gcj/2008/32013/Ishida/24481/1/extracted/traintimetable.c,"#include<stdio.h>
 
 int n,a,b,i,j,k,l,t,counta,countb,q;
 int tmp1,tmp2,tmp3,tmp4;
 int tafrom[200],tato[200],tat[200];
 int flag,what;
  
 int route(int index) {
     int m;
     if(flag == 0) {
         flag = 1;
         what = tat[index];
     }
     if(tat[index] == 0) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 1)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     } else
     if(tat[index] == 1) {
         for(m=0; m<a+b; m++) {
             if((tat[m] == 0)&&(tafrom[m] >= tato[index])) {
                 tat[index] = -1;
                 route(m);
                 break;
             }
         }  
     }
     tat[index] = -1;
     return what;
 }
 
 
 
 
 
 
    
 int main() {
     scanf(α%dα,&n);
     for(l=0;l<n;l++) {
         scanf(α%dα,&t);
         scanf(α%d %dα,&a,&b);
         for(j=0; j<a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 0;
         }
         for(; j<b+a; j++) {
             scanf(α%d:%d %d:%dα,&tmp1,&tmp2,&tmp3,&tmp4);
             tafrom[j] = (tmp1*60)+tmp2;
             tato[j] = (tmp3*60)+tmp4+t;
             tat[j] = 1;
         }
     
 // Sort
     for(i=0;i<a+b-1;i++)
         for(j=0;j<a+b-1;j++)
             if(tafrom[j] > tafrom[j+1]) {
                 tmp1 = tafrom[j];
                 tafrom[j] = tafrom[j+1];
                 tafrom[j+1] = tmp1;
                 tmp1 = tato[j];
                 tato[j] = tato[j+1];
                 tato[j+1] = tmp1;
                 tmp1 = tat[j];
                 tat[j] = tat[j+1];
                 tat[j+1] = tmp1;
             }
     for(i=0; i<a+b; i++) {
 
       
         q = route(i);
         if(q == 0) {
             counta++;
             flag = 0;
         }
         if(q == 1) {
             countb++;
             flag = 0;
         }
         if(q == -1)
             flag = 0;
     }
 
     printf(αCase #%d: %d %dnα,l+1,counta,countb);
 
 
     for(i=0; i<a+b; i++) {
         tafrom[i] = 0;
         tato[i] = 0;
         tat[i] = 0;
     }
     counta = 0;
     countb = 0;
     flag = 0;
 
     }
 
 return 0;
 }"
29121,2008,32013,ksnivas,24481,1,two.c,gcj/2008/32013/ksnivas/24481/1/extracted/two.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct Times{
 	int start;
 	int stop;
 };
 
 struct TestCase{
 	int turnAroundTime;
 	int numTripsAtoB;
 	int numTripsBtoA;
 	struct Times *aTob;
 	struct Times *bToa;
 };
 
 int getNumTestCases(FILE *fp){
 	static int numtc = -1;
 
 	if(numtc < 0){
 		fscanf(fp, α%dnα, &numtc);
 	}
 
 	return numtc;
 }
 
 struct TestCase* getTestCase(FILE *fp){
 	struct TestCase *pTst;
 	int a, b, c, d;
 	int i = 0;
 
 	// malloc the required structure
 	pTst = malloc(sizeof(struct TestCase));
 	
 	// get the turn around time
 	fscanf(fp, α%dnα, &pTst->turnAroundTime);
 
 	// get the trips from a to b and b to a
 	fscanf(fp, α%d%dnα, &pTst->numTripsAtoB, &pTst->numTripsBtoA);
 
 	// get the timings for trips from A to B
 	pTst->aTob = malloc(pTst->numTripsAtoB * sizeof(struct Times));
 	for(i = 0; i < pTst->numTripsAtoB; ++i){
 		fscanf(fp, α%d:%d%d:%dnα, &a, &b, &c, &d);
 		pTst->aTob[i].start = a * 60 + b;
 		pTst->aTob[i].stop = c * 60 + d;
 	}
 
 	// get the timings for trips from B to A
 	pTst->bToa = malloc(pTst->numTripsBtoA * sizeof(struct Times));
 	for(i = 0; i < pTst->numTripsBtoA; ++i){
 		fscanf(fp, α%d:%d%d:%dnα, &a, &b, &c, &d);
 		pTst->bToa[i].start = a * 60 + b;
 		pTst->bToa[i].stop = c * 60 + d;
 	}
 
 	return pTst;
 }
 
 int compare(const void *pa, const void *pb){
 	int a = *((int *) pa);
 	int b = *((int *) pb);
 	return (a < b)?-1:(a > b)?1:0;
 }
 
 int main(){
 	FILE *fp;
 	struct TestCase* tc;
 	struct Times ts;
 	int i, j, k;
 	int numAtoB = 0, numBtoA = 0;
 	int numTestCases = 0;
 	int maxDiff, minDiff, diff;
 	int maxIndex, minIndex;
 	int point;
 
 	// open the text file
 	fp = fopen(αtest.txtα, αrα);
 	numTestCases = getNumTestCases(fp);
 
 	for(k = 0; k < numTestCases; ++k){
 
 		// get the test case
 		tc = getTestCase(fp);
 		//printf(αTest Case 1 = %d, %d, %d, %d, %dnα, tc->turnAroundTime, tc->numTripsAtoB, tc->numTripsBtoA, tc->aTob, tc->bToa);
 
 		// now implement the algorithm
 		numAtoB = tc->numTripsAtoB;
 		numBtoA = tc->numTripsBtoA;
 
 		for(i = 0; i < tc->numTripsBtoA; ++i){
 
 			// initialize variables
 			maxDiff = 1;
 			minDiff = -1;
 			point = tc->bToa[i].stop + tc->turnAroundTime;
 			maxIndex = -1;
 
 			// loop through the other train list
 			for(j = 0; j < numAtoB; ++j){
 				diff = point - tc->aTob[j].start;
 				if(diff <= 0){
 					if(maxDiff == 1 ) maxDiff = diff;
 					if(maxDiff <= diff){
 						maxDiff = diff;
 						maxIndex = j;
 					}
 				}
 				else{
 					if(minDiff == -1) minDiff = diff;
 					if(minDiff > diff){
 						minDiff = diff;
 						minIndex = j;
 					}
 				}
 			}
 
 			// using the max and min index, to eliminate max
 			if(maxIndex != -1){
 				ts = tc->aTob[maxIndex];
 				tc->aTob[maxIndex] = tc->aTob[numAtoB - 1];
 				tc->aTob[numAtoB - 1] = ts;
 				--numAtoB;
 			}
 		}
 
 		for(i = 0; i < tc->numTripsAtoB; ++i){
 
 			// initialize variables
 			maxDiff = 1;
 			minDiff = -1;
 			point = tc->aTob[i].stop + tc->turnAroundTime;
 			maxIndex = -1;
 
 			// loop through the other train list
 			for(j = 0; j < numBtoA; ++j){
 				diff = point - tc->bToa[j].start;
 				if(diff <= 0){
 					if(maxDiff == 1 ) maxDiff = diff;
 					if(maxDiff <= diff){
 						maxDiff = diff;
 						maxIndex = j;
 					}
 				}
 				else{
 					if(minDiff == -1) minDiff = diff;
 					if(minDiff > diff){
 						minDiff = diff;
 						minIndex = j;
 					}
 				}
 			}
 
 			// using the max and min index, to eliminate max
 			if(maxIndex != -1){
 				ts = tc->bToa[maxIndex];
 				tc->bToa[maxIndex] = tc->bToa[numBtoA - 1];
 				tc->bToa[numBtoA - 1] = ts;
 				--numBtoA;
 			}
 		}
 
 		// print the results out
 		printf(αCase #%d: %d %dnα, k + 1, numAtoB, numBtoA);
 	}
 
 	// close the file
 	fclose(fp);
 }"
29176,2008,32013,MKS.TAMU,24480,1,Saving_the_Universe.c,gcj/2008/32013/MKS.TAMU/24480/1/extracted/Saving_the_Universe.c,"#include<stdio.h>
 #include<stdlib.h>
 
 struct se_struct
  {
    char name[101];
    int dist;
  };
 void update_the_dist(struct se_struct*, char**, int, int , int);
 int choose_search_engine( struct se_struct*, int,char *);
 
 int main()
 {
 struct se_struct *search_engine;
 int no_of_cases,no_of_se,no_of_query;
 int i,j,k,l;
 int index;
 int no_of_switches=0;
 char **query;
 char input_string[6];
 fgets(input_string,6,stdin);
 //printf(α%snα, input_string);
 sscanf(input_string,α%dα,&no_of_cases);
 //printf(α%dα,no_of_cases);
 fflush(stdout);
 
 for (i=0;i< no_of_cases;i++)
 {
   fgets(input_string,6,stdin);
   //printf(α%snα, input_string);
   sscanf(input_string,α%dα,&no_of_se);
   search_engine = (struct se_struct *)malloc(no_of_se * sizeof(struct se_struct));   
   for (j=0;j< no_of_se;j++)
    {
     fflush(stdout);
     fgets(search_engine[j].name,101,stdin);
 	search_engine[j].dist=2000;
 	//fprintf(stdout,α%d%sα,j,search_engine[j].name);
    }
   fflush(stdout); 
   fgets(input_string,6,stdin);
   //printf(α%snα, input_string);
   sscanf(input_string,α%dα,&no_of_query);
   
   if (no_of_query> 0)
 	{
 	  query= (char**)malloc (no_of_query* sizeof(char*));
 	 
 	  for (k=0;k< no_of_query;k++)
 	    query[k]= (char *)malloc(101);
 	  
       for (k=0;k< no_of_query;k++)
 	   {
 	   fflush(stdout);
 	   fgets(query[k],101,stdin);
 	   // fprintf(stdout,α%d%sα,k,query[k]);
 	   }
        
     	
 	// algorithm goes here
     
 	update_the_dist(search_engine,query,1,no_of_query,no_of_se);
 	index=choose_search_engine(search_engine,no_of_se,query[0]);
 	
 	for ( j=1;j< no_of_query;j++)
 	 {
 	   //printf(αQuery %sα,query[j]);
 	   //printf(αSE %sα,search_engine[index].name);
 	  if (strcmp(search_engine[index].name,query[j])==0)
 	     {
 		  no_of_switches++;
 		  update_the_dist(search_engine,query,j+1,no_of_query,no_of_se);
 	          index=choose_search_engine(search_engine,no_of_se,query[j]);
 		  
 	     }
 	  }
 
           for (j=0;j< no_of_query;j++)
              free(query[j]);
          free(query);
 
 	
        // algorithmee nds
 	
 	}
 
   	printf(α Case #%d: %dnα,i+1,no_of_switches);
 	no_of_switches=0;
 	// deallocating
 	free(search_engine);
             
  }
  }
  
 	
  void update_the_dist(struct se_struct *search_engine, char **query, int start_index, int no_of_query, int no_of_se)
   {
    int i,j;
 
     for (j=0;j<no_of_se;j++)
       
 	 search_engine[j].dist=2000;
       
        
        for (j=0;j<no_of_se;j++)
         {
 	  for(i=start_index;i< no_of_query;i++)
 	  {
 	     if (strcmp(search_engine[j].name,query[i])==0)  	  
    	         {
 		       search_engine[j].dist=i;
 		       break;
 		       //   printf(α%d%d α,search_engine[j].dist,j);
 		   }
        	}
 	  	  	          
 
 		 	  
        }
    }
   
  int choose_search_engine( struct se_struct *search_engine, int num,char *switch_se)
   {
     int i;
 	int max=-1;
 	int index=0;
     for (i=0;i <num;i++)
 	 {
            if (strcmp(search_engine[i].name,switch_se)!=0)
 	   {
 	     if (search_engine[i].dist >= max) 
 	     {
 		   index=i;
 		   max=search_engine[i].dist;
 
 	     }
 	   }
 	 } 
     //printf(αindex%d α,index);
      return index;
    }"
29206,2008,32013,Ruth,24480,1,a_saving.c,gcj/2008/32013/Ruth/24480/1/extracted/a_saving.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 typedef struct DllEntryStruct
 {
     struct DllEntryStruct *NextPtr;
     struct DllEntryStruct *PrevPtr;
     char SearchEngineName[102];
 } DLL_ENTRY_STRUCT;
 
 typedef struct DllCtrlStruct
 {
     DLL_ENTRY_STRUCT *NextPtr;
     DLL_ENTRY_STRUCT *PrevPtr;
     unsigned long Counter;
 } DLL_CTRL_STRUCT;
 
 DLL_CTRL_STRUCT SearchEngineList1;
 DLL_CTRL_STRUCT SearchEngineList2;
 DLL_ENTRY_STRUCT SearchEngineEntry[100];
 DLL_CTRL_STRUCT *DllList1Ptr;
 DLL_CTRL_STRUCT *DllList2Ptr;
 DLL_CTRL_STRUCT *DllTmpPtr;
 unsigned long SwitchCounter;
 
 void dll_init (DLL_CTRL_STRUCT *DllCtrlPtr)
 {
     DllCtrlPtr->NextPtr = (DLL_ENTRY_STRUCT *)DllCtrlPtr;
     DllCtrlPtr->PrevPtr = (DLL_ENTRY_STRUCT *)DllCtrlPtr;
     DllCtrlPtr->Counter = 0;
 }
 
 void dll_insert_at_tail (DLL_ENTRY_STRUCT *DllEntryPtr,
                          DLL_CTRL_STRUCT *DllCtrlPtr)
 {
     DllEntryPtr->NextPtr = (DLL_ENTRY_STRUCT *)DllCtrlPtr;
     DllEntryPtr->PrevPtr = DllCtrlPtr->PrevPtr;
     DllCtrlPtr->PrevPtr->NextPtr = DllEntryPtr;
     DllCtrlPtr->PrevPtr = DllEntryPtr;
     DllCtrlPtr->Counter++;
 }
 
 void dll_move_entry (DLL_ENTRY_STRUCT *DllEntryPtr)
 {
     DllEntryPtr->NextPtr->PrevPtr = DllEntryPtr->PrevPtr;
     DllEntryPtr->PrevPtr->NextPtr = DllEntryPtr->NextPtr;
     DllList1Ptr->Counter--;
     
     DllEntryPtr->NextPtr = (DLL_ENTRY_STRUCT *)DllList2Ptr;
     DllEntryPtr->PrevPtr = DllList2Ptr->PrevPtr;
     DllList2Ptr->PrevPtr->NextPtr = DllEntryPtr;
     DllList2Ptr->PrevPtr = DllEntryPtr;
     DllList2Ptr->Counter++;
 }
 
 void dll_search_from_list (char *Query)
 {
     DLL_ENTRY_STRUCT *CurrEntryPtr;
 
     CurrEntryPtr = DllList1Ptr->NextPtr;
 
     do
     {
         if (strcmp(CurrEntryPtr->SearchEngineName, Query) == 0)
         {
             if (DllList1Ptr->Counter > 1)
             {
                 dll_move_entry(CurrEntryPtr);
             }
             else
             {
                 SwitchCounter++;
                 DllTmpPtr = DllList1Ptr;
                 DllList1Ptr = DllList2Ptr;
                 DllList2Ptr = DllTmpPtr;
             }
             
             return;
         }
         
 
         CurrEntryPtr = CurrEntryPtr->NextPtr;
     }
     while(CurrEntryPtr != (DLL_ENTRY_STRUCT *)DllList1Ptr);
 }
 
 void main()
 {
     unsigned long X, N, S, Q;
     unsigned long SCntr, QCntr;
     char StrTmp[102];
 
     gets(StrTmp);
     N=atoi(StrTmp);
     
     for (X=1; X<=N; X++)
     {
         SwitchCounter=0;
 
         dll_init(&SearchEngineList1);
         dll_init(&SearchEngineList2);
         DllList1Ptr = &SearchEngineList1;
         DllList2Ptr = &SearchEngineList2;
 
         gets(StrTmp);
         S=atoi(StrTmp);
         for (SCntr=0; SCntr<S; SCntr++)
         {
             gets(SearchEngineEntry[SCntr].SearchEngineName);
             dll_insert_at_tail(&SearchEngineEntry[SCntr], &SearchEngineList1);
         }
 
         gets(StrTmp);
         Q=atoi(StrTmp);
         for (QCntr=0; QCntr<Q; QCntr++)
         {
             gets(StrTmp);
             dll_search_from_list(StrTmp);
         }
 
         printf(αCase #%i: %inα, X, SwitchCounter);
     }
 }"
29219,2008,32013,blackauron,24480,1,jam1.c,gcj/2008/32013/blackauron/24480/1/extracted/jam1.c,"#include αstdio.hα
 #include αstdlib.hα
 #include αstring.hα
 #define se 100
 
 int check(int *,int);
 
 int main(){
     int i,j,k,t,N,S,Q;
     int *a;
     FILE *in = fopen(αA-large.inα,αrα);
     FILE *out = fopen(αA-large.outα,αwα);
     char **sengine = calloc(se,sizeof(char *));
     char *tmp = calloc(100,sizeof(char));
     
     for(i = 0; i < se; i++)
         sengine[i] = calloc(100,sizeof(char));
     
     fscanf(in,α%dα,&N);
     /*Ciclo dentro il quale si svolge il programma vero e proprio*/
     for(i = 0; i < N; i++){
         k = 0;
         fscanf(in,α%dnα,&S);
         a = calloc(S,sizeof(int));
         for(j = 0; j < S; j++)
             fgets(sengine[j],100,in);
         fscanf(in,α%dnα,&Q);
         for(j = 0; j < Q; j++){
             free(tmp);
             tmp = calloc(100,sizeof(char));
             fgets(tmp,100,in);
             for(t = 0; t < S; t++){
                 if(!strcmp(sengine[t],tmp)){
                     if(!a[t]){
                         a[t] = 1;
                         if(check(a,S)){
                             k++;
                             free(a);
                             a = calloc(100,sizeof(char));
                             a[t] = 1;
                         }     
                     }
                 }
             }
         }
         fprintf(out,αCase #%d: %dnα,i+1,k);
     }
     fclose(in);
     fclose(out);
     return 0; 
 }
 
 int check(int *a,int S){
     int i;
     for(i = 0; i < S; i++)
         if(!a[i])
             return 0;
     return 1;                   
 }"
29315,2008,32013,amitray,24480,1,universe.c,gcj/2008/32013/amitray/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 struct node {
 	char name[105];
 	int p;
 };
 void print_input();
 void solve_case(int);
 int is_query_present(int);
 int is_all_present();
 void reset_marker(int);
 void initialize();
 int find_not_present();
 int num_not_present();
 int map_engine(int);
 
 int N, S, Q, num_switches;
 char n[6], s[10], q[10];
 struct node engine[105], query[1005];
 FILE *fin;
 
 
 int main(int argc, char *argv[])
 {
 	int i, j, k;
 	char inp[105];
 
 	//fin = fopen(αA-small3.inα, αrα);
 	fin = fopen(αmyinput.inα, αrα);
 
 	fgets(n, sizeof(n), fin);
 	N = atoi(n);
 	//printf(α%dnα, N);
 
     for (i=0; i<N; i++)
    	{
 		initialize();
 		fgets(s, sizeof(s), fin);
 		S = atoi(s);
 		for (j=0; j<S; j++)
 		{
 			memset(inp, '0', 105);
 			fgets(inp, sizeof(inp), fin);
 			for (k=0; k<strlen(inp)-2; k++)
 				engine[j].name[k] = inp[k];
 		}
 
 		fgets(q, sizeof(q), fin);
 		Q = atoi(q);
 		for (j=0; j<Q; j++)
 		{
 			memset(inp, '0', 105);
 			fgets(inp, sizeof(inp), fin);
 			for (k=0; k<strlen(inp)-2; k++)
 				query[j].name[k] = inp[k];
 		}
 		//print_input();
 		solve_case(i);
 	}
 	fclose(fin);
     return 0;
 }
 
 
 void solve_case(int n)
 {
 	int i, j, current, t;
 	for (i=0; i<Q; i++)
 	{
 		j = is_query_present(i);
 		if (j >= 0)
 			engine[j].p = 1;
 
 		// All the engines are present in the queries, and one
 		// engine is present exactly once
 		if (is_all_present() && i == Q-1)
 		{
 			num_switches++;
 			current = map_engine(i);
 		}
 		// All the engines are present in the queries, and every
 		// engine is present more than once
 		else if (is_all_present() && i<Q-1)
 		{
 			num_switches++;
 			current = map_engine(i);
 			reset_marker(current);
 		}
 		else if (!is_all_present() && i == Q-1)
 		{
 			t = num_not_present();
 			if (t == 1)
 			{
 				t = find_not_present();
 				if (t == current)
 					num_switches++;
 			}
 		}
 	}
 	printf(αCase #%d: %dnα, n+1, num_switches);
 }
 
 
 int map_engine(int x)
 {
 	int i;
 	for (i=0; i<S; i++)
 	{
 		if (strcmp(query[x].name, engine[i].name) == 0)
 			return(i);
 	}
 }
 
 
 void reset_marker(int x)
 {
 	int i;
 	for (i=0; i<S; i++)
 	{
 		if (i != x)
 			engine[i].p = 0;
 	}
 }
 
 
 int find_not_present()
 {
 	int i;
 	for (i=0; i<S; i++)
 	{
 		if (engine[i].p == 0)
 			return(i);
 	}
 }
 
 int num_not_present()
 {
 	int i, num;
 	for (i=0; i<S; i++)
 	{
 		if (engine[i].p == 0)
 			num++;
 	}
 	return(num);
 }
 
 
 int is_all_present()
 {
 	int i;
 	for (i=0; i<S; i++)
 	{
 		if (engine[i].p == 0)
 			return(0);
 	}
 	return(1);
 }
 
 int is_query_present(int i)
 {
 	int j;
 	for (j=0; j<S; j++)
 	{
 		if (strcmp(engine[j].name, query[i].name) == 0)
 			return(j);
 	}
 	return(-1);
 }
 
 
 void initialize()
 {
 	int i;
 
 	num_switches = 0;
 	for (i=0; i<105; i++)
 	{
 		memset(engine[i].name, '0', 105);
 		engine[i].p = 0;
 	}
 	for (i=0; i<1005; i++)
 	{
 		memset(query[i].name, '0', 105);
 		query[i].p = 0;
 	}
 }
 
 
 void print_input()
 {
 	int i;
 
 	printf(α%dnα, S);
 	for (i=0; i<S; i++)
 		printf(α%snα, engine[i].name);
 
 	printf(α%dnα, Q);
 	for (i=0; i<Q; i++)
 		printf(α%snα, query[i].name);
 	printf(α----------------------------nα);
 }"
29423,2008,32013,astronomy,24480,1,code.c,gcj/2008/32013/astronomy/24480/1/extracted/code.c,"#include <stdio.h>
 #include <string.h>
 
 char eng[256][256];
 char Qs[1024][256];
 int S, Q, viz[256];
 
 int solve(void)
 {
     int i, j, k, p, q, r, cnt, s, t, res = 0;
 
     memset(viz, 0, sizeof(viz));
     for(cnt = 0, i = 1; i <= Q; i++)
     {
         for(j = 1; j <= S; j++)
          if(strcmp(Qs[i], eng[j]) == 0 && !viz[j]) k = j, cnt += viz[j] = 1;
         if(cnt == S) res++, memset(viz, 0, sizeof(viz)), viz[k] = cnt = 1;
     }
     return res;
 }
 
 int main(void)
 {
     freopen(αcode.inα, αrtα, stdin);
     freopen(αcode.outα, αwtα, stdout);
     
     int i, c = 1, N;
     
     scanf(α%dnα, &N);
     while(N--)
     {
 
         memset(eng, 0, sizeof(eng)), memset(Qs, 0, sizeof(Qs));
         scanf(α%dnα, &S);
 
         for(i = 1; i <= S; i++)
             fgets(eng[i], 256, stdin);
 
         scanf(α%dnα, &Q);
         for(i = 1; i <= Q; i++)
             fgets(Qs[i], 256, stdin);
         printf(αCase #%d: %dnα, c, solve());
         c++;
     }
     return 0;
 }"
29491,2008,32013,eldho,24480,1,a.c,gcj/2008/32013/eldho/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 char s_eng[100][85];
 char sts[100];
 int ns;
 FILE *f1;
 
 void clear()
 {
 	int i;
 	for(i=0;i<ns;i++)
 		sts[i]=0;
 }
 
 int set_sel(char *s)
 {
 	int i;
 	for(i=0;i<ns;i++)
 	{
 		if(strcmp(s_eng[i],s)==0)
 		{
 			sts[i]='*';
 			break;
 		}
 	}
 	return(i);
 }
 
 int check()
 {
 	int i;
 	for(i=0;i<ns;i++)
 	{
 		if(sts[i]!='*')
 			return(0);	
 	}
 	return(1);
 }
 
 void read_line(char *s)
 {
 	int i=0;
 	char ch;
 	while((ch=fgetc(f1))!='n')
 	{
 		s[i]=ch;
 		i++;
 	}
 	s[i]='0';
 }
 
 int main()
 {   
 	int n,nq,i,j,count=0,pos;
 	char q[85];
 	f1=fopen(αa-large.inα,αrα);
 	read_line(q);
 	n=atoi(q);
 	//fscanf(f1,α%dα,&n);
 	for(i=0;i<n;i++)
 	{
 		count=0;
 		clear();
 		ns=0;
 		nq=0;
 		read_line(q);
 		ns=atoi(q);
 		//printf(α::%snα,q);
 		//fscanf(f1,α%dα,&ns);
 		//while(getchar() != 'n') continue;
 		for(j=0;j<ns;j++)
 		{
 			read_line(s_eng[j]);
 			//printf(α:%snα,s_eng[j]);
 			//fscanf(f1,α%sα,s_eng[j]);
 			//while(getchar() != 'n') continue;
 		}
 		//fscanf(f1,α%dα,&nq);
 		read_line(q);
 		nq=atoi(q);
 		for(j=0;j<nq;j++)
 		{
 			//fscanf(f1,α%sα,q);
 			//fgets(q,80,f1);
 			read_line(q);
 			//while(getchar() != 'n') continue;
 			pos=set_sel(q);
 			if(check()==1)
 			{
 				count++;
 				clear();
 				sts[pos]='*';
 			}
 			
 		}
 		printf(αCase #%d: %dnα,i+1,count);
 	}
 	fclose(f1);
 	return(0);
 }"
29493,2008,32013,eldho,24481,1,b.c,gcj/2008/32013/eldho/24481/1/extracted/b.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 int arr[200],dep[200];
 int ta=0,tb=0,a=0,b=0,tot=0;
 FILE *f1;
 int sts[200];
 
 void clear()
 {
 	int i;
 	for(i=0;i<200;i++)
 		sts[i]=250;
 }
 
 void read_line(char *s)
 {
 	int i=0;
 	char ch;
 	while((ch=fgetc(f1))!='n')
 	{
 		s[i]=ch;
 		i++;
 	}
 	s[i]='0';
 }
 
 void read_line2(char *s1,char *s2)
 {
 	int i=0;
 	char ch;
 	while((ch=fgetc(f1))!=' ')
 	{
 		s1[i]=ch;
 		i++;
 	}
 	s1[i]='0';
 	i=0;
 	while((ch=fgetc(f1))!='n')
 	{
 		s2[i]=ch;
 		i++;
 	}
 	s2[i]='0';
 }
 
 void read_time(int pos)
 {
 	char q[50],ch;
 	int i=0,t=0;
 	while((ch=fgetc(f1))!=':')
 	{
 		q[i]=ch;
 		i++;
 	}
 	q[i]='0';
 	i=0;
 	t=atoi(q);
 	while((ch=fgetc(f1))!=' ')
 	{
 		q[i]=ch;
 		i++;
 	}
 	q[i]='0';
 	i=0;
 	t=t*60+atoi(q);
 	dep[pos]=t;
 
 	t=0;
 	while((ch=fgetc(f1))!=':')
 	{
 		q[i]=ch;
 		i++;
 	}
 	q[i]='0';
 	i=0;
 	t=atoi(q);
 	while((ch=fgetc(f1))!='n')
 	{
 		q[i]=ch;
 		i++;
 	}
 	q[i]='0';
 	i=0;
 	t=t*60+atoi(q);
 	arr[pos]=t;
 }
 
 void sort_arrs()
 {
 	int i,j,t;
 	for(i=0;i<ta;i++)
 		for(j=0;j<ta;j++)
 		{
 			if(dep[i]<dep[j])
 			{
 				t=dep[j];
 				dep[j]=dep[i];
 				dep[i]=t;
 				t=arr[j];
 				arr[j]=arr[i];
 				arr[i]=t;
 			}
 		}
 		for(i=ta;i<(ta+tb);i++)
 		for(j=ta;j<(ta+tb);j++)
 		{
 			if(dep[i]<dep[j])
 			{
 				t=dep[j];
 				dep[j]=dep[i];
 				dep[i]=t;
 				t=arr[j];
 				arr[j]=arr[i];
 				arr[i]=t;
 			}
 		}
 
 }
 
 int main()
 {
 	int n,i,j,k;
 	char q[50],q1[50];
 	f1=fopen(αb-large.inα,αrα);
 	read_line(q);
 	n=atoi(q);
 	for(i=0;i<n;i++)
 	{
 		clear();
 		read_line(q);
 		tot=atoi(q);
 		read_line2(q,q1);
 		ta=atoi(q);
 		tb=atoi(q1);
 		a=ta;
 		b=tb;
 		for(j=0;j<(ta+tb);j++)
 		{
 			read_time(j);
 			//printf(α%d %dnα,dep[j],arr[j]);
 		}
 		sort_arrs();
 		//for(j=0;j<(ta+tb);j++)
 			//printf(α%d %dnα,dep[j],arr[j]);
 		for(j=0;j<ta;j++)
 		{
 			for(k=ta;k<(ta+tb);k++)
 			{
 				if(((arr[j]+tot)<=dep[k])&&sts[k]==250)
 				{
 					sts[k]=j;
 					b--;
 					break;
 				}
 			}
 		}
 
 		for(k=ta;k<(ta+tb);k++)
 		{
 			for(j=0;j<ta;j++)
 			{
 				if(((arr[k]+tot)<=dep[j])&&sts[k]!=j&&sts[j]==250)
 				{
 					sts[j]=k;
 					a--;
 					break;
 				}
 			}
 		}
 		printf(αCase #%d: %d %dnα,i+1,a,b);
 	}
 
 	fclose(f1);
 	return(0);
 }"
29532,2008,32013,dupim,24480,1,universe.c,gcj/2008/32013/dupim/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <string.h>
 #define MAXS 128
 #define MAXL 1024
 char engine[MAXS][MAXL];
 int mark[MAXS], s;
 
 int main(void)
 {
 	int n; //number of cases
 	int i, j, q, k;
 	int ss;
 	int troca;
 	char query[MAXL];
 	FILE *p;
 	p = fopen(αoutput.outα, αwα);
 	scanf(α%dα, &n);
 	for(i=0; i<n; i++)
 	{
 		ss=0;
 		troca=0;
 		memset(mark, 0, sizeof(mark));
 		scanf(α%dα, &s);
 		gets(engine[0]);
 		for(j=0; j<s; j++)
 		{
 			gets(engine[j]);
 		}
 				
 		scanf(α%dα, &q);
 		gets(query);
 		for(k=0; k<q; k++)
 		{
 			gets(query);
 			
 			for(j=0; j<s; j++)
 			{
 				if(!strcmp(query, engine[j]))
 				{
 					if(ss==s-1 && mark[j]==0)
 					{
 						troca++;
 						ss=0;
 						memset(mark, 0, sizeof(mark));
 						
 					}
 					if(mark[j]==0)
 					{
 						mark[j] = 1;
 						ss++;
 					}
 					break;
 				}
 			}
 		}
 		fprintf(p, αCase #%d: %dnα, i+1, troca);
 		
 	}
 	return 0;
 }"
29556,2008,32013,Lliane,24480,1,saving.c,gcj/2008/32013/Lliane/24480/1/extracted/saving.c,"#include <stdio.h>
 #include <string.h>
 char engine[101][101];
 char query[1001][101];
 int nb_testcase,nb_engine,nb_query;
 int engine_act,query_act;
 int tc,eng,que;
 int answer;
 void goto_last(){
   int engine_marks[101];
   int i;
   for (i=1;i<=nb_engine;i++)
     engine_marks[i] = 0;
   while (query_act <= nb_query){
     for (i=1;i<=nb_engine;i++){
       if (strstr(engine[i],query[query_act])){
         engine_marks[i] = 1;
         break;
       }
     }
     for (i=1;i<=nb_engine;i++){
       if (engine_marks[i] == 0)
         break;
     }
     if (i==nb_engine+1)
       return;
     query_act++;
   }
 }
 int main(){
  FILE * input;
  char line[101];
 
 //OUVERTURE DU FICHIER
  input = fopen (αinput.txtα,αrα);
 
 //RECUPERATION DU NOMBRE DE TESTCASE
  fgets(line,100,input);
  sscanf(line,α%dα,&nb_testcase);
  //RECUPERATION DES TESTCASE
  for(tc=1;tc<=nb_testcase;tc++){
   //RECUPERATION DU NOMBRE DE MOTEURS
   fgets(line,100,input);
   sscanf(line,α%dα,&nb_engine);
   //RECUPERATION DES MOTEURS
   for (eng=1;eng<=nb_engine;eng++)
     fgets(engine[eng],100,input); 
   //RECUPERATION DU NOMBRE DE QUERY
   fgets(line,100,input);
   sscanf(line,α%dα,&nb_query);
   //RECUPERATION DES QUERY
   for (que=1;que<=nb_query;que++)
     fgets(query[que],100,input);
   //RECUPERATION DU NOMBRE DE CHGTS NECESSAIRE
   query_act = 1;
   answer = 0;
   while (query_act <= nb_query){
     goto_last();
     if (query_act <= nb_query)
       answer++;
   }
   printf(αCase #%d: %dnα,tc,answer); 
  }
  fclose(input);
 }"
29663,2008,32013,dhamu,24481,1,TrainTime.c,gcj/2008/32013/dhamu/24481/1/extracted/TrainTime.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct {
 
 	int hh;
 	int mm;
 	
 	}Time;
 typedef struct train {
 
 	Time dep;
 	Time arv;
 	struct train *nextTrain;
 
 	}Train;
 
 Train* create();
 int checkLess(Time,Time); 
 int Available(Train *,Time );
 void sortInsert(Train **,Train *); 
 void makeQue(FILE **,int ,Train **);
 void memoryFree(Train *);
 void findMinTrains(Train **,Train **,int *,int *,int);
 void changeTime(Train *,int);
 
 
 
 Train* create() {
 
  Train *newnode;
  newnode=(Train *)malloc(sizeof(Train));
    if(newnode==NULL) {
 		printf(αn NO Spaceα);
 		exit(0);
 		}
 		 newnode->nextTrain=NULL;
    return newnode;
  }
 
 int checkLess(Time old,Time new) {
 
  if((old.hh > new.hh)||((new.hh==old.hh)&&(old.mm>new.mm)))
   	return 1;
  else if(old.hh == new.hh&&old.mm == new.mm)
   	return 2;
 else 
  	return 0;		
 
 }
 
 void sortInsert(Train **Head,Train *newNode)  {
 
 		
   	Train *temp = *Head,*temp1 = *Head;
 	int bool = 0;
 	newNode->nextTrain = NULL;
         if(!(*Head)) 
 		*Head = newNode;
 		
 	 else  {
  		bool = checkLess(temp->dep,newNode->dep);		
                 if((bool == 1)||((bool == 2)&&checkLess(temp1->arv,newNode->arv)) ) {		
          /* the element to be inserted has
                    lowest will be inserted at begining */
                   newNode->nextTrain = *Head;
 		  *Head = newNode;
         	 }
 		
       	     else {
                 while(temp1->nextTrain && !checkLess(temp1->nextTrain->dep,newNode->dep))			  			
                           temp1=temp1->nextTrain;
                 while(temp1->nextTrain && checkLess(temp1->nextTrain->dep,newNode->dep)==2 && !checkLess(temp1->nextTrain->arv,newNode->arv))			  			
                           temp1=temp1->nextTrain;
 
 		  if(temp1->nextTrain)
 			newNode->nextTrain = temp1->nextTrain;
              		temp1->nextTrain = newNode;
 		}	
 			
          }
 
 	}
 
 void makeQue(FILE **fp,int NA,Train **NAQ) {
 
 	char str[20];
 	Train *Temp;
 	while(NA--) {
 	
 	Temp = create();
 	fscanf(*fp,α%d:%d %d:%dα,&Temp->dep.hh,&Temp->dep.mm,&Temp->arv.hh,&Temp->arv.mm);
 	sortInsert(NAQ,Temp);
 	}	
 	
 
 }
 
 void changeTime(Train *Node,int Turn){
 
             Node->dep.mm = Node->arv.mm + Turn;		
 	    Node->dep.hh = Node->arv.hh;
 	    if(Node->dep.mm >59) {
 	    Node->dep.mm = (Node->dep.mm) % 60;	
 	    Node->dep.hh = Node->dep.hh + 1;
 	    }	
 }
 
 int Available(Train *WaitatBQ,Time AT) {
       
 	return(WaitatBQ && checkLess(AT,WaitatBQ->dep));
 }
 
 void findMinTrains(Train **NAQ,Train **NBQ,int *MinA,int *MinB,int Turn){
 
 	  Train *WaitatAQ = NULL,*WaitatBQ = NULL,*Temp;
           int NA = 0,NB = 0; 
 	while(*NAQ||*NBQ) {
 
 	  if(!(*NAQ)||((*NBQ) && checkLess((*NAQ)->dep,(*NBQ)->dep))) {
 		/*from B to A*/
 		if(Available(WaitatBQ,(*NBQ)->dep)) {
 			/*Assign waiting Train*/
 			Temp = WaitatBQ;
 			WaitatBQ = WaitatBQ->nextTrain;
 			free(Temp);
 
 		}
 		else /*use a new Train*/
 		      NB++;
 		
 		   Temp = *NBQ;
 		   *NBQ = (*NBQ)->nextTrain;	
 		   changeTime(Temp,Turn);	
 		   sortInsert(&WaitatAQ,Temp);	
 	  }
 	  else {
 		
 		/*from A to B*/
 		if(Available(WaitatAQ,(*NAQ)->dep)) {
 			/*Assign waiting Train*/
 			Temp = WaitatAQ;
 			WaitatAQ = WaitatAQ->nextTrain;
 			free(Temp);
 		}
 		else  /*use a new Train*/			
 		   NA++;
 
 		   Temp = *NAQ;
 		   *NAQ = (*NAQ)->nextTrain;	
 		   changeTime(Temp,Turn);	
 		   sortInsert(&WaitatBQ,Temp);	
 
 	  }		
 	}
 	*MinA = NA;
 	*MinB = NB;
 	if(WaitatAQ)
 		memoryFree(WaitatAQ);
 	if(WaitatBQ)
 		memoryFree(WaitatBQ);
 
    }
 
 void memoryFree(Train *Wait) {
 
 	Train *WaitTemp;
 	do{
 		WaitTemp = Wait;
 		Wait = Wait->nextTrain;
 		free(WaitTemp);
 	}while(Wait);
  }
 
 int main() {
 
   int noTestCases,cN = 1;
   int MinA,MinB,turnTime,NA,NB;
   FILE *fp,*out;
   Train *NAQ = NULL,*NBQ = NULL;
   fp = fopen(αB-large.inα,αrα);
   out =	fopen(αBprob.outα,αwα);
   fscanf(fp,α%dα,&noTestCases);
 	 
   while(noTestCases--) {
   	NAQ=NBQ=NULL;
 	fscanf(fp,α%dα,&turnTime);
 	fscanf(fp,α%d%dα,&NA,&NB);
 	makeQue(&fp,NA,&NAQ);
 	makeQue(&fp,NB,&NBQ);
 	findMinTrains(&NAQ,&NBQ,&MinA,&MinB,turnTime);
 	fprintf(out,αCase #%d: %d %dnα,cN++,MinA,MinB);
 	}
    
 	return 0;	
   }"
29717,2008,32013,Jenaky,24480,1,large.c,gcj/2008/32013/Jenaky/24480/1/extracted/large.c,"#include <stdio.h>
 #define MAX_ENGINE_NUM 100
 #define MAX_QUERY_NUM  1000
 #define MAX_NAME_LEN   100
 #define TMP_LINE_LEN   7
 
 //return non-zero if not equal
 int nonequal(char* engines, char* queries)
 {
 	int index;
 	for(index=0; index<100 && engines[index] != '0' && queries[index] != '0'; index++)
 	{
 		if(engines[index] != queries[index])
 		{
 			return 1;
 		}
 	}
 	if(engines[index] != queries[index])
 		return 1;
 
 	return 0;
 }
 
 // the main program
 int main(int argc, char *argv[])
 {
 	FILE *inputfile,*outputfile;
 	int testNum=0;	
 	
 	int engineNum=0;
 	int queryNumPerTest=0;
 	int switchNum=0;
 	
 	char engines[MAX_ENGINE_NUM][MAX_NAME_LEN+1];
 	char queries[MAX_QUERY_NUM][MAX_NAME_LEN+1];
 	int testCycle=0;
 	int offset=0,tmpoffset=0;
 	int inputPtr=0,enginePtr=0,queryPtr=0;
 
 	char tmpLine[TMP_LINE_LEN+1];//only for inputing the num
 
 	inputfile=fopen(αA-large-attempt1.inα,αrtα);
 	outputfile=fopen(αA-large-attempt1.outα,αwtα);
 	if(inputfile==NULL || outputfile==NULL)
 		return(1);//exit if file error
 
 	fgets(tmpLine,TMP_LINE_LEN,inputfile);
 	sscanf(tmpLine,α%dα,&testNum);
 
 	for(testCycle=0; testCycle < testNum; testCycle++)
 	{	//get search engines
 		fgets(tmpLine,TMP_LINE_LEN,inputfile);
 		sscanf(tmpLine,α%dα,&engineNum);
 		for(inputPtr=0; inputPtr < engineNum; inputPtr++)
 			fgets(engines[inputPtr],MAX_NAME_LEN,inputfile);
 		//get queries
 		fgets(tmpLine,TMP_LINE_LEN,inputfile);
 		sscanf(tmpLine,α%dα,&queryNumPerTest);
 		for(inputPtr=0; inputPtr < queryNumPerTest; inputPtr++)
 			fgets(queries[inputPtr],MAX_NAME_LEN,inputfile);
 
 		//init param
 		switchNum = 0;
 		offset = 0;
 		tmpoffset = 0;
 
 		//begin test
 		do
 		{
 			for(enginePtr=0;enginePtr < engineNum;enginePtr++)
 			{
 				for(queryPtr=offset; queryPtr < queryNumPerTest; queryPtr++)
 				{
 					if(!nonequal(engines[enginePtr],queries[queryPtr]))
 					{
 						break;
 					}
 				}
 				
 				if(tmpoffset < queryPtr)
 				{
 					tmpoffset = queryPtr;
 					//enginePtr = enginePtr;
 				}
 				
 				if(tmpoffset >= queryNumPerTest)
 					break;
 			}//end for
 			
 			//get the longest offset
 			offset = tmpoffset;
 		
 			switchNum++;
 			
 		}while(offset < queryNumPerTest);
 
 		switchNum--;//desent the first inital switch
 		fprintf(outputfile,αCase #%d: %dnα,testCycle+1,switchNum);
 		
 	}//end for
 
 	fclose(inputfile);
 	fclose(outputfile);
 	
 	return 0;
 }"
29795,2008,32013,Vincent,24480,1,testa.c,gcj/2008/32013/Vincent/24480/1/extracted/testa.c,"/* 
 To combat this, people came up with an interesting solution. All queries are pooled together. They are passed to a central system that decides which query goes to which search engine. The central system sends a series of queries to one search engine, and can switch to another at any time. Queries must be processed in the order they're received. The central system must never send a query to a search engine whose name matches the query. In order to reduce costs, the number of switches should be minimized.
 
 Your task is to tell us how many times the central system will have to switch between search engines, assuming that we program it optimally. To combat this, people came up with an interesting solution. All queries are pooled together. They are passed to a central system that decides which query goes to which search engine. The central system sends a series of queries to one search engine, and can switch to another at any time. Queries must be processed in the order they're received. The central system must never send a query to a search engine whose name matches the query. In order to reduce costs, the number of switches should be minimized.
 
 Your task is to tell us how many times the central system will have to switch between search engines, assuming that we program it optimally. 
 
 Sample input:
 2
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 10
 Yeehaw
 Yeehaw
 Googol
 B9
 Googol
 NSM
 B9
 NSM
 Dont Ask
 Googol
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 7
 Googol
 Dont Ask
 NSM
 NSM
 Yeehaw
 Yeehaw
 Googol
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //#define DEBUG			(1)
 #define MAX_STRING_SIZE		(100)
 #define READ_ERROR_CHK(i_ret)	{if( i_ret <= 0 ) goto L_FORMAT_ERR;}
 
 char **Server_Name = NULL;
 int *Server_Count = NULL;
 int Num_Test_Case;
 int Num_Server;
 int Num_Query;
 FILE*	Input_File = NULL;
 
 void CleanUp( void )
 {
 	int i;
 
 	if ( Server_Name != NULL ) {
 		/* Free up Server Name */
 		for ( i = 0; i < Num_Server; i++ ) {
 			if ( Server_Name[i] != NULL ) {
 				free(Server_Name[i]);
 			}
 		}
 		free( Server_Name );
 		Server_Name = NULL;
 	}
 	if (Server_Count != NULL ) {
 		free( Server_Count );
 		Server_Count = NULL;
 	}
 	Num_Server = 0;
 	Num_Query = 0;
 }
 
 char* readline(FILE* f)
 {
 	char* line = (char*) malloc(sizeof(char) * MAX_STRING_SIZE);
 	char* output;
         char c;
         int len = 0;
 
         while ( (c = fgetc(f) ) != EOF )
         {
 		if ( c != 'n' ) {
                 	line[len++] = c;
                 	line[len] = '0';
 		}
 		else  {
 			if (len > 0 ) break;
 		}
         }
 	output = (char*) malloc(sizeof(char) * (len + 2) );
 	if ( output != NULL ) {
 		memcpy(output, line, sizeof(char) * (len + 2));
 	}
 	else {
 		printf (αCannot allocate memorynα);
 	}
 	free( line );
         return output;
 }
 
 int Match_Server( char* query )
 {
 	int i;
 
 	for ( i = 0; i < Num_Server; i++ ) {
 		if (strcmp(query, Server_Name[i]) == 0 ) {
 			return i;
 		}
 	}
 
 	return -1;
 }
 
 int Cal_Server( void )
 {
 	char *query_str = NULL;
 	int i, j;
 	int match;
 	int count = 0;
 	int answer = 0;
 
 	for ( i = 0; i < Num_Query; i++ ) {	
 		query_str = readline( Input_File );
 #ifdef	DEBUG	
 		fprintf( stderr, α %snα, query_str );
 #endif
 
 		match = Match_Server(query_str);
 #ifdef DEBUG
 		fprintf( stderr, α match: %inα, match );
 #endif
 		if ( match >= 0 && match < Num_Server) {
 			if ( Server_Count[match] == 0 ) {
 				Server_Count[match]++;
 				count++;
 				if ( count >= Num_Server ) {
 					answer++;
 					for ( j = 0; j < Num_Server ; j++ ) {
 						Server_Count[j] = 0;
 					}
 					Server_Count[match]++;
 					count = 1;
 #ifdef DEBUG
 					fprintf( stderr, α %i %snα, answer, Server_Name[match]);
 #endif
 				}
 			}
 		}
 
 		if(query_str != NULL ) {
 			free(query_str);
 		}
 	}
 
 	return answer;
 }
 
 int main (int argc, char* argv[])
 {
 	int i_ret_value;
 	int i_test_case;
 	int i_server;
 	int i;
 
 	Server_Name = NULL;
 	Num_Test_Case = 0;
 	Num_Server = 0;
 	Num_Query = 0;
 
 	if ( argc != 2 ) {
 		fprintf( stdout, αInput arguement: input file is needednα );
 		return 0;
 	}
 
 #ifdef DEBUG
 	fprintf( stderr, αargc: %i, argv[2]: %snα, argc, argv[1] );
 #endif
 	/* Open input file */
 	Input_File = fopen( argv[1], αrα );
 	if ( Input_File == NULL ) {
 		fprintf( stdout, αCannot open input filenα);
 	}
 
 	/* Num of test case */
 	READ_ERROR_CHK(fscanf( Input_File, α%iα, &Num_Test_Case ));
 	if ( Num_Test_Case <= 0 ) {
 		fprintf( stdout, αNum Test Case <= %i!nα, Num_Test_Case );
 	}
 	
 	for ( i_test_case = 0; i_test_case < Num_Test_Case; i_test_case++ ){
 		/* Num of server */
 		READ_ERROR_CHK(fscanf( Input_File, α%iα, &Num_Server ));
 		if ( Num_Server <= 0 ) {
 			fprintf( stdout, αNum Server: %i!nα, Num_Server );
 		}
 #ifdef DEBUG
 		fprintf( stderr, αNum Server: %inα, Num_Server );
 #endif
 
 		Server_Name = (char**)malloc (sizeof(char *) * Num_Server );
 		Server_Count = (int *)malloc (sizeof(int) * Num_Server);
 		if ( Server_Name == NULL || Server_Count == NULL ) {
 			fprintf ( stdout, αMemory allocation fail: ServerName!nα);
 			goto L_FORMAT_ERR;
 		}
 		memset(Server_Name, 0, sizeof(char *) * Num_Server );
 		memset(Server_Count, 0, sizeof(int) * Num_Server );
 
 		for ( i = 0; i < Num_Server; i++ ) {
 			Server_Name[i] = readline( Input_File );
 #ifdef DEBUG
 			fprintf( stderr, α%snα, Server_Name[i] );
 #endif
 			if ( Server_Name[i] == NULL ) {
 				fprintf ( stdout, αMemory allocation fail: ServerName2!nα);
 			}
 		}
 
 		READ_ERROR_CHK(fscanf( Input_File, α%iα, &Num_Query ));
 		if ( Num_Query <= 0 ) {
 			fprintf (stdout, αCase #%i: 0nα, i_test_case+1 );
 		}
 		else {
 #ifdef DEBUG
 			fprintf( stderr, αNum Query: %inα, Num_Query );
 #endif
 			fprintf (stdout, αCase #%i: %inα, i_test_case+1, Cal_Server());
 		}
 		fflush(stdout);
 		CleanUp();
 	}
 	fclose( Input_File );
 	return 1;
 
 L_FORMAT_ERR:
 	fprintf( stdout, αRead file errornα );
 	if ( Input_File != NULL ) {
 		fclose( Input_File );
 	}
 	CleanUp();
 	return 0;
 }"
29797,2008,32013,Vincent,24481,1,testb.c,gcj/2008/32013/Vincent/24481/1/extracted/testb.c,"/* 
 	Train Timetable
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //#define DEBUG			(1)
 #define MAX_STRING_SIZE		(20)
 
 #define READ_ERROR_CHK(i_ret)   {if( i_ret <= 0 ) goto L_FORMAT_ERR;}
 
 typedef struct S_TIME {
 	int hour;
 	int minute;
 	int trip;       /* 0: A to B or 1: B to A */
 	int type;       /* 0: arrival or 1: departure */
 } S_TIME;
 
 int	Num_Test_Case = 0;
 int	T = 0;	/* turnaround time */
 int	NA = 0;	/* number of trips from A to B */
 int	NB = 0; /* number of trips from B to A */
 int	ATrain = 0; /* train at A location */
 int	BTrain = 0; /* train at B location */
 int	Schedule_Count = 0;
 S_TIME**	Schedule = NULL;
 FILE*	Input_File = NULL;
 
 void Print_Schedule( void )
 {
 	int i;
 	S_TIME* time;
 	
 	for ( i = 0; i < Schedule_Count; i++ ) {
 		time = Schedule[i];
 		fprintf ( stdout, α%i:%it%it%inα, time->hour, time->minute, time->trip, time->type);
 	}
 }
 
 int Insert_Schedule( S_TIME *time )
 {
 	if ( time != NULL ) {
 		Schedule[Schedule_Count] = time;
 		Schedule_Count++;
 
 		return ( Schedule_Count - 1 );
 	}
 
 	return -1;
 }
 
 int Compare_Time(int a, int b)
 {
 	int i;
 
 	i = Schedule[a]->hour - Schedule[b]->hour;
 	if ( i == 0 ) { /* Same hour */
 		i = Schedule[a]->minute - Schedule[b]->minute;
 		if ( i == 0 ) { /* Same minute */
 			if ( Schedule[a]->type == 0 ) {
 				/* arrival consider smaller */
 				return -1;
 			}
 			/* either equal or larger */
 			return 1;
 		}
 		else {
 			return i;
 		}
 	}
 	else {
 		return i;
 	}
 }
 
 void Swap_Schedule( int a, int b )
 {
 	S_TIME* temp;
 
 	temp = Schedule[a];
 	Schedule[a] = Schedule[b];
 	Schedule[b] = temp;
 }
 
 void Bubble_Sort( void ) 
 {
 	int i, j;
 	int smallest;
 	S_TIME* time;
 
 	for ( i = 0; i < Schedule_Count; i++ ) {
 		smallest = i;
 		for ( j = i; j < Schedule_Count; j++ ) {
 			if ( Compare_Time(smallest, j) > 0 ) {
 				/* j is smaller, swap them */
 				smallest = j;
 			}
 		}
 		if ( i != smallest ) {
 			Swap_Schedule( smallest, i );
 		}
 	}
 }
 
 void Add_Time(S_TIME* time, int minute)
 {
 	/* negative minute is not supported */
 
 	time->minute += minute;
 	if ( time->minute >= 60 ) {
 		time->hour++;
 		time->minute -= 60;
 	}
 }
 
 void CleanUp( void )
 {
 	int i;
 
 	if ( Schedule != NULL ) {
 		for ( i = 0; i < Schedule_Count; i++ ) {
 			if ( Schedule[i] != NULL ) {
 				free( Schedule[i] );
 				Schedule[i] = NULL;
 			}
 		}
 		free ( Schedule );
 		Schedule = NULL;
 	}
 	Schedule_Count = 0;
 }
 
 S_TIME* read_Time(FILE* f)
 {
 	S_TIME* time = NULL;
 	char c;
 
 	time = (S_TIME*) malloc( sizeof( S_TIME ) );
 
 	if ( time != NULL ) {
 		c = fgetc(f);
 		while( (c == 'n' || c == ' ') && c != EOF ){
 			c = fgetc(f);
 		}
 		time->hour = (c - '0') * 10;
 		c = fgetc(f);
 		time->hour += c - '0';
 		if ( time->hour < 0 || time->hour > 24 ) {
 			goto L_READ_ERR;
 		}
 
 		c = fgetc(f);
 		if ( c != ':' ) {
 			goto L_READ_ERR;
 		}
 		
 		c = fgetc(f);
 		time->minute = (c - '0') * 10;
 		c = fgetc(f);
 		time->minute += c - '0';
 		if ( time->minute < 0 || time->minute > 60 ) {
 			goto L_READ_ERR;
 		}
 
 #ifdef DEBUG
         fprintf( stderr, αHR: %i, MIN: %inα, time->hour, time->minute );
 #endif
 	}
 
 	return time;
 L_READ_ERR:
 	fprintf( stdout, αRead time fail.nα );
 
 	if ( time != NULL ) {
 		free( time );
 	}
 	return NULL;
 }
 
 char* readline(FILE* f)
 {
 	char* line = (char*) malloc(sizeof(char) * MAX_STRING_SIZE);
 	char* output;
         char c;
         int len = 0;
 
         while ( (c = fgetc(f) ) != EOF )
         {
 		if ( c != 'n' ) {
                 	line[len++] = c;
                 	line[len] = '0';
 		}
 		else  {
 			if (len > 0 ) break;
 		}
         }
 	output = (char*) malloc(sizeof(char) * (len + 2) );
 	if ( output != NULL ) {
 		memcpy(output, line, sizeof(char) * (len + 2));
 	}
 	else {
 		printf (αCannot allocate memorynα);
 	}
 	free( line );
         return output;
 }
 
 void Cal_Train( void )
 {
 	int i;
 	int a = 0;
 	int b = 0;
 
 	ATrain = 0;
 	BTrain = 0;
 
 	for ( i = 0; i < Schedule_Count; i++ ) {
 		if ( Schedule[i]->trip == 0 ) {
 			/* A to B */
 			if ( Schedule[i]->type == 0 ) {
 				/* arrival */
 				b--;
 			}
 			else {
 				/* departure */
 				a++;
 				if ( a > ATrain ) {
 					ATrain = a;
 				}
 			}
 		} 
 		else {
 			/* B to A */
 			if ( Schedule[i]->type == 0 ) {
 				/* arrival */
 				a--;
 			}
 			else {
 				/* departure */
 				b++;
 				if ( b > BTrain ) {
 					BTrain = b;
 				}
 			}
 		}
 	}
 }
 
 int main (int argc, char* argv[])
 {
 	int i_test_case;
 	S_TIME *time;
 	int i;
 
 	if ( argc != 2 ) {
 		fprintf( stdout, αInput arguement: input file is needednα );
 		return 0;
 	}
 
 #ifdef DEBUG
 	fprintf( stderr, αargc: %i, argv[2]: %snα, argc, argv[1] );
 #endif
 	/* Open input file */
 	Input_File = fopen( argv[1], αrα );
 	if ( Input_File == NULL ) {
 		fprintf( stdout, αCannot open input filenα);
 	}
 
 	/* Num of test case */
 	READ_ERROR_CHK(fscanf( Input_File, α%iα, &Num_Test_Case ));
 	if ( Num_Test_Case <= 0 ) {
 		fprintf( stdout, αNum Test Case <= %i!nα, Num_Test_Case );
 	}
 	
 	for ( i_test_case = 0; i_test_case < Num_Test_Case; i_test_case++ ){
 		/* Num of server */
 		READ_ERROR_CHK(fscanf( Input_File, α%iα, &T ));
 		if ( T < 0 ) {
 			fprintf( stdout, αTrunaround time: %i!nα, T);
 		}
 #ifdef DEBUG
 		fprintf( stderr, αTrunaround time: %inα, T );
 #endif
 		READ_ERROR_CHK(fscanf( Input_File, α%iα, &NA ));
 		READ_ERROR_CHK(fscanf( Input_File, α%iα, &NB ));
 		if ( NA < 0 || NB < 0 ) {
 			fprintf( stdout, αNA: %i, NB: %inα, NA, NB);
 		}
 
 		Schedule = (S_TIME**) malloc( sizeof(S_TIME*) * (NA+NB) *2 );
 #ifdef DEBUG
 		fprintf( stderr, αNA: %i, NB: %inα, NA, NB );
 #endif
 
 		/* A to B schedule */
 		for ( i = 0; i < (NA); i++ ) {
 			time = read_Time( Input_File );
 			if ( time != NULL ) {
 				time->type = 1; /* departure */
 				time->trip = 0; /* A to B */
 				Insert_Schedule( time );
 			}
 			time = read_Time( Input_File );
 			if ( time != NULL ) {
 				time->type = 0; /* arrival */
 				time->trip = 0; /* A to B */
 				Add_Time(time, T); /* add turnaround time */
 				Insert_Schedule( time );
 			}
 		}
 
 		/* B to A schedule */
 		for ( i = 0; i < (NB); i++ ) {
 			time = read_Time( Input_File );
 			if ( time != NULL ) {
 				time->type = 1; /* departure */
 				time->trip = 1; /* B to A */
 				Insert_Schedule( time );
 			}
 			time = read_Time( Input_File );
 			if ( time != NULL ) {
 				time->type = 0; /* arrival */
 				time->trip = 1; /* B to A */
 				Add_Time(time, T); /* add turnaround time */
 				Insert_Schedule( time );
 			}
 		}
 #ifdef DEBUG
 		fprintf( stdout, αSchedule_Count: %inα, Schedule_Count );
 #endif
 		Bubble_Sort();
 
 #ifdef DEBUG
 		Print_Schedule();
 #endif
 		Cal_Train();
 		fprintf ( stdout, αCase #%i: %i %inα, i_test_case+1, ATrain, BTrain);
 
 		fflush(stdout);
 		CleanUp();
 	}
 	fclose( Input_File );
 	return 1;
 
 L_FORMAT_ERR:
 	fprintf( stdout, αRead file errornα );
 	if ( Input_File != NULL ) {
 		fclose( Input_File );
 	}
 	CleanUp();
 	return 0;
 }"
29817,2008,32013,stray,24480,1,google_save_the_universe.c,gcj/2008/32013/stray/24480/1/extracted/google_save_the_universe.c,"/***********************************************************************
 *	File Name:		google_save_the_universe.cpp
 *	Author:			Utsav Ghosh
 *	Last Modified:	17/07/2008
 *	Description: 	This file is a part of the solution to google code jam's
 *					save the universe problem.
 *					Invoke On Command Line With 1st parameter as input file name
 *					Also 2nd parameter if specified acts as output file.
 *					If output file is not specified output.txt is default output file.
 *	
 *	
 ***********************************************************************/
 
 #include <stdio.h>
 #include <conio.h>
 #include <malloc.h>
 #include <stdlib.h>
 #include <string.h>
 #define MAX_LENGTH_OF_NUMBER 8
 #define MAX_LENGTH_OF_STRING 256
 #define DEFAULT_OUTPUT_FILENAME αoutput.txtα
 int GetNumberOnLine(FILE *);
 char * GetStringOnLine(FILE *);
 void GetMinNumberOfSwitches(char *,char *);
 
 /******************************************************************************
 *
 * ENTRY POINT	:	main
 * PURPOSE		:	Entry point for the application
 * PARAMETERS	:   int argc-no. of arguments passed
 					char * argv-list of arguments
 ******************************************************************************/
 int main(int argc,  char * argv[])
 {
 	if(argc<2)
 	{
 		printf(αInvalid syntaxnCorrect usage %s <input filename> [<output filename>]α,argv[0]);
 		exit(1);
 	}
 	else
 	{
 	
 		GetMinNumberOfSwitches(argv[1],argv[2]);
 	}
 	return 0;
 }
 
 /******************************************************************************
 *
 * ENTRY POINT	:	GetMinNumberOfSwitches
 * PURPOSE		:	Parses input file and processes testcases
 * PARAMETERS	:   char * pc_input_file_name-name of input file
 					char * pc_output_file_name-name of output file
 ******************************************************************************/
 
 void GetMinNumberOfSwitches(char * pc_input_file_name,char * pc_output_file_name)
 {
 	
 	FILE * pf_input;					//Input file pointer
 	FILE * pf_output;					//Output file pointer
 	int i_testcases = 0;				//number of test-cases
 	int i_search_engines = 0;			//number of search engines
 	int i_queries = 0;					//number of queries
 	int i_testcase_counter = 0;			//test-case being processed
 	int i_search_engine_counter;		//search engine being processed
 	int i_queries_counter = 0;			//query being processed
 	int i_switches_required = 0;		//total number of switches required 
 										//to process all queries
 	char ** ppc_search_engines = NULL;	//array of pointers to strings 
 										//ie. names of search engines
 	int * pi_search_engine_clash = NULL;//register recording whether a query to 
 										//this search engine has been found
 	int i_all_registers_set = 0;		//set if all search engines 
 										//have been queried atleast once
 	char * pc_query = NULL;				//query string
 	int i_last_chosen_engine = 0;		//Index of engine chosen before the switch
 	char c_outputstring_t[256];			//Output string
 
 	if(pc_input_file_name != NULL)
 	{
 		pf_input = fopen(pc_input_file_name,αrα);
 		if(pf_input == NULL)
 		{
 			printf(αInvalid input file nameα);
 			exit(1);
 		}
 		if(pc_output_file_name != NULL)
 		{
 			pf_output = fopen(pc_output_file_name,αwα);
 		}
 		else
 		{
 			pf_output = fopen(DEFAULT_OUTPUT_FILENAME,αwα);
 		}
 		if(pf_output == NULL)
 		{
 			printf(αCannot create output fileα);
 			exit(1);
 		}
 		/*get number of test-cases*/
 		i_testcases = GetNumberOnLine(pf_input);
 		for(i_testcase_counter = 0;i_testcase_counter < i_testcases;i_testcase_counter++)
 		{
 			//set number of switches to 0 initially
 			i_switches_required = 0;
 
 			//get number of search engines
 			i_search_engines = GetNumberOnLine(pf_input);
 			//allocate registers for each search engine
 			pi_search_engine_clash = (int *) malloc(i_search_engines*sizeof(int));
 			//array of pointers to search engine names
 			ppc_search_engines = (char **)malloc(i_search_engines*sizeof(char*));
 			//store search engine names
 			for(i_search_engine_counter = 0;i_search_engine_counter<i_search_engines;i_search_engine_counter++)
 			{
 				ppc_search_engines[i_search_engine_counter] = GetStringOnLine(pf_input);
 			}
 			/*get number of queries*/
 			i_queries = GetNumberOnLine(pf_input);
 			//set all search engine registers to zero before processing queries
 			for(i_search_engine_counter = 0;i_search_engine_counter < i_search_engines;i_search_engine_counter++)
 			{
 				pi_search_engine_clash[i_search_engine_counter] = 0;
 			}
 			//process each query
 			for(i_queries_counter = 0;i_queries_counter<i_queries;i_queries_counter++)
 			{
 				//get query string
 				pc_query = GetStringOnLine(pf_input);
 				//Set register for the search engine which this query matches
 				for(i_search_engine_counter = 0;i_search_engine_counter < i_search_engines;i_search_engine_counter++)
 				{
 					if(!strcmp(pc_query,ppc_search_engines[i_search_engine_counter]))
 					{
 						pi_search_engine_clash[i_search_engine_counter] = 1;
 						i_last_chosen_engine = i_search_engine_counter;
 						break;
 					}
 				}
 				//Check if all registers are set
 				for(i_search_engine_counter = 0,i_all_registers_set = 1;i_search_engine_counter < i_search_engines;i_search_engine_counter++)
 				{
 					if(pi_search_engine_clash[i_search_engine_counter] == 0)
 					{
 						i_all_registers_set = 0;
 						break;
 					}
 				}
 				if(i_all_registers_set)
 				{
 					//If all registers are set this query involves a switch of search engines
 					//Hence increment number of switches for this test case
 					i_switches_required++;
 					//clear all registers to indicate a new search engine has been chosen
 					//except for register for last chosen search engine
 					//as this engine cannnot be chosen again
 					for(i_search_engine_counter = 0,i_all_registers_set = 1;i_search_engine_counter < i_search_engines;i_search_engine_counter++)
 					{
 						if(i_search_engine_counter != i_last_chosen_engine)
 						{
 							pi_search_engine_clash[i_search_engine_counter] = 0;
 						}
 					}
 				}
 				//free query string memory
 				free(pc_query);
 			}
 			//write result for test-case to output file
 			sprintf(c_outputstring_t,αCase #%d: %dnα,i_testcase_counter+1,i_switches_required);
 			fputs(c_outputstring_t,pf_output);
 			//free registers
 			free(pi_search_engine_clash);
 			//free search engine strings
 			for(i_search_engine_counter = 0;i_search_engine_counter < i_search_engines;i_search_engine_counter++)
 			{
 				free(ppc_search_engines[i_search_engine_counter]);
 			}
 
 		}
 	fclose(pf_input);
 	fclose(pf_output);
 	}
 	
 }
 
 
 /******************************************************************************
 *
 * ENTRY POINT	:	GetNumberOnLine
 * PURPOSE		:	Return the value on the current line in input file as an integer
 * PARAMETERS	:   FILE *pf_input-Input file pointer
 ******************************************************************************/
 
 int GetNumberOnLine(FILE *pf_input)
 {
 	char * pc_buff_t = NULL;	//temporary buffer to hold no.as a string
 	char c_read;		//To read the file character by character
 	int i_counter = 0;	//counter for the loop
 	int i_result =0;		//Number
 
 	pc_buff_t = (char *) malloc(MAX_LENGTH_OF_NUMBER * sizeof(char));
 	for(i_counter = 0;
 		(c_read = fgetc(pf_input))!='n'&&(c_read != EOF);
 		i_counter++)
 	{
 		pc_buff_t[i_counter] = c_read;
 	}
 	pc_buff_t[i_counter] = '0';
 	i_result=atoi(pc_buff_t);
 	free((void*)pc_buff_t);
 	return(i_result);
 }
 
 /******************************************************************************
 *
 * ENTRY POINT	:	GetStringOnLine
 * PURPOSE		:	Return the value on the current line in input file as a string
 * PARAMETERS	:   FILE *pf_input-Input file pointer
 ******************************************************************************/
 
 char * GetStringOnLine(FILE *pf_input)
 {
 	char c_buff_t[MAX_LENGTH_OF_STRING];	//temporary buffer to hold string 
 	char * pc_buff;							//Pointer to buffer to be returned
 	char c_read;							//To read the file character by character
 	int i_counter = 0;						//counter for the loop
 
 	//read till the new line from from file
 	for(i_counter = 0;
 		(c_read = fgetc(pf_input))!='n'&&(c_read != EOF)&&(i_counter<MAX_LENGTH_OF_STRING);
 		i_counter++)
 	{
 		c_buff_t[i_counter] = c_read;
 	}
 	c_buff_t[i_counter++] = '0';
 
 	//alllocate the buffer to return !do not deallocate!
 	pc_buff = (char *)malloc(i_counter*sizeof(char));
 
 	//copy data to return buffer
 	for(i_counter = 0;c_buff_t[i_counter];i_counter++)
 	{
 		pc_buff[i_counter] = c_buff_t[i_counter];
 	}
 	pc_buff[i_counter] = c_buff_t[i_counter];
 	return pc_buff;
 }"
29819,2008,32013,viashino,24480,1,A.c,gcj/2008/32013/viashino/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_S 100 
 #define MAX_Q 1000 
 
 
 
 char site[MAX_S][100];
 int  count[MAX_S];
 int  output,S,Q,cur_site;
 
 int zero_count;
 int zero_site;
  
 
 void initCount(); 
 int check(char input[1000]);
 
 
 int main()
 {
         FILE* fpt;
         FILE* fout;
         int Case=1,N;
         fpt=fopen(αA-large.in.txtα,αrα);  
         fout=fopen(αlarge.out.txtα,αwα); 
         fscanf(fpt,α%dnα,&N);  
 
         int i,j;
         while(Case<=N)
         {
             fscanf(fpt,α%dnα,&S);     
                     
             for(i=0;i<S;i++)
                 for(j=0;site[i][j]=fgetc(fpt);j++)
                     if(site[i][j]=='n')
                     { 
                        site[i][j]='0'; 
                         break;
                     }         
 
 
             fscanf(fpt,α%dnα,&Q);  
 
             initCount();
             output=0;
             
             cur_site=-1; 
             char temp[1000]; 
 
             for(i=0;i<Q;i++)
             {
                 
                 for(j=0;temp[j]=fgetc(fpt);j++)
                     if(temp[j]=='n')
                     { 
                        temp[j]='0'; 
                         break;
                     }         
                 //printf(α%snα,temp);
                 check(temp); 
                 //printf(α%dnα,cur_site);
             } 
 
             fprintf(fout,αCase #%d: %dnα,Case,output);
 
             Case++;            
         }
         fclose(fpt);
         fclose(fout);
         system(αPAUSEα);
     
 }
 
 void initCount()
 {
     int i;
     for(i=0;i<MAX_S;i++)
         count[i]=0;
 
 }
 
 int check(char input[1000])
 {
     int i;
     zero_count=0;
 
     if(cur_site!=-1)
         count[cur_site]++;
     
         for(i=0;i<S;i++)
         {
             if(strcmp(input,site[i])==0)
                 count[i]++;
 
             if(count[i]==0)
             {
                 zero_count++;
                 zero_site=i;
             }           
         }
 
         if(zero_count==0)
         {
             if(cur_site==zero_site)
                 cur_site=cur_site^1;
             else
                 cur_site=zero_site;    
             //printf(α%dnα,cur_site);        
             output++;
             initCount();            
         }      
 }"
29821,2008,32013,viashino,24481,1,B.c,gcj/2008/32013/viashino/24481/1/extracted/B.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAX_NAB 100
 
 int turn,NAB[2];
 int out[2];
 struct trip
 {
     int dep;
     int arr;
     int x;
 }trip[2][MAX_NAB]; 
 
 void swap(int type,int in1,int in2);
 void sort();
 int checkx();
 
 int main()
 {
         FILE* fpt;
         FILE* fout;
         int Case=1,N;
         fpt=fopen(αB-large.in.txtα,αrα);  
         fout=fopen(αB-large.out.txtα,αwα); 
         fscanf(fpt,α%dnα,&N);  
 
 
         int i,j;
         while(Case<=N)
         {
             fscanf(fpt,α%dnα,&turn);
             fscanf(fpt,α%d %dnα,&NAB[0],&NAB[1]);
             int a,b,c,d; 
 
             for(j=0;j<=1;j++)
             { 
                 for(i=0;i<NAB[j];i++)
                 {
                     fscanf(fpt,α%d:%d %d:%dnα,&a,&b,&c,&d);
                     trip[j][i].dep=a*60+b; 
                     trip[j][i].arr=c*60+d;
                     trip[j][i].x=0;
                 }
             } 
 
 
 
             sort();
             out[0]=0;out[1]=0;
             int tmp1,tmp2,start,s;
 
            // printf(α%dα,turn);
             while(checkx())
             {
                 for(i=0;i<NAB[0];i++)
                     if(trip[0][i].x==0)
                     { 
                         tmp1=i;
                         break; 
                     } 
                 if(i==NAB[0])
                     trip[0][tmp1].dep=10000000;
 
                 for(i=0;i<NAB[1];i++)
                     if(trip[1][i].x==0)
                     {
                         tmp2=i;
                         break; 
                     } 
                 if(i==NAB[1])
                     trip[1][tmp2].dep=10000000;
 
                 if(trip[0][tmp1].dep<trip[1][tmp2].dep) 
                 {
                     start=tmp1;
                     s=0;
                 }
                 else if (trip[0][tmp1].dep>trip[1][tmp2].dep) 
                 {
                     start=tmp2;
                     s=1;
                 }
                 else if(trip[0][tmp1].arr<trip[1][tmp2].arr)
                 {
                     start=tmp1;
                     s=0;
                 }
                 else
                 {
                     start=tmp2;
                     s=1;
                 } 
 
                 trip[s][start].x=1;
                 out[s]++;
                 //printf(α1s=%d start=%dnα,s,start); 
 
                 while(1)
                 {
                     int s1=s^1;
                     for(i=0;i<NAB[s1];i++)
                     {
                         if(trip[s1][i].dep >=(trip[s][start].arr+turn) && trip[s1][i].x==0)
                         {
                             trip[s1][i].x=1;
                             s=s1;
                             start=i;
                             //printf(αs=%d start=%dnα,s,start); 
                             
                             break;
                         }             
                         
                     }
             
                     if(i==NAB[s1])
                     {
                      //   printf(α2nα);
                         break;
                     }
                 
                    // system(αPAUSEα);
 
                 }
                 // printf(α2s=%d start=%dnα,s,start); 
                 //printf(αx=%dnα,trip[s][start].x);
                 //system(αPAUSEα);
 
                 
 
             }
                 
             fprintf(fout,αCase #%d: %d %dnα,Case,out[0],out[1]);
 
         
 
 /*            for(i=0;i<NAB[0];i++)
                 printf(α%d %dnα,trip[0][i].dep,trip[0][i].arr);
             for(i=0;i<NAB[1];i++)
                 printf(α%d %dnα,trip[1][i].dep,trip[1][i].arr);*/
     
 
             Case++;            
         }
         fclose(fpt);
         fclose(fout);
         system(αPAUSEα);
     
 }
 
 void sort()
 {
     int i,j,k;
     for(k=0;k<2;k++) 
         for(i=0;i<NAB[k];i++)      
             for(j=i+1;j<NAB[k];j++)        
                 if(trip[k][j].dep<trip[k][i].dep)            
                     swap(k,i,j);
 }
 
 void swap(int type,int in1,int in2)
 {
     int t1,t2,t3;
 
         t1=trip[type][in1].dep;
         t2=trip[type][in1].arr;
         t3=trip[type][in1].x;
         trip[type][in1].dep=trip[type][in2].dep; 
         trip[type][in1].arr=trip[type][in2].arr;
         trip[type][in1].x=trip[type][in2].x;
         trip[type][in2].dep=t1;
         trip[type][in2].arr=t2;
         trip[type][in2].x=t3;
 
 }
 
 int checkx()
 {
     int i,j;
 
     for(i=0;i<2;i++)
         for(j=0;j<NAB[i];j++)
             if(trip[i][j].x==0)
                 return 1;
 
     return 0;
 
 }"
29964,2008,32013,greafine,24480,1,A.c,gcj/2008/32013/greafine/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAXS 112
 #define MAXQ 1123
 
 #define INF 10123
 
 #define Min(a,b) ((a)<(b)?(a):(b))
 
 int n, m;
 
 char engines[MAXS][MAXS];
 char queries[MAXQ][MAXS];
 
 int memo[MAXS][MAXQ];
 
 int rec(int s, int q) {
   int i, res;
 
   if (q == m)
     return 0;
 
   if (memo[s][q] != -1)
     return memo[s][q];
 
   if (strcmp(engines[s], queries[q]))
     res = rec(s, q+1);
   else {
     res = INF;
     for (i = 0; i < n; i++) {
       if (i == s)
 	continue;
       res = Min(res, rec(i, q+1)+1);
     }
   }
   
   return memo[s][q] = res;
 }
 
 int main() {
   int i, t;
   int res, cases=1;
   
   scanf(α%dα, &t);
   while (t--) {
     scanf(α%d α, &n);
     for (i = 0; i < n; i++)
       gets(engines[i]);
     scanf(α%d α, &m);
     for (i = 0; i < m; i++)
       gets(queries[i]);
 
     res = INF;
     memset(memo, -1, sizeof(memo));
     for (i = 0; i < n; i++) 
       if (strcmp(engines[i], queries[0])) {
 	res = Min(res, rec(i, 0));
       }
     printf(αCase #%d: %dnα, cases++, res);
 
   }
 
   return 0;
 }"
29981,2008,32013,HowDa,24480,1,a.c,gcj/2008/32013/HowDa/24480/1/extracted/a.c,"#include<stdio.h>
 int record[102],engine;
 void clear(){
 	int i;
 	for(i=0;i<engine;i++)
 		record[i]=0;
 }
 int main(){
 	char E[102][102],Q[1002][102];
 	int cases,query,i,count,j,switchtimes,k=1;
 	scanf(α%dα,&cases);
 	while(k<=cases){
 		count=0;
 		switchtimes=0;
 		scanf(α%d%*cα,&engine);
 		for(i=0;i<engine;i++)
 			fgets(E[i],102,stdin);
 		scanf(α%d%*cα,&query);
 		clear();
 		for(i=0;i<query;i++)
 			fgets(Q[i],102,stdin);
 		for(i=0;i<query;i++){
 			for(j=0;j<engine;j++){
 				if(!strcmp(E[j],Q[i])){
 					if(record[j]==0){
 						record[j]=1;
 						count++;
 					}
 					break;
 				}
 			}
 			if(count==engine){
 				count=0;
 				switchtimes++;
 				clear();
 				i--;
 			}
 		}
 		printf(αCase #%d: %dnα,k,switchtimes);
 		k++;
 	}
 	return 0;
 }"
30020,2008,32013,anuj27,24480,1,SavingTheUniverse.c,gcj/2008/32013/anuj27/24480/1/extracted/SavingTheUniverse.c,"/* Saving the Universe */
 
 #include<stdio.h>
 #include<conio.h>
 #include<string.h>
 
 main()
 {
       int N, S, Q, i, j, k, l, count, final; 
       char s_engines[101][101], querries[1001][101];
       int a[100];
       
       scanf (α%dα, &N);      
       for (i=0; i<N; i++)
       {
           scanf (α%dα, &S);
           for (j=0; j<=S; j++)
           {
               gets(s_engines[j]);              
           }          
           scanf (α%dα, &Q);
           for (j=0; j<=Q; j++)
           {
               gets(querries[j]);            
           }
             
           for (j=1; j<=S; j++)
           {
               a[j] = 0;
           }
           final = 0;
           count = 0;
           for (j=1; j<=Q; j++)
           {
               for (k=1; k<=S; k++)
               {
                   if (strcmp(querries[j], s_engines[k]) == 0)
                   {
                       if (a[k] == 0)
                       {
                           a[k] = 1;
                           count++;
                           if (count==S)
                           {
                               final++;
                               for (l=1; l<=S; l++)
                               {
                                   a[l] = 0;
                               }
                               count = 0;
                               a[k] = 1;
                               count++;
                           }
                       }
                   }
               }
           }      
           printf (αCase #%d: %dnα, i+1, final);          
       }      
 }"
30022,2008,32013,anuj27,24481,1,TrainTimetable.c,gcj/2008/32013/anuj27/24481/1/extracted/TrainTimetable.c,"/* Train Timetable */
 
 #include<stdio.h>
 #include<string.h>
 
 main()
 {
       int N, T, NA, NB, i, j, k, temp, h, m, count_A, count_B; 
       char str[10];
       int A_departure[100], A_arrival[100], B_departure[100], B_arrival[100];
       
       
       scanf (α%dα, &N);      
       for (i=0; i<N; i++)
       {
           scanf (α%dα, &T);
           scanf (α%dα, &NA);
           scanf (α%dα, &NB);
           
           for (j=0; j<NA; j++)
           {
               scanf (α%sα, &str);     
               sscanf(str, α%d:%dα, &h, &m);    
               A_departure[j] = (h*60) + m;       
               scanf (α%sα, &str);     
               sscanf(str, α%d:%dα, &h, &m); 
               A_arrival[j] = (h*60) + m;
           }         
           for (j=0; j<NB; j++)
           {
               scanf (α%sα, &str);      
               sscanf(str, α%d:%dα, &h, &m);
               B_departure[j] = (h*60) + m;           
               scanf (α%sα, &str);     
               sscanf(str, α%d:%dα, &h, &m);  
               B_arrival[j] = (h*60) + m;          
           }
             
           for (j=0; j<NA-1; j++) 
           {
               for (k=0; k<NA-1-j; k++)
               {
                   if (A_departure[k+1] < A_departure[k]) 
                   { 
                       temp = A_departure[k];        
                       A_departure[k] = A_departure[k+1];
                       A_departure[k+1] = temp;
                   }
                   if (A_arrival[k+1] < A_arrival[k]) 
                   { 
                       temp = A_arrival[k];        
                       A_arrival[k] = A_arrival[k+1];
                       A_arrival[k+1] = temp;
                   }
               }
           }
           for (j=0; j<NB-1; j++) 
           {
               for (k=0; k<NB-1-j; k++)
               {
                   if (B_departure[k+1] < B_departure[k]) 
                   { 
                       temp = B_departure[k];        
                       B_departure[k] = B_departure[k+1];
                       B_departure[k+1] = temp;
                   }
                   if (B_arrival[k+1] < B_arrival[k]) 
                   { 
                       temp = B_arrival[k];        
                       B_arrival[k] = B_arrival[k+1];
                       B_arrival[k+1] = temp;
                   }
               }
           }
           
           count_A = 0;
           for (j=0; j<NA; j++)
           {
               if (A_departure[j] >= (B_arrival[count_A] + T) && count_A<NB)
               {
                   count_A++;
               }
           }
           count_B = 0;
           for (j=0; j<NB; j++)
           {
               if (B_departure[j] >= (A_arrival[count_B] + T) && count_B<NA)
               {
                   count_B++;
               }
           }           
           
           printf (αCase #%d: %d %dnα, i+1, NA-count_A, NB-count_B);          
       }          
 }"
30097,2008,32013,ranjan,24480,1,g1finalb.c,gcj/2008/32013/ranjan/24480/1/extracted/g1finalb.c,"#include<stdio.h>
 #include<string.h>
 #include<conio.h>
 #include<ctype.h>
 #include<stdlib.h>
 #include<alloc.h>
 int findmin(int *sc, int ns);
 void main()
 {int i,ns,nq,j,min,nos=0,k,flag[100],val=0,res[21],cnt=0;
  int sc[10];
  char *se[101],*sq,ts[100],a[10];
  FILE *fp,*fq;
  fp=fopen(αA-large.inα,αrα);
  printf(α%dα,fp);
   fgets(ts,100,fp);
  printf(α%sα,ts);
  while(!feof(fp))
  {
 
  //for(k=1;k<=100;k++)
  fgets(ts,100,fp);
  printf(α%snα,ts);
  ns=atoi(ts);
  for(i=0;i<ns;i++)
 	{fgets(ts,100,fp);
 	 se[i]=(char *)malloc(strlen(ts)*sizeof(char));
 	 strcpy(se[i],ts);
 	 printf(α%sα,se[i]);
 	}                                   
   fgets(ts,100,fp);
  printf(α%snα,ts);
  nq=atoi(ts);
  /*for(i=0;i<nq;i++)
 	{fgets(ts,100,fp);
 	 sq[i]=(char *)malloc(strlen(ts)*sizeof(char));
 	 strcpy(sq[i],ts);
 	 printf(α%sα,sq[i]);
 	}*/
  for(j=0;j<ns;j++)
 		flag[j]=0;
  for(i=0;i<nq;i++)
 	{fgets(ts,100,fp);
 		 sq=(char *)malloc(strlen(ts)*sizeof(char));
 		 strcpy(sq,ts);
 		 printf(αsq=%sα,sq);
 	 for(j=0;j<ns;j++)
 		{
 		 if(strcmp(se[j],sq)==0)
 			{flag[j]=1;
 			 min=j;
 			  printf(α%d %dnα,min,ns);}
 			}
 	 //getch();
 	 for(j=0;j<ns;j++)
 		if(flag[j])
 			{
 			 if(j==ns-1)
 				val=1;
 			}
 		else break;
 	 if(val==0)
 		continue;
 	 else val=0;
 	 printf(α%snα,se[min]);
 	 nos++;
 	 for(j=0;j<ns;j++)
 		flag[j]=0;
 	 flag[min]=1;
 
 	 }
  printf(αResult=%d %dnα,nos,cnt+1);
  res[cnt++]=nos;
  nos=0;
  getch();
  }
  fclose(fp);
 	fq=fopen(αA-large.txtα,αwtα);
  for(i=0;i<20;i++)
 	{itoa(i+1,a,10);
 
 	printf(αnCase #%d: %dnα,i+1,res[i]);
 	fputs(αCase #α,fq);
 	fputs(a,fq);
 	fputs(α: α,fq);
 	itoa(res[i],a,10);
 	fputs(a,fq);
 	fputc('n',fq);
 	getch();
 	}
  fclose(fq);
 }"
30165,2008,32013,timerover,24480,1,A.c,gcj/2008/32013/timerover/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 int main() {
     int i, j, k, flag, count, last;
     int n, s, q, engine_mark[500];
     char engine[500][200], query[200], nl;
 
     scanf(α%dα, &n);
     for(i = 0; i < n; i++) {
 	count = 0;
 	scanf(α%dα, &s);
 	scanf(α%cα, &nl);
 	for(j = 0; j < s; j++) {
 	    fgets(engine[j], 200, stdin);
 	    engine_mark[j] = 0;
 	}
 	scanf(α%dα, &q);
 	scanf(α%cα, &nl);
 	for(j = 0; j < q; j++) {
 	    fgets(query, 200, stdin);
 	    for(k = 0; k < s; k++) {
 		if(strcmp(query, engine[k]) == 0) {
 		    engine_mark[k] = 1;
 		    last = k;
 		}
 	    }
 	    flag = 0;
 	    for(k = 0; k < s; k++) {
 		if(engine_mark[k] == 0) {
 		    flag = 1;
 		    break;
 		}
 	    }
 	    if(flag == 0) {
 		for(k = 0; k < s; k++) {
 		    engine_mark[k] = 0;
 		}
 		engine_mark[last] = 1;
 		count++; 
 	    }
 	}
 	printf(αCase #%d: %dnα, i+1, count);
     }
     return 0;
 }"
30167,2008,32013,timerover,24481,1,B.c,gcj/2008/32013/timerover/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int compare (const void *a, const void *b){
     return ( *(int*)a - *(int*)b );
 }
 
 int main() {
     int i, j, k;
     int n, na, nb, t, aa, ab, pos;
     int as[200], ae[200], bs[200], be[200];
     char time[50], str[50];
 
     scanf(α%dα, &n);
     for(i = 0; i < n; i++) {
 	scanf(α%dα, &t);
 	scanf(α%d %dα, &na, &nb);
 	for(j = 0; j < na; j++) {
 	    scanf(α%sα, time);
 	    time[2] = '0';
 	    as[j] = atoi(time) * 60 + atoi(time+3);
             scanf(α%sα, time);
             time[2] = '0';
             ae[j] = atoi(time) * 60 + atoi(time+3);
 	}
 	qsort(as, na, sizeof(as[0]), compare);
 	qsort(ae, na, sizeof(ae[0]), compare);
         for(j = 0; j < nb; j++) {
             scanf(α%sα, time);
             time[2] = '0';
             bs[j] = atoi(time) * 60 + atoi(time+3);
             scanf(α%sα, time);
             time[2] = '0';
             be[j] = atoi(time) * 60 + atoi(time+3);
         }
         qsort(bs, nb, sizeof(bs[0]), compare);
         qsort(be, nb, sizeof(be[0]), compare);
 
 	aa = na;
 	pos = 0;
 
 	for(j = 0; j < na; j++) {
 	    for(k = pos; k < nb; k++) {
 		if(as[j] >= be[k] + t) {
 		    aa--;
 		    pos = k + 1;
 		    break;
 		}
 	    }
 	}
 
 	ab = nb;
 	pos = 0;
 
         for(j = 0; j < nb; j++) {
             for(k = pos; k < na; k++) {
                 if(bs[j] >= ae[k] + t) {
                     ab--;
                     pos = k + 1;
                     break;
                 }
             }
         }
 
 	printf(αCase #%d: %d %dnα, i+1, aa, ab);
     }
     return 0;
 }"
30196,2008,32013,cavegeek,24480,1,universe.c,gcj/2008/32013/cavegeek/24480/1/extracted/universe.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef enum {FALSE, TRUE} bool;
 
 typedef struct TrieNode_tag {
 	bool hasValue;
 	unsigned value;
 
 	struct TrieNode_tag *next[256];
 } TrieNode;
 
 typedef TrieNode * Trie;
 typedef TrieNode * TrieNav;
 
 void trieConstruct(Trie *t) {
 	int i;
 
 	*t = (TrieNode *)malloc(sizeof(TrieNode));
 	for(i = 0; i < 256; i++)
 		(*t)->next[i] = NULL;
 	(*t)->hasValue = FALSE;
 }
 
 void trieDestruct(Trie *t) {
 	int i;
 	
 	if(*t == NULL)
 		return;
 	for(i = 0; i < 256; i++)
 		trieDestruct(&((*t)->next[i]));
 	free(*t);
 	(*t) = NULL;
 }
 
 TrieNav trieNavigate(Trie t) {
 	return t;
 }
 
 void trieNavMake(TrieNav *n, int c) {
 	if((*n)->next[c] == NULL) {
 		trieConstruct(&((*n)->next[c]));
 	}
 	(*n) = (*n)->next[c];
 }
 
 void trieNavSet(TrieNav n, unsigned val) {
 	n->hasValue = TRUE;
 	n->value = val;
 }
 
 bool trieNavNav(TrieNav *n, int c) {
 	if((*n)->next[c] == NULL) {
 		return FALSE;
 	} else {
 		(*n) = (*n)->next[c];
 		return TRUE;
 	}
 }
 
 bool trieNavHasVal(TrieNav n) {
 	return n->hasValue;
 }
 
 unsigned trieNavGet(TrieNav n) {
 	return n->value;
 }
 
 int main() {
 	unsigned cases = 0;
 	unsigned cas = 0;
 
 	scanf(α%uα, &cases);
 
 	for(cas = 1; cas <= cases; cas++) {
 		unsigned engines = 0;
 		unsigned engine = 0;
 
 		unsigned queries = 0;
 
 		Trie engineNums = NULL;
 		trieConstruct(&engineNums);
 		TrieNav nav = trieNavigate(engineNums);
 
 		scanf(α%uα, &engines);
 		scanf(α α); /* eats newline */
 
 		for(engine = 0; engine < engines; engine++) {
 			/* put engines into the trie */
 
 			int c = getchar();
 			
 			while(c != 'n') {
 				trieNavMake(&nav,c);
 				c = getchar();
 			}
 			trieNavSet(nav,engine);
 			nav = trieNavigate(engineNums);
 		}
 
 		scanf(α%uα, &queries);
 		scanf(α α); /* eats newline */
 
 		{
 			unsigned switches = 0;
 
 			unsigned numUsed = 0;
 			
 			unsigned query = 0;
 
 			unsigned i = 0;
 
 			bool *usedEngines = malloc(sizeof(bool)*engines);
 			for(i = 0; i < engines; i++)
 				usedEngines[i] = FALSE;	
 
 
 			for(query = 0; query < queries; query++) {
 				/* go through the queries, seeing how many switches are needed */
 				
 				/* greedy (going as far without a switch as possible) is optimal */
 
 				unsigned queryEngine = 0;
 
 				int c = getchar();
 
 				nav = trieNavigate(engineNums);
 				
 				while(c != 'n') {
 					if(!trieNavNav(&nav,c)) {
 						puts(αerror: invalid search enginenα);
 						return 1;
 					}
 					c = getchar();
 				}
 
 				if(!trieNavHasVal(nav)) {
 					puts(αerror: invalid search enginenα);
 				}
 
 				queryEngine = trieNavGet(nav);
 				if(!usedEngines[queryEngine]) {
 					numUsed++;
 					usedEngines[queryEngine] = TRUE;
 
 					if(numUsed >= engines) {
 						switches++;
 						numUsed = 1;
 						for(i = 0; i < engines; i++)
 							usedEngines[i] = FALSE;
 						usedEngines[queryEngine] = TRUE;
 					}
 				}
 			}
 
 			printf(αCase #%u: %unα, cas, switches);
 
 			free(usedEngines);
 
 		}
 		trieDestruct(&engineNums);
 	}
 
 	return 0;
 }"
30232,2008,32013,busta,24480,1,main.c,gcj/2008/32013/busta/24480/1/extracted/main.c,"#include <stdio.h>
 #include <string.h>
 #define MAX 100
 #define MAXS 100
 #define MAXQ 1000
 
 int main (int argc, char *argv[]){
 
 	char search[MAXS][MAX] = {'0'}, query[MAXQ][MAX] = {'0'};
 	int n, s, q, trocas, busca, init;
 	int t, i, j;
 	
 	FILE *input, *output;
 	input = fopen (αfile.inα,αrα);
 	output = fopen (αfile.outα,αwα);
 
 	fscanf(input, α%dα,&n);
 	for (t=1; t<=n; t++){
 		trocas = 0;
 		busca = 0;
 		
 		fscanf (input, α%dnα, &s);
 		for (j=0; j<s; j++)
 			fgets (search[j],MAX,input);
 		
 		fscanf (input, α%dnα, &q);
 		for (j=0; j<q; j++)
 			fgets (query[j],MAX,input);
 
 		while (1){			
 			init = busca;
 
 			for (i=0; i<s; i++){
 				for (j = init; j<q; j++){
 					if ( strcmp (search[i],query[j]) == 0 )
 						break;
 				}
 				if (busca <= j)
 					busca = j;
 			}
 
 			if (busca < q)
 			trocas++;
 			if (busca == q)
 				break;
 		}	
 		fprintf (output,αCase #%d: %dnα, t, trocas);
 	}
 	fclose (input);
 	fclose (output);
 	return 0;
 }"
30282,2008,32013,Kivson,24480,1,busca1.c,gcj/2008/32013/Kivson/24480/1/extracted/busca1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 int main(char argc,char **argv)
 {
 	FILE *in, *out;
 	char *temp, S[101][2000], Q[1001][2000];
 	int i, j, k, N, maxS, maxQ, resp, qtdS[101], trocou, ultimo;
 	temp = (char *) malloc(sizeof(char)*2000);
 	in = fopen(argv[1],αrα);
 	out= fopen(αoutα,αw+α);
 	temp=fgets(temp,2000,in);
 	sscanf(temp,α%dα,&N);
 	for(i=1;i<=N;i++)
 	{
 		resp=0;
 		temp=fgets(temp,2000,in);
 		sscanf(temp,α%dα,&maxS);
 		for(j=0;j<maxS;j++){
 			temp=fgets(temp,2000,in);
 			sscanf(temp,α%[^n]α,S[j]);
 		}
 		temp=fgets(temp,2000,in);
 		sscanf(temp,α%dα,&maxQ);
 		for(j=0;j<maxQ;j++){
 			temp=fgets(temp,2000,in);
 			sscanf(temp,α%[^n]α,Q[j]);
 		}
 		
 		for(k=0;k<maxS;k++) qtdS[k]=0;
 		
 		for(j=0;j<maxQ;j++){
 			for(k=0;k<maxS;k++){
 				if(strcmp(Q[j],S[k])==0)
 				{
 					qtdS[k]=1;
 					ultimo=k;
 				}
 			}
 			trocou=1;
 			for(k=0;k<maxS;k++){
 				if(qtdS[k]==0) trocou=0;
 			}
 			if(trocou){
 				resp++;
 				for(k=0;k<maxS;k++) qtdS[k]=0;
 				qtdS[ultimo]=1;
 			}
 		}
 		fprintf(out,αCase #%d: %dnα,i,resp);
 	}
 	return 0;
 }"
30284,2008,32013,Kivson,24481,1,trens.c,gcj/2008/32013/Kivson/24481/1/extracted/trens.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct h{
 	int partH, partMin, chegH, chegMin, ativo;
 }horario;
 
 void permutacaoC(horario *v, int tam);
 void permutacaoP(horario *v, int tam);
 
 int main(char argc,char **argv)
 {
 	FILE *in, *out;
 	char *temp;
 	int i, j, k, N, T,NA, NB, a, b;
 	horario A[101], B[101];
 	temp = (char *) malloc(sizeof(char)*2000);
 	in = fopen(argv[1],αrα);
 	out= fopen(αout.trensα,αw+α);
 	temp=fgets(temp,2000,in);
 	sscanf(temp,α%dα,&N);
 	for(i=1;i<=N;i++)
 	{
 		temp=fgets(temp,2000,in);
 		sscanf(temp,α%dα,&T);
 		//printf(α%dα,T);
 		temp=fgets(temp,2000,in);
 		sscanf(temp,α%d %dα,&NA, &NB);
 		a=NA;
 		b=NB;
 		for(j=0;j<NA;j++)
 		{
 			temp=fgets(temp,2000,in);
 			sscanf(temp,α%d:%d %d:%dα,&A[j].partH,&A[j].partMin,&A[j].chegH,&A[j].chegMin);
 			A[j].chegMin=A[j].chegMin+T;
 			A[j].ativo=1;
 			if(A[j].chegMin>60)
 			{
 				A[j].chegMin=A[j].chegMin-60;
 				A[j].chegH++;
 			}
 			//printf(α%d:%d %d:%dnα,A[j].partH,A[j].partMin,A[j].chegH,A[j].chegMin);
 		}
 
 		for(j=0;j<NB;j++)
 		{
 			temp=fgets(temp,2000,in);
 			sscanf(temp,α%d:%d %d:%dα,&B[j].partH,&B[j].partMin,&B[j].chegH,&B[j].chegMin);
 			B[j].chegMin=B[j].chegMin+T;
 			B[j].ativo=1;
 			if(B[j].chegMin>=60)
 			{
 				B[j].chegMin=B[j].chegMin-60;
 				B[j].chegH++;
 			}
 			//printf(α%d:%d %d:%dnα,B[j].partH,B[j].partMin,B[j].chegH,B[j].chegMin);
 		}
 
 		//ordenar A por chegadas e B por partidas
 		permutacaoC( A, NA);
 		permutacaoP( B, NB);
 		/*for(j=0;j<NA;j++)
 		{
 			printf(α%d:%d %d:%dnα,A[j].partH,A[j].partMin,A[j].chegH,A[j].chegMin);
 		}
 		for(j=0;j<NB;j++)
 		{
 			printf(α%d:%d %d:%dnα,B[j].partH,B[j].partMin,B[j].chegH,B[j].chegMin);
 		}*/
 		for(j=0;j<NA;j++)
 		{
 			for(k=0;k<NB;k++)
 			{
 				if(B[k].ativo==1 && ( A[j].chegH<B[k].partH ||  ( A[j].chegMin<=B[k].partMin && A[j].chegH==B[k].partH)))
 				{
 					B[k].ativo=0;
 					b--;
 					break;
 				}
 			}
 		}
 
 		//ordenar B por chegadas e A por partidas
 		permutacaoP( A,  NA);
 		permutacaoC( B,  NB);
 
 		for(j=0;j<NB;j++)
 		{
 			for(k=0;k<NA;k++)
 			{
 				if(A[k].ativo==1 && ( B[j].chegH<A[k].partH ||  ( B[j].chegMin<=A[k].partMin && B[j].chegH==A[k].partH)))
 				{
 					A[k].ativo=0;
 					a--;
 					break;
 				}
 			}
 		}
 
 		fprintf(out,αCase #%d: %d %dnα,i,a,b);
 	}
 	return 0;
 }
 
 void permutacaoC(horario *v, int tam)
 {
 	int i,j,trocou;
 	horario aux;
 	do
 	{
 		trocou=0;
 		for (i=0;i<tam-1;i++)
 		{
 			if ( v[i].chegH>v[i+1].chegH ||  ( v[i].chegMin>v[i+1].chegMin && v[i].chegH==v[i+1].chegH))
 			{
 				aux.partH=v[i].partH;
 				aux.partMin=v[i].partMin;
 				aux.chegH=v[i].chegH;
 				aux.chegMin=v[i].chegMin;
 				aux.ativo=v[i].ativo;
 
 				v[i].partH=v[i+1].partH;
 				v[i].partMin=v[i+1].partMin;
 				v[i].chegH=v[i+1].chegH;
 				v[i].chegMin=v[i+1].chegMin;
 				v[i].ativo=v[i+1].ativo;
 
 				v[i+1].partH=aux.partH;
 				v[i+1].partMin=aux.partMin;
 				v[i+1].chegH=aux.chegH;
 				v[i+1].chegMin=aux.chegMin;
 				v[i+1].ativo=aux.ativo;
 				trocou=1;
 			}
 		}
 	}while (trocou==1);
 }
 
 void permutacaoP(horario *v, int tam)
 {
 	int i,j,trocou;
 	horario aux;
 	do
 	{
 		trocou=0;
 		for (i=0;i<tam-1;i++)
 		{
 			if ( v[i].partH>v[i+1].partH ||  ( v[i].partMin>v[i+1].partMin && v[i].partH==v[i+1].partH))
 			{
 				aux.partH=v[i].partH;
 				aux.partMin=v[i].partMin;
 				aux.chegH=v[i].chegH;
 				aux.chegMin=v[i].chegMin;
 				aux.ativo=v[i].ativo;
 
 				v[i].partH=v[i+1].partH;
 				v[i].partMin=v[i+1].partMin;
 				v[i].chegH=v[i+1].chegH;
 				v[i].chegMin=v[i+1].chegMin;
 				v[i].ativo=v[i+1].ativo;
 
 				v[i+1].partH=aux.partH;
 				v[i+1].partMin=aux.partMin;
 				v[i+1].chegH=aux.chegH;
 				v[i+1].chegMin=aux.chegMin;
 				v[i+1].ativo=aux.ativo;
 				trocou=1;
 			}
 		}
 	}while (trocou==1);
 }"
30290,2008,32013,solmyr,24480,1,a.c,gcj/2008/32013/solmyr/24480/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 #define SE_NUMBER 120
 #define Q_NUMBER 1200
 int main(void) {
     FILE* out=fopen(αe:/ctd/gcjam/aoutα,αwα);
     int i,j,k,n,s,q,switchnum,num,final;
     char se[SE_NUMBER][110],query[Q_NUMBER][110];
     int flag[SE_NUMBER];
     memset(flag,0,SE_NUMBER);
     scanf(α%dα,&n);
     for(i=0;i<n;i++) {
         switchnum=0;
         num=0;
         for(j=0;j<s;j++)
             flag[j]=0;
         scanf(α%dα,&s);
         getchar();
         for(j=0;j<s;j++) {
             gets(se[j]);
         }
         scanf(α%dα,&q);
         getchar();
         for(j=0;j<q;j++) {
             gets(query[j]);
             for(k=0;k<s;k++) {
                 if(strcmp(query[j],se[k])==0) {
                     flag[k]=1;
                     break;
                 }
             }
             final=k;
             num=0;
             for(k=0;k<s;k++) {
                 num+=flag[k];
             }
             if(num==s) {
                 switchnum++;
                 for(k=0;k<s;k++) {
                     flag[k]=0;
                 }
                 flag[final]=1;
             }
         }
         fprintf(out,αCase #%d: %dnα,i+1,switchnum);
     }
     system(αpauseα);
     return 0;
 }"
30292,2008,32013,solmyr,24481,1,b.c,gcj/2008/32013/solmyr/24481/1/extracted/b.c,"#include<stdio.h>
 int judge(char dt[],char at[],int t) {
     int dh,dm,ah,am;
     sscanf(dt,α%d:%dα,&dh,&dm);
     sscanf(at,α%d:%dα,&ah,&am);
     am+=t;
     while(am>=60) {
         ah++;
         am-=60;
     }
     if(ah<dh || (ah==dh && am<=dm))
         return 1;
     else
         return 0;
 }
 
 int cmp(const void *a,const void *b) {
     char *p1=(char *)a;
     char *p2=(char *)b;
     return strcmp(p1,p2);
 }
 
 int main(void) {
     FILE* out=fopen(αe:/ctd/gcjam/boutα,αwα);
     int n,na,nb,t,x;
     char adt[120][10],bdt[120][10],aat[120][10],bat[120][10];
     int atrain[120],btrain[120],ause[120],buse[120];
     scanf(α%dα,&n);
     for(x=0;x<n;x++) {
         memset(atrain,0,120*sizeof(int));
         memset(btrain,0,120*sizeof(int));
         memset(ause,0,120*sizeof(int));
         memset(buse,0,120*sizeof(int));
         int anum=0,bnum=0;
         scanf(α%dα,&t);
         scanf(α%d %dα,&na,&nb);
         int i,j;
         for(i=0;i<na;i++) {
             scanf(α%s %sα,adt[i],aat[i]);
         }
         for(i=0;i<nb;i++) {
             scanf(α%s %sα,bdt[i],bat[i]);
         }
         qsort(adt,na,10*sizeof(char),cmp);
         qsort(bdt,nb,10*sizeof(char),cmp);
         qsort(aat,na,10*sizeof(char),cmp);
         qsort(bat,nb,10*sizeof(char),cmp);
         for(i=0;i<na;i++) {
             int flag=0;
             for(j=nb-1;j>=0;j--) {
                 if(buse[j]!=1 && judge(adt[i],bat[j],t)==1) {
                     flag=1;
                     buse[j]=1;
                     break;
                 }
             }
             if(flag==0) {
                 atrain[i]=1;
             }
         }
         for(i=0;i<nb;i++) {
             int flag=0;
             for(j=na-1;j>=0;j--) {
                 if(ause[j]!=1 && judge(bdt[i],aat[j],t)==1) {
                     flag=1;
                     ause[j]=1;
                     break;
                 }
             }
             if(flag==0) {
                 btrain[i]=1;
             }
         }
         for(i=0;i<na;i++) {
             anum+=atrain[i];
         }
         for(i=0;i<nb;i++) {
             bnum+=btrain[i];
         }
         fprintf(out,αCase #%d: %d %dnα,x+1,anum,bnum);
     }
     system(αpauseα);
     return 0;
 }"
30383,2008,32013,abz,24480,1,go.c,gcj/2008/32013/abz/24480/1/extracted/go.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
 #include <math.h>
 
 void usage (char *program_name)
 {
    printf (αn usage: %s <name of file with cases> nnα, program_name);
 }
 
 int main (int argn, char** args)
 {
    FILE *f;
    char  record[30000];
    int   case_cur;
    int   case_max;
 
    if (argn != 2)
    {
       usage (args[0]); return -1;
    }
 
    if (!(f=fopen (args[1], αrα)))
    {
       printf (αn can't open file α%sα: %s nnα, args[1], strerror(errno));
       return -1;
    }
   
    fgets(record,sizeof(record),f); case_max=atoi(record);
 
    for (case_cur=0; case_cur<case_max; case_cur++)
    {
       int    engine_max;
       int    engine_cur;
       char** engine_name;
       int    query_max;
       int    query_cur;
       char** query_name;
       int    Y=-1;
 
       /* 
        *
        * Load the engines
        *
        */
 
       fgets (record, sizeof(record), f);
       engine_max  = atoi   (record);
       engine_name = malloc (sizeof(char*) * engine_max);
      
       for (engine_cur=0; engine_cur<engine_max; engine_cur++)
       {
          fgets (record, sizeof(record), f);
 	 engine_name[engine_cur] = strdup (record);
       }
 
       /* 
        *
        * Load the queries
        *
        */
 
       fgets (record, sizeof(record), f);
       query_max  = atoi   (record);
       query_name = malloc (sizeof(char*) * query_max);
 
       for (query_cur=0; query_cur<query_max; query_cur++)
       {
          fgets (record, sizeof(record), f);
 	 query_name[query_cur] = strdup (record);
       }
 
       /* 
        *
        * Compute the result
        *
        */
 
       if (query_max)
       {
          for (query_cur=0; query_cur<query_max; Y++)
          {
             int best_result=0;
 
             for (engine_cur=0; engine_cur<engine_max; engine_cur++)
             {
 	       int i;
 
                for (i=query_cur; i<query_max; i++)
                {
 	           if (strcmp(query_name[i], engine_name[engine_cur])==0) break;
 	       }
 
 	       if (i-query_cur>best_result) best_result=i-query_cur;
       	    }
 
 	    query_cur+=best_result; 
          }
       }
       else
       {
          Y = 0;
       }
       /* 
        *
        * Print the results
        *
        */
 
       printf (αCase #%d: %dnα, case_cur+1, Y);
 
       /* 
        *
        * Clean the house
        *
        */
 
       for (engine_cur=0; engine_cur<engine_max; engine_cur++)
       {
          free(engine_name[engine_cur]);
       }
       free(engine_name);
 
       for (query_cur=0; query_cur<query_max; query_cur++)
       {
          free(query_name[query_cur]);
       }
       free(query_name);
    }
 
    fclose (f);
 
    return 0;
 }"
30445,2008,32013,hank,24480,1,temp.c,gcj/2008/32013/hank/24480/1/extracted/temp.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <fcntl.h>
 #include <unistd.h>
 
 int mark_it(int arr[],char *name,char s_eng[][100],int num_s){
 	
 	int i=0,j=0,sum=0;
 	
 	//printf(αdone: passed query %snα,name);
 	while (strcmp(name,s_eng[i])){
 		//printf(αdone %dnα,i);
 		i++;
 	}//while
 	//printf(αmatch found at %d %snα,i,s_eng[i]);
 	if (!arr[i])
 		arr[i]=1;
 	for(j=0;j<num_s;j++){
 		if (arr[j])
 			sum++;
 	}//if
 	if (sum==num_s){
 		for(j=0;j<num_s;j++)
 			arr[j]=0;
 		arr[i]=1;
 		return 1;
 	}//return
 	return 0;
 }//mark_it
 
 
 void reset_all_mark(int arr[],char s_eng[][100],char q[][100]){
 
 	int i;
 	
 	for(i=0;i<1000;i++){
 		arr[i]=0;
 		s_eng[i][0]='0';
 		q[i][0]='0';
 	}//for
 	return;
 
 }//reset_all_mark
 
 
 
 int main(int argc,char **argv){
 
 	FILE *inptr;
 	char buf[25];
 	int n,s,q;
 	char s_eng[1000][100],queries[1000][100];
 	int mark[1000];
 	int i,j,k=0,done,switches=0;
 	int ch;
 
 	inptr=fopen(argv[1],αrα);
 	fscanf(inptr,α%sα,buf);
 	n=atoi(buf);
 
 
 	for (i=0;i<n;i++){
 		
 		fscanf(inptr,α%sα,buf);
 		s=atoi(buf);
 		//printf(αnumber of engines %dnα,s);
 		ch=fgetc(inptr);
 		for(j=0;j<s;j++){
 			k=0;
 			ch=fgetc(inptr);
 			while (ch!='n'){
 				s_eng[j][k]=(char)ch;
 				k++;
 				ch=fgetc(inptr);
 			}//while
 			s_eng[j][k]='0';
 			//printf(αread engine %snα,s_eng[j]);
 		}//for
 	
 		//printf(αfollowing search engines:nα);
 		//for(j=0;j<s;j++){
 		//	printf(α%snα,s_eng[j]);
 		//}//for
 
 		fscanf(inptr,α%sα,buf);
 		q=atoi(buf);
 		//printf(αnumber of queries %dnα,q);
 		ch=fgetc(inptr);
 		for(j=0;j<q;j++){
 			k=0;
 			ch=fgetc(inptr);
 			while (ch!='n'){
 				queries[j][k]=ch;
 				k++;
 				ch=fgetc(inptr);
 			}//while
 			queries[j][k]='0';
 			//printf(αread query %snα,queries[j]);		
 			done=mark_it(mark,queries[j],s_eng,s);
 			if (done){
 				//printf(αmaking a switchnα);
 				switches++;
 			}//if
 		}//for
 		printf(αCase #%d: %dnα,i+1,switches);
 		reset_all_mark(mark,s_eng,queries);
 		q=s=switches=0;
 	}//for
 }//main"
30480,2008,32013,dlimpid,24480,1,qrA.c,gcj/2008/32013/dlimpid/24480/1/extracted/qrA.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int findEngine(char**, int, char*);
 
 int main(void)
 {
 	int i, j;
 	int sum;
 
 	int N, S, Q; // test cases, search engines, queries
 	char **sS;
 	char sQuery[101];
 	int *sQ, *sOn;
 	int switches;
 
 
 
 	scanf(α%dα, &N);
 	for (i = 0; i < N; ++i)
 	{
 		switches = 0;
 
 		// memory allocations and initialization
 		scanf(α%d%*cα, &S);
 		sS = malloc(S * sizeof(char*));
 		sOn = malloc(S * sizeof(int));
 		memset(sOn, 0, S * sizeof(int));
 		for (j = 0; j < S; ++j)
 		{
 			sS[j] = malloc(101 * sizeof(char));
 			scanf(α%[^n]%*cα, sS[j]);
 		}
 		scanf(α%d%*cα, &Q);
 		sQ = malloc(Q * sizeof(int));
 		for (j = 0; j < Q; ++j)
 		{
 			scanf(α%[^n]%*cα, sQuery);
 			sQ[j] = findEngine(sS, S, sQuery);
 		}
 
 		// process queries
 		sum = 0;
 		for (j = 0; j < Q; ++j)
 		{
 			if (sOn[sQ[j]] == 1)
 			{
 				// continue;
 				// do nothing
 			}
 			else
 			{
 				if (sum == S - 1) // time to switch engine
 				{
 					++switches;
 					memset(sOn, 0, S * sizeof(int));
 					sOn[sQ[j]] = 1;
 					sum = 1;
 				}
 				else
 				{
 					sOn[sQ[j]] = 1;
 					++sum;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα, i + 1, switches);
 
 
 		// free
 		for (j = 0; j < S; ++j)
 		{
 			free(sS[j]);
 		}
 		free(sS); free(sOn); free(sQ);
 	}
 	return 0; 
 }
 
 int findEngine(char** sS, int S, char* sQuery)
 {
 	int j;
 
 	for (j = 0; j < S; ++j)
 	{
 		if (strcmp(sS[j], sQuery) == 0)
 			return j;
 	} 
 
 	return -1;
 }"
30482,2008,32013,dlimpid,24479,1,qrC.c,gcj/2008/32013/dlimpid/24479/1/extracted/qrC.c,"#include <stdio.h>
 #include <math.h>
 #define PI 3.141592653589793238
 
 double getSafeArea(double, double, double, double, double);
 double getAngle(double, double, double, double);
 
 int main(void)
 {
 	int k, i, j, iMax;
 	int N;
 	double f, R, t, r, g;
 	double eR;
 	double x1, y1, x2, y2;
 	double safeArea;
 	double P;
 
 	scanf(α%dα, &N);
 
 	for (k = 0; k < N; ++k)
 	{
 		scanf(α%lf %lf %lf %lf %lfα, &f, &R, &t, &r, &g);
 		eR = R - t - f;
 		iMax = (int)((eR - r - f) / (g + 2 * r));
 
 		safeArea = 0;
 		if (g <= 2 * f // gap is too small
 			|| eR < 0 // interior of the racquet is smaller than fly
 			|| eR < sqrt(2) * r // string is too thick
 		   )
 		{
 			// safeArea = 0;
 			// Do nothing
 		}
 		else
 		{
 			for (i = 1; i <= iMax; ++i)
 			{
 				for (j = 0; j < i; ++j)
 				{
 					x1 = (r + f) + (g + 2 * r) * i;
 					y1 = (r + f) + (g + 2 * r) * j;
 
 					if (x1 * x1 + y1 * y1 > eR * eR) break;
 
 					x2 = (r + g - f) + (g + 2 * r) * i;
 					y2 = (r + g - f) + (g + 2 * r) * j;
 
 					if (x2 * x2 + y2 * y2 < eR * eR)
 					{
 						safeArea += (g - 2 * f) * (g - 2 * f);
 					}
 					else
 					{
 						safeArea += getSafeArea(x1, y1, x2, y2, eR);
 					}
 				}
 			}
 
 			for (i = 0; i <= iMax; ++i)
 			{
 				x1 = y1 = (r + f) + (g + 2 * r) * i;
 				x2 = y2 = (r + g - f) + (g + 2 * r) * i;
 
 				if (sqrt(2) * x1 > eR) break;
 
 				if (x2 * x2 + y2 * y2 < eR * eR)
 				{
 					safeArea += (g - 2 * f) * (g - 2 * f) / 2;
 				}
 				else
 				{
 					safeArea += getSafeArea(x1, y1, x2, y2, eR) / 2;
 				}
 			}
 		}
 
 		P = 1 - 4 * 2 * safeArea / (PI * R * R);
 
 		printf(αCase #%d: %fnα, k + 1, P);
 	}
 
 	return 0;
 }
 
 double getSafeArea(double x1, double y1, double x2, double y2, double eR)
 {
 	double safeArea = 0;
 	double x3, x4, y3, y4;
 
 	if (eR * eR < x1 * x1 + y2 * y2)
 	{
 		x3 = sqrt(eR * eR - y1 * y1);
 		y3 = sqrt(eR * eR - x1 * x1);
 
 		safeArea = eR * eR * getAngle(x3, y1, x1, y3) / 2 
 					- ((y3 - y1) * x1 + (x3 - x1) * y1) / 2;
 	}
 	else if (eR * eR < x2 * x2 + y1 * y1)
 	{
 		x3 = sqrt(eR * eR - y1 * y1);
 		x4 = sqrt(eR * eR - y2 * y2);
 		y3 = y2 / x4 * x1;
 	
 		safeArea = eR * eR * getAngle(x3, y1, x4, y2) / 2
 					- ((y3 - y1) * x1 + (x3 - x1) * y1) / 2
 					+ (y2 - y3) * (x4 - x1) / 2;
 	}
 	else
 	{
 		x4 = sqrt(eR * eR - y2 * y2);
 		y4 = sqrt(eR * eR - x2 * x2);
 		y3 = y2 / x4 * x1;
 		x3 = x2 / y4 * y1;
 
 		safeArea = eR * eR * getAngle(x2, y4, x4, y2) / 2
 					- ((y3 - y1) * x1 + (x3 - x1) * y1) / 2
 					+ ((y2 - y3) * (x4 - x1) + (x2 - x3) * (y4 - y1)) / 2;
 	}
 
 	return safeArea;
 }
 
 double getAngle(double x1, double y1, double x2, double y2)
 {
 	return acos((x1 * x2 + y1 * y2)
 				/ sqrt(x1 * x1 + y1 * y1) / sqrt(x2 * x2 + y2 * y2));
 }"
30484,2008,32013,dlimpid,24481,1,qrB.c,gcj/2008/32013/dlimpid/24481/1/extracted/qrB.c,"#include <stdio.h>
 #include <stdlib.h>
 #define A_DEP 1
 #define A_ARR 2
 #define B_DEP 3
 #define B_ARR 4
 
 void sort(int*, int*, int);
 
 int main(void)
 {
 	int i, j;
 	int depH, depM, arrH, arrM;
 	int stockA, stockB;
 	int sA, sB;
 
 	int N, T, NA, NB;
 	int *time, *type;
 
 	scanf(α%dα, &N);
 
 	for (i = 0; i < N; ++i)
 	{
 		sA = sB = 0;
 		stockA = stockB = 0;
 
 		scanf(α%dα, &T);
 		scanf(α%d %dα, &NA, &NB);
 
 		time = malloc((NA + NB) * 2 * sizeof(int));
 		type = malloc((NA + NB) * 2 * sizeof(int));
 
 		for (j = 0; j < NA; ++j)
 		{
 			scanf(α%d:%d %d:%dα, &depH, &depM, &arrH, &arrM);
 			time[2*j] = 60 * depH + depM;
 			type[2*j] = A_DEP;
 			time[2*j+1] = 60 * arrH + arrM + T;
 			type[2*j+1] = B_ARR;
 		}
 		for (; j < NA + NB; ++j)
 		{
 			scanf(α%d:%d %d:%dα, &depH, &depM, &arrH, &arrM);
 			time[2*j] = 60 * depH + depM;
 			type[2*j] = B_DEP;
 			time[2*j+1] = 60 * arrH + arrM + T;
 			type[2*j+1] = A_ARR;
 		}
 
 		sort(time, type, (NA + NB) * 2);
 
 		for (j = 0; j < (NA + NB) * 2; ++j)
 		{
 			switch (type[j])
 			{
 			case A_DEP:
 				if (stockA == 0)
 				{
 					++sA;
 				}
 				else
 				{
 					--stockA;
 				}
 				break;
 			case A_ARR:
 				++stockA;
 				break;
 			case B_DEP:
 				if (stockB == 0)
 				{
 					++sB;
 				}
 				else
 				{
 					--stockB;
 				}
 				break;
 			case B_ARR:
 				++stockB;
 				break;
 			}
 		}
 
 		printf(αCase #%d: %d %dnα, i + 1, sA, sB);
 
 		free(time);
 		free(type);
 	}
 
 	return 0;
 }
 
 void sort(int* time, int* type, int n)
 {
 	int i, j;
 	int temp;
 
 	// bubble sort
 	for (i = n - 1; i > 0; --i)
 	{
 		for (j = 0; j < i; ++j)
 		{
 			if ((time[j] > time[j+1])
 				|| (time[j] == time[j+1] 
 					&& (type[j+1] == A_ARR || type[j+1] == B_ARR)
 				   )
 			   )
 			{
 				temp = time[j];
 				time[j] = time[j+1];
 				time[j+1] = temp;
 				temp = type[j];
 				type[j] = type[j+1];
 				type[j+1] = temp;
 			}
 		}
 	}
 
 	return;
 }"
30493,2008,32013,Xiao,24480,1,gcj1.c,gcj/2008/32013/Xiao/24480/1/extracted/gcj1.c,"#include<stdio.h>
 
 main(){
 	int n, q, i, j, k, total, ch, s, v[1100], l;
 	char ss[1100][1100], qs[1100][1100];
 	scanf(α%dα, &n);
 	for(i = 0; i < n; i++){
 		scanf(α%d α, &s);
 		for(j = 0; j < s; j++){
 			v[j] = 1;
 			gets(ss[j]);
 		}
 		scanf(α%d α, &q);
 		for(k = 0; k < q; k++){
 			gets(qs[k]);
 		}
 		for(total = s, ch = 0, j = 0; j < q; j++){
 			for(k = 0; k < s; k++){
 				if(strcmp(ss[k], qs[j]) == 0 && v[k] == 1 && total != 1){
 					v[k]--;
 					total--;
 				}
 				if(total == 1 && v[k] == 1 && strcmp(ss[k], qs[j]) == 0){
 					ch++;
 					total = s;
 					for(l = 0; l < s; l++){
 						v[l] = 1;
 					}
 					v[k]--;
 					total--;
 				}
 			}
 		}
 		printf(αCase #%d: %dnα, i+1, ch);
 	}
 	
 }"
30502,2008,32013,JohnTortugo,24480,1,universe.c,gcj/2008/32013/JohnTortugo/24480/1/extracted/universe.c,"#include <stdio.h>
 
 #define MAX_ENGINES 105
 #define MAX_QUERIES 1010
 #define MAX_LEN_NAME 105
 
 int n;            /* test cases */
 int s;           /* num search engines */
 int q;            /* num of queries */
 int switches;     /* how many switches? */
 
 char engines[MAX_ENGINES][MAX_LEN_NAME];  /* the name of the engines */
 char queries[MAX_QUERIES][MAX_LEN_NAME];  /* the queries */
 int distances[MAX_ENGINES];               /* the distance from here to engines */
 
 int findSwitches();                       /* where the work is done ;-) */
 int findDistance(int);                    /* calculate the distance from that start position */
 
 int main(void) {
 
     int i, j;         /* counter(s) */ 
 
     /* how many test cases */
     scanf(α%dnα, &n);
     
     for (i=1; i<=n; i++) {
         switches = 0;        /* how many switches are needed */
         
         scanf(α%dnα, &s);    /* how many search engines */
         
         for (j=1; j<=s; j++) {
             gets(engines[j]);
         }
 
         scanf(α%dnα, &q);      /* how many queries */
 
         for (j=1; j<=q; j++) {
             gets(queries[j]);
         }
         
         switches = findSwitches();
         
         printf(αCase #%d: %dnα, i, switches);        
     }
     
     return 0;
 }
 
 int findSwitches() {
     
     int found = 1;               /* if could calculate the distance from ALL engines */
     int switches = 0;            /* how many switches */
     
     int i=1, j=1;                       /* counter(s) */
     
     found = findDistance(1);
     
     while (found) {
           switches ++;
           found = findDistance(found);
     }
 
     return switches;
 }
 
 int findDistance(int start) {
     
     int i, j;        /* counters */
     int max = 0;         /* the longest distance */
     
     for (i=1; i<=s; i++) {  /* estimates to all engines */
         distances[i] = 0;
         
         for (j=start; j<=q; j++) {
             if ( strcmp(queries[j], engines[i]) == 0 ) {  /* if found a query to that engine */
                  distances[i] = j;
                  break;
             }    
         }
         
         if (distances[i] == 0)  /* if no found query to that engine */
            return 0;
 
         /* find the most distant engine */
         if (distances[i] > max) max = distances[i];   
     }
     
     return max;
 }"
30504,2008,32013,JohnTortugo,24481,1,train.c,gcj/2008/32013/JohnTortugo/24481/1/extracted/train.c,"#include <stdio.h>
 
 #define MAX_TRAVELS 105
 
 typedef struct {
         int hSaida;
         int mSaida;
         int hChegada;
         int mChegada;
         int used;      	/* indica que j fizemos este viagem no dia */
 } travel;
 
 int n;   				/* test cases */
 int na, nb; 			/* number of travels from a and from b */
 int fromA, fromB;       /* trains fromA and trains fromB */
 
 travel tableA[MAX_TRAVELS];
 travel tableB[MAX_TRAVELS];
 
 /* prototypes */
 void readTimeTable();
 void addMinutes(travel *, int);
 int cmp(const void *a, const void *b);
 int cmpByArrives(const void *a, const void *b);
 int cmpChain(const void *a, const void *b);
 void walk(travel, int);
 int solveIt();
 
 int main(void) {
     
     int i, j;               /* counter(s); */
     
     scanf(α%dα, &n);
     
     for (i=1; i<=n; i++) {
         fromA = fromB = 0;
         
         /* Read the time table */
         readTimeTable();
         
         /* Solve it for me */
         solveIt();
     
         printf(αCase #%d: %d %dnα, i, fromA, fromB);    
     }
     
     return 0;   
 }
 
 void readTimeTable() {
      
      int turnAround;
      int i;  /* counter */
      
      scanf(α%dα, &turnAround);  
      scanf(α%d %dα, &na, &nb);
 
      /* table from A */     
      for (i=1; i<=na; i++) {
          scanf(α%d:%d %d:%dα, &tableA[i].hSaida, &tableA[i].mSaida, &tableA[i].hChegada, &tableA[i].mChegada);   
          addMinutes(&tableA[i], turnAround);
          tableA[i].used = 0;
      }
      
      qsort(&tableA[1], na, sizeof(travel), cmp);
 
      /* Table from B */
      for (i=1; i<=nb; i++) {
          scanf(α%d:%d %d:%dα, &tableB[i].hSaida, &tableB[i].mSaida, &tableB[i].hChegada, &tableB[i].mChegada);   
          addMinutes(&tableB[i], turnAround);
          tableB[i].used = 0;
      }
      
      qsort(&tableB[1], nb, sizeof(travel), cmp);
 }
 
 void addMinutes(travel *viagem, int minutes) {
      
      viagem->mChegada += minutes;
      
      if (viagem->mChegada >= 60) {
         viagem->mChegada = viagem->mChegada - 60;
         viagem->hChegada++;
         
         /* if (viagem->hChegada >= 24) printf(αcampo hora: %dnα, viagem->hChegada); */
      }
 }
 
 int cmp(const void *a, const void *b) {
     
     travel *x = (travel *) a;
     travel *y = (travel *) b;
     
     if (x->hSaida == y->hSaida)
        return x->mSaida - y->mSaida;
     else
        return x->hSaida - y->hSaida;
 }
 
 int cmpByArrives(const void *a, const void *b) {
     
     travel *x = (travel *) a;
     travel *y = (travel *) b;
     
     if (x->hChegada == y->hChegada)
        return x->mChegada - y->mChegada;
     else
        return x->hChegada - y->hChegada;
 }
 
 /** Retorna negativo se a viagem mais cedo for de A e positivo se for de B,
     retorna o indice da tabela **/
 int earning() {
     
     int ia, ib, i;
     int saida, chegada;
     
     for (ia=1; ia<=na; ia++) {
         if (tableA[ia].used == 0)
            break;
     }
     
     for (ib=1; ib<=nb; ib++) {
         if (tableB[ib].used == 0)
            break;
     }
 
     if (ia > na) {
        if (ib > nb)
           return 0;
           
        return ib;           
     }
     
     if (ib > nb) {
        if (ia > na)		/* dont need.. but for simplicity */
           return 0;
 
        return ia * -1	;
     }
 
     saida = cmp(&tableA[ia], &tableB[ib]);    
 
     if (saida == 0) {
         chegada = cmpByArrives(&tableA[ia], &tableB[ib]);    
         
         return (chegada >= 0) ? ib : ia * -1;
     }
     else
         return (saida > 0) ? ib : ia * -1;
 }
 
 int cmpChain(const void *a, const void *b) {
     
     travel *x = (travel *) a;
     travel *y = (travel *) b;
 
 	if (x->hChegada == y->hSaida)
 	   return x->mChegada <= y->mSaida;
 	else
 	   return x->hChegada < y->hSaida;
 }
 
 void walk(travel saida, int where) {
 	 
 	 int i;
 	 
 	 if (where == 1) {		/* find in the table A */
 	 	for (i=1; i<=na; i++) {
 			if (tableA[i].used == 0) {
 			   if ( cmpChain(&saida, &tableA[i]) ) {		/* cmpChain returns true if travel->chegada < tableA[i].saida */
 			   	  tableA[i].used = 1;
 				  return walk(tableA[i], 2);	  
 			   }
 			}	
 		}
      }
      else {					/* find in the table B */
 	 	for (i=1; i<=nb; i++) {
 			if (tableB[i].used == 0) {
 			   if ( cmpChain(&saida, &tableB[i]) ) {
 			   	  tableB[i].used = 1;
 				  return walk(tableB[i], 1);	  
 			   }
 			}	
 		}
 	 }
 }
 
 
 /** Find how many trains, need start at A and B */
 int solveIt() {
 	
 	int current = 1, found = 1, where = 1;
 	int i;	/* counter */
 	
 	while (current) {
 		current = earning();
 
 		if (current > 0) {
 		    fromB++;
 		   			
 		    tableB[current].used = 1;
 	 	   
 			walk(tableB[current], 1);			/* find the next int he table A */
 		}
 		else if (current < 0) {
 		   fromA++;	 
 			 
 	 	   tableA[current * -1].used = 1;	 
 	 	   
 	 	   walk(tableA[current * -1], 2);		/* find the next int he table B */
 		}
 	}
 }"
30560,2008,32013,amazingamazing,24480,1,stu.c,gcj/2008/32013/amazingamazing/24480/1/extracted/stu.c,"#include <stdio.h>
 int main()
 {
 FILE *fr, *fw;
 int i, j, k, l, m, switchs, N, S, Q, count[100];
 char *names[100], *list[1000], line[101];
 for (i = 0; i < 1000; i++)
 {
 	list[i] = (char*)malloc(101*sizeof(char));
 	if ( i < 100 )
 	{
 		names[i] = (char*)malloc(101*sizeof(char));
 	}
 }
 fr = fopen(αA-large.inα,αrtα);
 fw = fopen(αout.txtα,αwα);
 fgets(line,100,fr);
 N = atoi(line);
 
 
 for (i = 0; i < N; i++)
 {
 	
 	fgets(line,100,fr);
 	S = atoi(line);
 	for (j = 0; j < S; j++){
 		fgets(line,100,fr);
 		strcpy(names[j],line);
 	}
 	fgets(line,100,fr);
 	Q = atoi(line);
 	for (j = 0; j < Q; j++)
 	{
 		fgets(line,100,fr);
 		strcpy(list[j],line);	
 	}
 	k = 0;
 	switchs = -1;
 	while ( k < (Q) ){
 		for ( j = 0; j < S; j++)
 		{
 			count[j] = 0;
 			l = k;
 			while (strcmp(names[j],list[l]))
 			{
 				l++;
 				count[j]++;
 			}			
 		}
 		m = 0;
 		for ( j = 0; j < S; j++)
 			if ( count[j] >= count[m] )
 				m = j;
 		switchs++;
 		k = k + count[m];
 	}
 	if ( switchs == -1 )
 		switchs = 0;
 	fprintf(fw,αCase #%d: %dα,(i+1),switchs);
 	if ( i < (N-1) )
 		fprintf(fw,αnα);
 }
 fclose(fr);
 fclose(fw);
 return 0;
 }"
30562,2008,32013,amazingamazing,24481,1,train.c,gcj/2008/32013/amazingamazing/24481/1/extracted/train.c,"#include <stdio.h>
 
 
 
 int findtrainA( int time, int amx, int bmx, int atrains[], int btrains[])
 {
 	int i;
 	for (i=0;i<amx;i++){
 		if ( atrains[i] >= 0 && atrains[i] <= time )
 			return (i+1);
 	}
 
 	for (i=0;i<bmx;i++)
 		if ( btrains[i] < 0 &&  (0-btrains[i]) <= time )
 			return (0-i-1);
 
 	return 0;
 }
 
 int findtrainB( int time, int amx, int bmx, int atrains[], int btrains[] )
 {
 	int i;
 	
 	for (i=0;i<bmx;i++)
 		if ( btrains[i] >= 0 && btrains[i] <= time )
 			return (1+i);
 
 	for (i=0;i<amx;i++)
 		if ( atrains[i] < 0 &&  (0-atrains[i]) <= time )
 			return (0-i-1);
 
 	return 0;
 }
 
 int main() //34
 {
 FILE *fr, *fw;
 int i, j, k, l, m, N, T, at, bt, NA, NB;
 int inamin[100], outamin[100], inahour[100], outahour[100];
 int inbmin[100], outbmin[100], inbhour[100], outbhour[100];
 int btrains[100], atrains[100];
 
 
 int broke, found;
 
 
 fr = fopen(αB-large.inα,αrtα);
 fw = fopen(αout.txtα,αwα);
 fscanf(fr, α%dnα, &N);
 
 
 for (i = 0; i < N; i++)
 {
 	fscanf(fr, α%dnα, &T);
 	fscanf(fr, α%d %dnα, &NA, &NB);
 
 	for ( j = 0; j < NA; j++ )
 	{
 		fscanf(fr, α%d:%d %d:%dnα, &outahour[j], &outamin[j], &inahour[j], &inamin[j]);
 		inamin[j] += ( 60 * inahour[j] ) + T;
 		outamin[j] += ( 60 * outahour[j] );
 	}
 	for ( j = 0; j < NB; j++ )
 	{
 		fscanf(fr, α%d:%d %d:%dnα, &outbhour[j], &outbmin[j], &inbhour[j], &inbmin[j]);
 		inbmin[j] += ( 60 * inbhour[j] ) + T;
 		outbmin[j] += ( 60 * outbhour[j] );
 	}
 	at = -1;
 	found = 0;
 		
 	while ( ( at < NA ) && !found )
 	{
 		at++;
 		bt = -1;
 		while ( ( bt < NB ) && !found )
 		{
 			broke = 0;
 			bt++;
 			//printf(α%d atrains, %d btrainsnα,at,bt);
 			for ( j = 0; j < at; j++ )
 				atrains[j] = 0;
 			for ( j = 0; j < bt; j++ )
 				btrains[j] = 0;
 			for ( j = 0; j < (24 * 60); j++ )
 			{
 				for ( k = 0; k < NA; k++ )
 				{
 					if ( j == outamin[k] )
 					{
 						m = findtrainA(j,at,bt,atrains,btrains);
 						if ( m == 0 )
 							broke = 1;
 						else if ( m > 0 ){
 							atrains[m-1] = 0-(inamin[k]);
 							//printf(αatrains[%d] is now %dnα,m-1, atrains[m-1]);
 						}
 						else{
 							btrains[(-m)-1] = inamin[k];
 							//printf(α%d - btrains[%d] is now %dnα,m,(-m)-1, btrains[(-m)-1]);
 						}
 					}
 				}
 				for ( k = 0; k < NB; k++ )
 				{
 
 					if ( j == outbmin[k] )
 					{
 						m = findtrainB(j,at,bt,atrains,btrains);
 						if ( m == 0 )
 							broke = 1;
 						else if ( m > 0 ){
 							btrains[m-1] = 0-(inbmin[k]);
 							//printf(αbtrains[%d] is now %dnα,m-1, btrains[m-1]);
 						}
 						else 	{
 							atrains[(-m)-1] = inbmin[k];
 							//printf(αatrains[%d] is now %dnα,(-m)-1, atrains[(-m)-1]);
 						}
 					}
 				}
 				if (broke)
 					break;
 			}
 			if ( !broke )
 				found = 1;
 		}
 		
 
 	}
 
 	fprintf(fw,αCase #%d: %d %dnα,(i+1),at, bt);
 }
 fclose(fr);
 fclose(fw);
 return 0;
 }"
30590,2008,32013,bubis,24480,1,A.C,gcj/2008/32013/bubis/24480/1/extracted/A.C,"#include <set>
 #include <iostream>
 
 using namespace std;
 
 typedef set<string> Set;
 
 int main(int argc, char** argv)
 {
   int cases;
   cin >> cases;
   for (int c = 0; c<cases;c++)
   {
 
     int engins;
     cin >> engins;
     string t;
     getline(cin,t);//endl
     //we don't realy need these
     for (int i = engins; i-->0;)
     {
       getline(cin,t);
     }
     int queries;
     cin >> queries;
     getline(cin,t);//endl
     int switches = 0;
     Set exclude;
     for (; queries-->0;)
     {
       string q;
       getline(cin,q);
       if ((exclude.size()==engins-1) && exclude.find(q)==exclude.end())
       {
         //we have to switch
         exclude.clear();
         ++switches;
       }
       exclude.insert(q);
     }
     cout << αCase #α << (c+1) << α: α << switches << endl;
   }
 }"
30593,2008,32013,bubis,24481,1,B.C,gcj/2008/32013/bubis/24481/1/extracted/B.C,"#include <map>
 #include <iostream>
 
 using namespace std;
 
 typedef map<int,int> Map;
 
 int main(int argc, char** argv)
 {
   int cases;
   cin >> cases;
   for (int c = 0; c<cases; ++c)
   {
     int turn, na, nb;
     cin >> turn >> na >> nb;
     Map A,B;
     for ( int i = 0; i<na ; ++i)
     {
       int h1,m1,h2,m2;
       char c;
       cin >> h1 >> c >> m1 >> h2 >> c >> m2;
       A[60*h1+m1]      -= 1;
       B[60*h2+m2+turn] += 1;
     }
     for ( int i = 0; i<nb ; ++i)
     {
       int h1,m1,h2,m2;
       char c;
       cin >> h1 >> c >> m1 >> h2 >> c >> m2;
       B[60*h1+m1]      -= 1;
       A[60*h2+m2+turn] += 1;
     }
     int ma = 0, mb = 0, n;
 
     n = 0;
     Map::iterator aEnd = A.end();
     for (Map::iterator i = A.begin(); i!=aEnd; ++i)
     {
       n += i->second;
       if (n<ma)
       {
         ma = n;
       }
     }
 
     n = 0;
     Map::iterator bEnd = B.end();
     for (Map::iterator i = B.begin(); i!=bEnd; ++i)
     {
       n += i->second;
       if (n<mb)
       {
         mb = n;
       }
     }
 
     cout << αCase #α << (c+1) << α: α << -ma << α α << -mb << endl;
   }
 }"
30693,2008,32013,dakura,24480,1,save_the_universe.c,gcj/2008/32013/dakura/24480/1/extracted/save_the_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <strings.h>
 #include α../../lib/mylinklist.hα
 
 #define MAX_NAME_OF_SEARCHENGINE (110)
 
 typedef struct {
     char name[MAX_NAME_OF_SEARCHENGINE];
 } SearchEngine;
 
 int IsTheQueryExists(char *query,MyLinkList *list){
     int i;
 
     for(i=0; i < MyLinkListCounts(list); i++){
         char *name = MyLinkListGetElement(list,i);
         if(strcmp(query,name) == 0){
             return 1;
         }
     }
     return 0;
 }
 
 void StringCopy(char *dest,const char *src,size_t len){
     size_t i;
     for(i=0; i < len-1; i++){
         if(iscntrl(*src)){
             src++; 
         }
         *dest++ = *src++;
     }
     *dest = '0';
 }
 
 int main(int argc, char **argv){
     int numOfCases;
     int i;
 
     scanf(α%dα,&numOfCases);
     for(i=0; i < numOfCases; i++){
         int numOfsearchEngines;
         int numOfQueries;
         int j,k;
         MyLinkList *searchEngineList = NULL;
         int numOfSwitch;
 
         numOfSwitch = 0;
         scanf(α%dnα,&numOfsearchEngines);
         for(j=0; j < numOfsearchEngines; j++){
             // skip lines
             char dummy[MAX_NAME_OF_SEARCHENGINE];
             //            scanf(α%sα,dummy);
             fgets(dummy,sizeof(dummy),stdin);
         }
         scanf(α%dnα,&numOfQueries);
         for(k=0; k < numOfQueries; k++){
             char lineBuf[MAX_NAME_OF_SEARCHENGINE];
             char* query = malloc(MAX_NAME_OF_SEARCHENGINE);
 
             //            scanf(α%sα,query);
             fgets(lineBuf,MAX_NAME_OF_SEARCHENGINE,stdin);
             StringCopy(query,lineBuf,MAX_NAME_OF_SEARCHENGINE);
 
             if(IsTheQueryExists(query,searchEngineList)){
                 free(query);
             }else{
                 searchEngineList = MyLinkListAdd(searchEngineList,query);
                 //                printf(α%dnα,MyLinkListCounts(searchEngineList));
                 if(MyLinkListCounts(searchEngineList) == numOfsearchEngines){
                     char *copyBuf = malloc(MAX_NAME_OF_SEARCHENGINE);
                     strcpy(copyBuf,query);
                     numOfSwitch++;
                     searchEngineList = MyLinkListFree(searchEngineList);
                     searchEngineList = MyLinkListAdd(searchEngineList,copyBuf);
                 }
             }
         }
         printf(αCase #%d: %dnα,i+1,numOfSwitch);
     }
 }"
30777,2008,32013,Dhupar,24480,1,p1.C,gcj/2008/32013/Dhupar/24480/1/extracted/p1.C,"#include <iostream>
 #include <string.h>
 
 int execute();
 
 int main()
 {
 	int n,i,x;
 	
 	std::cin>>n;
 
 	for(i=0;i<n;i++)
 	{
 		fflush(stdin);		
 		x = execute();
 		std::cout<<αCase #α<<i+1<<α: α<<x<<std::endl;
 	}
 	return 0;
 }
 
 int execute()
 {
 	char **Search_Engine_Name,text[101];
 	int s,q;
 	int *list;
 	int ret=0,i,k;
 
 	std::cin>>s;	
 	
 		
 	Search_Engine_Name = new char*[s];
 
 	list = new int[s];
 
 	for(i=0;i<s;i++)
 		list[i]=0;
 
 	for(i=0;i<s;i++)
 	{
 		Search_Engine_Name[i] = new char[101];
 	}
 	
 	for(i=0;i<s;i++)
 		std::cin>>Search_Engine_Name[i];				
 	
 
 	int j;
 
 	std::cin>>q;
 	
 	for(i=0;i<q;i++)
 	{
 
 		std::cin>>text;	   
 	 
 		for(j=0;j<s;j++)
 		{
 			if(!strcmp(text,Search_Engine_Name[j]))
 			{
 				list[j]=1;
 				break;
 			}
 		}
 				  
 		int t=j;
 		int flag=0;
 
 		for(k=0;k<s && flag!=1;k++)
 		{
 			if(list[k]!=1)
 				flag=1;
 		}
 
 		if(flag==0)
 		{
 			ret++;
 			for(j=0;j<s;j++)
 				list[j]=0;
 		}
 
 		if(t<s)
 		   list[t]=1;
 	}
 	return ret;
 }"
30913,2008,32013,Nesciens,24480,1,1.c,gcj/2008/32013/Nesciens/24480/1/extracted/1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXS 100
 
 int s;
 char names[MAXS][103];
 
 int find_index (char *name) {
 	int i;
 
 	for (i = 0; i < s; i++) {
 		if (strcmp (name, names[i]) == 0) {
 			return i;
 		}
 	}
 
 	return s;
 }
 
 int main () {
 	int n, q, i, j, k;
 
 	int switches;
 
 	int avail;
 	int mark[MAXS];
 
 	char buffer[103];
 
 
 	fscanf (stdin, α%d α, &n);
 
 	for (i = 1; i <= n; i++) {
 		switches = 0;
 		memset (mark, 0, sizeof(mark));
 
 		fscanf (stdin, α%d α, &s);
 		for (j = 0; j < s; j++) {
 			fgets (names[j], sizeof(names[j]), stdin);
 		}
 
 		avail = s;
 
 		fscanf (stdin, α%d α, &q);
 		for (j = 0; j < q; j++) {
 			fgets (buffer, sizeof(buffer), stdin);
 
 			k = find_index (buffer);
 
 			if (!mark[k]) {
 				if (avail == 1) {
 					switches++;
 					avail = s;
 					memset (mark, 0, sizeof(mark));
 				}
 				mark[k] = 1;
 				avail--;
 			}
 		}
 
 		printf (αCase #%d: %dnα, i, switches);
 	}
 
 	return 0;
 }"
30915,2008,32013,Nesciens,24481,1,2.c,gcj/2008/32013/Nesciens/24481/1/extracted/2.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAXNA 100
 #define MAXNB 100
 
 typedef struct {
 	int time;
 	int delta;
 } foo;
 
 int foo_cmp (const void *p1, const void *p2) {
 	foo *f1 = (foo *)p1;
 	foo *f2 = (foo *)p2;
 
 	if (f1->time == f2->time) {
 		return f2->delta - f1->delta;
 	} else {
 		return f1->time - f2->time;
 	}
 }
 
 int main () {
 	foo a[MAXNA + MAXNB];
 	foo b[MAXNA + MAXNB];
 
 	int aneeded;
 	int bneeded;
 
 	int acurrent;
 	int bcurrent;
 
 	int n, t, na, nb;
 	int dh, dm, ah, am;
 
 	int i, j;
 
 	fscanf (stdin, α%d α, &n);
 
 	for (i = 1; i <= n; i++) {
 		fscanf (stdin, α%d α, &t);
 		fscanf (stdin, α%d %d α, &na, &nb);
 
 		for (j = 0; j < na; j++) {
 			fscanf (stdin, α%d:%d %d:%d α, &dh, &dm, &ah, &am);
 
 			a[j].time = dh * 60 + dm;
 			a[j].delta = -1;
 
 			b[j].time = ah * 60 + am + t;
 			b[j].delta = 1;
 		}
 
 		for (j = 0; j < nb; j++) {
 			fscanf (stdin, α%d:%d %d:%d α, &dh, &dm, &ah, &am);
 
 			a[na + j].time = ah * 60 + am + t;
 			a[na + j].delta = 1;
 
 			b[na + j].time = dh * 60 + dm;
 			b[na + j].delta = -1;
 		}
 
 		qsort (a, na + nb, sizeof(a[0]), foo_cmp);
 		qsort (b, na + nb, sizeof(b[0]), foo_cmp);
 
 		aneeded = 0;
 		acurrent = 0;
 
 		bneeded = 0;
 		bcurrent = 0;
 
 		for (j = 0; j < na + nb; j++) {
 			acurrent += a[j].delta;
 			if (acurrent < 0) {
 				aneeded -= acurrent;
 				acurrent = 0;
 			}
 
 			bcurrent += b[j].delta;
 			if (bcurrent < 0) {
 				bneeded -= bcurrent;
 				bcurrent = 0;
 			}
 		}
 
 		printf (αCase #%d: %d %dnα, i, aneeded, bneeded);
 	}
 
 	return 0;
 }"
30963,2008,32013,Andreia,24480,1,SavingUniverse.c,gcj/2008/32013/Andreia/24480/1/extracted/SavingUniverse.c,"/*
 Problem
 
 The urban legend goes that if you go to the Google homepage and search for αGoogleα, the universe will implode. We have a secret to share... It is true! Please don't try it, or tell anyone. All right, maybe not. We are just kidding. 
 
 The same is not true for a universe far far away. In that universe, if you search on any search engine for that search engine's name, the universe does implode! 
 
 To combat this, people came up with an interesting solution. All queries are pooled together. They are passed to a central system that decides which query goes to which search engine. The central system sends a series of queries to one search engine, and can switch to another at any time. Queries must be processed in the order they're received. The central system must never send a query to a search engine whose name matches the query. In order to reduce costs, the number of switches should be minimized. 
 
 Your task is to tell us how many times the central system will have to switch between search engines, assuming that we program it optimally. 
 
 Input
 
 The first line of the input file contains the number of cases, N. N test cases follow. 
 
 Each case starts with the number S -- the number of search engines. The next S lines each contain the name of a search engine. Each search engine name is no more than one hundred characters long and contains only uppercase letters, lowercase letters, spaces, and numbers. There will not be two search engines with the same name. 
 
 The following line contains a number Q -- the number of incoming queries. The next Q lines will each contain a query. Each query will be the name of a search engine in the case. 
 
 Output
 
 For each input case, you should output: 
 
 Case #X: Y
 where X is the number of the test case and Y is the number of search engine switches. Do not count the initial choice of a search engine as a switch. 
 Limits
 
 0 < N = 20 
 
 Small dataset
 
 2 = S = 10 
 
 0 = Q = 100 
 
 Large dataset
 
 2 = S = 100 
 
 0 = Q = 1000 
 
 */
 //Author: Andreia Aparecida Barbiero (andreiabarbiero@yahoo.com)
 
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h> 
 
 //Search engines
 struct
 {
 	char name[150];
 	char isEqual;
 	int valor;
 }engine[150];
 
 //Queries
 struct
 {
 	char name[150];
 	char sent;
 }query[1050];
 
 int main (void)
 {
 	FILE *entrada, *saida;
 	char linha[150];
 	int estado = 0;
 	int numTestes = 0;
 	int numEngines = 0;
 	int numQueries = 0;
 	int numTrocas = 0;
 	int numEnvios = 0;
 	int teste = 0;
 	int i,j,k;
 	
 	//Abre arquivo s
 	entrada = fopen(αA-large.inα, αr+α );
 	if(!entrada)
     {
              printf(αNo foi possivel abrir a entradanα);
 	         return -1;
     }
 	saida = fopen(αA-large.outα, αw+α );
 	if(!saida)
     {
              printf(αNo foi possivel abrir a saidanα);
 	         return -1;
     }
 	
 	//NUMERO DE TESTES
 	fgets(linha, sizeof(linha), entrada); //le uma linha
 	numTestes = atoi(linha);
 	//printf(αNum testes: %dnα, numTestes);
 	estado = 1;
 	
 	//Loop principal
 	while((teste <= numTestes) && !feof(entrada))
 	{
 		switch(estado)
 		{
 			case 1: //NUMERO DE ENGINES
 				fgets(linha, sizeof(linha), entrada); //le uma linha
 				numEngines = atoi(linha);
 				//printf(αNum Engines: %dnα, numEngines);
 				i = 0;
 				while(i < numEngines)
 				{
 					fgets(linha, sizeof(linha), entrada); //le uma linha
 					strcpy(engine[i].name,linha);
 					engine[i].isEqual = 0;
 					engine[i].valor = 0;
 					//printf(αengine %d: %snα, i,engine[i].name);
 					i++;
 				}
 				estado = 2;
 				continue;
 			case 2: //NUMERO DE QUERIES
 				fgets(linha, sizeof(linha), entrada); //le uma linha
 				numQueries = atoi(linha);
 				//printf(αNum Queries: %dnα, numQueries);
 				if(numQueries == 0)
 				{
 					teste ++;
 					numTrocas = 0;
 					estado = 3; 
 				}			
 				else //PROCESSAMENTO
 				{
 					i = 0;
 					// L as queries
 					while(i < numQueries)
 					{
 						fgets(linha, sizeof(linha), entrada); //le uma linha
 						strcpy(query[i].name,linha);
 						query[i].sent = 0;
 						
 					//	printf(αquery %d: %snα, i,query[i].name);
 						i++;
 					}
 					//Processa
 					numEnvios = 0;
 					numTrocas = 0;
 					while (numEnvios < numQueries) 
 					{
 						//Pontua os servidores
 						for ( j = 0; j < numQueries;j++) 
 						{
 							if(query[j].sent==0)
 							{
 								for (k=0;k < numEngines;k++) 
 								{
 									if(engine[k].isEqual == 0)
 										if ((strcmp(engine[k].name, query[j].name))) 
 										{
 											engine[k].valor++;
 											
 										}
 										else
 										{
 											engine[k].isEqual = 1;
 										}
 								}		
 							}
 						}
 						//Verifica os melhores
 						long maior = 0;
 						for (k=0;k < numEngines;k++) 
 						{
 							if (maior <  engine[k].valor)
 							{
 								maior = engine[k].valor;
 							}
 						}	
 						//Assinala os envios
 						if(numEnvios!=0)
 							numTrocas++;
 						numEnvios+= maior;
 						
 						//Zera os servidores
 						for (k=0;k < numEngines;k++) 
 						{
 							engine[k].valor = 0;
 							engine[k].isEqual = 0;
 						}
 			
 						long numE = 0;
 						for (j = 0; j < numQueries;j++) 
 						{
 							if(numE>=maior)
 							break;
 							if(query[j].sent==0)
 							{
 								query[j].sent = 1;
 								numE++;
 							}
 						}
 					}
 					teste ++;
 					estado = 3; 
 				}
 										
 			case 3: //SAIDA
 				//Gera o arquivo de sada
 				fprintf(saida, αCase #%d: %dα,teste,numTrocas);
 				if (teste < numTestes)
 					fprintf(saida, αnα);
 				
 				estado = 1;
 				continue;
 			
 		}
 		
 	}
 	puts(αExecutado com sucesso!α);	
 	fclose(entrada);
 	fclose(saida);
 	
 }"
31030,2008,32013,dchen,24480,1,QA.c,gcj/2008/32013/dchen/24480/1/extracted/QA.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 #define MAXLEN 101
 #define MAXENGINE 100
 
 char engine[MAXENGINE][MAXLEN];
 
 main(int argc, char *argv[])
 {
     FILE *inp;
     int N, n; // number of cases
     int S,s;    // number of search enginees
     int Q,q;    // number of queries
 
     int result;
     int current_engine_index;
     char ln[MAXLEN];
     int count[MAXENGINE];
     int min;
 
     // check syntax
     if (argc != 2){
         fprintf(stderr, αwrong syntaxnα);
         exit(1);
     }
     // try open input file
     if ((inp = fopen(argv[1], αrα)) == NULL){
         fprintf(stderr, αcan't open input file: %snα, argv[1]);
         exit(1);
     }
 
     // get N
     fgets(ln, MAXLEN, inp);
     N = atoi(ln);
     n = 1;
     // process each case
     while (fgets(ln, MAXLEN, inp) != NULL && n <= N) {
         //fgets(ln, MAXLEN, inp);
         S = atoi(ln);
         // get search engines
         for (s=1; s<=S; s++)
             fgets(engine[s-1], MAXLEN, inp);
         // get queries
         fgets(ln, MAXLEN, inp);
         Q = atoi(ln);
         // initial
         result = 0;
         current_engine_index = 0;
         for (s=1; s<=S; s++)
             count[s-1] = 0;
         // process
         for (q=1; q<=Q; q++){
             fgets(ln, MAXLEN, inp);
 
             for(s=1; s<=S && strcmp(engine[s-1],ln)!=0; s++)
                 ;
 
             // match engine
             if (s<=S){
                 count[s-1] = count[s-1] + 1;
                 min = s;
 
                 for(s=1; s<=S && count[s-1]!=0; s++)
                     ;
                 //set engine
                 if(s>S){
                     result++;
                     current_engine_index = min;
                     for (s=1; s<=S; s++)
                         count[s-1] = 0;
                     count[min-1] = 1;
                 }
             }
 
         }
         printf(αCase #%d: %dnα, n, result);
         n++;
     }
     exit(0);
 }"
31032,2008,32013,dchen,24481,1,QB.c,gcj/2008/32013/dchen/24481/1/extracted/QB.c,"#include<stdio.h>
 #include<string.h>
 #include<stdlib.h>
 
 #define MAXLEN 100
 #define TRUE 1
 #define FALSE 0
 void divide_string(char *, char, char *, char *);
 
 struct time {
     int clock;
     int minute;
 };
 
 struct train {
     struct time departure;
     struct time ready;
 };
 
 main(int argc, char *argv[])
 {
     FILE *inp;
     int N, n;
     int i,j;
     char ln[MAXLEN], ln_a[MAXLEN], ln_b[MAXLEN];
     char t1[MAXLEN], t2[MAXLEN];
 
     int turnaround_time;
     int NA, na, NB, nb;
     int clock, minute;
 
     int need_train_a, need_train_b;
     int train_available_a, train_available_b;
 
     struct train *train_a, *train_b;
 
     // check syntax
     if (argc != 2){
         fprintf(stderr, αwrong syntaxnα);
         exit(1);
     }
     // try open input file
     if ((inp = fopen(argv[1], αrα)) == NULL){
         fprintf(stderr, αcan't open input file: %snα, argv[1]);
         exit(1);
     }
 
     // get N
     fgets(ln, MAXLEN, inp);
     N = atoi(ln);
     n = 1;
     // process each case
     while (fgets(ln, MAXLEN, inp) != NULL && n <= N) {
         //get turnaround time
         turnaround_time = atoi(ln);
         //get NA, NB
         fgets(ln, MAXLEN, inp);
         divide_string(ln, ' ', ln_a, ln_b);
         NA = atoi(ln_a);
         NB = atoi(ln_b);
         //get train schedule
         train_a = (struct train *) malloc(NA * sizeof(struct train));
         for(na=1; na<=NA; na++){
             fgets(ln, MAXLEN, inp);
             divide_string(ln, ' ', ln_a, ln_b);
             divide_string(ln_a, ':', t1, t2);
             train_a[na-1].departure.clock = atoi(t1);
             train_a[na-1].departure.minute = atoi(t2);
             divide_string(ln_b, ':', t1, t2);
             train_a[na-1].ready.clock = atoi(t1);
             train_a[na-1].ready.minute = atoi(t2) + turnaround_time;
             if (train_a[na-1].ready.minute >= 60){
                 train_a[na-1].ready.minute -= 60;
                 train_a[na-1].ready.clock++;
             }
         }
         train_b = (struct train *) malloc(NB * sizeof(struct train));
         for(nb=1; nb<=NB; nb++){
             fgets(ln, MAXLEN, inp);
             divide_string(ln, ' ', ln_a, ln_b);
             divide_string(ln_a, ':', t1, t2);
             train_b[nb-1].departure.clock = atoi(t1);
             train_b[nb-1].departure.minute = atoi(t2);
             divide_string(ln_b, ':', t1, t2);
             train_b[nb-1].ready.clock = atoi(t1);
             train_b[nb-1].ready.minute = atoi(t2) + turnaround_time;
             if (train_b[nb-1].ready.minute >= 60){
                 train_b[nb-1].ready.minute -= 60;
                 train_b[nb-1].ready.clock++;
             }
         }
         //run timetable simulation
         clock = minute = 0;
         train_available_a = train_available_b = 0;
         need_train_a = need_train_b = 0;
         while(clock<24){
             // process
             for(nb = 1; nb <= NB; nb++)
                 if (train_b[nb-1].ready.clock == clock && train_b[nb-1].ready.minute == minute)
                     train_available_a++;
 
             for(na = 1; na <= NA; na++){
                 if (train_a[na-1].departure.clock == clock && train_a[na-1].departure.minute == minute){
                     if (train_available_a > 0)
                         train_available_a--;
                     else
                         need_train_a++;
                 }
             }
 
             for(na=1; na<=NA; na++)
                 if (train_a[na-1].ready.clock==clock && train_a[na-1].ready.minute == minute)
                     train_available_b++;
 
             for(nb=1; nb<=NB; nb++){
                 if (train_b[nb-1].departure.clock == clock && train_b[nb-1].departure.minute == minute){
                     if (train_available_b>0)
                         train_available_b--;
                     else
                         need_train_b++;
                 }
             }
             // next time
             minute++;
             if (minute == 60){
                 clock++;
                 minute -= 60;
             }
         }
         printf(αCase #%d: %d %dnα, n, need_train_a, need_train_b);
         n++;
     }
     fclose(inp);
     exit(0);
 }
 
 void divide_string(char *source, char spliter, char *dest1, char *dest2)
 {
     while (*source != spliter)
         *dest1++ = *source++;
     *dest1 = '0';
     source++;
     while (*source != '0' && *source != 'n')
         *dest2++ = *source++;
     *dest2 = '0';
 }"
31171,2008,32013,miguelpais,24481,1,time.c,gcj/2008/32013/miguelpais/24481/1/extracted/time.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define max(x,y) ((x > y) ? (x) : (y))
 
 int N;
 int T;
 int NA;
 int NB;
 
 typedef struct
 {
   int ah;
   int am;
   int dh;
   int dm;
 } time;
 
 int compare (const void *a, const void *b)
 {
   time c = *(time*)a;
   time d = *(time*)b;
   return (c.ah == d.ah ? c.am-d.am : c.ah-d.ah); 
 }
 
 int some_arrived_before(time x, time array[],int limit, char test[])
 {
   int e;
   for(e = 0; e < limit; ++e)
     {
       if (!test[e])
 	if (x.ah > array[e].dh || (x.ah == array[e].dh && x.am >= array[e].dm))
 	  {
 	    test[e] = 1;
 	    return 1;
 	  }
     }
   return 0;
 }
 
 void init(char * nx, char n)
 {
   int t;
   for(t = 0; t < n; ++t)
     *(nx+t) = 0;
 }
 
 
 void process()
 {
   int a;
   for(a = 0; a < N; ++a)
     {
       scanf(α%dn%d %dα, &T, &NA, &NB);
       int d;
       time AtoB[NA];
       time BtoA[NB];
       char checkA[NA];
       char checkB[NB];
       int numA=0;
       int numB=0;
 
       init(checkA,NA);
       init(checkB,NB);
 
       for(d =0; d < NA; ++d)
 	{
 	  scanf(α%d:%d %d:%dα, &AtoB[d].ah, &AtoB[d].am, &AtoB[d].dh, &AtoB[d].dm);
 	  if (AtoB[d].dm + T > 59)
 	    {
 	      AtoB[d].dh += 1;
 	      AtoB[d].dm = (AtoB[d].dm + T) % 60;
 	    }
 	  else
 	    AtoB[d].dm += T;
 	}
       for(d = 0; d < NB; ++d)
 	{
 	  scanf(α%d:%d %d:%dα, &BtoA[d].ah, &BtoA[d].am, &BtoA[d].dh, &BtoA[d].dm);
 	  if (BtoA[d].dm + T > 59)
 	    {
 	      BtoA[d].dh += 1;
 	      BtoA[d].dm = (BtoA[d].dm + T) % 60;
 	    }
 	  else
 	    BtoA[d].dm += T;
 	}
       qsort(AtoB, NA, sizeof(time), compare);
       qsort(BtoA, NB, sizeof(time), compare);
 
       /*   for(d =0; d < NA; ++d)
 	{
 	  printf(α%d:%d %d:%dnα, AtoB[d].ah, AtoB[d].am, AtoB[d].dh, AtoB[d].dm);
 	}
       printf(αnα);
       for(d = 0; d < NB; ++d)
 	{
 	  printf(α%d:%d %d:%dnα, BtoA[d].ah, BtoA[d].am, BtoA[d].dh, BtoA[d].dm);
 	}
 	printf(αnnα);*/
 
       int max = max(NA,NB);
       for(d = 0; d < max; ++d)
 	{
 	  if (d < NA)
 	    {
 	      /* code para A->B */
 	      if (!some_arrived_before(AtoB[d],BtoA,NB,checkB))
 		{
 		  
 		  ++numA;
 		}
 	    }
 	  if (d < NB)
 	    {
 	      if(!some_arrived_before(BtoA[d],AtoB,NA,checkA))
 		{
 		  ++numB;
 		}
 	    }
 	}
       printf(αCase #%d: %d %dnα, a+1, numA, numB);
     }
 }
 
 int main ()
 {
   scanf(α%dα, &N);
   process();
   return 0;
 }"
31320,2008,32013,libc,24480,1,A.c,gcj/2008/32013/libc/24480/1/extracted/A.c,"#include <stdio.h>
 
 char ** searches;
 char ** queries;
 int search_count;
 int query_count;
 int min_switches;
 
 int * hash_table;
 
 int find_switches(int search_engine, int query_offset) {
     int i, j, min_j, min_val, val;
     int switches = 0;
 
     for(i = query_offset; i < query_count; ++i) {
         if(!strcmp(searches[search_engine], queries[i])) {
             min_val = query_count + 1;
             for(j = 0; j < search_count; ++j) {
                 if(j == search_engine)
                     continue;
                 if(hash_table[j*query_count + i+1]==-1) {
                     val = find_switches(j, i+1);
                     hash_table[j*query_count + i+1] = val;
                 }else {
                     val = hash_table[j*query_count + i+1];
                 }
                 if(val < min_val) {
                     min_val = val;
                     min_j = j;
                 }
             }
             
             return 1 + min_val;
         }
     }
     return switches;
 }
 
 char * mgets()
 {
     static char buf[102];
     fgets(buf, sizeof(buf), stdin);
     buf[strlen(buf)-1] = 0;
     return buf;
 }
 
 
 int main()
 {
     int cases, current_case, i;
     cases = atoi(mgets());
     
     for(current_case = 0; current_case < cases; ++current_case) {
         int switches, negativ_one = -1; 
         
         search_count = atoi(mgets());
         searches = malloc(search_count*sizeof(char*));
         for(i = 0; i < search_count; ++i) {
             searches[i] = strdup(mgets());
         }
         
         query_count = atoi(mgets());
         queries = malloc(query_count*sizeof(char*));
         for(i = 0; i < query_count; ++i) {
             queries[i] = strdup(mgets());
         }
         
         hash_table = malloc(query_count*search_count*sizeof(int));
         memset_pattern4(hash_table, &negativ_one, query_count*search_count*sizeof(int));
         
         min_switches = query_count+1;
         
         for(i = 0; i < search_count; ++i) {
             switches = find_switches(i, 0);
             if(switches < min_switches)
                 min_switches = switches;
         }
         free(queries);
         free(searches);
         free(hash_table);
         
         printf(αCase #%d: %dnα, current_case+1, min_switches);
     }
 }"
31342,2008,32013,jpautom,24481,1,b.c,gcj/2008/32013/jpautom/24481/1/extracted/b.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <math.h>
 
 #define abs(a) ((a)>0?(a):(-(a)))
 #define debug if(0)printf
 
 int transform(int a, int b, int t) {
 	return a*60+b+t+1;
 }
 
 int comp(const void *va, const void *vb) {
 	int a, b;
 	a=*(int *)va;
 	b=*(int *)vb;
 	if (abs(a)<abs(b)) return -1;
 	else if (abs(b)<abs(a)) return +1;
 	else return (b-a);
 }
 
 int main() {
 	int N, iN;
 	int i, j, k;
 	int NA, NB, T;
 
 	int ta[300], tb[300];
 	int na, mina, nb, minb;
 	int h1, m1, h2, m2;
 
 	freopen(αb.inα, αrα, stdin);
 	scanf(α %dα, &N);
 	for (iN=1; iN<=N; iN++) {
 		scanf(α %d %d %dα, &T, &NA, &NB);
 		for (i=0; i<NA+NB; i++) {
 			scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			j=transform(h1, m1, 0);
 			k=transform(h2, m2, T);
 			if (i<NA) {
 				ta[i]=-j; tb[i]=k;
 			}
 			else {
 				tb[i]=-j; ta[i]=k;
 			}
 		}
 		for (i=0; i<NA+NB; i++) debug(α %dα, ta[i]);
 		debug(αnα);
 		for (i=0; i<NA+NB; i++) debug(α %dα, ta[i]);
 		debug(αnα);
 		qsort(ta, NA+NB, sizeof(int), comp);
 		qsort(tb, NA+NB, sizeof(int), comp);
 		for (i=0; i<NA+NB; i++) debug(α %dα, ta[i]);
 		debug(αnα);
 		for (i=0; i<NA+NB; i++) debug(α %dα, ta[i]);
 		debug(αnα);
 
 		na=0; mina=0; nb=0; minb=0;
 		for (i=0; i<NA+NB; i++) {
 			if (ta[i]<0) na--;
 			else na++;
 			if (tb[i]<0) nb--;
 			else nb++;
 			if (na<mina) mina=na;
 			if (nb<minb) minb=nb;
 		}
 
 		printf(αCase #%d: %d %dnα, iN, abs(mina), abs(minb));
 	}
 	
 	return 0;
 }"
31444,2008,32013,miura,24480,1,01.c,gcj/2008/32013/miura/24480/1/extracted/01.c,"#include <stdio.h>
 #include <string.h>
 
 struct check {
     char s[101];
     int flag;
 };
 
 int main()
 {
     int i, j, k, l;
     int strings;
     int count;
     int s_count;
     int q_count;
     struct check s[100];
     char buf[101];
     int switches;
     int all;
 
     fgets(buf, 101, stdin);
     sscanf(buf, α%dα, &count);
     for(i = 0; i < count; i++) {
         /* init */
         for(j = 0; j < 100; j++) {
             s[j].s[0] = '0';
             s[j].flag = 0;
         }
 
         fgets(buf, 101, stdin);
         sscanf(buf, α%dα, &s_count);
 
         /* 重複なしで検索エンジンを登録 */
         strings = 0;
         for(j = 0; j < s_count; j++) {
             fgets(buf, 101, stdin);
             for(k = 0; k < strings; k++) {
                 if(strcmp(buf, s[k].s) == 0) {
                     break;
                 }
             }
             if(k == strings) {
                 strcpy(s[strings].s, buf);
                 strings++;
             }
         }
 
         /* ひっかかるかひっかからないか */
         fgets(buf, 101, stdin);
         sscanf(buf, α%dα, &q_count);
 
         switches = 0;
         all = 0;
         for(j = 0; j < q_count; j++) {
             fgets(buf, 101, stdin);
             for(k = 0; k < strings; k++) {
                 if(s[k].flag == 0 && strcmp(buf, s[k].s) == 0) {
                     all++;
                     if(all == strings) {
                         switches++;
                         for(l = 0; l < strings; l++) {
                             s[l].flag = 0;
                         }
                         all = 0;
                         all++;
                     }
                     s[k].flag = 1;
                     break;
                 }
             }
         }
 
         printf(αCase #%d: %dnα, i+1, switches);
     }
 
     return 0;
 }"
31446,2008,32013,miura,24481,1,02.c,gcj/2008/32013/miura/24481/1/extracted/02.c,"#include <stdio.h>
 #include <string.h>
 
 struct trip {
     int start;
     int end;
     int flag;
 };
 
 void sort(struct trip *data, int n);
 
 int main()
 {
     int N;
     int NA;
     int NB;
     int T;
 
     struct trip a_data[100];
     struct trip b_data[100];
     int AHH, AMM, BHH, BMM;
     int a_count;
     int b_count;
     
     int i, j, k;
     char buf[128];
 
     fgets(buf, 128, stdin);
     sscanf(buf, α%dα, &N);
 
     for(i = 0; i < N; i++) {
         fgets(buf, 128, stdin);
         sscanf(buf, α%dα, &T);
 
         fgets(buf, 128, stdin);
         sscanf(buf, α%d %dα, &NA, &NB);
 
         for(j = 0; j < NA; j++) {
             fgets(buf, 128, stdin);
             sscanf(buf, α%d:%d %d:%dα, &AHH, &AMM, &BHH, &BMM);
             a_data[j].start = AHH * 60 + AMM;
             a_data[j].end   = BHH * 60 + BMM;
             a_data[j].flag  = 0;
         }
         sort(a_data, NA);
 
         for(j = 0; j < NB; j++) {
             fgets(buf, 128, stdin);
             sscanf(buf, α%d:%d %d:%dα, &AHH, &AMM, &BHH, &BMM);
             b_data[j].start = AHH * 60 + AMM;
             b_data[j].end   = BHH * 60 + BMM;
             b_data[j].flag  = 0;
         }
         sort(b_data, NB);
 
         a_count = NA;
         b_count = NB;
 
         for(j = 0; j < NA; j++) {
             for(k = 0; k < NB; k++) {
                 if(b_data[k].flag == 0
                 && (a_data[j].end + T) <= b_data[k].start) {
                     b_data[k].flag = 1;
                     b_count--;
                     break;
                 }
             }
         }
         for(j = 0; j < NB; j++) {
             for(k = 0; k < NA; k++) {
                 if(a_data[k].flag == 0
                 && (b_data[j].end + T) <= a_data[k].start) {
                     a_data[k].flag = 1;
                     a_count--;
                     break;
                 }
             }
         }
 
         printf(αCase #%d: %d %dnα, i+1, a_count, b_count);
     }
 
     return 0;
 }
 
 void sort(struct trip *data, int n)
 {
     int i, j;
     struct trip temp;
 
     for(i = 0; i < n-1; i++) {
         for(j = i+1; j < n; j++) {
             if(   data[i].start > data[j].start
                || (  (data[i].start == data[j].start)
                    &&(data[i].end    > data[j].end  )) ) {
                 temp    = data[i];
                 data[i] = data[j];
                 data[j] = temp;
             }
         }
     }
 }"
31481,2008,32013,shar,24480,1,AQ.C,gcj/2008/32013/shar/24480/1/extracted/AQ.C,"//name : sharmistha jat
 #include<stdio.h>
 #include<conio.h>
 #include<math.h>
 #include<string.h>
 
 FILE *input,*output;
 	static int s_q[110],switchf;
 int check(int size1)
 {
 	int i,flag=0;
 	for( i=1;i<size1+1;i++)
 	{
 		if(s_q[i]==0)
 		{
 		  flag++;
 		}
 
 	}
 	return flag;
 }
 
 
 void main()
 {
 	int size=0,i,j,sz,k,pos;
  int server=0,query=0,ans,counts,count=0;
 
 	char ser[110][100],querry[100];
 	clrscr();
 	input=fopen(αa7.inα,αrα);
 	fscanf(input,α%dα,&size);
 	 output=fopen(αa1.txtα,αwα);
 	  if(output==NULL)
 	  {
 	  exit(0);
 	  }
 	  sz=size;
 
 	while(size>0)
 	{
 			server=0;
 			query=0;
 			fscanf(input,α%dα,&server);
 
 			for(i=0;i<server+1;i++)
 			       {	fgets(&ser[i],100,input);
 					s_q[i]=0;
 					flushall();
 			       }
 			counts=0;
 			switchf=0;
 			fscanf(input,α%dα,&query);
 			if(query>0)
 			for(i=0;i<query+1;i++)
 			{
 				fgets(&querry,100,input);
 				if(i==0)
 				{       s_q[0]=1;
 					continue;}
 				for(j=1;j<server+1;j++)
 				{
 					if(!strcmp(querry,ser[j]))//check
 					{
 						s_q[j]=1;
 						pos=j;
 						break;
 					}
 				}
 				switchf=check(server);
 				if(switchf==0)
 				{  //then switch
 				counts++;
 					for(k=1;k<server+1;k++)
 					{
 						if(k!=pos)
 						s_q[k]=0;
 					}
 				}
 			}
 		   fprintf(output,αCase #%d: %dnα,(sz-size+1),counts);
 		   size--;
 
     }
     fclose(input);
     fclose(output);
     printf(αntdoneα);
 getch();
 }"
31635,2008,32013,Larry,24480,1,a.c,gcj/2008/32013/Larry/24480/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 char all[1005][105];
 char cur[105];
 int s;
 int prev[1005];
 int now[1005];
 
 int go( char* c ) {
   int i;
   for ( i = 0; i < s; i++ )
     if ( !strcmp( all[i], c ) )
       return i;
   return -1;
 }
 
 int main(){
   int N, ca, b, q, i, j, k, d;
 
   scanf(α%dnα, &N );
 
   for ( ca = 1; ca <= N; ca++ ) {
     scanf(α%dnα, &s );
 
     for ( i = 0; i < s; i++ )
       gets( all[i] );
 
     memset( prev, 0, sizeof( prev ) );
     memset( now, 0, sizeof( now ) );
     scanf(α%dnα, &q );
     for ( i = 0; i < q; i++ ) {
       gets( cur );
       d = go( cur );
 
       if ( d == -1 ) continue;
       now[d] = 1000000;
       for ( k = 0; k < s; k++ ) {
 	if ( k == d ) continue;
 	now[k] = 1000000;
 	for ( j = 0; j < s; j++ ) {
 	  /* from prev[j] to now[k] */
 	  if ( j != k && prev[j] + 1 < now[k] ) now[k] = prev[j] + 1;
 	  else if ( j == k && prev[j] < now[k] ) now[k] = prev[j];
 	}
       }
 
       memcpy( prev, now, sizeof( prev ) );
     }
 
     b = 1000000;
     for ( i = 0; i < s; i++ )
       if ( prev[i] < b ) b = prev[i];
 
     printf(αCase #%d: %dnα, ca, b );
   }
 
   return 0;
 }"
31665,2008,32013,beagoodboy,24480,1,main.c,gcj/2008/32013/beagoodboy/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int getline(char line[])
 {
     int c;
     int i;
 
     i = 0;
     while ((c = getchar()) != '0' && c != 'n')
     {
         line[i++] = c;
     }
     line[i] = '0';
 
     return i;
 }
 
 int main()
 {
     int casenum, senum, qnum, num, swnum;
     char judge[100];
     char se[100][101];
     //char q[100][101];
     char line[101];
     int i, j, k, l;
 
     scanf(α%dnα, &casenum);
     //printf(α%dnα, casenum);
     for (i = 0; i < casenum; i++)
     {
         for (l = 0; l < 100; l++)
         {
             judge[l] = 0;
         }
         num = 0;
         swnum = 0;
 
         scanf(α%dnα, &senum);
         for (j = 0; j < senum; j++)
         {
             getline(se[j]);
             //printf(α%snα, se[j]);
         }
 
         scanf(α%dnα, &qnum);
         for (j = 0; j < qnum; j++)
         {
             getline(line);
             //printf(α%snα, line);
             for (k = 0; k < senum; k++)
             {
                 if (strcmp(se[k], line) == 0)
                 {
                     if (judge[k] == 0)
                     {
                         if (num == senum - 1)
                         {
                             for (l = 0; l < 100; l++)
                             {
                                 judge[l] = 0;
                             }
                             judge[k] = 1;
                             num = 1;
                             swnum++;
                         }
                         else
                         {
                             judge[k] = 1;
                             num++;
                         }
                     }
                     break;
                 }
             }
         }
 
         printf(αCase #%d: %dnα, i + 1, swnum);
     }
 
     return 0;
 }"
31694,2008,32013,EasyCode,24480,1,A.c,gcj/2008/32013/EasyCode/24480/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 char map[100][100];
 char line[100];
 int intmap[100];
 
 int main()
 {
     int n;
     int s;
     int q;
     int i,j,k,t;
     int count;
     int temp;
     int answer;
     freopen(αA-large.inα,αrα,stdin);
     freopen(αA-large.outα,αwα,stdout);
     scanf(α%dα,&n);
     for(i = 0; i < n; i++)
     {
         for(t = 0; t < 100; t++)
         {
             intmap[t] = 0;
         }
         answer = 0;
         scanf(α%dα,&s);
         getchar();
         for(j = 0; j < s; j++)
         {
             gets(map[j]);
         }
         scanf(α%dα,&q);
         getchar();
         for(k = 0; k < q; k++)
         {
             gets(line);
             // map
             //ҵ Ӧλü1
             for(t = 0; t < s; t++)
             {
                 if(!strcmp(line,map[t]))
                 {
                     intmap[t]++;
                     temp = t;
                 }
             }
             count = 0;
        //     temp = -1;
             //ѯ
             for(t = 0; t < s; t++)
             {
                 if(intmap[t] == 0)
                 {
                     count++;
                     temp = t;
                 }
             }
             if(count == 0)
             {
 
                 answer++;
                 for(t = 0; t < s; t++)
                 {
                     intmap[t] = 0;
                     if(t == temp)//ȥ  ----- 99999
                     {
                         intmap[t] = 9999;
                     }
                 }
             }
             if(k == q-1)
             {
                 printf(αCase #%d: %dnα,i+1,answer);
             }
         }
         if(q == 0)
         {
             printf(αCase #%d: %dnα,i+1,answer);
         }
         for(t = 0; t < s; t++)
         {
             intmap[t] = 0;
         }
     }
     return 0;
 }"
31706,2008,32013,fena,24480,1,stu.c,gcj/2008/32013/fena/24480/1/extracted/stu.c,"#include <stdio.h>
 #include <string.h>
 /*Renato Coelho*/
 
 char quer[10010][110];
 int nextQuer[110][10010];
 
 int main(){
   int s,q;
   int i,k;
   int trocas;
   int cases,ccases;
   int max,argmax;
   int flag;
   char actual[110];
   char engines[110][110];
   int nc;
   int temp;
 
   scanf(α %d α,&cases);
 
   for(ccases=1;ccases<=cases;ccases++){  
     scanf(α %d α,&s);
     for(i=1; i<=s; i++){
       nextQuer[i][0] = 0;
       scanf(α%[^n]sα,engines[i]);
       getchar();
     }
 
     scanf(α %d α,&q);
     for(i=1; i<=q; i++){
       scanf(α%[^n]sα, actual);
       getchar();
       for(k=1; k<=s; k++){
 	if(!strcmp(actual,engines[k])){
 	  break;
 	}
       }
       strcpy(quer[i],actual);
       nextQuer[k][0]++;
       nextQuer[k][nextQuer[k][0]] = i;
     }
 
     for(i=1; i<=s; i++){
       nextQuer[i][nextQuer[i][0]+1] = -1;
       nextQuer[i][0] = 1;
     }
 
     printf(αCase #%d: α,ccases);
     max = -1;
     flag = 0;
 
     for(i=1; i<=s; i++){
       if(nextQuer[i][1]==-1){
 	flag = 1;
 	break;
       }
       else if(nextQuer[i][1]>max){
 	max = nextQuer[i][1];
 	argmax = i;
       }
     }
 
     if(flag){
       printf(α0nα);
       continue;
     }
 
     nc = nextQuer[argmax][1];
     trocas = 0;
     temp = argmax;
 
     for(i=1; i<=q; i++){
       if(i<nc){
 	for(k=1;k<=s;k++){
 	  if(!strcmp(quer[i],engines[k]))
 	    break;
 	}
 	nextQuer[k][0]++;
       }
       else{
 	trocas++;
 	max=nc;
 
 	for(k=1;k<=s;k++){
 	  if(nextQuer[k][nextQuer[k][0]]==-1){
 	    flag = 1;
 	    break;
 	  }
 	  else if(nextQuer[k][nextQuer[k][0]]>max){
 	    max = nextQuer[k][nextQuer[k][0]];
 	    nc = max;
 	    argmax = k;
 	  }
 	}
 
 	nextQuer[temp][0]++;
 	temp = argmax;
       }
 
       if(flag)
 	break;
 
     }
     printf(α%dnα,trocas); 
 
   }
 
   return 0;
 }"
31726,2008,32013,littleboy,24480,1,gc1.c,gcj/2008/32013/littleboy/24480/1/extracted/gc1.c,"#include <stdio.h>
 #include <string.h>
 
 char s[400];
 char name[200][400], q[2000][400];
 int Ncase, N;
 int i;
 int p, left;
 int used[200];
 int search, query;
 int tmp, ans;
 
 int find(const char *s) {
 	int i;
 
 	for (i = 0; i < search; i++)
 		if (strcmp(s, name[i]) == 0) return i;
 
 	while (1) printf(αERRORnα);
 }
 
 int main() {
 	gets(s);
 	sscanf(s, α%dα, &Ncase);
 	for (N = 1; N <= Ncase; N++) {
 		gets(s);
 		sscanf(s, α%dα, &search);
 		for (i = 0; i < search; i++) gets(name[i]);
 		gets(s);
 		sscanf(s, α%dα, &query);
 		for (i = 0; i < query; i++) gets(q[i]);
 
 		p = 0;
 		ans = 0;
 		while (1) {
 			memset(used, 0, sizeof(used));
 			left = search;
 
 			for (i = p; i < query; i++) {
 				tmp = find(q[i]);
 				if (!used[tmp]) {
 					used[tmp] = 1;
 					left--;
 				}
 
 				if (left == 0) break;
 			}
 			if (i == query) break;
 
 			ans++;
 			p = i;
 		}
 
 		printf(αCase #%d: %dnα, N, ans);
 	}
 	return 0;
 }"
31728,2008,32013,littleboy,24481,1,gc2.c,gcj/2008/32013/littleboy/24481/1/extracted/gc2.c,"#include <stdio.h>
 
 struct DepArr {
 	int dep, arr;
 } aTob[100], bToa[100];
 
 struct Ttrain {
 	char at;
 	int valid;
 } train[1000];
 
 int caseN, N;
 int turnAround, atb, bta;
 int h1, m1, h2, m2;
 int time1, time2;
 int t;
 int i, now;
 int t1, t2;
 
 void getTrainAToB(int n) {
 	int i;
 
 	for (i = 0; i < t; i++)
 		if (train[i].at == 'A' && train[i].valid <= now) {
 			train[i].at = 'B';
 			train[i].valid = aTob[n].arr;
 			return;
 		}
 
 	train[t].at = 'B';
 	train[t].valid = aTob[n].arr;
 	t++;
 	t1++;
 }
 
 void getTrainBToA(int n) {
 	int i;
 
 	for (i = 0; i < t; i++)
 		if (train[i].at == 'B' && train[i].valid <= now) {
 			train[i].at = 'A';
 			train[i].valid = bToa[n].arr;
 			return;
 		}
 
 	train[t].at = 'A';
 	train[t].valid = bToa[n].arr;
 	t++;
 	t2++;
 }	
 
 int main() {
 	scanf(α%dα, &caseN);
 	for (N = 1; N <= caseN; N++) {
 		scanf(α%dα, &turnAround);
 		scanf(α%d%dα, &atb, &bta);
 
 		for (i = 0; i < atb; i++) {
 			scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			time1 = h1*60 + m1;
 			time2 = h2*60 + m2;
 
 			aTob[i].dep = time1;
 			aTob[i].arr = time2+turnAround;
 		}
 
 		for (i = 0; i < bta; i++) {
 			scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			time1 = h1*60 + m1;
 			time2 = h2*60 + m2;
 
 			bToa[i].dep = time1;
 			bToa[i].arr = time2+turnAround;
 		}
 
 		t = 0;
 		t1 = t2 = 0;
 		for (now = 0; now < 24*60*60; now++) {
 			for (i = 0; i < atb; i++)
 				if (aTob[i].dep == now)
 					getTrainAToB(i);
 
 			for (i = 0; i < bta; i++)
 				if (bToa[i].dep == now)
 					getTrainBToA(i);
 		}
 
 		printf(αCase #%d: %d %dnα, N, t1, t2);
 	}
 	return 0;
 }"
31730,2008,32013,TheSandy,24480,1,save_universe.c,gcj/2008/32013/TheSandy/24480/1/extracted/save_universe.c,"#include <stdio.h>
 
 typedef unsigned short int U16;
 typedef unsigned int U32;
 typedef unsigned char U8;
 typedef char S8;
 
 #define	MAX_NAME_LEN	100+1
 #define	FILE_NAME	STD_IN
 
 typedef struct test_case {
 	U16	nSrchEng;
 	U8	**SrchEng;
 	U16	nQueries;
 	U8	**Queries;
 	U16	Switch;
 } TEST_CASE;
 
 static U16		gnTestCases = 0; // num. of test cases
 static TEST_CASE	*gTestCases = NULL;
 static U16		*nSwitch ; // num of switches done for each test case
 static FILE *gInFile = NULL; 
 
 U8*	TrimStr (U8* Str)
 {
 	U8* p = NULL;
 
 	// Trip From Start First
 	while ((' ' == *Str) || ('t' == *Str))	Str++;
 
 	//Trim From End
 	p = Str + strlen (Str) - 1;
 	while ((' ' == *p) || ('t' == *p)) p--;
 	*(p+1) = '0';
 
 	return	Str;
 }
 
 U16	ReadLine (U8*	pBuf, U16 BufLen)
 {
 	U16	Len;
 	
 	memset (pBuf, 0, BufLen);
 	if (NULL == fgets ((S8 *)pBuf, BufLen, gInFile)) {
 		printf (αnt File Read Error!!!nα);
 		exit (0);
 	}
 	// Remove NewLine
 	Len = strlen (pBuf);
 	pBuf [Len - 1] = '0';
 	pBuf = TrimStr (pBuf);
 	return	0;
 }
 
 U16	GetSearchNameIndex (U16	iTestCase, U8 *pName)
 {
 	U16	i;
 	TEST_CASE *pTestCase = &gTestCases [iTestCase];
 	U16	nSrchEng = pTestCase->nSrchEng;
 	
 	for ( i = 0; i < nSrchEng; i++ ) {
 		if (0 == strcmp (pTestCase->SrchEng[i], pName) )
 			return	i;
 	}
 }
 
 U16	FindFarthestIndex ( U16 iTestCase, U16 Start, U16 End )
 {
 	U16	i, iFarthest = Start, iFarthestIndex = 0;
 	U16	*pDist = NULL;
 	TEST_CASE *pTestCase = &gTestCases [iTestCase];
 	U16	nSrchEng = pTestCase->nSrchEng;
 	U16	nQueries = pTestCase->nQueries;
 	
 	pDist = (U16 *) malloc ( nSrchEng * sizeof (U16) );
 	
 	if (NULL == pDist) {
 		printf (αnt Malloc Failed for pDist!!!nα);
 		exit (0);
 	}
 	for ( i = 0; i < nSrchEng; i++ )
 		pDist [i]  = End+1;
 	
 	for ( i = Start; i < End; i++ ) {
 		U16	iSrchName = GetSearchNameIndex (iTestCase, pTestCase->Queries[i]);
 		if (End+1 == pDist [iSrchName] )	pDist [iSrchName] = i;
 	}
 	
 	/*
 	for ( i = 0; i < nSrchEng; i++ )
 		printf (αnt Name = %s, pDist [i]  = %huα, pTestCase->SrchEng[i], pDist [i]);
 	*/
 	
 	iFarthest = Start;
 	iFarthestIndex = 0;
 	for ( i = 0; i < nSrchEng; i++ ) {
 		if (iFarthest < pDist [i] ) {
 			iFarthest = pDist [i];
 			iFarthestIndex = i;
 		}
 	}
 	return	iFarthestIndex;
 }
 
 void	DecideQuery ( U16	iTestCase )
 {
 	U16	i;
 	TEST_CASE *pTestCase = &gTestCases [iTestCase];
 	U16	nSrchEng = pTestCase->nSrchEng;
 	U16	nQueries = pTestCase->nQueries;
 	U16 Start, End;
 	U16	iFarthestIndex = 0;
 	
 	printf (αnnt Test Case : %hu.α, iTestCase+1 );
 	printf (αnt --------------------------------------------------------α);
 	nSwitch [iTestCase] = 0;
 	Start = 0;
 	End = nQueries;
 	iFarthestIndex = FindFarthestIndex ( iTestCase, Start, End );
 	//printf (αnt Sis : %s.α, pTestCase->SrchEng[iFarthestIndex] );
 	//printf (αnt Farthest Search Engine is : %s.α, pTestCase->SrchEng[iFarthestIndex] );
 
 	for ( i = 0; i < nQueries; i++ ) {
 		if (0 == strcmp (pTestCase->Queries[i], pTestCase->SrchEng[iFarthestIndex]) ) {
 			// need to switch
 			printf (αn Need to Switch to another Search Engine............α);
 			nSwitch [iTestCase]++;
 			Start = i;
 			End = nQueries;
 			iFarthestIndex = FindFarthestIndex ( iTestCase, Start, End );
 			//printf (αnt Farthest Search Engine is : %s.α, pTestCase->SrchEng[iFarthestIndex] );
 		}
 		printf (αnt Sending  Query [%hu] to Search Engine [%s].α, i+1, pTestCase->SrchEng[iFarthestIndex] );	
 	}
 }
 
 void	DisplayInput ( void )
 {
 	U16	i;
 
 	printf (αnnn Inputα);
 	printf (αnn Number of Test Cases : %hu.α, gnTestCases );
 	printf (αnn ===========================================================α);
 	for (i=0; i < gnTestCases; i++) {
 		U16	j=0;
 		TEST_CASE *pTestCase = &gTestCases [i];
 		U16	nSrchEng = pTestCase->nSrchEng;
 		U16	nQueries = pTestCase->nQueries;
 		
 		printf (αnnt Test Case : %hu.α, i+1 );
 		printf (αnt --------------------------------------------------------α);
 		printf (αntt Number of Search Engines : %hu.α, nSrchEng );
 		for ( j = 0; j < nSrchEng; j++ ) {
 			printf (αnttt Name [%hu] : %s.α, j+1, pTestCase->SrchEng[j]);
 		}
 		printf (αntt Number of Queries : %hu.α, nQueries );
 		for ( j = 0; j < nQueries; j++ ) {
 			printf (αnttt Name [%hu] : %s.α, j+1, pTestCase->Queries[j]);
 		}
 	}
 }
 
 void	FillSearchEngineNames (U8 **SrchEng, U16 n)
 {
 	U16	i = 0, Index;
 	U8	Names [MAX_NAME_LEN+5];
 	
 	for (i=0; i< n; i++) {
 		memset (Names, 0, MAX_NAME_LEN+5);
 		// Read number of Queries
 		ReadLine (Names, MAX_NAME_LEN+5);
 		memset (SrchEng[i], 0, MAX_NAME_LEN);
 		//Index = NameHash (Names);
 		//printf (αnt Index for %s is %hu.α, Names, Index);
 		strcpy (SrchEng[i], Names);
 	}
 }
 
 void	FillQueries (U8 **Queries, U16 n)
 {
 	U16	i = 0, Index;
 	U8	Names [MAX_NAME_LEN+5];
 	
 	for (i=0; i< n; i++) {
 		memset (Names, 0, MAX_NAME_LEN+5);
 		// Read number of Queries
 		ReadLine (Names, MAX_NAME_LEN+5);
 		memset (Queries[i], 0, MAX_NAME_LEN);
 		strcpy (Queries[i], Names);
 	}
 }
 
 void GetTestCases ( void )
 {
 	U16	i = 0, Ret;
 	
 	U8	Buf [MAX_NAME_LEN+5];
 
 	// Read number of Test Cases
 	ReadLine (Buf, MAX_NAME_LEN+5);
 	sscanf (Buf, α%huα, &gnTestCases);
 	
 	gTestCases = (TEST_CASE *) malloc (sizeof (TEST_CASE) * gnTestCases );
 
 	if (NULL == gTestCases) {
 		printf (αnt Malloc Failed for Test Case!!!nα);
 		exit (0);
 	}
 	memset (gTestCases, 0, sizeof (TEST_CASE) * gnTestCases );
 
 	nSwitch = (U16 *) malloc (sizeof (U16) * gnTestCases );
 
 	if (NULL == nSwitch) {
 		printf (αnt Malloc Failed for nSwitch!!!nα);
 		exit (0);
 	}
 	memset (nSwitch, 0, sizeof (U16) * gnTestCases );
 	
 	for (i=0; i < gnTestCases; i++) {
 		U16	j;
 		// Read number of Search Engines
 		ReadLine (Buf, MAX_NAME_LEN+5);
 		sscanf (Buf, α%huα, &gTestCases [i].nSrchEng);
 		gTestCases [i].SrchEng = (U8 **) malloc ( gTestCases [i].nSrchEng * sizeof (U8 *) );
 	
 		if (NULL == gTestCases [i].SrchEng) {
 			printf (αnt Malloc Failed for Search Engines!!!nα);
 			exit (0);
 		}
 		gTestCases [i].SrchEng[0] = (U8 *) malloc ( gTestCases [i].nSrchEng * MAX_NAME_LEN );
 		for (j = 1; j<gTestCases [i].nSrchEng; j++) {
 			gTestCases [i].SrchEng[j] = gTestCases [i].SrchEng[0] + j*MAX_NAME_LEN;
 		}
 		FillSearchEngineNames ( gTestCases [i].SrchEng, gTestCases [i].nSrchEng) ;
 
 		// Read number of Queries
 		ReadLine (Buf, MAX_NAME_LEN+5);
 		sscanf (Buf, α%huα, &gTestCases [i].nQueries);
 		gTestCases [i].Queries = (U8 **) malloc ( gTestCases [i].nQueries * sizeof (U8 *) );
 	
 		if (NULL == gTestCases [i].Queries) {
 			printf (αnt Malloc Failed for Queries!!!nα);
 			exit (0);
 		}
 		gTestCases [i].Queries[0] = (U8 *) malloc (gTestCases [i].nQueries*MAX_NAME_LEN );
 		for (j = 1; j<gTestCases [i].nQueries; j++) {
 			gTestCases [i].Queries[j] = gTestCases [i].Queries[0] + j*MAX_NAME_LEN;
 		}
 		FillQueries (gTestCases [i].Queries, gTestCases [i].nQueries);
 	}
 }
 
 void	PrintOuput ( void )
 {
 	U16	i;
 	FILE *fp = fopen (αOutput.txtα, αw+α);
 	
 	if (fp == NULL) {
 		printf (αnt Failed to Create Outputfile...Output.txtnα);
 		return;
 	}
 	
 	for (i=0; i < gnTestCases; i++) {
 		fprintf (fp, αCase #%hu: %hunα, i+1, nSwitch[i]);
 	}
 	fclose (fp);
 }
 
 int	main (int argc, char *argv[])
 {
 	U16	i;
 
 	if (argc != 2) {
 		printf (αntUsage: exe inputfilennnα);
 		exit (0);
 	}
 	
 	gInFile = fopen (argv[1], αrα);
 	if (gInFile == NULL) {
 		printf (αnt Failed to Open Inputfile %snnnα, argv[1]);
 		exit (0);
 	}
 	
 	GetTestCases ();
 	DisplayInput ();
 	fclose (gInFile);
 	printf (αnnn Execution Tracesα);
 	for (i=0; i < gnTestCases; i++) {
 		DecideQuery ( i );
 	}
 	printf (αnnnα);
 	PrintOuput ();
 	return	0;
 }"
31800,2008,32013,lovedfish,24480,1,main.c,gcj/2008/32013/lovedfish/24480/1/extracted/main.c,"/*
  * =====================================================================================
  *
  *       Filename:  main.c
  *
  *    Description:  
  *
  *        Version:  1.0
  *        Created:  07/17/08 22:37:33
  *       Revision:  none
  *       Compiler:  gcc
  *
  *         Author:  Leon Bai
  *
  * =====================================================================================
  */
 
 #include <stdlib.h>
 #include <stdio.h>
 
 #define INPUT    αA-large.inα
 #define OUTPUT   αA-large.outα
 
 typedef struct _engine_res
 {
 	char engine_name[100];
 	int  engine_hits;
 }engine_result;
 
 
 int main()
 {
 	FILE* f_in = fopen(INPUT, αrbα);
 	FILE* f_out = fopen(OUTPUT, αwtα);
 	int   bytes_used = 0;
 	int   bytes_left = 0;
 	int   bytes_read = 0;
 	int   file_len = 0;
 	int   question_nr = 0;
 	int   case_seq = 0;
 
 	if((f_in == NULL) || (f_out == NULL))
 		return -1;
 
 	fscanf(f_in, α%dα, &question_nr);
 	if (question_nr <= 0)
 		return -1;
 
 	while(question_nr)
 	{
 		int engine_nr = 0;
 		int query_nr = 0;
 		engine_result *p_e_res;
 		int* engine_hit_seq = NULL;
 		int switch_nr = 0;
 		int override_nr = 0; 
 
 		fscanf(f_in, α%dα, &engine_nr);
 		p_e_res = (engine_result*)malloc(sizeof(engine_result)*engine_nr);
 		memset(p_e_res, 0, sizeof(engine_result)*engine_nr);
 		{
 			int i=0;
 			for(i=0;i<engine_nr;i++)
 			{
 				fscanf(f_in, α%sα, p_e_res[i].engine_name);
 				while(fgetc(f_in) == ' ')
 				{
 					p_e_res[i].engine_name[strlen(p_e_res[i].engine_name)] = ' ';
 					fscanf(f_in, α%sα, &(p_e_res[i].engine_name[strlen(p_e_res[i].engine_name)]));
 				}
 				p_e_res[i].engine_hits = 0;
 			}
 		}
 
 		fscanf(f_in, α%dα, &query_nr);
 		{
 			int i=0;
 			int j=0;
 			char query_name[100];
 			engine_hit_seq = (int*)malloc(sizeof(query_nr)*sizeof(int));
 			memset(engine_hit_seq, 0, sizeof(query_nr)*sizeof(int));
 			override_nr = engine_nr;
 			for(i=0;i<query_nr;i++)
 			{
 				memset(query_name, 0, sizeof(query_name));
 				fscanf(f_in, α%sα, query_name);
 				while(fgetc(f_in) == ' ')
 				{
 					query_name[strlen(query_name)] = ' ';
 					fscanf(f_in, α%sα, &(query_name[strlen(query_name)]));
 				}
 				for(j=0;j<engine_nr;j++)
 				{
 					if(!memcmp(query_name, p_e_res[j].engine_name, 100))
 					{
 						if (p_e_res[j].engine_hits == 0)
 						{
 							p_e_res[j].engine_hits = 1;
 							override_nr -= 1;
 							//fprintf(stdout, αhit in %d with left %dnα, j, override_nr);
 						}
 						
 						if (override_nr == 0)
 						{
 							int k;
 							for (k=0;k<engine_nr;k++)
 								p_e_res[k].engine_hits = 0;
 
 							override_nr = engine_nr;
 							p_e_res[j].engine_hits = 1;
 							override_nr -= 1;
 							switch_nr += 1;
 						}
 						break;
 					}
 				}
 				//fprintf(stdout, α%dnα, engine_hit_seq[i]);
 			}
 		}
 
 		case_seq += 1;
 		//fprintf(stdout, αCase #%d: %dnα, case_seq, switch_nr );
 		fprintf(f_out, αCase #%d: %dnα, case_seq, switch_nr );
 		question_nr -= 1;
 	}
 
 	return 0;
 }"
31802,2008,32013,lovedfish,24481,1,main.c,gcj/2008/32013/lovedfish/24481/1/extracted/main.c,"/*
  * =====================================================================================
  *
  *       Filename:  main.c
  *
  *    Description:  
  *
  *        Version:  1.0
  *        Created:  07/18/08 02:38:50
  *       Revision:  none
  *       Compiler:  gcc
  *
  *         Author:  Leon Bai 
  *
  * =====================================================================================
  */
 
 
 #include <stdio.h>
 #include <stdlib.h>
 
 #define INPUT  αB-large.inα
 #define OUTPUT αB-large.outα
 
 typedef struct _time_table_prop
 {
 	int time_depart;
 	int time_arrival;
 	struct _time_table_prop *prev;
 	struct _time_table_prop *next;
 }tt_prop;
 
 int GetTrainNum(tt_prop* tt_p_A, tt_prop* tt_p_B, int A_nr, int B_nr, int* train_A_nr, int* train_B_nr, int turn_around )
 {
 	int i=0, j=0;
 	//fprintf(stdout, α%s: A %d B %d, turn %dnα, __FUNCTION__, A_nr, B_nr, turn_around);
 
 	for (i=0;i<A_nr;i++)
 	{
 		if (tt_p_A[i].next == NULL)
 		{
 			int time_diff = 0x7fffffff;
 			int B_pos = -1;
 			for(j=0;j<B_nr;j++)
 			{
 				if(tt_p_A[i].time_arrival <= (tt_p_B[j].time_depart - turn_around) && (time_diff > (tt_p_B[j].time_depart - tt_p_A[i].time_arrival)))		
 				{
 					if(tt_p_B[j].prev == NULL)
 					{
 						B_pos = j;
 						fprintf(stdout, αmatch A %d B %dnα, i, j);
 						time_diff = tt_p_B[j].time_depart - tt_p_A[i].time_arrival;
 					}
 				}
 			}
 
 			if (B_pos != -1)
 			{
 				tt_p_B[B_pos].prev = &tt_p_A[i];
 				tt_p_A[i].next = &tt_p_B[B_pos];
 			}
 		}
 	}
 	for (i=0;i<B_nr;i++)
 	{
 		if (tt_p_B[i].next == NULL)
 		{
 			int A_pos = -1;
 			int time_diff = 0x7fffffff;
 			for(j=0;j<A_nr;j++)
 			{
 				if(tt_p_B[i].time_arrival <= (tt_p_A[j].time_depart - turn_around) && (time_diff > (tt_p_A[j].time_depart - tt_p_B[i].time_arrival)))
 				{
 					if(tt_p_A[j].prev == NULL)  
 					{
 						A_pos = j;
 						fprintf(stdout, αmatch B %d A %dnα, i, j);
 						time_diff = tt_p_A[j].time_depart - tt_p_B[i].time_arrival;
 					}
 				}
 			}
 
 			if (A_pos != -1)
 			{
 				tt_p_A[A_pos].prev = &tt_p_B[i];
 				tt_p_B[i].next = &tt_p_A[A_pos];
 			}
 		}
 	}
 
 	for (i=0;i<A_nr;i++)
 	{
 		if(tt_p_A[i].prev == NULL)
 			*train_A_nr += 1;
 	}
 	for (i=0;i<B_nr;i++)
 	{
 		if(tt_p_B[i].prev == NULL)
 			*train_B_nr += 1;
 	}
 
 	return 0;
 }
 
 int main()
 {
 	FILE* f_in = fopen(INPUT, αrbα);
 	FILE* f_out = fopen(OUTPUT, αwtα);
 	int   question_nr = 0;
 	int   turn_around = 0;
 	int   total_tt_A = 0;
 	int   total_tt_B = 0;
 	int   case_seq = 0;
 
 	if( (f_in == NULL) || (f_out == NULL))
 		return -1;
 
 	fscanf(f_in, α%dα, &question_nr);
 
 	while(question_nr)
 	{
 		int total_train_A = 0;
 		int total_train_B = 0;
 		tt_prop *tt_A = NULL;
 		tt_prop *tt_B = NULL;
 		fscanf(f_in, α%dα, &turn_around);
 		fscanf(f_in, α%d %dα, &total_tt_A, &total_tt_B);
 		fprintf(stdout, αturn around %d, A %d, B %dnα, turn_around, total_tt_A, total_tt_B);
 		if(total_tt_A)
 		{
 			tt_A = (tt_prop*)malloc(sizeof(tt_prop)*total_tt_A);
 			memset(tt_A, 0, sizeof(tt_prop)*total_tt_A);
 		}
 		if(total_tt_B)
 		{
 			tt_B = (tt_prop*)malloc(sizeof(tt_prop)*total_tt_B);
 			memset(tt_B, 0, sizeof(tt_prop)*total_tt_B);
 		}
 		if((total_tt_A == 0) || (total_tt_B == 0))
 		{
 			total_train_A = total_tt_A;
 			total_train_B = total_tt_B;
 		}
 		else
 		{
 			int int_a, int_b, int_c, int_d;
 			int i=0;
 			for(i=0;i<total_tt_A;i++)
 			{
 				fscanf(f_in, α%d:%dα, &int_a, &int_b);
 				fscanf(f_in, α%d:%dα, &int_c, &int_d);
 				fprintf(stdout, αtime %d:%d-%d:%dnα, int_a, int_b, int_c, int_d);
 				tt_A[i].time_depart = int_a*60+int_b;
 				tt_A[i].time_arrival = int_c*60+int_d;
 				tt_A[i].prev= 0;
 				tt_A[i].next = 0;
 			}
 			for(i=0;i<total_tt_B;i++)
 			{
 				fscanf(f_in, α%d:%dα, &int_a, &int_b);
 				fscanf(f_in, α%d:%dα, &int_c, &int_d);
 				fprintf(stdout, αtime %d:%d-%d:%dnα, int_a, int_b, int_c, int_d);
 				tt_B[i].time_depart = int_a*60+int_b;
 				tt_B[i].time_arrival = int_c*60+int_d;
 				tt_B[i].prev = 0;
 				tt_B[i].next = 0;
 			}
 
 			GetTrainNum(tt_A, tt_B, total_tt_A, total_tt_B, &total_train_A, &total_train_B, turn_around);
 		}
 
 		if (tt_A)
 			free(tt_A);
 		if (tt_B)
 			free(tt_B);
 		case_seq += 1;
 		fprintf(stdout, αCase #%d: %d %dnα, case_seq, total_train_A, total_train_B);
 		fprintf(f_out, αCase #%d: %d %dnα, case_seq, total_train_A, total_train_B);
 		question_nr -= 1;
 	}
 	return 0;
 }"
31845,2008,32013,itramana,24480,1,test.c,gcj/2008/32013/itramana/24480/1/extracted/test.c,"#include<stdio.h>
 int updateefound(int,char[100][50],char *);
 int isfull(int*,int);
 void clean(int*,int);
 int main()
 {
  FILE *fp;
  char s[80];
  int i = 0,tc=0,noOfSearchEngines=0,j=0,nq=0,k=0;
  char engines[100][50];
  char queries[1000][50];
  int efound[100];
  int pos = 0,out=0;
  fp = fopen(αc:\input.inα, αrα); 
  if(NULL != fp)
  {
     fgets(s, 80, fp);      
     sscanf(s,α%dα,&tc);
     
     for(i=0;i<tc;i++)
     {
      out = 0;                
      fgets(s, 80, fp);                       
      sscanf(s,α%dα,&noOfSearchEngines);
      for(j=0;j<noOfSearchEngines;j++)
      {
        fgets(engines[j], 80, fp);    
      }
      // No of queries
      fgets(s, 80, fp);      
      sscanf(s,α%dα,&nq);
      for(k=0;k<nq;k++)
      {
        fgets(queries[k], 80, fp);
        pos = updateefound(noOfSearchEngines,engines,queries[k]);                       
        if(-1 != pos)
          efound[pos] = 1;
        if(isfull(efound,noOfSearchEngines))
        {
          out++;
          for(j=0;j<noOfSearchEngines;j++)
          {
            efound[j] = 0;
          }
          pos = updateefound(noOfSearchEngines,engines,queries[k]);                       
          if(-1 != pos)
           efound[pos] = 1; 
        } 
      }
      printf(αnCase #%d: %dα,i+1,out);
      for(j=0;j<noOfSearchEngines;j++)
      {
        efound[j] = 0;
      }
     }
  }
  return 1;   
 }
 
 
 int updateefound(int n,char engines[100][50],char *queries)
 {
   int i=0,ret=-1;
   for(i=0;i<n;i++)
   {
    if(strcmp(queries,engines[i]) == 0)
    {
    
      ret = i;
      break;                            
    }
   }
   return ret;
 } 
 
 int isfull(int* a, int n)
 {
  int i =0;
  for(i=0;i<n;i++)
  {
    if(a[i] != 1)
      return 0;                
  }
  return 1;               
 }"
31847,2008,32013,itramana,24481,1,Train.c,gcj/2008/32013/itramana/24481/1/extracted/Train.c,"#include<stdio.h>
 
 char* convert(char *,char*,char*,int,int);
 int main(int argc,char* argv[])
 {
     char s[80];
     FILE *fp;
     int i=0,j=0,k=0;
     int tt=0,tA=0,tB=0,tc=0;
     int A_dep_hr[100],A_dep_min[100],A_arr_hr[100],A_arr_min[100];
     int B_dep_hr[100],B_dep_min[100],B_arr_hr[100],B_arr_min[100];
     int A_dep_time[100],A_arr_time[100],B_dep_time[100],B_arr_time[100]; 
     int hr,min;
     int A_flag[100],B_flag[100];
     int outA,outB;
     int diff=-1,pos=-1;
     int time;
     fp = fopen(αinput1.inα, αrα); 
     if(NULL != fp)
     {
         fgets(s, 80, fp);      
         sscanf(s,α%dα,&tc);
     }
     for(i=0;i<tc;i++)
     {
         fgets(s,80,fp);
         sscanf(s,α%dα,&tt);
         fgets(s,80,fp);
         sscanf(s,α%d %dα,&tA,&tB);
         outA = tA;
         outB = tB;
         for(j=0;j<tA;j++)
         {
             fgets(s,80,fp);
             sscanf(s,α%d:%d %d:%dα,&A_dep_hr[j],&A_dep_min[j],&A_arr_hr[j],&A_arr_min[j]);
             A_flag[j]=0;
             A_dep_time[j]=(A_dep_hr[j] * 60) + A_dep_min[j];
             A_arr_time[j]=(A_arr_hr[j] * 60) + A_arr_min[j];
         }
         for(j=0;j<tB;j++)
         {
             fgets(s,80,fp);
             sscanf(s,α%d:%d %d:%dα,&B_dep_hr[j],&B_dep_min[j],&B_arr_hr[j],&B_arr_min[j]);
             B_flag[j]=0;
             B_dep_time[j]=(B_dep_hr[j] * 60) + B_dep_min[j];
             B_arr_time[j]=(B_arr_hr[j] * 60) + B_arr_min[j];
            // printf(α%d %d %d %d nα,B_dep_hr[j],B_dep_min[j],B_arr_hr[j],B_arr_min[j]);
         }
         
         for(j=0;j<tA;j++)
         {
            time = A_arr_time[j]+tt;
            if(time>=1440)
            {
                continue;
            }
            diff = -1;
            pos = -1;
            for(k=0;k<tB;k++)
            {
                if((time <= B_dep_time[k]) && !B_flag[k] )
                {
                     if ((diff == -1) || (B_dep_time[k] - time <= diff))
                     {
                               pos=k;
                               diff = B_dep_time[k]-time;
                     }
                     
                }
                
            }
            if(pos != -1)
            {
                B_flag[pos]=1;
                outB--;
            }
           
         }
          for(j=0;j<tB;j++)
         {
            time = B_arr_time[j] + tt;
            if(time >= 1440)
            {
                continue;
            }
            diff = -1;
            pos = -1;
            for(k=0;k<tA;k++)
            {
            
               if((time <= A_dep_time[k]) && !A_flag[k] )
                {
                     if ((diff == -1) || (A_dep_time[k] - time <= diff))
                     {
                               pos=k;
                               diff = A_dep_time[k] - time;
                     }
                     
                }
            }
            if(pos != -1)
            {
                A_flag[pos]=1;
                outA--;
            }
         }
         printf(αCase #%d: %d %dnα,i+1,outA,outB);
                          
     }
     return 1;
 }"
31863,2008,32013,goober,24479,1,C.c,gcj/2008/32013/goober/24479/1/extracted/C.c,"#include <stdio.h>
 #include <math.h>
 
 #define PI 3.1415926535897932384626
 
 double sqr(double x) { return x*x; }
 
 double fun(double x, double a)
 {
 	return 0.5 * (asin(x / a) * a * a + x * sqrt(1 - sqr(x/a)));
 }
 
 int main()
 {
 	int n;
 
 	scanf(α%dα, &n);
 	for (int c = 1; c <= n; c++)
 	{
 		double res = 0;
 		double f, R, t, r, g;
 		double block, dim, inrad, sinrad;
 
 		scanf(α%lf %lf %lf %lf %lfα, &f, &R, &t, &r, &g);
 		block = 2*r + g;
 		dim = g - 2*f;
 		inrad = R - t - f; 
 		sinrad = sqr(inrad);
 
 		if (dim <= 0) res = 0;
 		else for (double x = r + f; x < inrad; x += block) for (double y = r + f; y < inrad; y += block)
 		{
 			double si, ei;
 
 			if (sqr(x) + sqr(y) >= sinrad) continue;
 			if (sqr(x + dim) + sqr(y + dim) < sinrad)
 			{
 				res += sqr(dim);
 				continue;
 			}
 
 			ei = sqrt(sinrad - sqr(y));
 			if (ei > x + dim) ei = x + dim;
 
 			if (sqr(x) + sqr(y + dim) >= sinrad) si = x;
 			else
 			{
 				si = sqrt(sinrad - sqr(y+dim));
 				res += (si - x) * dim;
 			}
 			res += fun(ei, inrad) - fun(si, inrad) - y * (ei - si);
 		}
 		
 		printf(αCase #%d: %fnα, c, 1.0 - 4 * res / (PI * R * R));
 	}
 	return 0;
 }"
31865,2008,32013,goober,24481,1,B.c,gcj/2008/32013/goober/24481/1/extracted/B.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct
 {
 	int t;
 	int d;
 } REC;
 
 REC la[200], lb[200];
 
 int cmp(const void *aa, const void *bb)
 {
 	const REC* a = (const REC*)aa;
 	const REC* b = (const REC*)bb;
 	if (a->t != b->t) return a->t - b->t;
 	return b->d - a->d;
 }
 
 int main()
 {
 	int n;
 
 	scanf(α%dα, &n);
 	for (int c = 1; c <= n; c++)
 	{
 		int t, na, nb;
 
 		scanf(α%dα, &t);
 		scanf(α%d %dα, &na, &nb);
 		
 		for (int i = 0; i < na; i++)
 		{
 			int h1, m1, h2, m2;
 			scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			la[i].t = 60*h1 + m1;
 			la[i].d = -1;
 			lb[i].t = 60*h2 + m2 + t;
 			lb[i].d = +1;
 		}
 
 		for (int i = na; i < na+nb; i++)
 		{
 			int h1, m1, h2, m2;
 			scanf(α%d:%d %d:%dα, &h1, &m1, &h2, &m2);
 			lb[i].t = 60*h1 + m1;
 			lb[i].d = -1;
 			la[i].t = 60*h2 + m2 + t;
 			la[i].d = +1;
 		}
 
 		qsort(la, na+nb, sizeof(REC), cmp);
 		qsort(lb, na+nb, sizeof(REC), cmp);
 
 		int ma = 0, ca = 0;
 		for (int i = 0; i < na+nb; i++)
 		{
 			ca += la[i].d;
 			if (ca < ma) ma = ca;
 		}
 
 		int mb = 0, cb = 0;
 		for (int i = 0; i < na+nb; i++)
 		{
 			cb += lb[i].d;
 			if (cb < mb) mb = cb;
 		}
 		printf(αCase #%d: %d %dnα, c, -ma, -mb);
 	}
 	return 0;
 }"
31954,2008,32013,nishiMIT,24481,1,Max Priority Queue based on Max Heaps.c,gcj/2008/32013/nishiMIT/24481/1/extracted/Max Priority Queue based on Max Heaps.c,"#include<stdio.h>
 #include<stdlib.h>
 #define MIN_INT (int)((UInt)(-1) ^ ((~0u)>>1)) 
 typedef unsigned int UInt;
 
 void swap(int *ptrA,int *ptrB);
 void maxHeapify(int a[],UInt n,UInt i);
 int isPowerOf2(unsigned int x); 
 void displayHeap(int a[],int n);
 void getData(int a[],int n);
 inline int parent(UInt i);
 
 int heapMaximum(int a[],UInt n);
 int heapExtractMax(int a[],UInt *ptrN);
 void heapIncreaseKey(int a[],UInt n,UInt i,int key);
 void maxHeapInsert(int a[],UInt *ptrN,int key);
 void heapDelete(int a[],UInt *ptrN,UInt i);
 
 int main()
 {
 	int a[50],n=0;
 	while(n < 16)
 	{
 		int key;
 		printf(αnEnter key :α);
 		scanf(α%dα,&key);
 		maxHeapInsert(a,&n,key);
 	}
 	displayHeap(a,n);
 	printf(αnMax :%dα,heapExtractMax(a,&n));
 	displayHeap(a,n);
 	heapDelete(a,&n,3);
 	displayHeap(a,n);
 	system(αPAUSEα);
 	return 0;
 }
 void swap(int *ptrA,int *ptrB)
 {
 	int temp=*ptrA;
 	*ptrA=*ptrB;
 	*ptrB=temp;
 }
 /* 
 This algorithm is better than the recursive method given in Cormen.
 My Algorithm does fewer comparisons
 1.	Takes advantage of the fact that if right node is there, then
  	the left node will also be there
 2. 	Non-recursive algorithm
 3.  Shorter Way to make comparison b/w the node and its children
 */
 void maxHeapify(int a[],UInt n,UInt i)
 {
 	while((i<<1)+2 < n)
 	{
 		int k=(a[(i<<1)+1] > a[(i<<1)+2])? (i<<1)+1:(i<<1)+2;
 		if(a[k] < a[i])
 			return;
 		swap(&a[k],&a[i]);
 		i=k;
 	}		
 	/* if node i has only one child */
 	if((i<<1)+1 < n)
 	 if(a[i] < a[(i<<1)+1])
 		swap(&a[i],&a[(i<<1)+1]);
 }
 
 int isPowerOf2(unsigned int x) 
 {
 	if(!x) return -1;
 	int count=0;
 	while((x&1) == 0)
 	{
 		count++;
 		x>>=1;
 	}	
 	if(x>>1) return -1;
 	return count;
 }
 void displayHeap(int a[],int n)
 {
 	int i=0;
 	while(i < n)
 	{
 		if(isPowerOf2(i+1) != -1)
 			printf(αnα);
 		printf(α%d α,a[i]);
 		i++;
 	}	
 }
 
 void getData(int a[],int n)
 {
 	int i;
 	for(i=0;i < n;i++)
 	{
 		printf(α%d :α,i);
 		scanf(α%dα,&a[i]);
 	}
 }
 
 
 int heapMaximum(int a[],UInt n)
 {
 	return a[0];/* error checking for a == NULL and n >= 1 can be done*/ 
 }
 
 int heapExtractMax(int a[],UInt *ptrN)
 {
 	if(*ptrN == 0)
 		return MIN_INT; /* error */
 	int max=a[0];
 	a[0]=a[--(*ptrN)];
 	maxHeapify(a,*ptrN,0);
 	return max;
 }
 
 inline int parent(UInt i)
 {
 	i=i+(i&1);
 	return (i>>1)-1;
 }
 
 void heapIncreaseKey(int a[],UInt n,UInt i,int key)
 {
 	if(key <= a[i])
 		return;
 	a[i]=key;
 	while(parent(i) >= 0 && a[i] > a[parent(i)])
 	{
 		swap(&a[i],&a[parent(i)]);
 		i=parent(i);
 	}
 }
 
 void maxHeapInsert(int a[],UInt *ptrN,int key)
 {
 	a[(*ptrN)++]=MIN_INT;
 	heapIncreaseKey(a,*ptrN,*ptrN-1,key);
 }
 void heapDelete(int a[],UInt *ptrN,UInt i)
 {
 	while(parent(i) >= 0)
 	{
 		a[i]=a[parent(i)];
 		i=parent(i);
 	}
 	a[0]=a[--(*ptrN)];
 	maxHeapify(a,*ptrN,0);
 }"
31979,2008,32013,Chewbacca,24479,1,tennis.c,gcj/2008/32013/Chewbacca/24479/1/extracted/tennis.c,"#include <stdio.h>
 
 #include <math.h>
 
 typedef long double REAL;
 
 float read_number(void) { 
   float A; scanf(α%gα,&A);
   return A;
 }
 
 /* I hate globals but.... */
 static REAL max_sq_error, r0;
 double square_area(REAL x, REAL y, REAL d)
 {
   if(x*x+y*y>=r0*r0) return 0.0;
   if((x+d)*(x+d)+(y+d)*(y+d)<=r0*r0) return d*d;
   if(d*d<max_sq_error) 
     return 0.5*d*d;
   d/=2;
   return 
     square_area(x,y,d) +
     square_area(x+d,y,d) +
     square_area(x,y+d,d) +
     square_area(x+d,y+d,d);
 }
 
 double test_case(void)
 {
   REAL f, R, t, r, g;
   REAL Ssq;
 
   REAL Stotal, maxsq;
   REAL x,y,dx;
     
   f = read_number(); R = read_number();
   t = read_number(); r = read_number();
   g = read_number();
 
   /* The inner circle */
   r0 = R-t-f;
 
   /* Update string width to match the fly */
   r+=f; g -= 2*f;
 
   /* Test trivial case: fly doesn't fit */
   if(r0<0 || g<=0) return 0;
 
   /* Total circle area of 1/4 of circle*/
   Stotal = M_PI*R*R;
 
   /* Distant between square corners */
   dx=2*r+g;
 
 
   /* Maximal number of squares (in fact more than that) 4/PI times, but who cares */
   maxsq = M_PI*r0*r0/dx/dx;
 
   fprintf(stderr, αDebug: sq=%gnα, (double)maxsq);
 
   /* Maximal error of square area */
   max_sq_error = Stotal*1e-7/maxsq;
   
   for(Ssq=0,x=r; x<r0; x+=dx) {
     for(y=r; y<r0; y+=dx) {
       REAL t = square_area(x,y,g);
       if(t==0.0) break;
       Ssq+=t;
     }
   }
   return 4*Ssq/Stotal;
 }
 
 
 int main(void)
 {
   int case_no, total_cases;
 
   total_cases = read_number();
   for(case_no=1; case_no<=total_cases; case_no++) 
     printf(αCase #%d: %-9gnα, case_no, 1-test_case());
   return 0;
 }"
32003,2008,32013,yannis,24481,1,b.c,gcj/2008/32013/yannis/24481/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 typedef struct train train;
 
 struct train {
 	int st, end, type, vis;
 } tr[202];
 
 int compare(const void *a, const void *b) {
 	train c = *((train *)a), d = *((train *)b);
 	
 	return c.end - d.end;
 }
 
 int main(void) {
 	freopen(αinput.txtα, αrα, stdin);
 	freopen(αoutput.txtα, αwα, stdout);
 	int i, j, test, T, ans[3], w, x, y, z, NA, NB, N, delay, min, minw;
 	
 	scanf(α%dnα, &T);
 	
 	for(test=1; test<=T; test++) {
 		scanf(α%dn%d %dnα, &delay, &NA, &NB);
 		
 		ans[1] = ans[2] = 0;
 		
 		for (i=1; i<=NA; i++) {
 			scanf(α%d:%d %d:%dnα, &w, &x, &y, &z);
 			tr[i].st = w*60 + x;
 			tr[i].end = y*60 + z;
 			tr[i].type = 1;
 			tr[i].vis = 0;
 		}
 		
 		for (i=1; i<=NB; i++) {
 			scanf(α%d:%d %d:%dnα, &w, &x, &y, &z);
 			tr[NA+i].st = w*60 + x;
 			tr[NA+i].end = y*60 + z;
 			tr[NA+i].type = 2;
 			tr[NA+i].vis = 0;
 		}
 		
 		N = NA + NB;
 		
 		qsort(&tr[1], N, sizeof(train), compare);
 		
 		for (i=1; i<=N; i++) {
 			if ( !tr[i].vis ) {
 				ans[ tr[i].type ]++;
 			}
 			
 			tr[i].vis = 1;
 			
 			min = -1; minw = -1;
 			
 			for (j=1; j<=N; j++) {
 				if ( tr[j].type == tr[i].type || tr[j].vis || tr[j].st < tr[i].end + delay ) continue;
 				if ( tr[j].st < min || minw == -1 ) {
 					min = tr[j].st;
 					minw = j;
 				}
 			}
 			
 			if ( minw != -1 ) tr[minw].vis = 1;
 		}
 		
 		printf(αCase #%d: %d %dnα, test, ans[1], ans[2]);
 	}
 	
 	return 0;
 }"
32074,2008,32013,b0le,24480,1,main.c,gcj/2008/32013/b0le/24480/1/extracted/main.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
 typedef struct _GoogleCase
 {
     char **se; /* array of search engines */
     int nS;
     int *qu; /* array of queries */
     int nQ;
 } GoogleCase;
 
 FILE *fp;
 
 static char *
 getLine ()
 {
     char *str = malloc (sizeof(char)*101);
 	if(!str) return NULL;
     int c;
     int n=0;
 	    
     while( (c=getc(fp)) != EOF)
     {
 	
 	str[n]=c;
 	if(c=='n' || c=='0' || c=='r') /* the line is ended - return */
 	{
 	    str[n]='0';
 	    return str;
 	}
 	n++;	
     }
     
     str[n]='0';
     return str;
 }
 
 static int
 nameToInt (GoogleCase *gc, char *name)
 {
     int n;
     for (n=0;n<gc->nS;n++) if(!strcmp(name,gc->se[n])) return n;
     return -1;
 }
 
 static void
 loadCase (GoogleCase *gc)
 {
     gc->nS = atoi (getLine());
     gc->se = malloc (sizeof(char *) * gc->nS);
     int n;
     for (n=0; n< gc->nS; n++) gc->se[n] = getLine();
     
     gc->nQ = atoi (getLine());
     gc->qu = malloc(sizeof(int) * gc->nQ);
     for(n=0; n<gc->nQ; n++) 
     {
 	gc->qu[n] = nameToInt (gc, getLine());
     }
     
 }
 
 static int
 runLength (int *q, int n, int want)
 {
     int i;
     for(i=0;i<n;i++) if(q[i]== want) break;
     return i;
 }
 
 static int
 handleCase (GoogleCase *gc)
 {
     int switches=0;
     int done=0;
     
     while(1)
     {
 	int n;
 	int maxRun=0;	 
 	for(n=0;n<gc->nS;n++)
 	{
 	    int tmp;
 	    if((tmp=runLength(&gc->qu[done], gc->nQ-done, n)) > maxRun) maxRun = tmp;
 	}
         
 	done+=maxRun;
 //fprintf(stderr,α%d %dnα,done, maxRun);  	
 	if(done == gc->nQ) break;
 		
 	switches++;
       
 
     }
     
     return switches;
 }
 
 int
 main (int argc, char **argv)
 {
     fp = stdin;
     
     int nG = atoi(getLine());
     GoogleCase *gc = malloc (sizeof(GoogleCase)*nG);
 
     int n;
     for(n=0;n<nG;n++) loadCase(&gc[n]);
     for(n=0;n<nG;n++) fprintf(stdout,αCase #%d: %dnα, n+1,handleCase(&gc[n]));
 }"
32076,2008,32013,b0le,24481,1,main.c,gcj/2008/32013/b0le/24481/1/extracted/main.c,"#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdbool.h>
 
 typedef struct _TrainTime TrainTime;
 typedef enum 
 {
     AtoB,
     BtoA
 } TrainDirection;
 
 struct _TrainTime
 {  
     TrainDirection d;
     
     int arrive; //MINUTES
     int depart; //MINUTES 
     
     TrainTime *A;  //next in list of those that arrive/depart from A
     TrainTime *B;  // α B
 };
 
 typedef struct _GoogleCase
 {
     int turnTime;
     
     TrainTime *A; //arrive or depart from A
     TrainTime *B; //arrive or depart from B
     
     int NA;
     int NB;
 } GoogleCase;
 
 FILE *fp;
 
 static char *
 getLine ()
 {
     char *str = malloc (sizeof(char)*101);
 	if(!str) return NULL;
     int c;
     int n=0;
 	    
     while( (c=getc(fp)) != EOF)
     {
 	
 	str[n]=c;
 	if(c=='n' || c=='0' || c=='r') /* the line is ended - return */
 	{
 	    str[n]='0';
 	    return str;
 	}
 	n++;	
     }
     
     str[n]='0';
     return str;
 }
 
 static void
 splitNum (char *l, int *a, int *b)
 {
     int n=0;
     while(1)
     {
 	if(l[n]==' ')
 	{
 	    l[n]='0';
 	    break;
 	}
 	n++;
     }
     
     *a = atoi (l);
     *b = atoi (&l[n+1]);
 }
 
 static void
 lineToTrainTime (char *l, TrainTime *t)
 {
 //0123456789
 //HH:MM HH:MM
     l[2]='0';
     l[5]='0';
     l[8]='0';
 
     int dh = atoi(&l[0]);
     int dm = atoi(&l[3]);    
     int ah = atoi(&l[6]);    
     int am = atoi(&l[9]);
 
     t->arrive = 60*ah + am;
     t->depart = 60*dh + dm;
 }
 
 #define ADJUST_TIME_A(time) ((time)->d == AtoB ? ((time)->depart) : ((time)->arrive + gc->turnTime))
 #define ADJUST_TIME_B(time) ((time)->d == BtoA ? ((time)->depart) : ((time)->arrive + gc->turnTime))
 
 //returns true if t is after test
 static bool
 compareTime (GoogleCase *gc, TrainTime *test, TrainTime *t, char station)
 {
     if(station == 'a')
     {
 	if (ADJUST_TIME_A(test) < ADJUST_TIME_A (t)) return true;
 	
 	return false;	
     }
     if(station == 'b')
     {
 	if (ADJUST_TIME_B(test) <= ADJUST_TIME_B (t)) return true;
 	
 	return false;	
     }    
 }
 
 static void
 insertTrainTime (GoogleCase *gc, TrainTime *t)
 {
     TrainTime *test;
     TrainTime *prev = NULL;
     for(test = gc->A; test; prev = test, test = test->A) if(!compareTime(gc, test, t, 'a')) break;
     
     t->A = test;
     if(!prev) gc->A = t;
     else prev->A = t;
     
     prev = NULL;
     for(test = gc->B; test; prev = test, test = test->B) if(!compareTime(gc, test, t, 'b')) break;
 
     t->B = test;
     if(!prev) gc->B = t;
     else prev->B = t;        
 }
 
 static void
 loadCase (GoogleCase *gc)
 {
     gc->turnTime = atoi(getLine());
     gc->A = NULL;
     gc->B = NULL;
     
     splitNum(getLine(), &gc->NA, &gc->NB);
 
     int n;
     for (n=0; n< gc->NA; n++) 
     {
 	TrainTime *t = malloc(sizeof(TrainTime));
 	t->A = NULL;
 	t->B = NULL;
 	t->d = AtoB;
 		
 	lineToTrainTime (getLine(), t);
 	
 	insertTrainTime (gc, t);
     }
 
     for (n=0; n< gc->NB; n++) 
     {
 	TrainTime *t = malloc(sizeof(TrainTime));
 	t->A = NULL;
 	t->B = NULL;
 	t->d = BtoA;
 		
 	lineToTrainTime (getLine(), t);
 	
 	insertTrainTime (gc, t);
     }
 }
 
 static void
 handleCase (GoogleCase *gc)
 {
     TrainTime *a;
     int nA=0, nB=0;
     int aM=0, bM=0;
     for(a=gc->A;a;a=a->A) 
     {
 	if(a->d == AtoB) nA--; else nA++;
 //fprintf(stderr,α%dnα, nA);
 	if(nA<aM) aM = nA;
     }
     
 //fprintf(stderr,αA above, B belownα);    
     for(a=gc->B;a;a=a->B) 
     {
 	if(a->d == BtoA) nB--; else nB++;
 //fprintf(stderr,α%d nα, nB);
 	if(nB<bM) bM= nB;
     }
     
 /*    if(aM<0) aM=-aM;
     else aM=0;
 
     if(bM<0) bM=-bM;
     else bM=0;*/
     
     aM=-aM;
     bM=-bM;
         
     fprintf(stdout,α%d %dnα, aM, bM);
 }
 
 int
 main (int argc, char **argv)
 {
     fp = stdin;
     
     int nG = atoi(getLine());
     GoogleCase *gc = malloc (sizeof(GoogleCase)*nG);
     int n;
     
     for(n=0;n<nG;n++) loadCase(&gc[n]);
     for(n=0;n<nG;n++)
     {
 	fprintf(stdout,αCase #%d: α,n+1);
 	handleCase(&gc[n]);    
     }
 }"
32125,2008,32013,ankitjain,24480,1,univ1.c,gcj/2008/32013/ankitjain/24480/1/extracted/univ1.c,"//Program for saving the universe
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 struct searchengine
 {
 char enginename[100];
 int occurence;
 };
 main()
 {
 FILE *fp,*out;
 char str[100];
 int i,j,inputs,queries,min,x=1,count,last;
 struct searchengine *arr;
 fp=fopen(αA-large.inα,αrα);
 out=fopen(αoutput1.txtα,αwα);
 fscanf(fp,α%dnα,&inputs);
 while(inputs--)
 {
 	min=0;
 	fscanf(fp,α%dnα,&count);
 	printf(α%dα,count);
 	arr=(struct searchengine *)malloc(sizeof(int)*count);
 	for(i=0;i<count;i++)
 	{
 		fgets(str,100,fp);
 		printf(α%sα,str);
 		strcpy(arr[i].enginename,str);
 		arr[i].occurence=0;
 	}
 	fscanf(fp,α%dnα,&queries);
 	printf(α%dα,queries);
 	while(queries--)
 	{
 	        fgets(str,100,fp);
 		for(i=0;i<count;i++)
 		{
 			if(!strcmp(str,arr[i].enginename))
 			{
 				arr[i].occurence++;
 				last=i;
 				break;
 			}
 		}
 		for(i=0;i<count;i++)
 		{
 			if(arr[i].occurence<1)
 		 	break;
 		}	
 		if(i==count)
 		{
 			for(j=0;j<count;j++)
 			{
 				if(j==last)
 				arr[j].occurence=1;
 				else
 				arr[j].occurence=0;
 			}
 			min++;
 		}
 	}
 	fprintf(out,αCase #%d: %dnα,x,min);
 	x++;
 	fscanf(fp,α%dnα,&count);
 }
 fclose(fp);
 fclose(out);
 }"
32136,2008,32013,bahadir,24480,1,main.c,gcj/2008/32013/bahadir/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int
 findsequence(int queries[], int index, int querynum, int engine)
 {
     while (index < querynum) {
         if (queries[index] == engine) {
             return index;
         }
         index++;
     }
     return index;
 }
 
 int
 solve(int queries[], int querynum, int enginenum)
 {
     int i, changes = 0, index = 0;
     
     while (index < querynum) {
         int max = findsequence(queries, index, querynum, 0);
         for (i = 1; i < enginenum; i++) {
             int seq = findsequence(queries, index, querynum, i);
             if (seq > max) {
                 max = seq;
             }
         }
         index = max;
         if (index != querynum) {
             changes++;
         }
     }
 
     return changes;
 }
 
 int
 main(int argc, char** argv) 
 {
     int i, j, k, casenum;
     FILE *in, *out;
     
     if (argc < 3) {
         fprintf(stderr, αWrong number of arguments!nα);
         exit(1);
     }
     
     in = fopen(argv[1], αrα);
     out = fopen(argv[2], αwα);
     
     fscanf(in, α %dα, &casenum);
     for (i = 0; i < casenum; i++) {
         int enginenum;
         char engines[100][100];
         int querynum;
         int queries[1000];
         int solution;
         
         fscanf(in, α %d α, &enginenum);
         for (j = 0; j < enginenum; j++) {
             fgets(engines[j], 100, in);    
         }
         
         fscanf(in, α %d α, &querynum);
         for (j = 0; j < querynum; j++) {
             char str[100];
             fgets(str, 100, in);
             for (k = 0; k < enginenum; k++) {
                 if (strcmp(engines[k], str) == 0) {
                     queries[j] = k;
                     break;
                 }
             }
         }
         
         solution = solve(queries, querynum, enginenum);
         fprintf(out, αCase #%d: %dnα, i + 1, solution);
     }
     
     fclose(in);
     fclose(out);
     
     return 0;
 }"
32139,2008,32013,bahadir,24481,1,main.c,gcj/2008/32013/bahadir/24481/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct trip {
     int departure, arrival;
 };
 
 struct timetable {
     int num_a, num_b;
     struct trip fromA[100], fromB[100];
 };
 
 int
 compare(const void *first, const void *second)
 {
     return *(int *) first - *(int *) second;
 }
 
 void
 addaction(int array[], int *size, int num)
 {
     int i;
     for (i = 0; i < *size; i++) {
         if (array[i] == num) {
             return;
         }
     }
     array[(*size)++] = num;
 }
 
 int
 solve(struct timetable *table, int *sol_a, int *sol_b)
 {
     int i, j, actionsize = 0;
     int actions[400];
     int ready_a = 0, ready_b = 0;
     int need_a = 0, need_b = 0;
 
     for (i = 0; i < table->num_a; i++) {
         addaction(actions, &actionsize, table->fromA[i].departure);
         addaction(actions, &actionsize, table->fromA[i].arrival);
     }
 
     for (i = 0; i < table->num_b; i++) {
         addaction(actions, &actionsize, table->fromB[i].departure);
         addaction(actions, &actionsize, table->fromB[i].arrival);
     }
     
     qsort(actions, actionsize, sizeof(int), compare);
     for (i = 0; i < actionsize; i++) {
         for (j = 0; j < table->num_a; j++) {
             if (table->fromA[j].arrival == actions[i]) {
                 ready_b++;
             }
         }
         for (j = 0; j < table->num_b; j++) {
             if (table->fromB[j].arrival == actions[i]) {
                 ready_a++;
             }
         }
         for (j = 0; j < table->num_a; j++) {
             if (table->fromA[j].departure == actions[i]) {
                 if (ready_a > 0) {
                     ready_a--;
                 } else {
                     need_a++;
                 }
             }
         }
         for (j = 0; j < table->num_b; j++) {
             if (table->fromB[j].departure == actions[i]) {
                 if (ready_b > 0) {
                     ready_b--;
                 } else {
                     need_b++;
                 }
             }
         }
     }
     
     *sol_a = need_a;
     *sol_b = need_b;
     return 0;
 }
 
 
 int
 main(int argc, char** argv) 
 {
     int i, j, casenum;
     FILE *in, *out;
     
     if (argc < 3) {
         fprintf(stderr, αWrong number of arguments!nα);
         exit(1);
     }
     
     in = fopen(argv[1], αrα);
     out = fopen(argv[2], αwα);
     
     fscanf(in, α %dα, &casenum);
     for (i = 0; i < casenum; i++) {
         int turnaround, sol_a, sol_b;
         struct timetable table;
         
         fscanf(in, α %d %d %dα, &turnaround, &table.num_a, &table.num_b);
         for(j = 0; j < table.num_a; j++) {
             int dh, dm, ah, am;
             fscanf(in, α %d:%d %d:%dα, &dh, &dm, &ah, &am);
             table.fromA[j].departure = dh * 60 + dm;
             table.fromA[j].arrival = ah * 60 + am + turnaround;
         }
         
         for(j = 0; j < table.num_b; j++) {
             int dh, dm, ah, am;
             fscanf(in, α %d:%d %d:%dα, &dh, &dm, &ah, &am);
             table.fromB[j].departure = dh * 60 + dm;
             table.fromB[j].arrival = ah * 60 + am + turnaround;
         }
         
         solve(&table, &sol_a, &sol_b);
         fprintf(out, αCase #%d: %d %dnα, i + 1, sol_a, sol_b);
     }
     
     fclose(in);
     fclose(out);
     
     return 0;
 }"
32438,2008,32013,manikarthik84,24480,1,univ.c,gcj/2008/32013/manikarthik84/24480/1/extracted/univ.c,"#include <stdio.h>
 #include <conio.h>
 #include <stdlib.h>
 #include <string.h>
 int main()
 {
    FILE * pFile;
    FILE * oFile;
    char str [100];
    int noi = 0, nos = 0, noq = 0;
    int i,j,k,eof = 0;
    int uniq = 0, sw = 0;
    char  arr[100][100]; int present = 0;
    
 
    pFile = fopen (αc:\kar\A-small.inα , αrα);
    oFile = fopen (αc:\kar\out.txtα , αwα);
    if (pFile == NULL) perror (αError opening pFileα);
    if (oFile == NULL) perror (αError opening oFileα);
    
    if (fgets (str , 100 , pFile) != NULL)
    {
           noi = atoi(str);
         //  printf(αn Num of inputs : %dα,noi);
           }  
           
    for (i = 1; i <= noi && eof == 0; i++)
    {
        
        if (fgets (str , 100 , pFile) != NULL)
        {
               nos = atoi(str);
             //  printf(αn Num of search engines : %dα,nos);
               }
        else
               eof = 1;
               
        for (j = 1; j <= nos &&  eof == 0; j++)
            if (fgets (str , 100 , pFile) == NULL)
               eof = 1;
           // else 
             //    printf (αnSrch: %sα,str);
            
        if (fgets (str , 100 , pFile) != NULL)
        {
               noq = atoi(str);
               //printf(αn Num of queries : %dα,noq);
               }
        else
               eof = 1;
               
               
        for (k = 1; k <= noq &&  eof == 0; k++)
        {
            if (fgets (str , 100 , pFile) == NULL)
               eof = 1;
            else 
            {
                 if (uniq < nos )
                 {
                      present = 0;
                      for (j = 0; j < uniq; j++)
                      {
 
                          if (strcmp(arr[j],str) == 0)
                             present = 1; 
                      }
                             
                       if (present == 0)
                       {
                          strcpy(arr[uniq],str); uniq++;
                   
                          }
                   }
                   if (uniq == (nos))
                   {
                       uniq = 0;
                       strcpy(arr[uniq],str); uniq++;
                         
                       sw++;
 
                   }
            }
            }              
                 fprintf (oFile,αCase #%d: %dnα,i,sw);sw=0;uniq=0;
               
               
        }
    
  
      fclose (pFile);     fclose (oFile);
 
 
    getch();
    return 0;
 }"
32661,2008,32013,migacr,24480,1,saving_universe.c,gcj/2008/32013/migacr/24480/1/extracted/saving_universe.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 int readvalue(char *c) {
 int r;
 	r = 0;
 	for (; *c >= '0' && *c <= '9'; *c = (char)fgetc(stdin)) {
 		r = r > 0 ? 10*r+(*c-'0'):*c-'0';
 	}
 	return r;
 }
 char *readstring(char *c) {
 char *r;
 int i;
 	r = (char *)malloc(sizeof(char));
 	i = 0;
 	for (; *c >= ' ' && *c <= '~'; *c = (char)fgetc(stdin)) {
 		r[i] = *c;
 		i++;
 		r = (char *)realloc(r,sizeof(char)*(i+1));
 	}
 	r[i] = '0';
 	return r;
 }
 void readblanks(char *c) {
 	for (; *c == ' ' || *c == 't'; *c = (char)fgetc(stdin));
 }
 void readeol(char *c) {
 	for (; *c != 'n'; *c = (char)fgetc(stdin));
 }
 int main(int argc,char **argv) {
 char c,**searchengines,**queries;
 int n,s,*queriesbysearchengine,q,switches,maxq,idxs,i,j,k,l;
 	c = (char)fgetc(stdin);
 	n = readvalue(&c);
 	readeol(&c);
 	for (i = 1; i <= n; i++) {
 		c = (char)fgetc(stdin);
 		s = readvalue(&c);
 		readeol(&c);
 		searchengines = (char **)malloc(sizeof(char *)*s);
 		queriesbysearchengine = (int *)malloc(sizeof(int)*s);
 		for (j = 0; j < s; j++) {
 			c = (char)fgetc(stdin);
 			searchengines[j] = readstring(&c);
 			queriesbysearchengine[j] = 0;
 			readeol(&c);
 		}
 		c = (char)fgetc(stdin);
 		q = readvalue(&c);
 		readeol(&c);
 		queries = (char **)malloc(sizeof(char *)*q);
 		for (j = 0; j < q; j++) {
 			c = (char)fgetc(stdin);
 			queries[j] = readstring(&c);
 			for (k = 0; k < s && strcmp(searchengines[k],queries[j]); k++);
 			if (k < s) {
 				queriesbysearchengine[k]++;
 			}
 			readeol(&c);
 		}
 		switches = 0;
 		if (q > 0) {
 			maxq = -1;
 			idxs = -1;
 			for (j = 0; j < s; j++) {
 				for (k = 0; k < q && strcmp(searchengines[j],queries[k]); k++);
 				if (k > maxq) {
 					maxq = k;
 					idxs = j;
 				}
 			}
 			fprintf(stderr,α0 %snα,searchengines[idxs]);
 			fflush(stderr);
 			for (j = 1; j < q; j++) {
 				if (!strcmp(searchengines[idxs],queries[j])) {
 					maxq = -1;
 					for (k = 0; k < s; k++) {
 						for (l = j; l < q && strcmp(searchengines[k],queries[l]); l++);
 						if (l > maxq) {
 							maxq = l;
 							idxs = k;
 						}
 					}
 					switches++;
 				}
 				fprintf(stderr,α%i %snα,j,searchengines[idxs]);
 				fflush(stderr);
 			}
 		}
 		fprintf(stdout,αCase #%i: %inα,i,switches);
 		fflush(stdout);
 		for (j = 0; j < q; j++) {
 			free(queries[j]);
 		}
 		free(queries);
 		for (j = 0; j < s; j++) {
 			free(searchengines[j]);
 		}
 		free(queriesbysearchengine);
 		free(searchengines);
 	}
 	return 0;
 }"
32663,2008,32013,Desmond,24480,1,A-small.c,gcj/2008/32013/Desmond/24480/1/extracted/A-small.c,"#include <stdio.h>
 #include <string.h>
 
 int main(void) {
     FILE *fin = fopen(αA-small.inα, αrα);
     FILE *fout = fopen(αA-small.outα, αwα);
     int N, S, Q;
     char sname[100][101], sbool[100], query[101];
     int nsbool, nswitch;
     int c, i, j, k;
     
     fscanf(fin, α%dnα, &N);
     for (c = 1; c <= N; c++) {
         fscanf(fin, α%dnα, &S);
         for (i = 0; i < S; i++) {
             fgets(sname[i], 101, fin);
             sbool[i] = 0;
         }
         nsbool = 0;
         nswitch = 0;
         
         fscanf(fin, α%dnα, &Q);
         for (i = 0; i < Q; i++) {
             fgets(query, 101, fin);
             j = 0;
             while (j < S && strcmp(sname[j], query) != 0)
                 j++;
             if (sbool[j] == 0) {
                 if (nsbool == S-1) {
                     for (k = 0; k < S; k++)
                         sbool[k] = 0;
                     sbool[j] = 1;
                     nsbool = 1;
                     nswitch++;
                 }
                 else {
                     sbool[j] = 1;
                     nsbool++;
                 }
             }
         }
         
         fprintf(fout, αCase #%d: %dnα, c, nswitch);
     }
     
     return 0;
 }"
32665,2008,32013,Desmond,24481,1,B.c,gcj/2008/32013/Desmond/24481/1/extracted/B.c,"#include <stdio.h>
 
 struct TIME {
     int h;
     int m;
     int type;
 };
 typedef struct TIME TIME;
 
 int main(void) {
     FILE *fin = fopen(αB.inα, αrα);
     FILE *fout = fopen(αB.outα, αwα);
     int N, T, NA, NB;
     TIME atime[400], ttime[200], tmptime;
     int natime, cttime, nttime;
     int ctraina, ctrainb, ntraina, ntrainb;
     int c, i, j;
     
     fscanf(fin, α%dnα, &N);
     for (c = 1; c <= N; c++) {
         fscanf(fin, α%dnα, &T);
         fscanf(fin, α%d %dnα, &NA, &NB);
         for (i = 0; i < NA; i++) {
             fscanf(fin, α%d:%d %d:%dnα, &atime[2*i].h, &atime[2*i].m, &atime[2*i+1].h, &atime[2*i+1].m);
             atime[2*i].type = 0;
             atime[2*i+1].type = 2;
         }
         for (i = 0; i < NB; i++) {
             fscanf(fin, α%d:%d %d:%dnα, &atime[2*(NA+i)].h, &atime[2*(NA+i)].m, &atime[2*(NA+i)+1].h, &atime[2*(NA+i)+1].m);
             atime[2*(NA+i)].type = 1;
             atime[2*(NA+i)+1].type = 3;
         }
         natime = (NA + NB) * 2;
         for (i = natime-1; i >= 0; i--)
             for (j = 0; j < i; j++)
                 if (atime[j].h > atime[j+1].h || (atime[j].h == atime[j+1].h && atime[j].m > atime[j+1].m) || (atime[j].h == atime[j+1].h && atime[j].m == atime[j+1].m && atime[j].type < atime[j+1].type)) {
                     tmptime = atime[j];
                     atime[j] = atime[j+1];
                     atime[j+1] = tmptime;
                 }
         
         cttime = nttime = ctraina = ctrainb = ntraina = ntrainb = 0;
         for (i = 0; i < natime; i++) {
             while (cttime < nttime) {
                 if ((ttime[cttime].h < atime[i].h) || (ttime[cttime].h == atime[i].h && ttime[cttime].m <= atime[i].m)) {
                     if (ttime[cttime].type == 2)
                         ctrainb++;
                     else
                         ctraina++;
                     cttime++;
                 }
                 else
                     break;
             }
             switch(atime[i].type) {
                 case 0:
                     if (ctraina == 0)
                         ntraina++;
                     else
                         ctraina--;
                     break;
                 case 1:
                     if (ctrainb == 0)
                         ntrainb++;
                     else
                         ctrainb--;
                     break;
                 case 2: case 3:
                     ttime[nttime] = atime[i];
                     ttime[nttime].m += T;
                     while (ttime[nttime].m >= 60) {
                         ttime[nttime].h++;
                         ttime[nttime].m -= 60;
                     }
                     nttime++;
                     break;
             }
         }
         
         fprintf(fout, αCase #%d: %d %dnα, c, ntraina, ntrainb);
     }
     
     return 0;
 }"
32810,2008,32013,HenryW,24480,1,a.c,gcj/2008/32013/HenryW/24480/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 
 int n,s,q;
 char engines[1001][1001];
 char queries[1001][1001];
 int costs[1001][1001];
 
 void dp() {
   int i,j,k;
   for (i=0;i<s;i++) {
     costs[0][i]=0;
     if (strcmp(queries[0], engines[i]) == 0)
       costs[0][i]=20000;
   }
 
   for (i=1;i<q;i++) {
     for (j=0;j<s;j++) {
       costs[i][j] = 20000;
 
       for (k=0;k<s;k++) {
         if (j==k)
           continue;
         if (costs[i-1][k] + 1 < costs[i][j])
           costs[i][j] = costs[i-1][k]+1;
       }
 
       //      printf(αQuery %d-%s and engine%d-%snα,i,queries[i],j,engines[j]);
       if (strcmp(queries[i],engines[j])){
         //      printf(αand got in w/ cost %dnα, costs[i-1][j]);
         if (costs[i-1][j] < costs[i][j])
           costs[i][j] = costs[i-1][j];
       }
     }
   }
   return;
 }
 
 void printarr()
 {
   int i,j;
   printf(α***nα);
   for (i=0;i<q;i++,printf(αnα))
     for (j=0;j<s;j++)
       printf(α%5d α,costs[i][j]);
   printf(α***nnα);
   return;
 }
 
 
 void main()
 {
   FILE *in=fopen(αinput.txtα,αrα);
   FILE *out=fopen(αoutput.txtα,αwα);
   int i;
   int j;
   int mincost;
 
   fscanf(in,α%d α,&n);
   fprintf(stdout,α%dnα,n);
   for (i=0;i<n;i++) {
     fscanf(in,α%d α,&s);
     fprintf(stdout,α%dnα,s);
     for (j=0;j<s;j++)
       fgets(engines[j], 1000, in);
 
    fscanf(in,α%d α,&q);
    fprintf(stdout,α%dnα,q);
    for (j=0;j<q;j++)
       fgets(queries[j], 1000, in);
 
    if (q == 0) {
       fprintf(out,αCase #%d: 0nα,i+1);
       continue;
    }
 
     dp();
 
     printarr();
     mincost = 100000;
     for (j=0;j<s;j++)
       if (mincost > costs[q-1][j])
         mincost = costs[q-1][j];
     fprintf(out,αCase #%d: %dnα,i+1,mincost);
   }
 }"
32812,2008,32013,HenryW,24481,1,b.c,gcj/2008/32013/HenryW/24481/1/extracted/b.c,"#include <stdio.h>
 #include <string.h>
 
 #define A 0
 #define B 1
 
 #define swap(a,b) {temp=(b);(b)=(a);(a)=temp;}
 
 int n,na, nb, t;
 int depH[1000], depM[1000], depAB[1000], depT[1000];
 int arrH[1000], arrM[1000], arrAB[1000];
 int assignedTo[1000], readyH[1000],readyM[1000],readyAt[1000];
 int totalc,c[2];
 
 void sort() {
   int i,j;
   int temp;
 
   for (i=0;i<na+nb;i++)
     for (j=i+1;j<na+nb;j++) {
       if (depH[i]>depH[j]
 	  || (depH[i]==depH[j] && depM[i]>depM[j]))
 	{
 	  swap(depH[i],depH[j]);
 	  swap(arrH[i],arrH[j]);
 	  swap(depM[i],depM[j]);
 	  swap(arrM[i],arrM[j]);
 	  swap(depAB[i],depAB[j]);
 	  swap(arrAB[i],arrAB[j]);
 	}
     }
   printf(αnα);
   for (i=0;i<na+nb;i++)
 printf(αTrain %d->%d, %02d:%02d ~ %02d:%02dnα,depAB[i],arrAB[i],depH[i],depM[i],arrH[i],arrM[i]);
   printf(αnα);
 
 
   return;
 }
 
 void process() {
   int i,j;
   int mH, mM, mIdx;
 
   sort();
   for (i=0;i<na+nb;i++) {
     mH = mM = 100;
     mIdx = -1;
       
     for (j=0;j<totalc;j++) {
       if ((readyH[j] < mH 
 	   || (readyM[j] <= mM && readyH[j] == mH))
 	  && (readyH[j] < depH[i]
 	      || (readyM[j] <= depM[i] && readyH[j] == depH[i]))
 	  && readyAt[j] == depAB[i]) {
 	mH = readyH[j];
 	mM = readyM[j];
 	mIdx = j;
       }
     }
     
     printf(αTrain %d->%d, %02d:%02d ~ %02d:%02dnα,depAB[i],arrAB[i],depH[i],depM[i],arrH[i],arrM[i]);
 
     if (mIdx == -1) {
       printf(αAdded new train %d at %dnα, totalc, depAB[i]);
       mIdx = totalc++;
       c[depAB[i]]++;
     }
    
     readyAt[mIdx] = arrAB[i];
     readyM[mIdx] = (arrM[i]+t)%60;
     readyH[mIdx] = arrH[i] + (int)((arrM[i]+t)/60);
     printf(αTrain %d moved to %d and ready at %02d:%02dnα,mIdx,readyAt[mIdx],readyH[mIdx],readyM[mIdx]);
   }
 
   return;
 }
 
 int toInt(char *str) {
   int ret = 0;
   ret = (str[0]-'0')*10 + str[1]-'0';
   return ret;
 }
 
 
 void main() 
 {
   FILE *in=fopen(αinput.txtα,αrα);
   FILE *out=fopen(αoutput.txtα,αwα);
   int i;
   int j;
   char dep[100];
   char arr[100];
 
   fscanf(in,α%d α,&n);
 
   for (i=0;i<n;i++) {
     fscanf(in,α%d α,&t);
     fscanf(in,α%d %dα,&na,&nb);
 
     for (j=0;j<na;j++) {
       fscanf(in,α%s %s α,dep, arr);
       depH[j] = toInt(dep);
       depM[j] = toInt(dep+3);
       arrH[j] = toInt(arr);
       arrM[j] = toInt(arr+3);
       depAB[j] = A;
       arrAB[j] = B;
     }
 
     for (j=0;j<nb;j++) {
       fscanf(in,α%s %s α,dep, arr);
       depH[na+j] = toInt(dep);
       depM[na+j] = toInt(dep+3);
       arrH[na+j] = toInt(arr);
       arrM[na+j] = toInt(arr+3);
       depAB[na+j] = B;
       arrAB[na+j] = A;
     }
 
 
     totalc=c[0]=c[1]=0;
     process();
     fprintf(out,αCase #%d: %d %dnα,i+1,c[0],c[1]);
   }
 }"
32835,2008,32013,ramus,24480,1,main.c,gcj/2008/32013/ramus/24480/1/extracted/main.c,"// GCJ Problem 1
 // Clint Sbisa
 
 // Simple greedy algorithm--find the farthest search engine and pick that, and so forth.
 
 #include <stdio.h>
 
 //#define INPUT αA-small.inα
 #define INPUT αA-large.inα
 
 int main()
 {
         FILE *input = fopen(INPUT, αrα);
         int cases, i;
         fscanf(input, α%iα, &cases);
         for (i=0; i<cases; i++) {
                 int engines, j, searches, k, l;
                 // Grab list of engines
                 fscanf(input, α%iα, &engines);
                 char *list[engines][101];
                 fgets(list[0], 101, input); //discard rest of second line
                 for (j=0; j<engines; j++) fgets(list[j], 101, input);
                 // Grab list of searches and do it
                 fscanf(input, α%iα, &searches);
                 int switches = 0, found[engines], now = engines;
                 for (j=0;j<engines;j++) found[j]=0; // initializing array to 0
                 char *search[101];
                 fgets(search, 101, input); //discard rest of previous line
                 for (j=0; j<searches; j++)
                 {
                         fgets(search, 101, input);
                         // Need to find the last referenced search engine
                         for (k=0; k<engines; k++) {
                                 if (strcmp(search, list[k]) == 0) {
                                         if (found[k] != 1) {
                                                 found[k] = 1;
                                                 now--;
                                                 if (now == 0) {
                                                         switches++;
                                                         for (l=0;l<engines;l++) found[l]=0; //resetting variables
                                                         found[k] = 1; // need to keep this
                                                         now = engines-1;
                                                 }
                                         }
                                         break;
                                 }
                         }
                 }
                 printf(αCase #%i: %inα, i+1, switches);
         }
 }"
32948,2008,32013,jperelli,24480,1,main.c,gcj/2008/32013/jperelli/24480/1/extracted/main.c,"#include <stdio.h>
 #include <string.h>
 #include <malloc.h>
 #include <stdlib.h>
 
 
 //#define argv[1] αA.inα
 #define ARCHIVO_SALIDA αA.outα
 
 
 
 int main(int argc, char *argv[]){
 
 	FILE *archivo;
 	FILE *archivo2;
 	char linea[250];
 	char* motores[100];
 	char* consultas[1000];
 	int distanciaMotor[100];
 	int cantCasos, cantConsultas, cantMotores;
 	int k, i, j, PRIMERO, cantCambiosBuscador;
 
 	if ((archivo=fopen(argv[1],αrα))==NULL){
 		printf(αERROR FATAL [1]. No se pudo abrir el archivo de entrada de datos α%sαnα,argv[1]);
 		exit(1);
 	}
 	else {
 		printf(αArchivo de datos de entrada abierto correctamente [α%sα]nα,argv[1]);
 	}
 	
 	if ((archivo2=fopen(ARCHIVO_SALIDA,αwα))==NULL){
 		printf(αERROR FATAL [1]. No se pudo abrir el archivo de salida de datos α%sαnα,ARCHIVO_SALIDA);
 		exit(1);
 	}
 	else {
 		printf(αArchivo de datos de salida abierto correctamente [α%sα]nα,ARCHIVO_SALIDA);
 	}
 
 	fgets (linea, 250, archivo);
 	cantCasos=atoi(linea);
 	printf (αLa cantidad de casos es %i nα, cantCasos);
 	printf(α-----------------Salida al archivo A.out------------------nα);
 
 	for (k=0;k<cantCasos;k++){
 	
 		//leo los motores de busqueda
 		fgets (linea, 250, archivo);
 		cantMotores = atoi(linea);
 		for (i=0;i<cantMotores;i++) {
 			fgets (linea, 250, archivo);
 			motores[i] = (char*)malloc(sizeof(char)*(strlen(linea)+1));
 			strcpy(motores[i], linea);
 		}
 		
 		//leo las consultas
 		fgets (linea, 250, archivo);
 		cantConsultas = atoi(linea);
 		for (i=0;i<cantConsultas;i++) {
 			fgets (linea, 250, archivo);
 			consultas[i] = (char*)malloc(sizeof(char)*(strlen(linea)+1));
 			strcpy(consultas[i], linea);
 		}
 		
 		PRIMERO=0;
 		cantCambiosBuscador=0;
 		
 		while (PRIMERO<cantConsultas) {
 			// guarda en distanciaMotor las distancias al motor mas proximo en la lista de consultas
 			for (i=0;i<cantMotores;i++) {
 				j=PRIMERO;
 				while ((j<cantConsultas) && strcmp(consultas[j],motores[i])) {
 					//printf(αValor j-(%i)nα,j);
 					//printf(α%s-%s-(%i)nnα,consultas[j],motores[i],strcmp(motores[i],consultas[j]));
 						j++;
 				} 
 				distanciaMotor[i]=j;
 			}
 			
 			for (i=0;i<cantMotores;i++) {
 				//printf(αdistanciaMotor[%i]=%inα,i,distanciaMotor[i]);
 			}
 
 			//obtengo en j el indice del motor mas lejano en la lista de consultas
 			j=0;
 			for (i=0;i<cantMotores;i++) {
 				if (distanciaMotor[j]<distanciaMotor[i]) {
 					j=i;
 				}
 			}
 			
 			PRIMERO=distanciaMotor[j];
 			
 			if (PRIMERO<cantConsultas) cantCambiosBuscador++;
 			//printf(αPRIMERO=%in----------------------------------nα,PRIMERO);
 
 			
 		}
 		
 		printf(αCase #%i: %inα,k+1,cantCambiosBuscador);
 		fprintf(archivo2,αCase #%i: %inα,k+1,cantCambiosBuscador);
 		
 	}
 	
 
 
 	if (fclose(archivo)!=0){
 		printf(αERROR DE CIERRE [2]. No se pudo cerrar el archivo de entrada de datos α%sαnα,argv[1]);
 	}
 	
 	if (fclose(archivo2)!=0){
 		printf(αERROR DE CIERRE [3]. No se pudo cerrar el archivo de salida de datos α%sαnα,αA.outα);
 	}
 	else {
 		printf(α---------------FIN EJECUCION---------------nα);
 	}
 
 	return 0;
 }"
32954,2008,32013,Akalanka,24480,1,GCJ_QR_A.C,gcj/2008/32013/Akalanka/24480/1/extracted/GCJ_QR_A.C,"#include <iostream>
 #include <string.h>
 #include <fstream>
 #include <map>
 
 
 using namespace std;
 
 
 map<string, int>	map_Engines;
 string		a_Engines[128];
 int			i_Engines;
 int			i_Queries;
 
 int			i_SwitchCount;
 
 
 void Reset()
 {
 	map_Engines.clear();
 	for (int i = 0; i < 128; i++)
 	{
 		a_Engines[i] = αα;
 	}
 	i_Engines = 0;
 	i_Queries = 0;
 
 	i_SwitchCount = 0;
 
 }
 
 
 void FillEngineMap()
 {
 	for (int i = 0; i < i_Engines; i++)
 	{
 		map_Engines.insert(pair<string, int>(a_Engines[i], 1));
 	}
 }
 
 
 
 int main (int argc, char **argv)
 {
 	if (argc != 3)
 	{
 		cerr << αusage: α << argv[0] << α <input file> <output file>α << endl;
 		exit(-1);
 	}
 
 	ifstream input;
 	input.open(argv[1]);
 	ofstream output;
 	output.open(argv[2]);
 
 	int iCases;
 	char zLine[128];
 	input.getline(zLine, 128);
 	iCases = atoi(zLine);
 
 	for (int iCase = 1; iCase <= iCases; iCase++)
 	{
 		Reset();
 
 
 		input.getline(zLine, 128);
 		i_Engines = atoi(zLine);
 		for (int iEngine = 0; iEngine < i_Engines; iEngine++)
 		{
 			input.getline(zLine, 128);
 			a_Engines[iEngine] = zLine;
 			//cout << αEngine = α << zLine << endl;
 		}
 
 		FillEngineMap();
 
 		input.getline(zLine, 128);
 		i_Queries = atoi(zLine);
 		for (int iQuery = 0; iQuery < i_Queries; iQuery++)
 		{
 			input.getline(zLine, 128);
 			//cout << αQuery = α << zLine << endl;
 
 			map_Engines.erase(zLine);
 			if (map_Engines.empty())
 			{
 				i_SwitchCount++;
 				cout << αEngine α << zLine << α switched. # α << i_SwitchCount << endl;
 
 				FillEngineMap();
 				map_Engines.erase(zLine);
 			}
 		}
 
 		output << αCase #α << iCase << α: α << i_SwitchCount << endl;
 	}
 
 
 	input.close();
 	output.close();
 
 	exit(0);
 }"
33042,2008,32013,kandagatla,24480,1,main.c,gcj/2008/32013/kandagatla/24480/1/extracted/main.c,"#include <stdio.h>
 #include <stdlib.h>
 
 /*
  * readline.h
  *
  * Graham Watt
 */
 
 #include <stdlib.h>
 #include <stdio.h>
 typedef struct
 {
 	char se_name[101];
 	int hit;
 }se_t;
 typedef struct{
 	char query[101];
 }queries_t;
 se_t *ses;
 queries_t *queries;
 int no_of_ses;
 int no_of_queries;
 
 char* my_readline(FILE* f)
 {
 	char* line = (char*) calloc(0, sizeof(char) );;
 	char c;
 	int len = 0;
 	while ( (c = fgetc(f) ) != EOF && c != 'n')
 	{
 		line = (char*) realloc(line, sizeof(char) * (len + 2) );
 		line[len++] = c;
 		line[len] = '0';
 	}
 	return line;
 }
 int get_next_hit(queries_t *q, se_t se, int count)
 {
 	int i;
 	for(i=0;i<count;i++)
 	{
 		if(strcmp(se.se_name, q[i].query) ==0)
 			return i;
 	}
 	return count;
 	
 }
 void sort_se(se_t *se, int count, int flag)
 {
 	int hit, hit1;
 	int i,j;
 	int tmp_hit;
 	char tmp_se[101];
 	for(i=0;i<count;i++)
 	{	
 		for(j=i;j<count;j++)
 		{
 			hit=se[i].hit;
 			hit1=se[j].hit;
 			if((hit1>hit))
 			{
 				tmp_hit=hit;
 				strcpy(tmp_se, se[i].se_name);
 				se[i].hit=se[j].hit;
 				strcpy(se[i].se_name, se[j].se_name);
 
 				se[j].hit = hit;
 				strcpy(se[j].se_name, tmp_se);
 			}
 		}
 	}
 }
 int get_all_next_hits(se_t *se,queries_t *q)
 {
 	int i=0;
 	queries_t *que=q;
 	int qcount = no_of_queries;
 	int left= no_of_queries;
 	int finished=0;
 	int switches=0;
 	
 	while(left)
 	{
 		for(i=0;i<no_of_ses;i++)
 			se[i].hit=get_next_hit(que+(finished), se[i], left);
 
 		sort_se(se, no_of_ses,0);
 		finished += se[0].hit;
 		left = qcount-finished;
 		if(left>0)
 			switches++;
 	}
 	return switches;
 	
 
 }
 
 int main()
 {
 /* Sort the queries*/
 /* Sort the ses*/
 /* Get the count from se*/
 	/* get inputs */
 /*
  * Build avail matrix for both for trains from stn a and b
  *
  * get_trains_to_start_from_stn_a(char *time_table, int count)
  */
 	int count,i;
 	char out_put[105][20]={0};
 	int tmp;
 	int case_num=1;
 	char *line;
 
 	FILE *fd=stdin;
 //	fd = fopen(αfile.inα, αrα);
 //	if (fd == NULL) {
 //		printf(αunable to open file.innα);
 //	}
 	count= atoi(my_readline(fd));
 	while(count--)
 	{
 		no_of_ses= atoi(my_readline(fd));
 		tmp=no_of_ses;
 		ses= (se_t *)malloc(sizeof(se_t) * no_of_ses);
 		memset(ses, 0, sizeof(se_t)*no_of_ses);
 		i=0;
 		while(tmp--)
 		{
 		line= my_readline(fd);
 			memcpy(ses[i].se_name, line, strlen(line));
 			i++;				
 		}
 		no_of_queries= atoi(my_readline(fd));
 		tmp=no_of_queries;
 		queries= (queries_t *)malloc(sizeof(queries_t) * no_of_queries);
 		memset(queries, 0, sizeof(queries_t)*no_of_queries);
 		i=0;
 		while(tmp--)
 		{
 			line= my_readline(fd);
 			memcpy(queries[i].query, line, strlen(line));
 			i++;		
 		}
 		sprintf(out_put[case_num],αCase #%d: %d nα,case_num++, get_all_next_hits(ses,queries));
 		free(ses);
 		free(queries);
 
 	}
 	count=0;
 	while(case_num-->=0)
 	{
 		
 		printf(α%sα, out_put[count++]);
 	}
 //fclose(fd);	
 }"
33044,2008,32013,kandagatla,24481,1,main.c,gcj/2008/32013/kandagatla/24481/1/extracted/main.c,"#include <stdio.h>
 
 /*O/p*/
 int new_train_from_stn_a=0;
 int new_train_from_stn_b=0;
 /*Inputs*/
 int stn_a_time_table_count;
 int stn_b_time_table_count;
 int turn_around_time;
 
 typedef struct
 {
 	char dep_time[8];
 	char ari_time[8];
 }time_table_t;
 time_table_t *stn_b_time_table;
 time_table_t *stn_a_time_table;
 typedef struct
 {
 	int from_hr, to_hr;
 	int from_min, to_min;
 	int available;
 }train_available_matrix_t;
 train_available_matrix_t *avl_matrix_stn_a;
 train_available_matrix_t *avl_matrix_stn_b;
 void add_min_to_time(int *hr, int *min, int min_offset)
 {
 	*hr+=(*min+ min_offset)/60;
 	*min= (*min+ min_offset )% 60;
 }
 //09:00 12:00
 void time_to_int(int *hr, int *min, char *time)
 {
 	char tmp_hr[3];
 	char tmp_min[3];
 
 	tmp_hr[0]=time[0];
 	tmp_hr[1]=time[1];
 	tmp_hr[2]='0';
 
 	tmp_min[0]=time[3];
 	tmp_min[1]=time[4];
 	tmp_min[2]='0';
 
 	*hr=atoi(tmp_hr);
 	*min=atoi(tmp_min);
 }
 void dep_time_to_int(int *hr, int *min, char *time)
 {
 	time_to_int(hr, min, time);
 }
 void arival_time_to_int(int *hr, int *min, char *time)
 {
 	time_to_int(hr, min, time+6);
 }
 
 void build_train_availablity_matrix(time_table_t *time_table, train_available_matrix_t *matrix, int count)
 {
 	int hr, min, i;
 	
 	for(i=0;i<count;i++)
 	{		
 		time_to_int(&hr, &min, time_table[i].ari_time);
 		add_min_to_time(&hr, &min, turn_around_time);
 		matrix[i].from_hr=hr;
 		matrix[i].from_min=min;
 		matrix[i].available=1;
 		//printf(α%d, %d nα, matrix[i].from_hr, matrix[i].from_min);
 	}		
 
 //	printf(αn-----------nα);
 
 }
 int is_train_ready_to_go_from_stn(int req_hr, int req_min, int stn_a)
 {
 	int hr, min,i;
 
 	int count;
 	train_available_matrix_t *matrix;
 	if(stn_a){
 		count=stn_b_time_table_count; matrix=avl_matrix_stn_a;
 	}
 	else{ 
 		count=stn_a_time_table_count;matrix=avl_matrix_stn_b;
 	}
 
 	for(i=0;i<count;i++)
 	{
 		
 		hr=matrix[i].from_hr;
 		min=matrix[i].from_min;
 		if(matrix[i].available)
 		{
 			if((req_hr>hr) || (req_hr == hr && req_min>=min))
 			{
 				matrix[i].available=0;
 				goto available;
 			}
 		}
 		
 	}	
 	return 0;
 available:
 	return 1;
 }
 
 
 
 int get_trains_to_start_from_stn(time_table_t *time_table, int stn_a)
 {
 	int hr, min, i;
 	
 	int count;
 	if(stn_a)	
 		count = stn_a_time_table_count;	
 	else
 		count = stn_b_time_table_count;	
 	
 
 	for(i=0;i<count;i++)
 	{
 		
 		time_to_int(&hr, &min, time_table[i].dep_time);
 		if(!is_train_ready_to_go_from_stn(hr, min, stn_a))
 		{
 			if(stn_a)
 				new_train_from_stn_a++;
 			else
 				new_train_from_stn_b++;
 		}
 	}
 
 }
 void print_tt(time_table_t *time_table, int count)
 {
 	int i;
 	printf(α---------nα);
 	for(i=0;i<count;i++)
 		printf(α%s %snα, time_table[i].dep_time, time_table[i].ari_time);
 }
 void sort_am(train_available_matrix_t *matrix, int count)
 {
 	int hr, min, hr1, min1;
 	int i,j;
 	int tmp_hr, tmp_min;
 	for(i=0;i<count;i++)
 	{	
 		for(j=i;j<count;j++)
 		{
 			hr=matrix[i].from_hr;
 			min=matrix[i].from_min;
 			hr1=matrix[j].from_hr;
 			min1=matrix[j].from_min;
 
 			if((hr1<hr) ||( hr1==hr && min1<min))
 			{
 				tmp_hr=hr;
 				tmp_min=min;
 				matrix[i].from_hr=matrix[j].from_hr;
 				matrix[i].from_min=matrix[j].from_min;
 
 				matrix[j].from_hr=tmp_hr;
 				matrix[j].from_min=tmp_min;
 
 
 			}
 			//if(time_table[i].dep_time)
 		}
 	}
 }
 void sort_tt(time_table_t *time_table, int count, int type)
 {
 	int hr, min, hr1, min1;
 	int i,j;
 	char tmp_time[8+1];
 	for(i=0;i<count;i++)
 	{	
 		for(j=i;j<count;j++)
 		{
 			if(type)
 			{
 				time_to_int(&hr, &min, time_table[i].ari_time);
 				time_to_int(&hr1, &min1, time_table[j].ari_time);
 			}
 			else
 			{
 				time_to_int(&hr, &min, time_table[i].dep_time);
 				time_to_int(&hr1, &min1, time_table[j].dep_time);
 			}
 
 			if((hr1<hr) ||( hr1==hr && min1<min))
 			{
 				memcpy(tmp_time, time_table[i].dep_time,8);
 //				printf(αtmp time is %s nα, tmp_time);
 				memcpy(time_table[i].dep_time, time_table[j].dep_time,8);
 				memcpy(time_table[j].dep_time, tmp_time,8);
 
 				memset(tmp_time, 0, 8);	
 				memcpy(tmp_time, time_table[i].ari_time,8);
 				memcpy(time_table[i].ari_time, time_table[j].ari_time,8);
 				memcpy(time_table[j].ari_time, tmp_time,8);
 
 
 			}
 			//if(time_table[i].dep_time)
 		}
 	}
 }
 #define TIME_TABLE_ENTRY_SIZE	11
 int main()
 {
 	/* get inputs */
 /*
  * Build avail matrix for both for trains from stn a and b
  *
  * get_trains_to_start_from_stn_a(char *time_table, int count)
  */
 	int count,i;
 	char out_put[105][20]={0};
 	int tmp;
 	int case_num=1;
 	scanf(α%dα,&count);
 	while(count--)
 	{
 		scanf(α%dα,&turn_around_time);
 		scanf(α%d %dα,&stn_a_time_table_count, &stn_b_time_table_count);
 		tmp=stn_a_time_table_count;
 
 		stn_a_time_table= (time_table_t *)malloc(sizeof(time_table_t) * stn_a_time_table_count);
 		memset(stn_a_time_table, 0, sizeof(time_table_t)*stn_a_time_table_count);
 		i=0;
 		while(tmp--)
 		{
 			scanf(α%sα,stn_a_time_table[i].dep_time);
 
 
 			scanf(α%sα,stn_a_time_table[i].ari_time);
 			i++;				
 		}
 
 		//print_tt(stn_a_time_table, stn_a_time_table_count);
 		sort_tt(stn_a_time_table, stn_a_time_table_count, 0);
 //		print_tt(stn_a_time_table, stn_a_time_table_count);
 		tmp=stn_b_time_table_count;
 		stn_b_time_table= (time_table_t *)malloc(sizeof(time_table_t) * stn_b_time_table_count);
 		memset(stn_b_time_table, 0, sizeof(time_table_t)*stn_b_time_table_count);
 		i=0;
 		while(tmp--)
 		{
 			scanf(α%sα,stn_b_time_table[i].dep_time);
 			scanf(α%sα,stn_b_time_table[i].ari_time);
 			i++;		
 		}
 		sort_tt(stn_b_time_table, stn_b_time_table_count,0);
 //		print_tt(stn_b_time_table, stn_b_time_table_count);
 
 		avl_matrix_stn_a=(train_available_matrix_t *)malloc(sizeof(train_available_matrix_t)*stn_b_time_table_count);
 		avl_matrix_stn_b=(train_available_matrix_t *)malloc(sizeof(train_available_matrix_t)*stn_a_time_table_count);
 		memset(avl_matrix_stn_a, 0, sizeof(train_available_matrix_t)*stn_b_time_table_count);
 		memset(avl_matrix_stn_b, 0, sizeof(train_available_matrix_t)*stn_a_time_table_count);
 
 		build_train_availablity_matrix(stn_b_time_table, avl_matrix_stn_a, stn_b_time_table_count);
 		build_train_availablity_matrix(stn_a_time_table, avl_matrix_stn_b, stn_a_time_table_count);
 		sort_am(avl_matrix_stn_a, stn_b_time_table_count);
 		sort_am(avl_matrix_stn_b, stn_a_time_table_count);
 
 		get_trains_to_start_from_stn(stn_a_time_table,1);
 		get_trains_to_start_from_stn(stn_b_time_table,0);
 
 
 		sprintf(out_put[case_num],αCase #%d: %d %dnα,case_num++, new_train_from_stn_a, new_train_from_stn_b);
 
 		free(stn_a_time_table);
 		free(stn_b_time_table);
 		free(avl_matrix_stn_b);
 		free(avl_matrix_stn_a);
 		new_train_from_stn_b=new_train_from_stn_a=0;
 
 	}
 	count=0;
 	while(case_num-->=0)
 	{
 		
 		printf(α%sα, out_put[count++]);
 	}
 	
 }"
33106,2008,32013,aledm,24480,1,saving.c,gcj/2008/32013/aledm/24480/1/extracted/saving.c,"// google code jam: saving the universe
 // aled morris
 // 17 July 2008
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 unsigned S, Q;
 char *engines[100];	// given: max S is 100
 
 // find the longest run which doesn't require a switch
 unsigned
 howmany(char *searches)
 {
 	char *maxs = searches;
 	unsigned t;
 
 	for (t = 0; t < S; t++) {
 		char *s = searches;
 		while (*s != -1 && *s != t)
 			s++;
 		if (s >= maxs)
 			maxs = s;
 	}
 	if (*maxs == -1)
 		return 0;
 	return 1 + howmany(maxs);
 }
 
 main()
 {
 	char buf[120];			// given: max input line len 100
 	unsigned N, i;
 
 	fgets(buf, sizeof buf, stdin);
 	N = atoi(buf);
 
 	for (i=1; i<=N; i++) {
 		unsigned j;
 		char search[1001];	// given: max Q is 1000 + terminator
 
 		fgets(buf, sizeof buf, stdin);
 		S = atoi(buf);
 
 		for (j = 0; j < S; j++) {
 			// the terminating newline will be retained but it doesn't
 			// change the operation of the program as it will be consistently
 			// retained for all input lines
 			fgets(buf, sizeof buf, stdin);
 			engines[j] = strdup(buf);
 		}
 
 		fgets(buf, sizeof buf, stdin);
 		Q = atoi(buf);
 
 		// read in the queries encoding them as indexes into the table of search engine names
 		for (j = 0; j < Q; j++) {
 			unsigned k;
 			fgets(buf, sizeof buf, stdin);
 			for (k = 0; k < S; k++) {
 				if (strcmp(buf, engines[k]) == 0) {
 					search[j] = k;
 					break;
 				}
 			}
 		}
 		// our own terminator used to stop searches
 		search[j] = -1;
 
 		printf(αCase #%u: %unα, i, howmany(search));
 	}
 }
 
 //end"
33108,2008,32013,aledm,24481,1,train.c,gcj/2008/32013/aledm/24481/1/extracted/train.c,"// google code jam: train timetable
 // aled morris
 // 17 July 2008
 
 #include <stdio.h>
 #include <string.h>
 
 main()
 {
 	unsigned N, i;
 
 	scanf(α%unα, &N);
 
 	for (i=1; i<=N; i++) {
 		unsigned T, NA, NB, j;
 		char needa, needb;
 		char atrains[24*60];	// how many trains available at any given minute
 		char btrains[24*60];
 
 		bzero(atrains, sizeof atrains);
 		bzero(btrains, sizeof btrains);
 
 		scanf(α%unα, &T);
 		scanf(α%u %unα, &NA, &NB);
 
 		// first, journeys from A to B
 		for (j = 0; j < NA; j++) {
 			unsigned hhd,mmd, hha,mma, l;
 			scanf(α%u:%u %u:%unα, &hhd,&mmd, &hha,&mma);
 			for (l = hhd * 60 + mmd; l < (24*60); l++)
 				atrains[l]--;
 			for (l = hha * 60 + mma + T; l < (24*60); l++)
 				btrains[l]++;
 		}
 
 		// second, journeys from B to A
 		for (j = 0; j < NB; j++) {
 			unsigned hhd,mmd, hha,mma, l;
 			scanf(α%u:%u %u:%unα, &hhd,&mmd, &hha,&mma);
 			for (l = hhd * 60 + mmd; l < (24*60); l++)
 				btrains[l]--;
 			for (l = hha * 60 + mma + T; l < (24*60); l++)
 				atrains[l]++;
 		}
 
 		// now look for the αpeakα demand
 		for (j = 0, needa = 0; j < (24*60); j++)
 			if (atrains[j] < needa)
 				needa = atrains[j];
 		for (j = 0, needb = 0; j < (24*60); j++)
 			if (btrains[j] < needb)
 				needb = btrains[j];
 
 		printf(αCase #%u: %d %dnα, i, abs(needa), abs(needb));
 	}
 }
 
 //end"
33113,2008,32013,Cgeek,24480,1,universe.c,gcj/2008/32013/Cgeek/24480/1/extracted/universe.c,"#include<stdio.h>
 #include<conio.h>
 #include<string.h>
 #define SIZE 1000
 int main()
 {  
    int testcase,output[SIZE]; 
    char server[SIZE][SIZE];
    char query[SIZE][SIZE];
    FILE *fp;
    fp=fopen(αoutput.txtα,αwα);
    int server_size,query_size,index,i,j,no_switch,m,k,max,l;
    int a[SIZE];
    scanf(α%dα,&testcase);
    fflush(stdin);
    for(l=0;l<testcase;l++)
    {
     scanf(α%dα,&server_size);
     fflush(stdin);
     for(m=0;m<server_size;m++)
     {
      gets(server[m]);
                        //       fflush(stdin);
     }                          
     scanf(α%dα,&query_size);
     fflush(stdin);
     for(m=0;m<query_size;m++)
     gets(query[m]);
     j=0;
     
     no_switch=-1;
     while(j<query_size)
     {
       for(i=0;i<server_size;i++)
       {
          index=i;
          for(k=j;k<query_size;k++)
          {
             if(strcmp(server[index],query[k])==0)
             {
                   printf(αIndex for %s=%dnα,server[index],k);
                   break;
             }      
          }
 
          a[index]=k;
       }
       max=a[0];
       for(m=1;m<server_size;m++)
       {
          if(max < a[m])
             max=a[m];
       }
       printf(αmax=%dnα,max);  
       j=max;
       no_switch++;
     }                    
     if(no_switch == -1)
        no_switch=0;             
     output[l]=no_switch;
   }
   for(k=0;k<testcase;k++)
   {
   fprintf(fp,αCase #%d: %dnα,k+1,output[k]);
   }
   fclose(fp);
   getch();                          
 }"
33115,2008,32013,Cgeek,24481,1,train.c,gcj/2008/32013/Cgeek/24481/1/extracted/train.c,"#include<stdio.h>
 #include<conio.h>
 #define MAX 400
 #define MAXSIZE 60
 char arrival_time[MAX][MAXSIZE]={0};
 char departure_time[MAX][MAXSIZE]={0};
 int arrival[MAX]={0};
 int departure[MAX]={0};
 int tt;
 int NA, NB;
 int da[MAX]={0},db[MAX]={0},aa[MAX]={0},ab[MAX]={0};
 int noa=0,nob=0;
 
 
 void sort(int a[],int n)
 {
       int i=0,j=0,temp=0;
       for(i=0;i<n;i++)
       {
        for(j=i+1;j<n;j++)
            {
                if(a[i]>a[j])
                 {
                 temp=a[i];
                 a[i]=a[j];
                 a[j]=temp;               
                 }
           }    
        }
 }
 void TrainforA()
 {
      int i=0;
      int j=0;
      while(i<NA)
      {
                // da & ab
                while(j<NB){
                      if(ab[j]<=da[i])
                           {
                                     ab[j]=4000;
                                     noa--;
                                     break;
                           }
                           j++;
                }
               i++;
               j=0;
      }
 }
 
 void TrainforB()
 {
      int i=0;
      int j=0;
      while(i<NB)
      {
                // da & ab
                while(j<NA){
                      if(db[i]>=aa[j])
                           {
                                     aa[j]=4000;
                                     nob--;
                                     break;
                           }
                           j++;
                }
               i++;
               j=0;
      }
 }
 convert_min(int i)
 {
    int j=0,temp=0,h[2]={0},m[2]={0},k=0,rem=0;
    char c[2];
    while( departure_time[i][j]!=':')
    {
           c[j]=departure_time[i][j];
           h[j]=c[j]-48;
           j++;
    }
    temp=j;
    j++;       
    while(departure_time[i][j]!='0')
    {
           c[k]=departure_time[i][j];
           m[k]=c[k]-48;
           j++;
           k++;
    }
    rem=m[0]*10+m[1];
    j=temp;
    if(j==2)
             departure[i]=(h[0]*10 +h[1])*60 + rem ;
    else if(j==1)
            departure[i]=h[0]*60 + rem ;
     else
             departure[i]=0 + rem ;
 
 j=0;
 temp=0;
 k=0;
 rem=0;
 //arrival            
    while( arrival_time[i][j]!=':')
    {
           c[j]=arrival_time[i][j];
           h[j]=c[j]-48;
           j++;
    }
    temp=j;
    j++;       
    while(arrival_time[i][j]!='0')
    {
           c[k]=arrival_time[i][j];
           m[k]=c[k]-48;
           j++;
           k++;
    }
    rem=m[0]*10+m[1];
    j=temp;
    if(j==2)
             arrival[i]=(h[0]*10 +h[1])*60 + rem +tt;
    else if(j==1)
            arrival[i]=h[0]*60 + rem + tt ;
     else
             arrival[i]=0 + rem + tt;           
    printf(αdeparture %d arrival %d α,departure[i],arrival[i]);
 }
 
 int main()
 {
  int i,j;
  int testcase=1;                                                                     
  int total,k=0;
  int ln=1;
  FILE *fp;
   fp=fopen(αoutput.txtα,αwα);
  scanf(α%dα,&testcase);
  while(testcase>0)
  {
   tt=0; NA=0; NB=0;k=0;
    printf(αturn arount time nα);                    
     scanf(α%dα,&tt);
     printf(αn NA α);
     scanf(α%dα,&NA);
     printf(αnNB α);
     scanf(α%d α,&NB);
     noa=NA;
     nob=NB;
     total=NA+NB;
               for(i=0;i<total;i++)
               {
                 scanf(α%sα,departure_time[i]);
                 scanf(α%sα,arrival_time[i]);
                 convert_min(i);
                 }
                 printf(αnα);
                 for(i=0;i<total;i++)
                 {
                 printf(α%s tα,departure_time[i]);
                 printf(α%s nα,arrival_time[i]);
                 }
                 k=0;
                 j=0;
               //  for(i=0;i<NA;i++)
                 //                 printf(α%d  t α, arrival[i]);
                 for(i=0;i<total;i++)
                 {
                    if(j<NA)
                    {                   
                               da[j]=departure[i];
                                aa[j]=arrival[i];
                                j++;
                                 }
                                 else if (k<NB)
                                 {
                                  db[k]=departure[i];
                                   ab[k]=arrival[i];
                                     k++;    
                                     }
                 }
      printf(αn departure %d t arrival %d nα,departure[i],arrival[i]);
      
      sort(da,NA);
      sort(db,NB);
     sort(aa,NA);
      sort(ab,NB);
      i=0;
       for(i=0;i<NB;i++)
                    printf(α%d  t α,db[i]);
     
      TrainforA();
      TrainforB();
      //fp=fopen(αnew.txtα,αaα);
      fprintf(fp,αCase #%d: %d %dnα,ln,noa,nob);
      //printf(α noa =%d , nob=%dα,noa,nob);                    
      testcase--;
      ln++;
   }
   fclose(fp); 
   getch();
 }"
33185,2008,32013,lucastdcj,24480,1,Saving The Universe.c,gcj/2008/32013/lucastdcj/24480/1/extracted/Saving The Universe.c,"#include <stdio.h>
 #include <string.h>
 
 #define TAM 111
 #define INF 0x7f7f7f7f
 
 int n,m;
 char nome[TAM][TAM];
 
 int Busca(char *nome);
 
 int main(){
     int i,j;
     int aux;
     int maior,trocas;   
     int teste,nteste;
     int dist[TAM],Lista[10*TAM];
     char auxnome[TAM];    
     scanf(α%dα,&nteste);
     for(teste=1;teste<=nteste;teste++){                                  
         scanf(α%dα,&n);getchar();        
         for(i=0;i<n;i++) gets(nome[i]);                
         scanf(α%dα,&m);getchar();
         for(i=0;i<m;i++){
             gets(auxnome);           
             Lista[i]=Busca(auxnome);
         }
         trocas=0;
         maior=0;
         for(i=0;i<m && maior!=INF;i++){
            maior=0;
            for(j=0;j<n;j++) dist[j]=INF;
            for(j=i;j<m;j++)
              if(dist[Lista[j]]==INF)
                 dist[Lista[j]]=j-i;             
            for(j=0;j<n;j++)
              if(dist[j]>maior){
                 maior=dist[j];
                 aux=j;
              } 
            if(maior!=INF){
               trocas++;   
               while(Lista[i]!=aux) i++;
               i--;
            }
         }
         printf(αCase #%d: %dnα,teste,trocas);
     }
     return 0;
 }
 
 int Busca(char *auxnome){
     int i;
     for(i=0;i<n;i++)
       if(!strcmp(nome[i],auxnome))
          return i;
 }"
33189,2008,32013,sinomaen,24480,1,a.C,gcj/2008/32013/sinomaen/24480/1/extracted/a.C,"#include <stdio.h>
 #include <string.h>
 
 int sw[1002][102];
 int n,s,q;
 char b[5000];
 char ss[102][105];
 
 int min(int a, int b) { return a<b?a:b; }
 
 int main() {
 	int i,j,k,mi,fk,pfk;
 	gets(b);
 	sscanf(b,α%dα,&n);
 	for (i=0; i<n; ++i) {
 		gets(b);
 		sscanf(b,α%dα,&s);
 		for (j=0; j<s; ++j) {
 			gets(ss[j]);
 			sw[0][j]=0;
 		}
 		gets(b);
 		sscanf(b,α%dα,&q);
 		pfk=-1;
 		for (j=0; j<q; ++j) {
 			gets(b);
 			mi=0x7ffffff0;
 			for (k=0; k<s; ++k) {
 				if (!strcmp(b,ss[k])) {
 					sw[j+1][k]=-1;
 					fk=k;
 				} else {
 					sw[j+1][k]=sw[j][k];
 				}
 				if (sw[j][k]!=-1) {
 					mi=min(mi,sw[j][k]);
 				}
 			}
 			if (pfk>=0) sw[j+1][pfk]=mi+1;
 			pfk=fk;
 //			for (k=0; k<s; ++k) printf(α%d α,sw[j+1][k]);
 //			printf(αnα);
 		}
 		mi=0x7fffffff;
 		for (j=0; j<s; ++j) if (sw[q][j]!=-1) mi=min(mi,sw[q][j]);
 		printf(αCase #%d: %dnα,i+1,mi);
 	}
 	return 0;
 }"
33191,2008,32013,sinomaen,24479,1,c.C,gcj/2008/32013/sinomaen/24479/1/extracted/c.C,"#include <stdio.h>
 #include <math.h>
 const double PI=2*acos(0);
 
 int main() {
 	double f,R,r,t,g,res;
 	int i,n;
 	scanf(α%dα,&n);
 	for (i=0; i<n; ++i) {
 		scanf(α%lf %lf %lf %lf %lfα,&f,&R,&t,&r,&g);
 		if (2*f>=g || R-t-f<0) res=1.0;
 		else {
 			double l,u,ar=0;
 			for (l=r; l<R-t; l+=g+2*r) for (u=r; u*u+l*l<(R-t)*(R-t); u+=g+2*r) {
 				double rt=(R-t-f)*(R-t-f);
 					double l2=l+f,r2=l+g-f,b2=u+f,u2=u+g-f;
 					double lx,rx,ux,ar2=0;
 					if (r2*r2+u2*u2<=rt) { ar+=pow(g-2*f,2); continue; }
 					else if (l2*l2+b2*b2>=rt) continue;
 					if (l2*l2+u2*u2<rt) {
 						lx=sqrt(rt-u2*u2);
 						if (lx>l2) ar2+=(lx-l2)*(u2-b2);
 						// upper cut
 					} else {
 						lx=l2;
 						// left cut
 					}
 					if (r2*r2+b2*b2<rt) {
 						ux=sqrt(rt-r2*r2);
 						if (ux>b2) ar2+=(r2-lx)*(ux-b2);
 						rx=r2;
 						// right cut
 					} else {
 						ux=b2;
 						rx=sqrt(rt-b2*b2);
 						// bottom cut
 					}
 					//printf(αar2 vs. pow(g-2*f): %.6lf %.6lf; rx=%.6lf, sqrt(rt)=%.6lfnα,ar2,pow(g-2*f,2),rx,sqrt(rt));
 					double asinrx=(rx*rx>=rt ? 1.0 : rx/sqrt(rt)),sqrx=(rx*rx>=rt ? 0.0 : rt-rx*rx);
 					double asinlx=(lx*lx>=rt ? 1.0 : lx/sqrt(rt)),sqlx=(lx*lx>=rt ? 0.0 : rt-lx*lx);
 					double cr=rt/2*asin(asinrx)+rx/2*sqrt(sqrx) - (rt/2*asin(asinlx)+lx/2*sqrt(sqlx));
 					double st=ux*(rx-lx);
 					ar2+=cr-st;
 					//printf(αar2 vs. pow(g-2*f): %.6lf %.6lfnα,ar2,pow(g-2*f,2));
 					ar+=ar2;
 			}
 			res=1-4*ar/(PI*R*R);
 			if (res<0) res=0;
 		}
 		printf(αCase #%d: %.6lfnα,i+1,res);
 	}
 	return 0;
 }"
33193,2008,32013,sinomaen,24481,1,b.C,gcj/2008/32013/sinomaen/24481/1/extracted/b.C,"#include <stdio.h>
 #include <algorithm>
 using namespace std;
 
 struct A {
 	int d,a;
 	int valid;
 	bool operator<(const A& c) const { return d<c.d || (d==c.d && a<c.a); }
 } ab[110],ba[110];
 char b[1000];
 const int BAD=100000;
 int nca,ncb,na,nb,t;
 
 int ffirst() {
 	int i,mi=-1;
 	for (i=0; i<na; ++i) if (ab[i].valid) { mi=i; break; }
 	for (i=0; i<nb; ++i) if (ba[i].valid) break;
 	if (mi==-1 && i==nb) return BAD;
 	if (mi==-1) return -i-1;
 	if (i==nb || ab[mi]<ba[i]) return mi;
 	return -i-1;
 }
 int fnext(A* aa, int n, int d) {
 	int i;
 	for (i=0; i<n; ++i) if (aa[i].valid && aa[i].d>=d) return i;
 	return BAD;
 }
 void simul(int a) {
 	if (a<0) ++ncb;
 	else ++nca;
 	while (a!=BAD) {
 //		printf(α%c%d α,a<0?'b':'a',a<0?-a-1:a);
 		if (a<0) {
 			ba[-a-1].valid=0;
 			a=fnext(ab,na,ba[-a-1].a+t);
 		} else {
 			ab[a].valid=0;
 			a=fnext(ba,nb,ab[a].a+t);
 			if (a!=BAD) a=-a-1;
 		}
 	}
 //	printf(αnα);
 }
 
 int main() {
 	int i,j,n,h1,h2,m1,m2;
 	gets(b);
 	sscanf(b,α%dα,&n);
 	for (i=0; i<n; ++i) {
 		gets(b);
 		sscanf(b,α%dα,&t);
 		gets(b);
 		sscanf(b,α%d %dα,&na,&nb);
 		for (j=0; j<na; ++j) {
 			gets(b);
 			sscanf(b,α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
 			ab[j].d=60*h1+m1;
 			ab[j].a=60*h2+m2;
 			ab[j].valid=1;
 		}
 		for (j=0; j<nb; ++j) {
 			gets(b);
 			sscanf(b,α%d:%d %d:%dα,&h1,&m1,&h2,&m2);
 			ba[j].d=60*h1+m1;
 			ba[j].a=60*h2+m2;
 			ba[j].valid=1;
 		}
 		sort(ab,ab+na);
 		sort(ba,ba+nb);
 //		for (j=0; j<na; ++j) printf(α%d-%d α,ab[j].d,ab[j].a);
 //		printf(αnα);
 //		for (j=0; j<nb; ++j) printf(α%d-%d α,ba[j].d,ba[j].a);
 //		printf(αnα);
 		nca=ncb=0;
 		while ((j=ffirst())!=BAD) {
 			simul(j);
 		}
 		printf(αCase #%d: %d %dnα,i+1,nca,ncb);
 	}
 	return 0;
 }"
33265,2008,32013,coucou747,24480,1,test.c,gcj/2008/32013/coucou747/24480/1/extracted/test.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define SIZE_ENGINE 100
 struct liste{
 	int size;
 	char content[1000][SIZE_ENGINE];
 };
 struct cas{
 	struct liste moteurs;
 	struct liste requetes;
 };
 
 void remplireliste(struct liste *l, FILE *f){
 	int i, j;
 	for (i=0;i<l->size;i++){
 		j=-1;
 		do{
 			l->content[i][++j]=fgetc(f);
 		} while (l->content[i][j] != 'n');
 		l->content[i][j]=0;
 		//printf(αtt-%snα, l->content[i]);
 	}
 }
 void getCas(struct cas *c, FILE *f){
 	fscanf(f, α%dnα, &(c->moteurs.size));
 	//printf(αt%d moteursnα, c->moteurs.size);
 	remplireliste(&(c->moteurs), f);
 	fscanf(f, α%dnα, &(c->requetes.size));
 	//printf(αt%d requetesnα, c->requetes.size);
 	remplireliste(&(c->requetes), f);
 }
 
 int compare(char * a, char * b){
 	if (*a == 0) return *b == 0;
 	if (*b == 0) return *a == 0;
 	if (*a == *b) return compare(a+1, b+1);
 	return 0;
 }
 
 int getSol(struct cas *c, int start){
 	int m;
 	int i;
 	int max = 0;
 	int b;
 	for (m=0;m<c->moteurs.size;m++){
 		b = 0;
 		for (i=start; i<c->requetes.size;i++){
 			if (compare(c->requetes.content[i],
 				c->moteurs.content[m])){
 				b = 1;
 				break;
 			}
 		}
 		if (i>max){
 			if (!b) return 0;
 			max = i;
 		}
 	}
 	if (max){
 		//printf(αchangement %d nα, max);
 		return 1 + getSol(c, max);
 	}else{
 		return 0;
 	}
 }
 
 void solveCas(struct cas *c, int testCaseNumber){
 	int sol = getSol(c, 0);
 	printf(αCase #%d: %dnα, testCaseNumber, sol);
 }
 int main(int argc, char ** argv){
 	FILE *f = stdin;
 	int nbrCas;
 	int i;
 	struct cas c;
 	fscanf(f, α%dnα, &nbrCas);
 	//printf(α%d casnα, nbrCas);
 	for (i=0;i<nbrCas;i++){
 		getCas(&c, f);
 		solveCas(&c, i+1);
 	}
 	return 0;
 }"
33267,2008,32013,coucou747,24481,1,test.c,gcj/2008/32013/coucou747/24481/1/extracted/test.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct train{
 	int td; // depart
 	int ta; // arrivee
 
 	int da, aa; // depart et arrivee en a
 	int db, ab; // depart et arrivee en b
 };
 
 struct cas{
 	int temps_demi_tour;
 	int nbA, nbB, nbT;
 	struct train trains[200];
 };
 int gettime(int h, int m){
 	return h * 60 + m;
 }
 void getCas(struct cas *c, FILE *f){
 	int i;
 	int hd, md;
 	int ha, ma;
 	fscanf(f, α%dnα, &(c->temps_demi_tour));
 	fscanf(f, α%dnα, &(c->nbA));
 	fscanf(f, α%dnα, &(c->nbB));
 	c->nbT=c->nbA+c->nbB;
 	//printf(αNA:%d, NB:%d, t:%dnα, c->nbA, c->nbB, c->temps_demi_tour);
 	for (i=0;i<c->nbA;i++){
 		fscanf(f, α%d:%d %d:%dnα, &hd, &md, &ha, &ma);
 		c->trains[i].td=gettime(hd, md);
 		c->trains[i].ta=gettime(ha, ma) + c->temps_demi_tour;
 		c->trains[i].da = -1; c->trains[i].aa = 0;
 		c->trains[i].db = 0;  c->trains[i].ab = 1;
 	}
 	for (i=c->nbA;i<c->nbT;i++){
 		fscanf(f, α%d:%d %d:%dnα, &hd, &md, &ha, &ma);
 		c->trains[i].td=gettime(hd, md);
 		c->trains[i].ta=gettime(ha, ma) + c->temps_demi_tour;
 		c->trains[i].da = 0;  c->trains[i].aa = 1;
 		c->trains[i].db = -1; c->trains[i].ab = 0;
 	}
 	for (i=0;i<c->nbT;i++){
 	//	printf(αt%d, %dnα, c->trains[i].ta, c->trains[i].tb);
 	}
 }
 
 void solveCas(struct cas *c, int testCaseNumber){
 	int minute = 0;
 	int t;
 	int na=0, nb=0;
 	int mina=0, minb=0;
 	for (;minute < 60 * 24; minute++){
 		for (t=0;t<c->nbT;t++){
 			if (c->trains[t].td == minute){
 				na += c->trains[t].da;
 				nb += c->trains[t].db;
 			}else if (c->trains[t].ta == minute){
 				nb += c->trains[t].ab;
 				na += c->trains[t].aa;
 			}
 		}
 		if (na<mina){ mina = na; }
 		if (nb<minb){ minb = nb; }
 	}
 	printf(αCase #%d: %d %dnα, testCaseNumber, -mina, -minb);
 }
 int main(int argc, char ** argv){
 	FILE *f = stdin;
 	int nbrCas;
 	int i;
 	struct cas c;
 	fscanf(f, α%dnα, &nbrCas);
 	//printf(α%d casnα, nbrCas);
 	for (i=0;i<nbrCas;i++){
 		getCas(&c, f);
 		solveCas(&c, i+1);
 	}
 	return 0;
 }"
33342,2008,32013,Gaius,24481,1,train.c,gcj/2008/32013/Gaius/24481/1/extracted/train.c,"#include <stdio.h>
     #include <stdlib.h>
 
     typedef struct {
     int hours;
     int min;
     }time;
     typedef struct {
     int start;
     time stime;
     time dtime;
     }trip;
     typedef struct t{
     int curStn,curDst;
     time arrtime;
     time deptime;
     int origStn;
     struct t*nxt;
     }train;
 
     int tempturnTime=0,ntrips=0,na=0,nb=0,cases=0,a=0,b=0;
     time turnTime;
     train *trains=NULL;
     trip *trips=NULL;
 
     void converToTime(char *tme,time *j){
     char t1[2]=α00α,t2[2]=α00α;
     int i=0;
 
     t1[0]=tme[0];
     t1[1]=tme[1];
     t2[0]=tme[3];
     t2[1]=tme[4];
 
     j->hours=atoi(t1);
     j->min=atoi(t2)%60;
 
     }
     void copyTrip(trip *a,trip *b){
     a->dtime.hours=b->dtime.hours;
     a->dtime.min=b->dtime.min;
     a->stime.hours=b->stime.hours;
     a->stime.min=b->stime.min;
     a->start=b->start;
     }
     void swap(trip *a, trip *b){
     trip temp;
     copyTrip(&temp,a);
     copyTrip(a,b);
     copyTrip(b,&temp);
     }
     void diffTime(time t1, time t2, time*t2dt1){
     int tm1,tm2;
     tm1=t1.hours*60+t1.min;
     tm2=t2.hours*60+t2.min;
     t2dt1->hours=(tm2-tm1)/60;
     t2dt1->min=(tm2-tm1)%60;
     }
 
     int isValidTime(time t){
     return((t.hours>=0&&t.hours<24)&&(t.min>=0&&t.min<60));
     }
     int isEqualTime(time t1,time t2){
     return ((t1.hours==t2.hours)&&(t2.hours==t2.hours));
     }
     int isGreaterTime(time t1,time t2){
     int tm1,tm2;
     tm1=t1.hours*60+t1.min;
     tm2=t2.hours*60+t2.min;
     return tm1>tm2;
     }
     int isLessTime(time t1, time t2){
     int tm1,tm2;
     tm1=t1.hours*60+t1.min;
     tm2=t2.hours*60+t2.min;
     return tm1<tm2;
     }
 
     void sort(int start,int end){
     int i=0,j=0;
     if(!(start<end))return;
     for(i=start;i<end;i++)
         for(j=start+1;j<end;j++){
             if (isLessTime(trips[j].stime,trips[j-1].stime)){
                 swap(&trips[j],&trips[j-1]);
                 }
             }
      for(i=start;i<end;i++){
         printf(αn%d:%d  %d:%d from %cα,trips[i].stime.hours,trips[i].stime.min,trips[i].dtime.hours,trips[i].dtime.min,trips[i].start?'b':'a');
      }
     }
 //0 == stA 1 == stB
     void updateTrains(trip curTrip){
     int flag =0;
     train *temp=NULL;
 
     time dtime;
     dtime.hours=dtime.min=0;
 
     if(trains){
         temp=trains;
         while(temp)
             {
             if(temp->curStn==curTrip.start && !isLessTime(curTrip.stime,temp->arrtime))
                 {
                 diffTime(temp->arrtime,curTrip.stime,&dtime);
                 if(!isValidTime(dtime))printf(αnInvalid time foundα);
                 if(!isLessTime(dtime,turnTime))
                     {
                     if(temp->curStn)printf(αnb to aα);
                     else printf(αna to bα);
                     temp->curDst=curTrip.start;
                     temp->curStn=!(temp->curDst);
                     temp->arrtime=curTrip.dtime;
                     temp->deptime=curTrip.stime;
                     flag=1;
                     break;
                     }
                 }
             temp=temp->nxt;
             }
         }
     if (flag==0){
         temp=(train *)malloc(sizeof(train));
         temp->arrtime=curTrip.dtime;
         temp->deptime=curTrip.stime;
         temp->origStn=curTrip.start;
         temp->curDst=curTrip.start;
         temp->curStn=!(temp->curDst);
         temp->nxt=NULL;
         if(temp->origStn){
             printf(αnbα);
             b++;
             }
         else{
             printf(αnaα);
             a++;
             }
         if(trains){
             temp->nxt = trains;
             trains=temp;
             }
         else trains=temp;
         }
     }
 
 
     void calcTrains(){
     int i=0;
     train *newTrain = NULL;
 
 
     for (i=0;i<ntrips;i++){
         if(i==0){
             newTrain=(train *)malloc(sizeof(train));
             newTrain->arrtime=trips[i].dtime;
             newTrain->deptime=trips[i].stime;
             newTrain->origStn=trips[i].start;
             newTrain->curDst=trips[i].start;
             newTrain->curStn=!(newTrain->curDst);
             newTrain->nxt=NULL;
             if(newTrain->origStn == 0){
                 printf(αnaα);
                 a++;
                 }
             else 
                 {
                 printf(αnbα);
                 b++;
                 }
             trains=newTrain;
             }
         else updateTrains(trips[i]);
         }
 
     }
 
 
     void readinput(char *filename){
     int i=0,j=0,QuitCase=0;
     char t1[6],t2[6];
 
     FILE *fp = fopen(filename,αrα);
     FILE *fp1 = fopen(αout.txtα,αwα);
 
     fscanf(fp,α%dα,&cases);
     printf(αn%dα,cases);
     while(i++<cases && !feof(fp)){
         j=0;a=0;b=0;
         fscanf(fp,α%dn%d%dα,&tempturnTime,&na,&nb);
         ntrips=na+nb;
         turnTime.hours = tempturnTime/60;
         turnTime.min = tempturnTime%60;
         if(!isValidTime(turnTime))printf(αnInvalid turnaround time foundα);
         printf(αn%dn%d%dα,ntrips,na,nb);
         if(na == 0 || nb == 0){
             fprintf(fp1,αCase #%d: %d %dnα,i,na,nb);fflush(fp1);
             }
         else{
             trips = (trip *)malloc(ntrips*sizeof(trip));
             memset(trips,0,ntrips*sizeof(trip));
             while(j<ntrips){
                 if(j<na)
                     trips[j].start=0;
                 else
                     trips[j].start=1;
                 fscanf(fp,α%s%sα,t1,t2);
                 converToTime(t1,&(trips[j].stime));
                 if(!isValidTime(trips[j].stime))QuitCase=1;
                 converToTime(t2,&(trips[j].dtime));
                 if(!isValidTime(trips[j].dtime))QuitCase=1;
                 j++;
                 }
             sort(0,ntrips);
             calcTrains();
             if(QuitCase){
                 fprintf(fp1,αCase #%d: 0 0nα,i);fflush(fp1);
                 }
             else{
                 fprintf(fp1,αCase #%d: %d %dnα,i,a,b);fflush(fp1);
                 printf(αCase #%d: %d %dnα,i,a,b);
                 }
             }
         }
     fclose(fp);
     fclose(fp1);
     }
 
     int main ()
     {
     readinput(αB-large.inα);
     return 0;
     }"
33372,2008,32013,oscarbg,24480,1,universe.c,gcj/2008/32013/oscarbg/24480/1/extracted/universe.c,"// universe.cpp : Defines the entry point for the console application.
 // Oscar Barenys Garcia
 // Google Code Jam 2008
 #include <stdio.h>
 #include <string.h>
 #define KK 1000000
 int sol(int ns,int nq, int *q)
 {
 	int Nof=0;
 	int prof=-1;	int Smin[100];
 	int qmax=-1;
 	int i;
 	while(qmax!=KK)
 	{
 		prof++;
 		for(i=0; i<ns; i++)
 			Smin[i]=KK;
 		for(i=Nof; i<nq; i++)
 		{
 			if(i<Smin[q[i]])
 				Smin[q[i]]=i;
 		}
 		for(i=0; i<ns; i++)
 		{
 			if(qmax<Smin[i]) 
 				qmax=Smin[i];
 		}
 		Nof=qmax;
 	}
 	return(prof);
 	
 }
 void lee(char *in)
 {
 	FILE *fp,*fp2;
 	int i,j,k;
 
 	int N;
 	char Sn[100][105];
 	char ftemp[105];
 	int Qn[1000];
 	int S;
 	int Q;
 
 	char out[100];
 	fp=fopen(in,αrtα);
 	sprintf(out,α%s.outα,in);
 	fp2=fopen(out,αwtα);
 	//while(!feof(fp))
 	{
 		fscanf(fp,α%dnα,&N);
 		for(i=0; i<N; i++)
 		{
 			fscanf(fp,α%dnα,&S);
 			for(j=0; j<S; j++)
 			{
 				fscanf(fp,α%[ a-zA-Z0-9]nα,Sn[j]);
 				//fscanf(fp,α%sα,Sn[j]);
 				//fgets(Sn[j],101,fp);
 			}
 			fscanf(fp,α%dnα,&Q);
 			for(j=0; j<Q; j++)
 			{
 				fscanf(fp,α%[ a-zA-Z0-9]nα,ftemp);
 				//fscanf(fp,α%srnα,ftemp);
 				//fgets(ftemp,101,fp);
 				Qn[j]=-1;
 				for(k=0; k<S; k++)
 				{
 					if(strcmp(ftemp,Sn[k])==0)
 					{
 						Qn[j]=k;
 						break;
 					}
 				}
 			}
 			fprintf(fp2,αCase #%d: %dnα,i+1,sol(S,Q,Qn));
 		}
 	}
 	fclose(fp);
 	fclose(fp2);
 }
 
 int main(int argc, char* argv[])
 {
 	if(argc>1)
 	{
 		lee(argv[1]);
 	}
 	return 0;
 }"
33374,2008,32013,oscarbg,24481,1,tren.c,gcj/2008/32013/oscarbg/24481/1/extracted/tren.c,"// tren.cpp : Defines the entry point for the console application.
 // Oscar Barenys Garcia
 // Google Code Jam 2008
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 int compareA(const void *_a, const void *_b) {
  
         int *a, *b;
         
         a = (int *) _a;
         b = (int *) _b;
         
         return (*a - *b);
 }
 
 int compareB(const void *_a, const void *_b) {
  
         int *a, *b;
         
         a = (int *) _a;
         b = (int *) _b;
         
         return (*a - *b);
 }
 
 void sol(int na,int nb, int Sa[100][2],int Sb[100][2],int *res)
 {	
 	int i;
 	int j=0;
 	int tB=0;
 	int gastados=0;
 	int libres;
 	int tA=0;
 	qsort(Sa,na,2*sizeof(int),compareA);
 	for(i=0; i<na; i++)
 	{
 		libres=0;
 		for(j=0; j<nb; j++)
 		{
 			if(Sb[j][1]<=Sa[i][0])
 				libres++;
 		}
 		if((libres-gastados)==0)
 			tA++;
 		else
 			gastados++;
 	}
 	res[0]=tA;
 	qsort(Sb,nb,2*sizeof(int),compareB);
 	gastados=0;
 	for(i=0; i<nb; i++)
 	{
 		libres=0;
 		for(j=0; j<na; j++)
 		{
 			if(Sa[j][1]<=Sb[i][0])
 				libres++;
 		}
 		if((libres-gastados)==0)
 			tB++;
 		else
 			gastados++;
 	}
 	res[1]=tB;
 	
 }
 void lee(char *in)
 {
 	int NA,NB;
 int h1,m1,h2,m2;
 	FILE *fp,*fp2;
 	int i,j,k;
 	int res[2];
 	int N;
 	int SA[100][2];
 	int SB[100][2];
 	int T;
 	
 	char out[100];
 	if((fp=fopen(in,αrtα))==NULL) exit(0);
 	sprintf(out,α%s.outα,in);
 	fp2=fopen(out,αwtα);
 	//while(!feof(fp))
 	{
 		fscanf(fp,α%dnα,&N);
 		for(i=0; i<N; i++)
 		{
 			fscanf(fp,α%dnα,&T);
 			fscanf(fp,α%d %dnα,&NA,&NB);
 			for(j=0; j<NA; j++){
 				fscanf(fp,α%d:%d %d:%dnα,&h1,&m1,&h2,&m2);
 				SA[j][0]=h1*60+m1;
 				SA[j][1]=h2*60+m2+T;
 			}
 			for(j=0; j<NB; j++){
 				fscanf(fp,α%d:%d %d:%dnα,&h1,&m1,&h2,&m2);
 				SB[j][0]=h1*60+m1;
 				SB[j][1]=h2*60+m2+T;
 			}
 			sol(NA,NB,SA,SB,res);
 			fprintf(fp2,αCase #%d: %d %dnα,i+1,res[0],res[1]);
 		}
 	}
 	fclose(fp);
 	fclose(fp2);
 }
 
 int main(int argc, char* argv[])
 {
 	if(argc>1)
 	{
 		lee(argv[1]);
 	}
 	return 0;
 }"
33381,2008,32013,Hiroshi,24480,1,cs.c,gcj/2008/32013/Hiroshi/24480/1/extracted/cs.c,"#include <stdio.h>
 #include <string.h>
 
 #define BUFSZ	(8192)
 char buf[BUFSZ];
 
 char *engines[100];
 char *queries[1000];
 
 int used[100];
 int nr_used;
 
 void clear_used(int S)
 {
 	int i;
 
 	for (i = 0; i < S; i++)
 		used[i] = 0;
 	nr_used = 0;
 }
 
 int check_used(int S, char *q)
 {
 	int i;
 
 	for (i = 0; i < S; i++) {
 		if (!strcmp(engines[i], q)) {
 			if (used[i] == 0) {
 				if (++nr_used == S)
 					return 1;
 			}
 			used[i] = 1;
 			break;
 		}
 	}
 
 	return 0;
 }
 
 void resolve(void)
 {
 	int S, Q;
 	int i, nr;
 
 	fgets(buf, BUFSZ, stdin);
 	S = atoi(buf);
 	for (i = 0; i < S; i++) {
 		fgets(buf, BUFSZ, stdin);
 		engines[i] = strdup(buf);
 	}
 
 	clear_used(S);
 
 	nr = 0;
 	fgets(buf, BUFSZ, stdin);
 	Q = atoi(buf);
 	for (i = 0; i < Q; i++) {
 		fgets(buf, BUFSZ, stdin);
 		if (check_used(S, buf)) {
 			++nr;
 			clear_used(S);
 			check_used(S, buf);
 		}
 	}
 
 	printf(α%dnα, nr);
 }
 
 int main(void)
 {
 	int N;
 	int i;
 
 	fgets(buf, BUFSZ, stdin);
 	N = atoi(buf);
 	for (i = 0; i < N; i++) {
 		printf(αCase #%d: α, i+1);
 		resolve();
 	}
 }"
33383,2008,32013,Hiroshi,24481,1,timetable.c,gcj/2008/32013/Hiroshi/24481/1/extracted/timetable.c,"#include <stdio.h>
 #include <string.h>
 
 #define BUFSZ	(8192)
 char buf[BUFSZ];
 int nr_A, nr_B;
 
 struct tbl {
 	int dep, arr;
 	int prev, next;
 };
 struct tbl tbl_A[100], tbl_B[100];
 
 int numtbl[256];
 
 void parse(char *str, struct tbl *e)
 {
 	int h0, m0, h1, m1;
 
 	h0 = (numtbl[str[0]] * 10) + numtbl[str[1]];
 	m0 = (numtbl[str[3]] * 10) + numtbl[str[4]];
 	h1 = (numtbl[str[6]] * 10) + numtbl[str[7]];
 	m1 = (numtbl[str[9]] * 10) + numtbl[str[10]];
 
 	e->dep = h0 * 60 + m0;
 	e->arr = h1 * 60 + m1;
 
 	fprintf(stderr, α%d->%dnα, e->dep, e->arr);
 }
 
 struct tbl tmp[100];
 
 void tblsort(int N, struct tbl *tbl)
 {
 	int i, k, m;
 	int min;
 
 	for (i = 0; i < N; i++) {
 		tmp[i].dep = tbl[i].dep;
 		tmp[i].arr = tbl[i].arr;
 	}
 
 	for (i = 0; i < N; i++) {
 		m = N;
 		min = 24*60;
 		for (k = 0; k < N; k++) {
 			if (tmp[k].dep < min) {
 				min = tmp[k].dep;
 				m = k;
 			}
 		}
 		tbl[i].dep = tmp[m].dep;
 		tbl[i].arr = tmp[m].arr;
 		tmp[m].dep = 24*60;
 		fprintf(stderr, α%d: %d->%dnα, i, tbl[i].dep, tbl[i].arr);
 	}
 }
 
 void solve(void)
 {
 	int T, NA, NB;
 	int i, k;
 
 	fgets(buf, BUFSZ, stdin);
 	T = atoi(buf);
 	fgets(buf, BUFSZ, stdin);
 	sscanf(buf, α%d %dα, &NA, &NB);
 
 	fprintf(stderr, α%d %d %dnα, T, NA, NB);
 
 	for (i = 0; i < NA; i++) {
 		fgets(buf, BUFSZ, stdin);
 		parse(buf, &tbl_A[i]);
 	}
 	for (i = 0; i < NB; i++) {
 		fgets(buf, BUFSZ, stdin);
 		parse(buf, &tbl_B[i]);
 	}
 	tblsort(NA, tbl_A);
 	tblsort(NB, tbl_B);
 
 	for (i = 0; i < NA; i++) {
 		tbl_A[i].prev = -1;
 		tbl_A[i].next = -1;
 	}
 	for (i = 0; i < NB; i++) {
 		tbl_B[i].prev = -1;
 		tbl_B[i].next = -1;
 	}
 
 	nr_A = NA;
 	nr_B = NB;
 	for (i = 0; i < NA; i++) {
 		if (tbl_A[i].next != -1)
 			continue;
 		for (k = 0; k < NB; k++) {
 			if (tbl_B[k].prev != -1)
 				continue;
 			if (tbl_A[i].arr + T <= tbl_B[k].dep) {
 				tbl_A[i].next = k;
 				tbl_B[k].prev = i;
 				nr_B--;
 fprintf(stderr,
 αA %d:%d->%d %d:%d->%dnα,
 i, tbl_A[i].dep, tbl_A[i].arr,
 k, tbl_B[k].dep, tbl_B[k].arr);
 				break;
 			}
 		}
 	}
 	for (i = 0; i < NB; i++) {
 		if (tbl_B[i].next != -1)
 			continue;
 		for (k = 0; k < NA; k++) {
 			if (tbl_A[k].prev != -1)
 				continue;
 			if (tbl_B[i].arr + T <= tbl_A[k].dep) {
 				tbl_B[i].next = k;
 				tbl_A[k].prev = i;
 				nr_A--;
 fprintf(stderr,
 αB %d:%d->%d %d:%d->%dnα,
 i, tbl_B[i].dep, tbl_B[i].arr,
 k, tbl_A[k].dep, tbl_A[k].arr);
 				break;
 			}
 		}
 	}
 
 	fprintf(stderr, αans: %d %dnα, nr_A, nr_B);
 	printf(α%d %dnα, nr_A, nr_B);
 }
 
 int main(void)
 {
 	int N;
 	int i;
 
 	for (i = '0'; i <= '9'; i++)
 		numtbl[i] = i - '0';
 
 	fgets(buf, BUFSZ, stdin);
 	N = atoi(buf);
 	for (i = 1; i <= N; i++) {
 		printf(αCase #%d: α, i);
 		solve();
 	}
 	return 0;
 }"
33745,2008,32001,sao3,24439,1,A.c,gcj/2008/32001/sao3/24439/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 #define IMPOSSIBLE 99999999
 
 int f[10001][2];
 int node[10001][2];
 int m, v;
 
 int min(int a, int b){
 	return a > b ? b : a;
 }
 
 void go(){
 	int i, a, b, sum, x;
 	scanf(α%d%dα, &m, &v);
 	memset(f, 0, sizeof(f));
 	memset(node, 0, sizeof(node));
 	for(i = 1; i <= (m - 1)/ 2; i++){
 		scanf(α%d%dα, &node[i][0], &node[i][1]);
 	}
 	
 	for(i = (m - 1) / 2 + 1; i <= m; i++){
 		scanf(α%dα, &x);
 		if(x == 0){
 			f[i][0] = 0;
 			f[i][1] = IMPOSSIBLE;
 		}
 		if(x == 1){
 			f[i][1] = 0;
 			f[i][0] = IMPOSSIBLE;
 		}
 	}
 	for(i = (m - 1) /2; i > 0; i--){
 		f[i][0] = IMPOSSIBLE;
 		f[i][1] = IMPOSSIBLE;
 		for(a = 0; a < 2; a++)
 			for(b = 0; b < 2; b++)
 				if(f[i * 2][a] != IMPOSSIBLE && f[i * 2 + 1][b] != IMPOSSIBLE){
 					sum = f[i * 2][a] + f[i * 2 + 1][b];
 					if(node[i][0] == 1){
 						f[i][a && b] = min(f[i][a && b], sum);
 					}
 					else{
 						f[i][a || b] = min(f[i][a || b], sum);
 					}
 					if(node[i][1] == 1){
 						if(node[i][0] == 0){
 							f[i][a && b] = min(f[i][a && b], sum + 1);
 						}
 						else{
 							f[i][a || b] = min(f[i][a || b], sum + 1);
 						}
 					}
 				}
 	}
 }
 
 int main(){
 	int cs, i;
 	freopen(αa.inα, αrα, stdin);
 	freopen(αa.outα, αwα, stdout);
 	scanf(α%dα, &cs);
 	for(i = 0; i < cs; i++){
 		go();
 
 		printf(αCase #%d: α, i + 1);
 		if(f[1][v] == IMPOSSIBLE){
 			printf(αIMPOSSIBLEnα);
 		}
 		else{
 			printf(α%dnα, f[1][v]);
 		}
 	}
 	return 0;
 }"
33892,2008,32001,pvncad,24439,1,bbt.c,gcj/2008/32001/pvncad/24439/1/extracted/bbt.c,"#include <stdio.h>
 
 
     int cflag[10010];
 int answer(int g[], int v[], int r, int n, int a)
 {
     int min, v2, p, d;
 
     int vl1, vl0, vr0, vr1;
 
     if (r >= n) return -1;
 
     if (a == v[r]) {
 //        printf(αRoot = %d; V = %d; min = %dnα, r, a, 0);
         return 0;
     }
 
     if (r >= ((n - 1) / 2)) {
   //      printf(αRoot = %d; V = %d; min = %dnα, r, a, -1);
         return -1;
     }
 
     vl0 = vl1 = -1;
     vr0 = vr1 = -1;
 
     vl0 = answer(g, v, 2 * r + 1, n , 0);
     vl1 = answer(g, v, 2 * r + 1, n , 1);
 
     vr0 = answer(g, v, 2 * r + 2, n , 0);
     vr1 = answer(g, v, 2 * r + 2, n , 1);
 
     min = -1;
     d = 0;
     if (g[r] == 0 || cflag[r] == 1) {
         if (g[r] == 1) d = 1;
         if (a == 1) {
             if (vl1 >= 0 && (min == -1 || (vl1 + d) < min)) min = vl1 + d;
             if (vr1 >= 0 && (min == -1 || (d + vr1) < min)) min = vr1 + d;
         }
         else if (vl0 >= 0 && vr0 >= 0) {
             if (min == -1 || (vr0 + vl0 + d) < min) min = vr0 + vl0 + d;
         }
     }
 
     d = 0;
     if (g[r] == 1 || cflag[r] == 1) {
         if (g[r] == 0) d = 1;
         if (a == 0) {
             if (vl0 >= 0 && (min == -1 || (vl0 +d) < min)) min = vl0 + d;
             if (vr0 >= 0 && (min == -1 || (vr0 +d) < min)) min = vr0 + d;
         }
         else if (vl1 >= 0 && vr1 >= 0) {
             if (min == -1 || (vr1 + vl1+d) < min) min = vr1 + vl1+d;
         }
     }
 
   //  printf(αRoot = %d; V = %d; min = %dnα, r, a, min);
 
     return min;
 }
 int main(char **argv, int argc)
 {
     int N, M, V,i,j,k,p, a, v1, v2;
     int gates[10010];
     int values[10010];
 
     scanf(α%dα, &N);
 
     for (i = 1; i <= N; i++)
     {
         printf(αCase #%d: α, i);
         scanf(α%d%dα, &M, &V);
 
         for (j = 0; j < (M - 1) / 2; j ++) {
             scanf(α%d%dα, &gates[j], &cflag[j]);
             values[j] = -1;
         }
 
         k = j;
 
         for (j = 0; j < (M + 1) / 2; j ++)
             scanf(α%dα, &values[k + j]);
 
         j = k + j - 2;
         for (; j > 0; j -= 2) {
            p = j / 2;
            v1 = values[j];
            v2 = values[j + 1];
 
            if (gates[p] == 0) {
                values[p] = (v1 || v2);
            }
            else {
                values[p] = (v1 && v2);
            }
         }
 
         a = answer(gates, values, 0, M, V);
         if (a == -1) {
             printf(αIMPOSSIBLEnα);
         }
         else {
             printf(α%dnα, a);
         }
     }
 
     return 0;
 }"
34295,2008,32001,schultz,24439,1,a.c,gcj/2008/32001/schultz/24439/1/extracted/a.c,"#include<stdio.h>
 
 typedef unsigned nat;
 
 #define INFINITY 2000000
 
 typedef struct {
 	nat gate, change;
 	nat zero, one;
 } gate;
 
 #define N_SIZE (16*1024)
 
 gate A[N_SIZE];
 
 inline nat min(nat x, nat y) {
 	return x < y ? x : y;
 }
 
 int main() {
 	nat tc, cs;
 	nat n, target;
 	nat i, g, c;
 	nat v, x;
 	nat a, b;
 	nat and, or;
 	nat inter;
 
 	scanf(α%uα, &tc);
 	for (cs = 0; cs != tc; ++cs) {
 		scanf(α%u%uα, &n, &target);
 		inter = (n-1)/2;
 
 		for (i = 0; i != inter; ++i) {
 			scanf(α%u%uα, &g, &c);
 			A[i].gate = g;
 			A[i].change = c;
 		}
 
 		for (i = inter; i != n; ++i) {
 			scanf(α%uα, &x);
 			A[i].one = x ? 0 : INFINITY;
 			A[i].zero = x ? INFINITY : 0;
 		}
 
 		for (i = inter; i != 0;) {
 			--i;
 
 			a = 2*i+1;
 			b = 2*i+2;
 
 			or = min(A[a].one, A[b].one);
 			and = A[a].one + A[b].one;
 
 			v = A[i].gate ? and : or;
 			if (A[i].change) {
 				x = 1 + (!A[i].gate ? and : or);
 				if (x < v)
 					v = x;
 			}
 
 			if (v > INFINITY)
 				v = INFINITY;
 
 			A[i].one = v;
 
 			or = A[a].zero + A[b].zero;
 			and = min(A[a].zero, A[b].zero);
 
 			v = A[i].gate ? and : or;
 			if (A[i].change) {
 				x = 1 + (!A[i].gate ? and : or);
 				if (x < v)
 					v = x;
 			}
 
 			if (v > INFINITY)
 				v = INFINITY;
 
 			A[i].zero = v;
 		}
 
 		printf(αCase #%u: α, cs+1);
 		v = target ? A[i].one : A[i].zero;
 		if (v < INFINITY)
 			printf(α%unα, v);
 		else
 			puts(αIMPOSSIBLEα);
 	}
 
 	return 0;
 }"
34344,2008,32001,rompel,24439,1,cbt.c,gcj/2008/32001/rompel/24439/1/extracted/cbt.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 #include <ctype.h>
 
 
 inline static double fsqr(double x) { return x*x; }
 inline static int isqr(int x) { return x*x; }
 inline static int imin(int x, int y) { return x<y ? x : y; }
 inline static int imax(int x, int y) { return x>y ? x : y; }
 
 
 static int split(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       while(*x && strchr(r, *x))
           x++;
       if(!*x)
           break;
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 static int splitn(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
   char buf[100];
 
   fgets(buf, 100, stdin);
   assert(1==sscanf(buf,α%dnα, &N));
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 void do_one_case(int cnum)
 {
   int M, V;
   int i, j, k, l, t;
 
   const int logic[2][2][2] = {{{0,1},{1,1}},{{0,0},{0,1}}};
   double cost[11000][2];
   int gate[11000], change[11000];
 
   scanf(α%d %dnα, &M, &V);
   for(i=0; 2*i<M-2; i++)
       scanf(α%d %dnα, &gate[i], &change[i]);
   for(; i<M; i++)
     {
       scanf(α%dnα, &t);
       cost[i][t] = 0;
       cost[i][1-t] = 1e30;
     }
   for(i=(M-1)>>1; --i>=0;)
     {
       cost[i][0] = cost[i][1] = 1e20;
       for(j=0; j<2; j++)
           for(k=0; k<2; k++)
               for(l=0; l<2; l++)
                 {
                   double x = cost[2*i+1][k] + cost[2*i+2][l] + (j!=gate[i])*(1+(!change[i])*1e25);
                   if(x<cost[i][logic[j][k][l]])
                      cost[i][logic[j][k][l]] = x;
                   // cost[i][logic[j][k][l]] = fmin(cost[i][logic[j][k][l]], x);
                 }
     }
 
 #if 0
   for(i=0; i<M; i++)
       fprintf(stderr, α%d %g %gnα, i, cost[i][0], cost[i][1]);
 #endif
 
   if(cost[0][V] > M)
       printf(αCase #%d: IMPOSSIBLEnα, cnum);
   else
       printf(αCase #%d: %.0fnα, cnum, cost[0][V]);
 }"
34346,2008,32001,rompel,24442,1,prle.c,gcj/2008/32001/rompel/24442/1/extracted/prle.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 #include <ctype.h>
 
 
 inline static double fsqr(double x) { return x*x; }
 inline static int isqr(int x) { return x*x; }
 inline static int imin(int x, int y) { return x<y ? x : y; }
 inline static int imax(int x, int y) { return x>y ? x : y; }
 
 
 static int split(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       while(*x && strchr(r, *x))
           x++;
       if(!*x)
           break;
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 static int splitn(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
   char buf[100];
 
   fgets(buf, 100, stdin);
   assert(1==sscanf(buf,α%dnα, &N));
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 static int bc[65536];
 
 void initbc()
 {
   static init=0;
   int i, j;
 
   if(init)
       return;
 
   bc[0] = 0;
 
   for(i=1; i<65536; i*=2)
       for(j=0; j<i; j++)
           bc[i+j] = 1 + bc[j];
 
   init = 1;
 }
 
 
 void do_one_case(int cnum)
 {
   static int R[65536][16][16];
   int C[16][16];
   int C2[16][16];
   static char S[60000];
   int k,l,ll;
   int i,j,n,m, i1,i2,i3, ss, nn;
 
   initbc();
 
   scanf(α%dnα, &k);
   scanf(α%snα, S);
   l = strlen(S);
   assert(l%k == 0);
   ll = l/k;
 
   for(i=0; i<k; i++)
       for(j=0; j<k; j++)
         {
           for(n=m=0; m<l; m+=k)
               n += S[m+i] != S[m+j];
           C[i][j] = n;
           for(n=m=0; m+k<l; m+=k)
               n += S[m+i] != S[m+k+j];
           C2[i][j] = n;
         }
 
   nn = 1<<k;
   for(i=0; i<nn; i++)
       for(i1=0; i1<k; i1++)
           for(i2=0; i2<k; i2++)
               R[i][i1][i2] = 1000000;
   for(i1=0; i1<k; i1++)
     {
       i = 1<<i1;
       R[i][i1][i1] = 0;
     }
 
   for(ss=2; ss<=k; ss++)
       for(i=0; i<nn; i++)
           if(bc[i]==ss)
             {
               for(i1=0; i1<k; i1++)
                   if(i & (1<<i1))
                       for(i2=0; i2<k; i2++)
                           if(i&(1<<i2) && i1!=i2)
                             {
                               m = 10000000;
                               for(i3=0; i3<k; i3++)
                                   if(i&(1<<i3) && i1!=i3)
                                       m = imin(m, C[i1][i3] + R[i&(~(1<<i1))][i3][i2]);
                               R[i][i1][i2] = m;
                               // fprintf(stderr, αi=%d i1=%d i2=%d m=%dnα, i,i1,i2,m);
                             }
             }
 
   m = 10000000;
   for(i1=0; i1<k; i1++)
       for(i2=0; i2<k; i2++)
           if(i1!=i2)
               m = imin(m, C2[i2][i1] + R[nn-1][i1][i2]);
 
   printf(αCase #%d: %dnα, cnum, m+1);
 }"
34805,2008,32001,nutki,24439,1,A.c,gcj/2008/32001/nutki/24439/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 #define M 10008
 #define INF (1000000000)
 int n,c,C,i,m,m2,v;
 int t[M],op[M],mi[2][M],ch[M];
 static int MIN(int x, int y) { return x<y? x:y; }
 static int MAX(int x, int y) { return x==INF || y==INF ? INF :x+y; }
 int main() {
 	scanf(α%dα,&C);
 	for(c=1;c<=C;c++) {
 		scanf(α%d%dα,&m,&v);
 		memset(mi,0,sizeof(mi));
 		memset(t,0,sizeof(t));
 		memset(ch,0,sizeof(ch));
 		memset(op,0,sizeof(op));
 		m2 = (m-1)/2;
 //		printf(α%dnα,m2);
 		for(i=0;i<m2;i++) {
 			scanf(α%d%dα,op+i,ch+i);
 			mi[0][i] = mi[1][i] = INF;
 		}
 		for(;i<m;i++) {
 			scanf(α%dα,t+i);
 			mi[t[i]][i] = 0;
 			mi[!t[i]][i] = INF;
 		}
 //		printf(α%dnα,m2);
 		for(i=m2-1;i>=0;i--) {
 			int l = 2*i+1, r = 2*i+2;
 			int b0 = INF, b1 = INF;
 			int b00 = MAX(mi[0][l],mi[0][r]);
 			int b01 = MAX(mi[0][l],mi[1][r]);
 			int b10 = MAX(mi[1][l],mi[0][r]);
 			int b11 = MAX(mi[1][l],mi[1][r]);
 //			printf(α%8d%8d%8d%8dnα,b00,b10,b01,b11);
 			int b0and = MIN(b00,MIN(b01,b10)), b1and = b11;
 			int b1or = MIN(b11,MIN(b01,b10)), b0or = b00;
 //			printf(α%8d%8d%8d%8dnα,b0and,b1and,b0or,b1or);
 			if(b0and != INF) {
 				if(op[i])/*AND*/{
 					b0 = MIN(b0and, b0);
 				} else if(ch[i]) {
 					b0 = MIN(b0and + 1, b0);
 				}
 			}
 			if(b1and != INF) {
 				if(op[i])/*AND*/{
 					b1 = MIN(b1and, b1);
 				} else if(ch[i]) {
 					b1 = MIN(b1and + 1, b1);
 				}
 			}
 			if(b0or != INF) {
 				if(!op[i])/*OR*/{
 					b0 = MIN(b0or, b0);
 				} else if(ch[i]) {
 					b0 = MIN(b0or + 1, b0);
 				}
 			}
 			if(b1or != INF) {
 				if(!op[i])/*OR*/{
 					b1 = MIN(b1or, b1);
 				} else if(ch[i]) {
 					b1 = MIN(b1or + 1, b1);
 				}
 			}
 			mi[0][i] = b0;
 			mi[1][i] = b1;
 //			printf(α%d(%d):%8d%8dnα,i,ch[i],b0,b1);
 		}
 		fprintf(stderr,αr%d/%dα,c,C); fflush(stderr);
 		if(mi[v][0]!=INF) {
 			printf(αCase #%d: %dnα,c,mi[v][0]);
 		} else {
 			printf(αCase #%d: IMPOSSIBLEnα,c);
 		}
 	}
 	fprintf(stderr,αnα);
 	return 0;
 }"
34813,2008,32001,tiagomt,24439,1,a.c,gcj/2008/32001/tiagomt/24439/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MIN(a,b)	(((a) < (b)) ? (a) : (b))
 #define MAX(a,b)	(((a) > (b)) ? (a) : (b))
 
 #define INFINITO	0x3F3F3F3F
 
 #define MAXM		(1 << 14)
 
 int	b[MAXM][2];
 int	m;
 
 int	g[MAXM],
 	c[MAXM];
 
 int main (void)
 {
 	int	nc,
 		h;
 	int	v;
 	int	i,
 		j,
 		k;
 
 	for (scanf(α%dα, &nc), h = 1; h <= nc; h++)
 	{
 		scanf(α%d%dα, &m, &v);
 		for (i = 0; i < ((m - 1) / 2); i++)
 		{
 			scanf(α%d%dα, &(g[i]), &(c[i]));
 		}
 		for ( ; i < m; i++)
 		{
 			scanf(α%dα, &(g[i]));
 		}
 		memset(b, INFINITO, sizeof(b));
 		for (i = (m - 1); i >= ((m - 1) / 2); i--)
 		{
 			if (g[i] == 0)
 			{
 				b[i][0] = 0;
 				b[i][1] = INFINITO;
 			}
 			else
 			{
 				b[i][0] = INFINITO;
 				b[i][1] = 0;
 			}
 		}
 		for ( ; i >= 0; i--)
 		{
 			j = (i * 2) + 1;
 			k = (i * 2) + 2;
 			if (g[i] == 0)
 			{
 				if ((b[j][0] < INFINITO) && (b[k][0] < INFINITO))
 				{
 					b[i][0] = b[j][0] + b[k][0];
 				}
 				if ((b[j][1] < INFINITO) || (b[k][1] < INFINITO))
 				{
 					b[i][1] = MIN(b[j][1], b[k][1]);
 				}
 				if (c[i])
 				{
 					if ((b[j][0] < INFINITO) || (b[k][0] < INFINITO))
 					{
 						b[i][0] = MIN(b[i][0], MIN(b[j][0], b[k][0]) + 1);
 					}
 					if ((b[j][1] < INFINITO) && (b[k][1] < INFINITO))
 					{
 						b[i][1] = MIN(b[i][1], b[j][1] + b[k][1] + 1);
 					}
 				}
 			}
 			else
 			{
 				if ((b[j][0] < INFINITO) || (b[k][0] < INFINITO))
 				{
 					b[i][0] = MIN(b[j][0], b[k][0]);
 				}
 				if ((b[j][1] < INFINITO) && (b[k][1] < INFINITO))
 				{
 					b[i][1] = b[j][1] + b[k][1];
 				}
 				if (c[i])
 				{
 					if ((b[j][0] < INFINITO) && (b[k][0] < INFINITO))
 					{
 						b[i][0] = MIN(b[i][0], b[j][0] + b[k][0] + 1);
 					}
 					if ((b[j][1] < INFINITO) || (b[k][1] < INFINITO))
 					{
 						b[i][1] = MIN(b[i][1], MIN(b[j][1], b[k][1]) + 1);
 					}
 				}
 			}
 		}
 		printf(αCase #%d: α, h);
 		if (b[0][v] < INFINITO)
 		{
 			printf(α%dnα, b[0][v]);
 		}
 		else
 		{
 			printf(αIMPOSSIBLEnα);
 		}
 	}
 
 	return 0;
 }"
35506,2008,32001,Yao,24439,1,a.c,gcj/2008/32001/Yao/24439/1/extracted/a.c,"#include<stdio.h>
 
 int v[10001],c[10001],g[10001];
 int dp[10001][2];
 int n,m;
 
 void run(int T) {
 	int i,j,k;
 	scanf(α%d %dα,&n,&m);
 	for(i=0;i<=n;i++) dp[i][0]=dp[i][1]=1000000000;
 	for(i=1;i<(n+1)/2;i++) {
 		scanf(α%d %dα,&g[i],&c[i]);
 	}
 	for(;i<=n;i++) {
 		scanf(α%dα,&v[i]);
 		dp[i][v[i]]=0;
 		dp[i][1-v[i]]=1000000000;
 	}
 	for(i=(n-1)/2;i;i--) {
 		for(j=0;j<2;j++)
 			if (dp[i<<1][j]<1000000000)
 				for(k=0;k<2;k++)
 					if (dp[i<<1|1][k]<1000000000) {
 						if (g[i]) {
 							int cur=j&k;
 							if (dp[i][cur]>dp[i<<1][j]+dp[i<<1|1][k])
 								dp[i][cur]=dp[i<<1][j]+dp[i<<1|1][k];
 							if (c[i]) {
 								cur=j|k;
 								if (dp[i][cur]>dp[i<<1][j]+dp[i<<1|1][k]+1)
 									dp[i][cur]=dp[i<<1][j]+dp[i<<1|1][k]+1;
 							}
 						}
 						else {
 							int cur=j|k;
 							if (dp[i][cur]>dp[i<<1][j]+dp[i<<1|1][k])
 								dp[i][cur]=dp[i<<1][j]+dp[i<<1|1][k];
 							if (c[i]) {
 								cur=j&k;
 								if (dp[i][cur]>dp[i<<1][j]+dp[i<<1|1][k]+1)
 									dp[i][cur]=dp[i<<1][j]+dp[i<<1|1][k]+1;
 							}
 						}
 					}
 	}
 	if (dp[1][m]<1000000000) printf(αCase #%d: %dnα,T,dp[1][m]); else printf(αCase #%d: IMPOSSIBLEnα,T);
 }
 
 int main() {
 	int N,cs=0;
 	for(scanf(α%dα,&N);N--;)
 		run(++cs);
 	return 0;
 }"
35691,2008,32001,anhcuong,24439,1,booleantree.c,gcj/2008/32001/anhcuong/24439/1/extracted/booleantree.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MAXNODES 10000
 
 int N, M, V, Y;
 int T[MAXNODES];
 int G[MAXNODES];
 int C[MAXNODES];
 
 int change(int node) {
   int y = 0;
   int left = node * 2 + 1;
   int right = node * 2 + 2;
 
   if (left >= M || right >= M) return -1;
 
   if ((C[node] == 1) && (T[left] != T[right])) {    
     return 1;
   }
 
   int yleft = change(left);  
   int yright = change(right);  
 
   if (yleft == -1 && yright == -1) return -1;
 
   if (G[node] == 0) {
     if (T[left] != T[right]) {
       if (T[left] == 1) {
         if (yleft == -1) y = -1;
         else y += yleft;
       }
       else {
         if (yright == -1) y = -1;
         else y += yright;
       }
     } else if (T[left] == 1) {
       if (C[node] == 1) {
         if (yleft < yright) {
           if (yleft == -1) y += yright + 1;
           else y += yleft + 1;
         } else {
           if (yright == -1) y += yleft + 1;
           else y += yright + 1;
         }
       } else {
         if (yleft == -1 || yright == -1) y = -1;
         else y += yleft + yright;
       }
     } else {
       if (yleft < yright) {
         if (yleft == -1) y += yright;
         else y += yleft;
       } else {
         if (yright == -1) y += yleft;
         else y += yright;
       }
     }
   } else {
     if (T[left] != T[right]) {
       if (T[left] == 0) {
         if (yleft == -1) y = -1;
         else y += yleft;
       } else {
         if (yright == -1) y = -1;
         else y += yright;
       }
     } else if (T[left] == 0) {
       if (C[node] == 1) {
         if (yleft < yright) {
           if (yleft == -1) y += yright + 1;
           else y += yleft + 1;
         } else {
           if (yright == -1) y += yleft + 1;
           else y += yright + 1;
         }
       } else {
         if (yleft == -1 || yright == -1) y = -1;
         else y += yleft + yright;
       }
     } else {
       if (yleft < yright) {
         if (yleft == -1) y += yright;
         else y += yleft;
       } else {
         if (yright == -1) y += yleft;
         else y += yright;
       }
     }
   }
   return y;
 }
 
 void buildtree() {
   for (int i = M - 1; i > 0; i -= 2) {
     if (G[(i - 1) / 2] == 1) T[(i - 1) / 2] = T[i] & T[i - 1];
     else T[(i - 1) / 2] = T[i] | T[i - 1];
     
   }
   //for (int i = 0; i < M; ++i) printf(αtree:%d %d α,i + 1, T[i]);
   //for (int i = 0; i < (M - 1) / 2; ++i) printf(αC:%d %d α,i + 1, C[i]);
 }
 
 void solve() {
   scanf(α%d %dα, &M, &V);
   for (int i = 0; i < (M - 1) / 2; ++i) {
     scanf(α%d %dα, &G[i], &C[i]);
   }
   for (int i = (M - 1) / 2; i < M; ++i) {
     scanf(α%dα, &T[i]);
   }  
   buildtree();
   Y = 0;
   if (V != T[0]) Y+= change(0);    
 }
 
 int main(int argc, char** argv) {
   scanf(α%dα, &N);
   for (int i = 0; i < N; ++i) {
     solve();
     if (Y >= 0 ) printf(αCase #%d: %dnα, i + 1, Y);
     else printf(αCase #%d: IMPOSSIBLEnα, i + 1);
   }
   return (EXIT_SUCCESS);
 }"
35778,2008,32001,lbackstrom,24439,1,a.c,gcj/2008/32001/lbackstrom/24439/1/extracted/a.c,"int min(int a, int b){
     if(a<b)return a;
     else return b;
 }
 int main(){
     int N, M, V, i, j, k, a,b,c,d;
     int value[10010];
     int change[10010];
     int cost0[10010];
     int cost1[10010];
     scanf(α%dα,&N);
     for(i = 1; i<=N; i++){
         scanf(α%d%dα,&M,&V);
         for(j = 0; j<(M-1)/2; j++){
             scanf(α%dα,&value[j]);
             scanf(α%dα,&change[j]);
         }
         for(j = (M-1)/2;j<M; j++){
             scanf(α%dα,&value[j]);
             cost0[j] = cost1[j] = 1000000;
             if(value[j])cost1[j] = 0;
             else cost0[j] = 0;
         }
         int m = 10000;
         for(j = (M-1)/2-1;j>=0;j--){
             cost0[j] = 1000000;
             cost1[j] = 1000000;
             a = cost1[j*2+1]+cost1[j*2+2];
             b = cost1[j*2+1]+cost0[j*2+2];
             c = cost0[j*2+1]+cost1[j*2+2];
             d = cost0[j*2+1]+cost0[j*2+2];
             if(value[j]){//AND
                 cost1[j] = min(cost1[j],a);
                 cost0[j] = min(cost0[j],b);
                 cost0[j] = min(cost0[j],c);
                 cost0[j] = min(cost0[j],d);
             }else{
                 cost1[j] = min(cost1[j],a);
                 cost1[j] = min(cost1[j],b);
                 cost1[j] = min(cost1[j],c);
                 cost0[j] = min(cost0[j],d);
             }
             if(change[j]){
                 if(value[j]){//AND
                     cost1[j] = min(cost1[j],a+1);
                     cost1[j] = min(cost1[j],b+1);
                     cost1[j] = min(cost1[j],c+1);
                     cost0[j] = min(cost0[j],d+1);
                 }else{
                     cost1[j] = min(cost1[j],a+1);
                     cost0[j] = min(cost0[j],b+1);
                     cost0[j] = min(cost0[j],c+1);
                     cost0[j] = min(cost0[j],d+1);
                 }
             }
         }
         if(V)m = cost1[0];
         else m = cost0[0];
         if(m >=10000)
             printf(αCase #%d: IMPOSSIBLEnα,i);
         else
             printf(αCase #%d: %dnα,i,m);
 
 
     }
 
 }"
35780,2008,32001,lbackstrom,24441,1,c.c,gcj/2008/32001/lbackstrom/24441/1/extracted/c.c,"double abs(double n){
     return n < 0 ? -n : n;
 }
 int compare (const void * a, const void * b)
 {
   return ( *(int*)a - *(int*)b );
 }
 
 int main(){
     int T, N;
     int x[1001];
     int y[1001];
     int z[1001];
     int p[1001];
     int i, j, k, l;
     double d;
     scanf(α%dα,&T);
     for(i = 1; i<=T; i++){
         scanf(α%dα,&N);
         for(j = 0; j<N; j++){
             scanf(α%d%d%d%dα,&x[j],&y[j],&z[j],&p[j]);
         }
         if(N == 1){
             printf(αCase #%d: %0.6lfnα,i,0);
             continue;
         }
         double ans = 1e9;
         double xx = 0, yy = 0, zz = 0, step = 1e5;
         int idx;
         while(step > 1e-7){
             double dd = 0;
             for(l = 0; l<N; l++){
                 double d = abs((xx-x[l]) / p[l]) + abs((yy-y[l]) / p[l]) + abs((zz-z[l]) / p[l]);
                 if (d > dd){
                     dd = d;
                     idx = l;
                 }
             }
             if(x[idx] > xx)xx += step;
             else xx -= step;
             if(y[idx] > yy)yy += step;
             else yy -= step;
             if(z[idx] > zz)zz += step;
             else zz -= step;
             step *= 0.999;
             if(dd < ans)ans = dd;
         }
         printf(αCase #%d: %0.6lfnα,i,ans);
     }
 }"
35782,2008,32001,lbackstrom,24440,1,tri.c,gcj/2008/32001/lbackstrom/24440/1/extracted/tri.c,"int main(){
     int N, M, C, A;
     int i, j, k;
     scanf(α%dα,&C);
     for(i = 1; i<=C; i++){
         scanf(α%d%d%dα,&N,&M,&A);
         if(N*M < A){
             printf(αCase #%d: IMPOSSIBLEnα,i);
             continue;
         }
         j = (A+N-1)/N;
         k = (N-A%N)%N;
         printf(αCase #%d: %d %d %d %d %d %dnα,i,0,0,k,j,N,1);
     }
 }"
36593,2008,32001,Baiger,24439,1,A.c,gcj/2008/32001/Baiger/24439/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAXLEN 10001
 
 int calc_0(int s10, int s11, int s20, int s21, int g, int c)
 {
      int a = 100000, b = 100000;
      if (g == 1 /*AND*/)
 	  a = (s10<=s20)?s10:s20;
      else
 	  a = s10+s20;
      if (c == 1)
 	  b = (s10<=s20)?s10+1:s20+1;
      return (a<b)?a:b;
 }
 
 int calc_1(int s10, int s11, int s20, int s21, int g, int c)
 {
      int a = 100000, b = 100000;
      if (g == 0 /*OR*/)
 	  a = (s11<=s21)?s11:s21;
      else
 	  a = s11+s21;
      if (c == 1)
 	  b = (s11<=s21)?s11+1:s21+1;
      return (a<b)?a:b;
 }
 
 int main()
 {
      int n, i;
      scanf(α%dα, &n);
      for (i = 1; i <= n; i++) {
 	  int m, v, j, g[MAXLEN], c[MAXLEN], vi[MAXLEN];
 	  scanf(α%d %dα, &m, &v);
 	  for (j = 1; j <= (m-1) >> 1; j++)
 	       scanf(α%d %dα, &g[j], &c[j]);
 	  int f[MAXLEN][2];
 	  memset(f, 39, sizeof(f)); /* try it */
 	  for (j = ((m-1)>>1)+1; j <= m; j++) {
 	       scanf(α%dα, &vi[j]);
 	       f[j][vi[j]] = 0;
 	  }
 	  for (j = ((m-1)>>1); j > 0; j--) {
 	       f[j][0] = calc_0(f[j*2][0], f[j*2][1], f[j*2+1][0], f[j*2+1][1], g[j], c[j]);
 	       f[j][1] = calc_1(f[j*2][0], f[j*2][1], f[j*2+1][0], f[j*2+1][1], g[j], c[j]);
 	  }
 	  
 	  if (f[1][v] < m)
 	       printf(αCase #%d: %dnα, i, f[1][v]);
 	  else
 	       printf(αCase #%d: IMPOSSIBLEnα, i);
      }
      
      return 0;
 }"
36743,2008,32001,Serraa,24439,1,a.c,gcj/2008/32001/Serraa/24439/1/extracted/a.c,"#include <stdio.h>
 
 #define INF 1234567
 #define MIN(A,B) ((A<B)?(A):(B))
 
 int main () {
   int n,m,v;
   int t,i;
   int ins;
   int node[15000][2];
   int cost[15000][2];
   int x;
 
   scanf(α%dα, &n);
   for (t=1; t<=n; t++) {
     scanf(α%d%dα,&m,&v);
     ins=(m-1)/2;
     for (i=0; i<ins;i++)
       scanf(α%d%dα,node[i]+0, node[i]+1);
     for (i=ins;i<m;i++) {
       scanf(α%dα, &x);
       cost[i][x]=0;
       cost[i][1-x]=INF;
     }
     for (i=ins-1;i>=0;i--) {
       if (node[i][1]==0) { /*not change*/
 	if (node[i][0]==0) { /*OR*/
 	  cost[i][0]=cost[i*2+1][0]+cost[i*2+2][0];
 	  if (cost[i][0]>=INF) cost[i][0]=INF;
 	  cost[i][1]=MIN(cost[i*2+1][1], cost[i*2+2][1]);
 	}
 	if (node[i][0]==1) { /*AND*/
 	  cost[i][1]=cost[i*2+1][1]+cost[i*2+2][1];
 	  if (cost[i][1]>=INF) cost[i][1]=INF;
 	  cost[i][0]=MIN(cost[i*2+1][0], cost[i*2+2][0]);
 	}
       }
       else { /*change*/
 	if (node[i][0]==0) { /*OR*/
 	  cost[i][0]=MIN(cost[i*2+1][0]+cost[i*2+2][0], 1+ MIN(cost[i*2+1][0], cost[i*2+2][0]));
 	  if (cost[i][0]>=INF) cost[i][0]=INF;
 	  cost[i][1]=MIN(MIN(cost[i*2+1][1], cost[i*2+2][1]), 1+ cost[i*2+1][1]+cost[i*2+2][1]);
 	  if (cost[i][1]>=INF) cost[i][1]=INF;
 	}
 	if (node[i][0]==1) { /*AND*/
 	  cost[i][1]=MIN(cost[i*2+1][1]+cost[i*2+2][1], 1 + MIN(cost[i*2+1][1], cost[i*2+2][1]));
 	  if (cost[i][1]>=INF) cost[i][1]=INF;
 	  cost[i][0]=MIN(MIN(cost[i*2+1][0], cost[i*2+2][0]), 1 + cost[i*2+1][0]+cost[i*2+2][0]);
 	  if (cost[i][0]>=INF) cost[i][0]=INF;
 	}
 
 
       } 
     }
     printf(αCase #%d: α,t);
     if (cost[0][v]>=INF) printf(αIMPOSSIBLEnα);
     else printf(α%dnα, cost[0][v]);
   }
 
   return 0;
 }"
37009,2008,32001,along,24439,1,a.c,gcj/2008/32001/along/24439/1/extracted/a.c,"#include <iostream>
 #include <stdio.h>
 #include <string.h>
 using namespace std;
 
 int M,V;
 int g[10001], v[10001];
 int best[10001][2];
 
 int calc(int p, int dv)
 {
 	if (best[p][dv] >= 0)
 		return best[p][dv];
 	if (p > (M-1)/2)
 	{
 		if (v[p] == dv)
 			return 0;
 		else
 			return 1000000;
 	}
 	int& r = best[p][dv];
 	r = 1000000;
 	int t;
 	if (g[p] == 1) // AND gate
 	{
 		if (dv == 1)
 		{
 			t = calc(p*2, 1) + calc(p*2+1, 1);
 			if (t < r ) r = t;
 		}
 		else
 		{
 			t = calc(p*2, 1) + calc(p*2+1, 0);
 			if (t < r) r = t;
 			t = calc(p*2, 0) + calc(p*2+1, 1);
 			if (t < r) r = t;
 			t = calc(p*2, 0) + calc(p*2+1, 0);
 			if (t < r ) r = t;
 		}
 	}
 	else // OR gate
 	{
 		if (dv == 1)
 		{
 			t = calc(p*2, 1) + calc(p*2+1, 1);
 			if (t < r) r = t;
 			t = calc(p*2, 1) + calc(p*2+1, 0);
 			if (t < r) r = t;
 			t = calc(p*2, 0) + calc(p*2+1, 1);
 			if (t < r) r = t;
 		}
 		else
 		{
 			t = calc(p*2, 0) + calc(p*2+1, 0);
 			if (t < r) r = t;
 		}
 	}
 	if (v[p]) // changable
 	{
 		if (g[p] == 1) // calc as or gate
 		{
 			if (dv == 1)
 			{
 				t = calc(p*2, 1) + calc(p*2+1, 1) + 1;
 				if (t < r) r = t;
 				t = calc(p*2, 1) + calc(p*2+1, 0) + 1;
 				if (t < r) r = t;
 				t = calc(p*2, 0) + calc(p*2+1, 1) + 1;
 				if (t < r) r = t;
 			}
 			else
 			{
 				t = calc(p*2, 0) + calc(p*2+1, 0) + 1;
 				if (t < r) r = t;
 			}
 		}
 		else // calc as and gate
 		{
 			if (dv == 1)
 			{
 				t = calc(p*2, 1) + calc(p*2+1, 1) + 1;
 				if (t < r ) r = t;
 			}
 			else
 			{
 				t = calc(p*2, 1) + calc(p*2+1, 0) + 1;
 				if (t < r) r = t;
 				t = calc(p*2, 0) + calc(p*2+1, 1) + 1;
 				if (t < r) r = t;
 				t = calc(p*2, 0) + calc(p*2+1, 0) + 1;
 				if (t < r ) r = t;
 			}
 		}
 	}
 	return r;
 }
 
 int main()
 {
 	int cc,ca;
 	int i,j,k;
 	cin >> ca;
 	for(cc=1; cc<=ca; cc++)
 	{
 		cin >> M >> V;
 		for(i=1; i<=(M-1)/2; i++)
 		{
 			int a,b;
 			cin >> a >> b;
 			g[i] = a;
 			v[i] = b;
 		}
 		for(;i<=M; i++)
 			cin >> v[i];
 		for(i=0; i<=10000; i++) for(j=0; j<2; j++) best[i][j] = -1;
 		int r = calc(1, V);
 		if (r == 1000000)
 			printf(αCase #%d: IMPOSSIBLEnα, cc);
 		else
 			printf(αCase #%d: %dnα, cc, r);
 	}
 }"
37401,2008,32001,Greggypoo,24439,1,buh.c,gcj/2008/32001/Greggypoo/24439/1/extracted/buh.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <ctype.h>
 
 int
 read_int(void)
 {
 	char s[1000];
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	return atoi(s);
 }
 
 char *
 read_string(void)
 {
 	char s[1000];
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	s[strcspn(s,αrnα)] = 0;
 	return strdup(s);
 }
 void
 read_int2(int *x,int *y)
 {
 	char s[1000];
 	char *p;
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	p = s;
 	*x = strtoul(p, &p, 10);
 	p++;
 	*y = strtoul(p, &p, 10);
 }
 
 void
 read_int4(int *x,int *y, int *z, int *a)
 {
 	char s[1000];
 	char *p;
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	p = s;
 	*x = strtoul(p, &p, 10);
 	p++;
 	*y = strtoul(p, &p, 10);
 	p++;
 	*z = strtoul(p, &p, 10);
 	p++;
 	*a = strtoul(p, &p, 10);
 }
 void
 read_double5(double *a,double *b,double*c,double*d,double*e)
 {
 	char s[1000];
 	char *p;
 	if (!fgets(s, 1000, stdin)) {
 		perror(αfgetsα);
 		exit(-1);
 	}
 	p = s;
 	*a = strtod(p, &p);
 	p++;
 	*b = strtod(p, &p);
 	p++;
 	*c = strtod(p, &p);
 	p++;
 	*d = strtod(p, &p);
 	p++;
 	*e = strtod(p, &p);
 }
 
 int
 read_intx(char **s)
 {
 	char *p = *s;
 	int ret;
 	while (isspace(*p)) {
 		p++;
 	}
 	ret = strtoul(p, &p, 10);
 	*s = p;
 	return ret;
 }
 
 struct {
 	char curr;		/* 1 = AND, 0 = OR */
 	char orig;
 	char changable;	
 } interiors[100000];
 char exteriors[100000];
 int M,V;
 int num_ints;
 #define LEFT(x) ((((x+1)*2)+0)-1)
 #define RIGHT(x) ((((x+1)*2)+1)-1)
 
 int compute(int node)
 {
 	int l,r;
 	if (node >= num_ints) {
 		return exteriors[node-num_ints];
 	}
 	l = compute(LEFT(node));
 	r = compute(RIGHT(node));
 	if (interiors[node].curr) {
 		return l&r;
 	} else {
 		return l|r;
 	}
 }
 
 
 int tryx(int node, int val)
 {
 	int l,r,op,x;
 	int num_changed =   1000000000;
 	int first = 1;
 	int first_changed = 1000000000;
 	int i,j;
 	if (node >= num_ints) {
 		return (compute(node) == val) ? 0 : -1;
 	}
 	l = compute(LEFT(node));
 	r = compute(RIGHT(node));
 	op = interiors[node].curr;
 	if (op) {
 		x = l&r;
 	} else {
 		x = l|r;
 	}
 	if (x == val) {
 		/* already there */
 		return 0;
 	}
 	if (interiors[node].changable) {
 		if (!op) {
 			x = l&r;
 		} else {
 			x = l|r;
 		}
 		if (x == val) {
 			return 1;
 		}
 	}
 retry: ;
 	if (op && val) {
 		/* AND, want 1 */
 		if (l) {
 			i = tryx(RIGHT(node), 1);
 			if ((i > 0) && (i < num_changed)) {
 				num_changed = i;
 			}
 		} else if (r) {
 			i = tryx(LEFT(node), 1);
 			if ((i > 0) && (i < num_changed)) {
 				num_changed = i;
 			}
 		} else {
 			i = tryx(RIGHT(node), 1);
 			if ((i > 0) && (i < num_changed)) {
 				j = tryx(LEFT(node), 1);
 				if (j > 0) {
 					i += j;
 					if ((i > 0) && (i < num_changed)) {
 						num_changed = i;
 					}
 				}
 			}
 		}
 	} else if (op && !val) {
 		i = tryx(LEFT(node), 0);
 		if ((i > 0) && (i < num_changed)) {
 			num_changed = i;
 		}
 		i = tryx(RIGHT(node), 0);
 		if ((i > 0) && (i < num_changed)) {
 			num_changed = i;
 		}
 	} else if (!op && val) {
 		i = tryx(LEFT(node), 1);
 		if ((i > 0) && (i < num_changed)) {
 			num_changed = i;
 		}
 		i = tryx(RIGHT(node), 1);
 		if ((i > 0) && (i < num_changed)) {
 			num_changed = i;
 		}
 	} else if (!op && !val) {
 		if (!l) {
 			i = tryx(RIGHT(node), 0);
 			if ((i > 0) && (i < num_changed)) {
 				num_changed = i;
 			}
 		} else if (!r) {
 			i = tryx(LEFT(node), 0);
 			if ((i > 0) && (i < num_changed)) {
 				num_changed = i;
 			}
 		} else {
 			i = tryx(RIGHT(node), 0);
 			if ((i > 0) && (i < num_changed)) {
 				j = tryx(LEFT(node), 0);
 				if (j > 0) {
 					i += j;
 					if ((i > 0) && (i < num_changed)) {
 						num_changed = i;
 					}
 				}
 			}
 		}
 	}
 	if (interiors[node].changable && first) {
 		first = 0;
 		first_changed = num_changed;
 		num_changed = 1000000000;
 		op = !op;
 		goto retry;
 	}
 	if (!first) {
 		num_changed++;
 		if (first_changed < num_changed) {
 			num_changed = first_changed;
 		}
 	}
 	if (num_changed == 1000000000) {
 		return -1;
 	}
 	return num_changed;
 }
 
 int main(void)
 {
 	int N = read_int();
 	int i,j,k;
 	for (i = 0; i < N; i++) {
 		char buf[10000];
 		char *s = buf;
 		fgets(buf, 1000, stdin);
 		M = read_intx(&s);
 		V = read_intx(&s);
 		num_ints = (M-1)/2;
 		for (j = 0; j < num_ints; j++) {
 			fgets(buf, 1000, stdin);
 			s=buf;
 			interiors[j].curr = interiors[j].orig = read_intx(&s);
 			interiors[j].changable = read_intx(&s);
 		}
 		for (j = 0; j < (M+1)/2; j++) {
 			exteriors[j] = read_int();
 		}
 		k = tryx(0,V);
 		if (k == -1) {
 			printf (αCase #%d: IMPOSSIBLEnα, i+1);
 		} else {
 			printf (αCase #%d: %dnα, i+1,k);
 		}
 	}
 	return 0;
 }"
37511,2008,32001,Emsee,24439,1,Tree.c,gcj/2008/32001/Emsee/24439/1/extracted/Tree.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define INF 999999999
 
 inline int max(int a, int b) {return a>b ? a : b;}
 inline int min(int a, int b) {return a<b ? a : b;}
 inline int norm(int a) {return min(INF, a);}
 
 typedef struct
 {
 	int type;
 	int l,r;
 	int inspect0;
 	int inspect1;
 
 } Node;
 Node Tree[20000];
 
 
 inline int inspectAND(int X, int V)
 {
 	if(V)
 		return norm(inspect(Tree[X].l, 1) + inspect(Tree[X].r, 1));
 	else
 		return min(inspect(Tree[X].l, 0), inspect(Tree[X].r, 0));
 }
 
 inline int inspectOR(int X, int V)
 {
 	if(V)
 		return min(inspect(Tree[X].l, 1), inspect(Tree[X].r, 1));
 	else
 	{
 		return norm(inspect(Tree[X].l, 0) + inspect(Tree[X].r, 0));
 	}
 }
 
 int inspect(int X, int V)
 {
 	if (V == 0 && Tree[X].inspect0 != -1) return Tree[X].inspect0;
 	if (V == 1 && Tree[X].inspect1 != -1) return Tree[X].inspect1;
 
 	// Leaf case already precomputed
 	
 	int ret;
 
 	if(Tree[X].type & 1) // changeable
 	{
 		if(Tree[X].type & (1<<1))
 			ret = min(inspectAND(X, V), inspectOR(X,V)+1);
 		else
 			ret = min(inspectAND(X, V)+1, inspectOR(X,V));
 	}
 	else
 	{
 		if(Tree[X].type & (1<<1))
 			ret = inspectAND(X, V);
 		else
 			ret = inspectOR(X,V);
 	}
 	
 	if(V)
 		return Tree[X].inspect1 = ret;
 	else
 		return Tree[X].inspect0 = ret;
 }
 
 inline void process()
 {
 	int M, V;
 	scanf(α%d %dα, &M, &V);
 
 	int i;
 	int G, C, L;
 	int parent;
 	for (i = 0; i < (M-1)/2; i ++)
 	{
 		scanf(α%d %dα, &G, &C);
 		Tree[i].type = 0 + (G<<1) + (C<<0);
 		Tree[i].inspect1 = -1;
 		Tree[i].inspect0 = -1;
 		if(i)
 		{
 			if ((i+1)&1)
 			{
 				Tree[(i-1)/2].r = i;
 			} else
 			{
 				Tree[(i-1)/2].l = i;
 			}
 		}
 	}
 
 	for (; i < M; i ++)
 	{
 		scanf(α%dα, &L);
 		parent = (i-1)/2;
 		Tree[i].type = 1<<2;
 		Tree[i].l = L;
 		if(L == 0)
 		{
 			Tree[i].inspect0 = 0;
 			Tree[i].inspect1 = INF;
 		}
 		else
 		{
 			Tree[i].inspect0 = INF;
 			Tree[i].inspect1 = 0;
 		}
 
 		if ((i+1)&1)
 			Tree[parent].r = i;
 		else
 			Tree[parent].l = i;
 	}
 	/*
 	for(i = 0; i < M; i ++)
 	{
 		printf(αNode %i α,i);
 		if (Tree[i].type & (1<<2))
 		{
 			printf(αleaf %inα, Tree[i].l);
 			continue;
 		}
 		if(Tree[i].type & (1<<1))
 			printf(αAND α);
 		else
 			printf(αOR α);
 
 		if(Tree[i].type & (1<<0))
 			printf(αchangeable α);
 
 		printf(α; Left %i α, Tree[i].l);
 		printf(αRight %i α, Tree[i].r);
 
 		printf(αnα);
 	}*/
 
 	int ret = inspect(0, V);
 
 	if(ret == INF)
 		printf(αIMPOSSIBLEnα);
 	else
 		printf(α%inα, ret);
 }
 
 int main()
 {
 	int N;
 	scanf(α%dα,&N);
 
 	int i;
 	for(i = 0; i < N; i ++)
 	{
 		printf(αCase #%i: α, i+1);
 		process();
 	}
 }"
37745,2008,32001,LayCurse,24439,1,a.c,gcj/2008/32001/LayCurse/24439/1/extracted/a.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 #define INF 1000000
 
 int n,n1,n2;
 int target;
 int type[20000], change[20000]; /* type=1 and, type=0 or */
 int value[20000];
 int opt0[20000],opt1[20000];
 
 void solve(int node){
   int i,j,k;
   int tmp0,tmp1;
 
   if(opt0[node]>=0) return;
 
   if(node>=n1){
     if(value[node]==0){opt0[node]=0; opt1[node]=INF;}
     else              {opt0[node]=INF; opt1[node]=0;}
     return;
   }
 
   opt0[node]=opt1[node]=INF;
   solve(node*2+1); solve(node*2+2);
 
   tmp0 = opt0[node*2+1] + opt0[node*2+2];
   if(opt0[node] > tmp0) opt0[node]=tmp0;
 
   tmp1 = opt1[node*2+1] + opt1[node*2+2];
   if(opt1[node] > tmp1) opt1[node]=tmp1;
 
   tmp0 = opt0[node*2+1] + opt1[node*2+2];
   tmp1 = opt1[node*2+1] + opt0[node*2+2];
   if(tmp0 > tmp1) tmp0 = tmp1; tmp1=tmp0;
 
   if(type[node]==0) if(opt1[node] > tmp0) opt1[node]=tmp0;
   if(type[node]==1) if(opt0[node] > tmp0) opt0[node]=tmp0;
   
   if(change[node]){
     if(opt0[node] > tmp0+1) opt0[node]=tmp0+1;
     if(opt1[node] > tmp0+1) opt1[node]=tmp0+1;
   }
 }
 
 int main(){
   int i,j,k,l,m;
   int size,count=0;
 
   scanf(α%dα,&size);
   while(size--){
     scanf(α%d%dα,&n,&target);
     n1=(n-1)/2; n2=(n+1)/2;
 
     rep(i,n1){
       scanf(α%d%dα,&j,&k);
       type[i]=j; change[i]=k;
     }
     REP(i,n1,n){
       scanf(α%dα,&j);
       value[i]=j;
     }
 
     rep(i,n) opt0[i]=opt1[i]=-1;
     
     solve(0);
 
     printf(αCase #%d: α,++count);
 
     if(target==0) m=opt0[0]; else m=opt1[0];
     if(m>=INF) puts(αIMPOSSIBLEα);
     else printf(α%dnα,m);
     
   }
 
   return 0;
 }"
37748,2008,32001,LayCurse,24442,1,d.c,gcj/2008/32001/LayCurse/24442/1/extracted/d.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 char in[60000];
 int len,k,per;
 
 int opt[16][70000][16];
 int pre[16][16];
 
 int solve(int st,int p,int last){
   int i,j,res=0,tmp;
 
   if(opt[st][p][last]>=0) return opt[st][p][last];
 
   if(p==0){
     REP(i,1,per) if(in[(i-1)*k+last]==in[i*k+st]) res++;
     opt[st][p][last]=res; return res;
   }
 
   rep(i,k) if(p&(1<<i)){
     tmp = solve(st,p^(1<<i),i);
     tmp += pre[last][i];
     if(res<tmp) res=tmp;
   }
 
   opt[st][p][last]=res; return res;
 }
 
 int main(){
   int i,j,l,m,n,p;
   int a,b;
   int res;
   int size,count=0;
 
   scanf(α%dα,&size);
   while(size--){
     fprintf(stderr,α%dnα,size);
     scanf(α%d%sα,&k,in);
     for(i=0;;i++) if(in[i]<' ') break; len=i;
     per = len/k;
 
     rep(a,k) rep(b,k){
       pre[a][b]=0;
       rep(j,per) if(in[j*k+a]==in[j*k+b]) pre[a][b]++;
     }
 
     res=0; p=(1<<k)-1;
     rep(i,k) rep(j,p) rep(m,k) opt[i][j][m]=-1;
     rep(i,k){
       j = solve(i,p^(1<<i),i);
       if(res<j) res=j;
     }
     
     printf(αCase #%d: %dnα,++count,len-res);
   }
   
   return 0;
 }"
38132,2008,32001,palas,24439,1,a.c,gcj/2008/32001/palas/24439/1/extracted/a.c,"#include <stdio.h>
 #include <math.h>
 
 long long int expo[28];
 
 int arbol[20000][2];
 
 int M, V; //nnodos
 
 double bas;
 
 int fila(int celda)
 {
   return floor(log(celda)/bas) + 1;
 }
 /*
 int celda_subarbol(int celda, int nivel, int subcelda)
 {
   int nuevafila;
   int viejacelda;
   int viejafila;
   viejafila = fila(celda);
   nuevafila = viejafila + nivel;
   viejacelda = celda - expo[viejafila - 1];
   return expo[nuevafila - 1] + viejacelda * subcelda;
 }
 */
 int numero_movimientos(int celda, int deseado)
 {
   int celda_s = celda - 1;
   int total = 0;
   int sub_a = 0;
   int sub_b = 0;
   if ((arbol[celda_s][0] == 2) && (arbol[celda_s][1] != deseado)) return 20000;
   if ((arbol[celda_s][0] == 2) && (arbol[celda_s][1] == deseado)) return 0;
   sub_a = numero_movimientos(celda * 2, deseado);
   sub_b = numero_movimientos(celda * 2 + 1, deseado);
   if ((arbol[celda_s][0] != deseado) || (((arbol[celda_s][0] == deseado) && arbol[celda_s][1] && ((sub_a > 0) || (sub_b > 0)))))
     total = (sub_a <= sub_b)?(sub_a):(sub_b);
   else total = sub_a + sub_b;
   if (total >= 20000) return 20000;
   if ((arbol[celda_s][0] == deseado) && arbol[celda_s][1] && ((sub_a > 0) || (sub_b > 0))) return total + 1;
   else return total;
 }
 
 int main(int argc, char *argv[])
 {
   bas = log(2);
   int i, j;
   int cases;
   expo[0] = 1;
   for (i = 1; i < 28; i++) expo[i] = expo[i - 1] * 2;;
   scanf(α%dnα, &cases);
 //  celda_subarbol(3, 1, 1);
   for (i = 1; i <= cases; i++)
   {
     int resultado;
     scanf(α%d %dnα, &M, &V);
     for (j = 0; j < (M - 1)/2; j++)
       scanf(α%d %dnα, &(arbol[j][0]), &(arbol[j][1]));
     for (j = ((M - 1) / 2); j < M; j++) {
       arbol[j][0] = 2;
       scanf(α%dnα, &(arbol[j][1]));
     }
     resultado = numero_movimientos(1, V); 
     if (resultado >= 20000) {
       printf(αCase #%d: IMPOSSIBLEnα, i);
     } else {
       printf(αCase #%d: %dnα, i, resultado);
     }
   }
   return 0;
 }"
38181,2008,32001,RodrigoBurgos,24439,1,a.c,gcj/2008/32001/RodrigoBurgos/24439/1/extracted/a.c,"# include <stdio.h>
 
 int n;
 int m;
 
 
 int G[ 10002 ], C[ 10002];
 int val[ 10002];
 
 int din[ 3 ][ 10002 ];
 
 int min( int a, int b){ return a < b ? a : b; }
 
 int solve( int V, int nodo ){
     int res = (1<<22), carry , X = nodo;
     if( nodo > m ) return ( val[ nodo ] == V ? 0 : (1<<22) ) ;
     if( din[ V ][ nodo ] != -1 ) return din[ V ][ nodo ];
     if( C[ nodo ] == 1){
        if( G[ nodo ] == 1 ) carry  = 0;
        else carry = 1;
           if( V == 0 ){
             res = min( solve( 0, X* 2 ) + solve( 1, X*2 + 1) + carry, res ); 
             res = min( solve( 1, X* 2 ) + solve( 0, X*2 + 1) + carry, res ); 
             res = min( solve( 0, X* 2 ) + solve( 0, X*2 + 1) + carry , res ); 
           }
           if( V == 1 ){
             res = min( solve( 1, X* 2 ) + solve( 1, X*2 + 1) + carry , res); 
           }
        
        if( G[ nodo ] == 0) carry = 0;
        else carry = 1;
           if( V == 0){
             res = min( solve( 0, X* 2 ) + solve( 0, X*2 + 1) + carry, res );             
           }    
           if( V == 1){
             res = min( solve( 0, X* 2 ) + solve( 1, X*2 + 1) + carry, res ); 
             res = min( solve( 1, X* 2 ) + solve( 0, X*2 + 1) + carry , res ); 
             res = min( solve( 1, X* 2 ) + solve( 1, X*2 + 1) + carry , res );               
           }
        
     }else{
        if( G[ nodo ] == 1 ){ // AND
           if( V == 0 ){
             res = min( solve( 0, X* 2 ) + solve( 1, X*2 + 1), res ); 
             res = min( solve( 1, X* 2 ) + solve( 0, X*2 + 1), res ); 
             res = min( solve( 0, X* 2 ) + solve( 0, X*2 + 1), res ); 
           }
           if( V == 1 ){
             res = min( solve( 1, X* 2 ) + solve( 1, X*2 + 1) , res); 
           }
        }
        if( G[ nodo ] == 0){
           if( V == 0){
             res = min( solve( 0, X* 2 ) + solve( 0, X*2 + 1), res );             
           }    
           if( V == 1){
             res = min( solve( 0, X* 2 ) + solve( 1, X*2 + 1), res ); 
             res = min( solve( 1, X* 2 ) + solve( 0, X*2 + 1), res ); 
             res = min( solve( 1, X* 2 ) + solve( 1, X*2 + 1), res );               
           }
        }
     }
     return din[ V ][ nodo ] = res;
 }
 
 
 main(){
   int casos, r, x, pos, set, v; 
   freopen(αa2.inα,αrα, stdin);
   freopen(αa2.outα,αwα, stdout);
   
   for( scanf(α%dα, &casos), set = 1 ; set <= casos ; set++ ){
      scanf(α%d %dα, &n, &v);
      m = (n - 1) / 2;
      for( pos = 1, x = 0; x < m; x++, pos++){
         scanf(α%d %dα, &G[pos], &C[ pos ]);
      }
      for(  x = 0; pos <= n; x++, pos++){
         scanf(α%dα, &val[ pos ]);
      }
      memset( din, -1, sizeof( din ));
      r = solve(v, 1 );
      printf(αCase #%d: α, set);
      if( r == (1<<22)) printf(αIMPOSSIBLEnα);
      else printf(α%dnα, r );
   }
   return 0; 
 }"
38536,2008,32001,greafine,24439,1,A.c,gcj/2008/32001/greafine/24439/1/extracted/A.c,"#include <stdio.h>
 #include <string.h>
 
 #define MAXM 10123
 #define INF 10*MAXM
 
 #define Min(a,b) ((a)<(b)?(a):(b))
 
 /* 1 = AND */
 int G[MAXM], C[MAXM], L[MAXM], LC[MAXM];
 
 int memo[MAXM][5];
 
 int eval(int u, int m, int v) {
   int res = INF;
 
   if (u >= (m+1)/2) {
     if (v == L[u-1-(m-1)/2])
       return 0;
     else
       return INF;
   }
   
   if (memo[u][v] != -1)
     return memo[u][v];
 
   if (G[u-1] == 1) {
     if (v == 1)
       res = Min(res, eval(2*u, m, 1) + eval(2*u+1, m, 1));
     if (v == 0) {
       int a, b, c;
       a = eval(2*u, m, 0) + eval(2*u+1, m, 0);
       b = eval(2*u, m, 0) + eval(2*u+1, m, 1);
       c = eval(2*u, m, 1) + eval(2*u+1, m, 0);
       res = Min(res, Min(a, Min(b, c)));
     }
   } else {
     if (v == 0)
       res = Min(res, eval(2*u, m, 0) + eval(2*u+1, m, 0));
     if (v == 1) {
       int a, b, c;
       a = eval(2*u, m, 1) + eval(2*u+1, m, 1);
       b = eval(2*u, m, 0) + eval(2*u+1, m, 1);
       c = eval(2*u, m, 1) + eval(2*u+1, m, 0);
       res = Min(res, Min(a, Min(b, c)));
     }
   }
 
   if (C[u-1]) {
     G[u-1] = (G[u-1]+1)%2;
 
     /*  */
     if (G[u-1] == 1) {
       if (v == 1)
 	res = Min(res, eval(2*u, m, 1) + eval(2*u+1, m, 1) +1);
       if (v == 0) {
 	int a, b, c;
 	a = eval(2*u, m, 0) + eval(2*u+1, m, 0) +1;
 	b = eval(2*u, m, 0) + eval(2*u+1, m, 1) +1;
 	c = eval(2*u, m, 1) + eval(2*u+1, m, 0) +1;
 	res = Min(res, Min(a, Min(b, c)));
       }
     } else {
       if (v == 0)
 	res = Min(res, eval(2*u, m, 0) + eval(2*u+1, m, 0) +1);
       if (v == 1) {
 	int a, b, c;
 	a = eval(2*u, m, 1) + eval(2*u+1, m, 1) +1;
 	b = eval(2*u, m, 0) + eval(2*u+1, m, 1) +1;
 	c = eval(2*u, m, 1) + eval(2*u+1, m, 0) +1;
 	res = Min(res, Min(a, Min(b, c)));
       }
     }
     /*  */
 
     G[u-1] = (G[u-1]+1)%2;
   }
 
   return memo[u][v] = res;
 }
  
 int main() {
   int t, cases = 1;
   int m, v, i, k, nchang, res;
   int a, modf;
 
   scanf(α%dα, &t);
   while (t--) {
     scanf(α%d%dα, &m, &v);
 
     nchang = 0;
     for (i = 0; i < (m-1)/2; i++) {
       scanf(α%d%dα, &G[i], &C[i]);
       if (C[i]) LC[nchang++] = i;
     }
     for (i = 0; i < (m+1)/2; i++)
       scanf(α%dα, &L[i]);
 
 /*     res = 1000000; */
 /*     for (a = 0; a < (1<<nchang); a++) { */
 /*       modf = 0; */
 
 /*       for (k = 0; k < nchang; k++) */
 /* 	if (a & (1<<k)) { */
 /* 	  G[LC[k]] = (G[LC[k]]+1)%2; */
 /* 	  modf++; */
 /* 	} */
 
 /*       if (eval(1, m) == v) */
 /* 	if (modf < res) res = modf; */
 
 /*       for (k = 0; k < nchang; k++) */
 /* 	if (a & (1<<k)) */
 /* 	  G[LC[k]] = (G[LC[k]]+1)%2; */
 /*     } */
 
     memset(memo, -1, sizeof(memo));
     res = eval(1, m, v);
     
     printf(αCase #%d: α, cases++);
     if (res >= INF)
       printf(αIMPOSSIBLEnα);
     else printf(α%dnα, res);
   }
 
   return 0;
 }"
39139,2008,32001,Desmond,24439,1,A.c,gcj/2008/32001/Desmond/24439/1/extracted/A.c,"#include <stdio.h>
 
 int N, M, V, G[10000], C[10000], I[10000], req[10000];
 
 int smin(int n) {
     int min1 = 0, min2 = 0, min3 = 0;
     if (n > (M-1)/2) {
         if (req[n] != I[n])
             return 10000;
         else
             return 0;
     }
     if (req[n] == I[n])
         return 0;
     if (C[n] == 0) {
         if (req[n] == 0) {
             if (G[n] == 0)
                 min1 = min2 = 10000;
             else {
                 req[2*n] = 0; req[2*n+1] = 1;
                 min1 += smin(2*n) + smin(2*n+1);
                 req[2*n] = 1; req[2*n+1] = 0;
                 min2 += smin(2*n) + smin(2*n+1);
             }
             req[2*n] = 0; req[2*n+1] = 0;
             min3 += smin(2*n) + smin(2*n+1);
         }
         if (req[n] == 1) {
             if (G[n] == 1)
                 min1 = min2 = 10000;
             else {
                 req[2*n] = 0; req[2*n+1] = 1;
                 min1 += smin(2*n) + smin(2*n+1);
                 req[2*n] = 1; req[2*n+1] = 0;
                 min2 += smin(2*n) + smin(2*n+1);
             }
             req[2*n] = 1; req[2*n+1] = 1;
             min3 += smin(2*n) + smin(2*n+1);
         }
     }
     if (C[n] == 1) {
         if (req[n] == 0) {
             if (G[n] == 0)
                 min1 = min2 = 1;
             req[2*n] = 0; req[2*n+1] = 1;
             min1 += smin(2*n) + smin(2*n+1);
             req[2*n] = 1; req[2*n+1] = 0;
             min2 += smin(2*n) + smin(2*n+1);
             req[2*n] = 0; req[2*n+1] = 0;
             min3 += smin(2*n) + smin(2*n+1);
         }
         if (req[n] == 1) {
             if (G[n] == 1)
                 min1 = min2 = 1;
             req[2*n] = 0; req[2*n+1] = 1;
             min1 += smin(2*n) + smin(2*n+1);
             req[2*n] = 1; req[2*n+1] = 0;
             min2 += smin(2*n) + smin(2*n+1);
             req[2*n] = 1; req[2*n+1] = 1;
             min3 += smin(2*n) + smin(2*n+1);
         }
     }
     if (min1 <= min2 && min1 <= min3)
         return min1;
     else if (min2 <= min1 && min2 <= min3)
         return min2;
     else
         return min3;
 }
 
 int main(void) {
     FILE *fin = fopen(αA.inα, αrα);
     FILE *fout = fopen(αA.outα, αwα);
     int i, j, min;
     
     fscanf(fin, α%dα, &N);
     for (i = 1; i <= N; i++) {
         fscanf(fin, α%d %dα, &M, &V);
         for (j = 1; j <= (M-1)/2; j++)
             fscanf(fin, α%d %dα, &G[j], &C[j]);
         for (j = (M-1)/2+1; j <= M; j++)
             fscanf(fin, α%dα, &I[j]);
         for (j = (M-1)/2; j >= 1; j--) {
             if (G[j] == 0) {
                 if (I[2*j] == 1 || I[2*j+1] == 1)
                     I[j] = 1;
                 else
                     I[j] = 0;
             }
             else {
                 if (I[2*j] == 1 && I[2*j+1] == 1)
                     I[j] = 1;
                 else
                     I[j] = 0;
             }
         }
         req[1] = V;
         min = smin(1);
         fprintf(fout, αCase #%d: α, i);
         if (min >= 10000)
             fprintf(fout, αIMPOSSIBLEnα);
         else
             fprintf(fout, α%dnα, min);
     }
     
     return 0;
 }"
39177,2008,32001,HenryW,24439,1,a.c,gcj/2008/32001/HenryW/24439/1/extracted/a.c,"#include<stdio.h>
 
 #define OUTSTREAM stdout
 
 int N,M,V;
 int changable[10001];
 int minChg[2][10001];
 int type[10001];
 
 int tryChg(int l, int r, int p, int add) {
   int nChg = minChg[l][p*2] + minChg[r][p*2+1] + add;
   int result;
   if ((type[p]+add)%2 == 1) { // AND
     result = l & r;
   }
   else {
     result = l | r;
   }
 
   if (minChg[result][p] > nChg) {
     minChg[result][p]= nChg;
   }
 
   return;
 }
 
 void print() {
   int j;
   return;
   for (j=1;j<=M;j++)
     printf(α(%d, %d)nα,minChg[0][j],minChg[1][j]);
 
   printf(αnα);
 }
 
 int getMin() {
   int k;
   int lIdx, rIdx;
   int j;
   int nChg;
 
   for (j=(M-1)/2; j>=1; j--) {
     for (k=0;k<4;k++) {
       lIdx = k/2;
       rIdx = k%2;
 
       if (minChg[lIdx][j*2] == 99999 ||
 	  minChg[rIdx][j*2+1] == 99999)
 	continue;
 
       nChg = tryChg (lIdx, rIdx, j, 0);
       if (changable[j])
 	nChg = tryChg (lIdx, rIdx, j, 1);
     }
 
     print();
   }
 
   return minChg[V][1];
 }
 
 void main() {
   FILE *in=fopen(αinput.txtα,αrα);
   FILE *out=fopen(αoutput.txtα,αwα);
   long i,j;
   int tmp, min;
   
   fscanf(in,α%dα,&N);
   for (i=0;i<N;i++) {
     fscanf(in,α%d %dα,&M, &V);
     
     for (j=1;j<=(M-1)/2;j++) {
       minChg[0][j] = 99999;
       minChg[1][j] = 99999;
       fscanf(in,α%d %dα, &type[j], &changable[j]);
     }
 
     for (j=1;j<=(M+1)/2;j++) {
       fscanf(in,α%dα,&tmp);
       minChg[0][j+(M-1)/2] = minChg[1][j+(M-1)/2] = 99999;
       minChg[tmp][j+(M-1)/2] = 0;
     }
     
     print();
     min=getMin();
     
     fprintf(OUTSTREAM,αCase #%ld: α,i+1);
     if (min == 99999)
       fprintf(OUTSTREAM, αIMPOSSIBLEnα);
     else
       fprintf(OUTSTREAM, α%dnα, min);
   }
 }"
39904,2008,32017,rompel,24489,1,mt.c,gcj/2008/32017/rompel/24489/1/extracted/mt.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 #include <ctype.h>
 
 
 inline static double fsqr(double x) { return x*x; }
 inline static int isqr(int x) { return x*x; }
 inline static int imin(int x, int y) { return x<y ? x : y; }
 inline static int imax(int x, int y) { return x>y ? x : y; }
 
 
 static int split(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       while(*x && strchr(r, *x))
           x++;
       if(!*x)
           break;
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 static int splitn(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
   char buf[100];
 
   fgets(buf, 100, stdin);
   assert(1==sscanf(buf,α%dnα, &N));
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 
 void do_one_case(int cnum)
 {
   int K, N, r, d;
   int p, k, i;
 
   printf(αCase #%d:α, cnum);
   scanf(α%dnα, &K);
   scanf(α%dα, &N);
   for(r=0; r<N; r++)
     {
       scanf(α%dα, &d);
       p = 0;
       k = K;
       for(i=1; i<=K; i++)
         {
           p += i;
           if(p>k)
             {
               p = 1 + ((p-1)%k);
             }
           if(p==d)
             {
               printf(α %dα, i);
               break;
             }
           else if(p<d)
               d--;
           p--;
           k--;
         }
     }
   printf(αnα);
 }"
39906,2008,32017,rompel,24485,1,ns.c,gcj/2008/32017/rompel/24485/1/extracted/ns.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 #include <assert.h>
 #include <ctype.h>
 
 
 inline static double fsqr(double x) { return x*x; }
 inline static int isqr(int x) { return x*x; }
 inline static int imin(int x, int y) { return x<y ? x : y; }
 inline static int imax(int x, int y) { return x>y ? x : y; }
 
 
 static int split(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       while(*x && strchr(r, *x))
           x++;
       if(!*x)
           break;
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 static int splitn(char *s, int m, char **v, char *r)
 {
   int n=0;
   char *x;
 
   for(x=s;;)
     {
       assert(n<m);
       v[n++] = x;
       while(*x && !strchr(r, *x))
           x++;
       if(!*x)
           break;
       *x++ = 0;
     }
   return n;
 }
 
 
 
 
 void do_one_case(int);
 
 
 int main(int argc, char **argv)
 {
   int N, cnum;
   char buf[100];
 
   fgets(buf, 100, stdin);
   assert(1==sscanf(buf,α%dnα, &N));
 
   for(cnum=1; cnum<=N; cnum++)
     {
       do_one_case(cnum);
     }
 
   return 0;
 }
 
 #define MAX 1001000
 static int head[MAX];
 
 void collapse(int n)
 {
   int x, y, z;
 
   for(x=n; head[x]!=x;)
       x = head[x];
   for(y=n; head[y]!=y;)
     {
       z = head[y];
       head[y] = x;
       y = z;
     }
 }
 
 void do_one_case(int cnum)
 {
   long long A, B, P0;
   int D, p, f, P;
   int i, n, x, y, z;
 
   assert(3==scanf(α%lld %lld %lldnα, &A, &B, &P0));
 
   D = B-A+1;
   for(i=0; i<D; i++)
       head[i] = i;
   P = (P0>D) ? D : P0;
 
   for(p=P; p<D; p++)
     {
       if(p>2 && (p&1)==0)
           continue;
       for(f=3; f*f<=p; f+=2)
           if(p%f == 0)
               break;
       if(f*f <= p)
           continue;
 
       x = p - (A%p);
       if(x==p) x=0;
 
       collapse(x);
       z = head[x];
       for(y=x+p; y<D; y+=p)
         {
           //fprintf(stderr, α%lld %lldnα, A+x, A+y);
           collapse(y);
           head[head[y]] = z;
         }
     }
 
   for(i=0; i<D; i++)
       collapse(i);
 
   for(i=n=0; i<D; i++)
       if(head[i]==i)
         {
           //fprintf(stderr, α%lld α, A+i);
           n++;
         }
 
   printf(αCase #%d: %dnα, cnum, n);
 }"
40533,2008,32017,Yao,24437,1,a.c,gcj/2008/32017/Yao/24437/1/extracted/a.c,"#include<stdio.h>
 #include<string.h>
 
 int r[3][3];
 
 int main() {
     int x,y,a,b,c,d,n,m,N,i,j,l,k,cs=0;
     long long ret;
 
     for(scanf(α%dα,&N);N--;) {
         scanf(α%d %d %d %d %d %d %d %dα,&n,&a,&b,&c,&d,&x,&y,&m);
         memset(r,0,sizeof(r));
         ret=0;
         for(i=0;i<n;i++) {
             r[x%3][y%3]++;
             x=((long long)a*x+b)%m;
             y=((long long)c*y+d)%m;
         }
         for(i=0;i<3;i++)
             for(j=0;j<3;j++) {
                 for(k=0;k<3;k++)
                     for(l=0;l<3;l++)
                         if (k!=i || l!=j) {
                             x=(6-i-k)%3,y=(6-j-l)%3;
                             if ((x!=i || y!=j) && (x!=k || y!=l)) 
                                 ret+=(long long)r[i][j]*r[k][l]*r[x][y];
                             else ret+=(long long)r[i][j]*r[k][l]*(r[x][y]-1)/2;
                         }
                 ret+=(long long)r[i][j]*(r[i][j]-1)*(r[i][j]-2);
             }
         printf(αCase #%d: %lldnα,++cs,ret/6);
     }
     return 0;
 }"
40535,2008,32017,Yao,24489,1,c.c,gcj/2008/32017/Yao/24489/1/extracted/c.c,"#include<stdio.h>
 
 int main() {
     int N,cs=0;
     int K,d,n,i,j;
 
     for(scanf(α%dα,&N);N--;) {
         scanf(α%dα,&K);
         scanf(α%dα,&n);
         printf(αCase #%d:α,++cs);
         for(;n--;) {
             scanf(α%dα,&d);
             for(d--,i=1;i<=K;i++) {
                 d=((d-i)%(K-i+1)+K-i+1)%(K-i+1);
                 if (d==K-i) break;
             }
             printf(α %dα,i);
         }
         puts(αα);
     }
     return 0;
 }"
40537,2008,32017,Yao,24485,1,b.c,gcj/2008/32017/Yao/24485/1/extracted/b.c,"#include<stdio.h>
 #include<string.h>
 
 #define MAXN 1000000
 
 char b[MAXN+1];
 int p[80000];
 int np;
 
 void init() { 
     int i,j; 
     for(i=2;i<MAXN;i++) { 
         if (!b[i]) p[np++]=i; 
         for(j=0;j<np && i*p[j]<MAXN;j++) { 
             b[i*p[j]]=1; 
             if (i%p[j]==0) break; 
         }
     } 
 } 
 
 int u[MAXN+1];
 int cnt;
 int top(int k) {
     return u[k]<0?k:(u[k]=top(u[k]));
 }
 void uu(int tt1,int tt2) {
     int t1=top(tt1),t2=top(tt2);
     if (t1!=t2) u[t2]=t1,cnt--;
 }
 
 int main() {
     int N,cs=0;
     int i;
     long long a,b,pp,j;
 
     init();
     for(scanf(α%dα,&N);N--;) {
         scanf(α%lld %lld %lldα,&a,&b,&pp);
         memset(u,0xff,sizeof(u));
         cnt=b-a+1;
         for(i=0;i<np;i++)
             if (p[i]>=pp) {
                 for(j=(a+p[i]-1)/p[i]*p[i];j+p[i]<=b;j+=p[i])
                     uu(j-a,j+p[i]-a);
             }
         printf(αCase #%d: %dnα,++cs,cnt);
     }
     return 0;
 }"
41112,2008,32017,ledia,24437,1,a.c,gcj/2008/32017/ledia/24437/1/extracted/a.c,"#include <stdio.h>
 
 void InitCategory(int cat[])
 {
     int i;
     for(i=0;i<9;i++)
         cat[i] = 0;
 }
 
 void AddCategory(int cat[], long long int x, long long int y)
 {
     int nx = (int)(x % 3);
     int ny = (int)(y % 3);
 
     cat[nx * 3 + ny]++;
 }
 long long int CountCategory(int cat[])
 {
     int i, j, k;
     int used_time[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
     long long int ans = 0;
 
     for (i=0;i<9;i++)
         for (j=i;j<9;j++)
             for (k=j;k<9;k++)
                 if ( (i/3 + j/3 + k/3) % 3 == 0 &&
                      (i%3 + j%3 + k%3) % 3 == 0)
                 {
                     long long int temp_count = 1;
 
                     temp_count *= cat[i] - used_time[i];
                     used_time[i]++;
                     temp_count /= used_time[i];
                     temp_count *= cat[j] - used_time[j];
                     used_time[j]++;
                     temp_count /= used_time[j];
                     temp_count *= cat[k] - used_time[k];
                     used_time[k]++;
                     temp_count /= used_time[k];
 
                     ans += temp_count;
                     #ifdef DEBUG
                     if( temp_count != 0)
                         printf(α%d %d %d -> %dnα, i, j, k, temp_count);
                     #endif
                     used_time[i]--;
                     used_time[j]--;
                     used_time[k]--;
                 }
     return ans;
 }
 
 int main(void)
 {
     int n, i;
     long long int A, B, C, D;
     long long int x0, y0;
     long long int M;
     int category[9];
     int ncase = 0;
     int icase;
 
     scanf(α%dα, &ncase);
 
     for (icase = 1; icase <= ncase; icase++)
     {
         InitCategory(category);
         scanf(α%d%lld%lld%lld%lld%lld%lld%lldα,
                 &n, &A, &B, &C, &D, &x0, &y0, &M);
         AddCategory(category, x0, y0);
         #ifdef DEBUG
         printf(α%lld, %lld, %lld, %lld, %lldnα, A, B, C, D, M);
         printf(α%lld, %lldnα, x0, y0);
         #endif
         for(i=1;i<n;i++)
         {
             x0 = (A*x0 + B) % M;
             y0 = (C*y0 + D) % M;
             #ifdef DEBUG
             printf(α%lld, %lldnα, x0, y0);
             #endif
             AddCategory(category, x0, y0);
         }
         #ifdef DEBUG
         for(i=0;i<9;i++)
             printf(α%d α, category[i]);
         printf(αnα);
         #endif
         printf(αCase #%d: %lldnα, icase, CountCategory(category));
     }
 
     return 0;
 }"
42632,2008,32017,srkiboy,24437,1,A.c,gcj/2008/32017/srkiboy/24437/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define MaxN 100010
 
 typedef struct
 {
       long long x, y;
 } tree_t;
 
 int cmp (const void *a, const void *b)
 {
    tree_t *x = (tree_t *) a;
    tree_t *y = (tree_t *) b;
 
    if (x->x > y->x)
       return 1;
    if (x->x < y->x)
       return -1;
    if (x->y > y->y)
       return 1;
    if (x->y < y->y)
       return -1;
    return 0;
 }
 
 int main ()
 {
    tree_t tree[MaxN];
    int t, testCase, p1, p2, q1, q2, s1, s2, x, y, s;
    long long i, n, A, B, C, D, M, sols[3][3], sol;
 
    scanf(α%dnα, &t);
    for (testCase = 1; testCase <= t; testCase++)
    {
       for (x = 0; x < 3; x++)
          for (y = 0; y < 3; y++)
             sols[x][y] = 0;
 
       scanf(α%lld %lld %lld %lld %lld %lld %lld %lldnα, &n, &A, &B, &C, &D, &tree[0].x, &tree[0].y, &M);
 
       for (i = 1; i < n; i++)
       {
          tree[i].x = (A*tree[i-1].x+B)%M;
          tree[i].y = (C*tree[i-1].y+D)%M;
       }
 
       for (i = 0; i < n; i++)
       {
          tree[i].x %= 3;
          tree[i].y %= 3;
       }
       for (i = 0; i < n; i++)
          sols[tree[i].x][tree[i].y]++;
 
       sol = 0;
       for (x = 0; x < 8; x++)
       {
          for (y = x + 1; y < 9; y++)
          {
             p1 = x / 3;
             p2 = x % 3;
             q1 = y / 3;
             q2 = y % 3;
             s1 = (9-p1-q1)%3;
             s2 = (9-p2-q2)%3;
             s = 3*s1 + s2;
             if (s <= y)
                continue;
             sol += sols[p1][p2]*sols[q1][q2]*sols[s1][s2];
          }
       }
       for (x = 0; x < 9; x++)
       {
          p1 = x / 3;
          p2 = x % 3;
          sol += sols[p1][p2]*(sols[p1][p2]-1)*(sols[p1][p2]-2)/6;
 
       }
 
       printf(αCase #%d: %lldnα, testCase, sol);
    }
    return 0;
 }"
42673,2008,32017,yannis,24437,1,a.c,gcj/2008/32017/yannis/24437/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 
 struct point {
 	long long x, y;
 } t[111111];
 
 long long cnt[3][3];
 
 int main(void) {
 	freopen(αinput.txtα, αrα, stdin);
 	int i, j, k, m, n, test, T, N, x0, y0;
 	long long A, B, C, D, M, p, q, ans, cans;
 	
 	scanf(α%dα, &T);
 	
 	for(test=1; test<=T; test++) {
 		scanf(α%d %lld %lld %lld %lld %d %d %lldα, &N, &A, &B, &C, &D, &x0, &y0, &M);
 		
 		ans = 0;
 		
 		p = x0; q = y0;
 		t[1].x = p;
 		t[1].y = q;
 		for (i=2; i<=N; i++) {
 			p = (A * p + B) % M;
 			q = (C * q + D) % M;
 			t[i].x = p;
 			t[i].y = q;
 		}
 		
 		for (i=0; i<=2; i++) {
 			for (j=0; j<=2; j++) {
 				cnt[i][j] = 0;
 			}
 		}
 		
 		for (i=1; i<=N; i++) {
 			cnt[ t[i].x % 3 ][ t[i].y % 3 ]++;
 		}
 		
 		for (i=1; i<=N; i++) {
 			cnt[ t[i].x % 3 ][ t[i].y % 3 ]--;
 			cans = 0;
 			for (j=0; j<=2; j++) for (k=0; k<=2; k++) {
 				for (m=0; m<=2; m++) for (n=0; n<=2; n++) {
 					if ( (t[i].x%3 + j + m)%3 == 0 && (t[i].y%3 + k + n)%3 == 0) {
 						if ( j == m && k == n ) cans += cnt[j][k] * (cnt[j][k] - 1);
 						else cans += cnt[j][k] * cnt[m][n];
 					}
 				}
 			}
 
 			cans /= 2;
 			ans += cans;
 		}
 		
 		printf(αCase #%d: %lldnα, test, ans);
 	}
 
 	return 0;
 }"
42676,2008,32017,yannis,24485,1,b.c,gcj/2008/32017/yannis/24485/1/extracted/b.c,"#include <stdio.h>
 #include <stdlib.h>
 
 char isprime[1000010];
 int p[1000010], rank[1000010], un[1000010];
 
 long long min(long long a, long long b) { return ( a < b ? a : b ); }
 
 int ask(int w) {
 	int i;
 	
 	for (i=2; i*i <= w; i++) {
 		if ( w%i == 0 ) return 0;
 	}
 	
 	return 1;
 }
 
 int Find(int x) {
 	if ( p[x] != x ) p[x] = Find(p[x]);
 	return p[x];
 }
 
 int Union(int x, int y) {
 	x = Find(x); y = Find(y);
 	
 	if ( rank[x] > rank[y] ) {
 		p[y] = x;
 	}
 	else {
 		p[x] = y;
 		if ( rank[x] == rank[y] ) rank[y]++;
 	}
 }
 
 long long gcd(long long a, long long b) {
 	if ( b == 0 ) return a;
 	return gcd(b, a%b);
 }
 
 int main(void) {
 	freopen(αinput.txtα, αrα, stdin);
 	int T, test;
 	long long i, j, k, A, B, P, ans;
 	
 	for (i=2; i<=1000000; i++) isprime[i] = ask(i);
 	
 	scanf(α%dα, &T);
 	for(test=1; test<=T; test++) {
 		scanf(α%lld %lld %lldα, &A, &B, &P);
 		
 		for (i=A; i<=B; i++) {
 			p[i - A] = i-A;
 			rank[i - A] = 0;
 		}
 		
 		for (k=P; k<=min(1000000,B-A+2); k++) {
 			if ( !isprime[k] ) continue;
 			
 			i = A + (k - A%k)%k;
 			if ( i > B ) continue;
 			
 			for (j=i; j<=B; j+=k) {
 				if ( j%k == 0 ) {
 					Union(i-A, j-A);
 				}
 			}
 		}
 		
 		for (i=A; i<=B; i++) {
 			Find(i-A);
 			un[i-A] = 0;
 		}
 		
 		ans = 0;
 		for (i=A; i<=B; i++) {
 			if ( !un[ p[i - A] ] ) {
 				un[ p[i - A] ] = 1;
 				ans++;
 			}
 		}
 		
 		printf(αCase #%d: %dnα, test, ans);
 	}
 	
 	return 0;
 }"
42767,2008,32017,Desmond,24437,1,A.c,gcj/2008/32017/Desmond/24437/1/extracted/A.c,"#include <stdio.h>
 
 int N, n, A, B, C, D, x0, y0, M;
 int xy[200003][2];
 int nxy[3][3];
 long long ans;
 
 
 int main(void) {
     FILE *fin = fopen(αA.inα, αrα);
     FILE *fout = fopen(αA.outα, αwα);
     int i, j, k, tmpx, tmpy;
     
     fscanf(fin, α%dα, &N);
     for (i = 1; i <= N; i++) {
         for (j = 0; j < 200003; j++)
             xy[j][0] = xy[j][0] = -1;
         for (j = 0; j < 3; j++)
             for (k = 0; k < 3; k++)
                 nxy[j][k] = 0;
         ans = 0;
         fscanf(fin, α%d %d %d %d %d %d %d %dα, &n, &A, &B, &C, &D, &x0, &y0, &M);
         for (j = 0; j < n; j++) {
             k = (x0 + y0) % 200003;
             while (xy[k][0] > -1 && (xy[k][0] != x0 || xy[k][1] != y0)) {
                 k++;
                 k %= 200003;
             }
             if (xy[k][0] == -1) {
                 xy[k][0] = x0;
                 xy[k][1] = y0;
                 tmpx = x0 % 3;
                 tmpy = y0 % 3;
             }
             else
                 tmpx = 3;
             if (tmpx < 3) {
                 nxy[tmpx][tmpy]++;
                 if (nxy[tmpx][tmpy] >= 3)
                     ans += (long long) (nxy[tmpx][tmpy]-1) * (nxy[tmpx][tmpy]-2) / 2;
                 if (nxy[tmpx][(tmpy+1)%3] >= 1 && nxy[tmpx][(tmpy+2)%3] >= 1)
                     ans += (long long) nxy[tmpx][(tmpy+1)%3] * nxy[tmpx][(tmpy+2)%3];
                 if (nxy[(tmpx+1)%3][tmpy] >= 1 && nxy[(tmpx+2)%3][tmpy] >= 1)
                     ans += (long long) nxy[(tmpx+1)%3][tmpy] * nxy[(tmpx+2)%3][tmpy];
                 if (nxy[(tmpx+1)%3][(tmpy+1)%3] >= 1 && nxy[(tmpx+2)%3][(tmpy+2)%3] >= 1)
                     ans += (long long) nxy[(tmpx+1)%3][(tmpy+1)%3] * nxy[(tmpx+2)%3][(tmpy+2)%3];
                 if (nxy[(tmpx+2)%3][(tmpy+1)%3] >= 1 && nxy[(tmpx+1)%3][(tmpy+2)%3] >= 1)
                     ans += (long long) nxy[(tmpx+2)%3][(tmpy+1)%3] * nxy[(tmpx+1)%3][(tmpy+2)%3];
             }
             x0 = ((long long) A * x0 + B) % M;
             y0 = ((long long) C * y0 + D) % M;
         }
         fprintf(fout, αCase #%d: %I64dnα, i, ans);
     }
     
     return 0;
 }"
43241,2008,32005,LayCurse,24457,1,c.c,gcj/2008/32005/LayCurse/24457/1/extracted/c.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 #define EPS 1e-8
 
 double dp[70000], next[70000];
 
 int main(){
   int i,j,k,l,m,n,node,round;
   int size,count=0;
   int s;
   int target=1000000;
   double p,res,per,sum,opt,tmp1,tmp2,tmp;
   int a,b,c1,c2;
 
   scanf(α%dα,&size);
   while(size--){
     fprintf(stderr,α%dnα,size);
     scanf(α%d%lf%dα,&n,&p,&s);
     node = (1<<n) + 1;
     rep(i,node) dp[i]=0; dp[node-1]=1;
     rep(round,n){
       rep(i,node) next[i]=0;
 
       rep(i,node){
         a=0; b=i; if(b > node-1-i) b = node-1-i;
         while(a >= b+10){
           c1 = (a+a+b)/3; c2 = (a+b+b)/3;
           tmp1 = p*dp[i+c1] + (1-p)*dp[i-c1];
           tmp2 = p*dp[i+c2] + (1-p)*dp[i-c2];
           if(tmp1 > tmp2) b=c2; else a=c1;
         }
         opt=0;
         REP(k,a,b+1){
           tmp = p*dp[i+k] + (1-p)*dp[i-k];
           if(opt < tmp) opt = tmp;
         }
         next[i]=opt;
       }
       
       rep(i,node) dp[i]=next[i];
     }
     per = (double) target / (node - 1); sum = 0;
     rep(i,node-1){
       sum += per;
       if( (double) s < sum - EPS) break;
     }
     res = dp[i];
     printf(αCase #%d: %0.8lfnα,++count,res);
   }
 
   return 0;
 }"
43243,2008,32005,LayCurse,24456,1,a.c,gcj/2008/32005/LayCurse/24456/1/extracted/a.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 int main(){
   int i,j,k,l,m,n,q;
   int size,count=0;
   char tmp[10000];
   int a[2000],b[2000],c[2000]; char in[2000];
   int a_min,a_max,b_min,b_max;
   int c_min,c_max,d_min,d_max;
   int x,y;
   
   scanf(α%dα,&size);
   while(size--){
     scanf(α%d α,&n);
     printf(αCase #%d:nα,++count);
     rep(i,n){
       gets(tmp); sscanf(tmp,α%d%d%sα,a+i,b+i,in);
       if(in[0]=='B') c[i]=0; else c[i]=1;
     }
 
     a_min = b_min = c_max = d_max = 100000000;
     a_max = b_max = c_min = d_min = -a_min;
     rep(i,n) if(c[i]==0){
       if(a_min > a[i]) a_min = a[i]; if(a_max < a[i]) a_max = a[i];
       if(b_min > b[i]) b_min = b[i]; if(b_max < b[i]) b_max = b[i];
     }
 
     rep(i,n) if(c[i]==1){
       if(a_min <= a[i] && a[i] <= a_max){
         if(b[i] > b_max && d_max > b[i]) d_max = b[i];
         if(b[i] < b_min && d_min < b[i]) d_min = b[i];
       }
       if(b_min <= b[i] && b[i] <= b_max){
         if(a[i] > a_max && c_max > a[i]) c_max = a[i];
         if(a[i] < a_min && c_min < a[i]) c_min = a[i];
       }
     }
     
     scanf(α%dα,&q);
     while(q--){
       scanf(α%d%dα,&x,&y);
       
       rep(i,n) if(a[i]==x && b[i]==y){
         if(c[i]==0) puts(αBIRDα); else puts(αNOT BIRDα);
         break;
       }
       if(i<n) continue;
 
       if(a_min <= x && x <= a_max && b_min <= y && y <= b_max){
         puts(αBIRDα); continue;
       }
 
       if( x>=c_max || x<=c_min || y>=d_max || y<=d_min ){
         puts(αNOT BIRDα); continue;
       }
 
       rep(i,n) if(c[i]==1){
         if(a[i] > a_max && x < a[i]) continue;
         if(a[i] < a_min && x > a[i]) continue;
         if(b[i] > b_max && y < b[i]) continue;
         if(b[i] < b_min && y > b[i]) continue;
         puts(αNOT BIRDα); break;
       }
       if(i<n) continue;
 
       puts(αUNKNOWNα);
     }
   }
 
   return 0;
 }"
43245,2008,32005,LayCurse,24455,1,b.c,gcj/2008/32005/LayCurse/24455/1/extracted/b.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 #define N 50
 #define INF 1000000000
 
 int x,y;
 int sx,sy;
 int opt;
 int mp[N][N];
 
 int dx[4]={-1,0,0,1}, dy[4]={0,-1,1,0};
 
 void solve(int depth){
   int i,j,k,d;
   int ni,nj;
   int cp[N][N];
 
   if(mp[sx][sy]<=0) return;
   if(opt < depth) opt = depth;
 
   k=0;
   rep(d,4){
     ni = sx+dx[d]; nj = sy+dy[d];
     if(ni<0 || nj<0 || ni>=x || nj>=y) continue;
     if(mp[ni][nj] > 0) k++;
   }
   if(k==0) {opt=INF; return;}
   if(opt==INF) return;
 
 /*  printf(αdepth %d, rest %dnα,depth,k);
   rep(i,x){rep(j,y) printf(α%03d α,mp[i][j]); puts(αα);}
 */
   rep(i,x) rep(j,y) cp[i][j]=mp[i][j];
   rep(i,x) rep(j,y){
     if(i==sx && j==sy) continue;
     if(cp[i][j]<=0) continue;
 
     k=0;
     rep(d,4){
       ni = i+dx[d]; nj = j+dy[d];
       if(ni<0 || nj<0 || ni>=x || nj>=y) continue;
       if(k < cp[ni][nj]) k=cp[ni][nj];
     }
     if(k==0) continue;
     rep(d,4){
       ni = i+dx[d]; nj = j+dy[d];
       if(ni<0 || nj<0 || ni>=x || nj>=y) continue;
       if(k == cp[ni][nj]) {mp[ni][nj] -= cp[i][j]; break;}
     }
   }
 
   solve(depth+1);
   rep(d,4){
     ni = sx+dx[d]; nj = sy+dy[d];
     if(ni<0 || nj<0 || ni>=x || nj>=y) continue;
     mp[ni][nj] -= cp[sx][sy];
     solve(depth+1);
     mp[ni][nj] += cp[sx][sy];
   }
 
   rep(i,x) rep(j,y) mp[i][j]=cp[i][j];
 }
 
 int main(){
   int i,j,k,l,m,n;
   int size,count=0;
 
   scanf(α%dα,&size);
   while(size--){
     scanf(α%d%d%d%dα,&y,&x,&sy,&sx); sx--; sy--;
     rep(i,x) rep(j,y) scanf(α%dα,mp[i]+j);
     opt=0; solve(0);
 
     printf(αCase #%d: α,++count);
     if(opt >= INF) puts(αforeverα);
     else printf(α%d day(s)nα,opt);
   }
 
   return 0;
 }"
44179,2008,32011,LayCurse,24473,1,c.c,gcj/2008/32011/LayCurse/24473/1/extracted/c.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 int x,y;
 int mp[5][5];
 int now[5][5];
 int res;
 
 int ok(int i,int j){
   int ii,jj;
   int nx,ny;
   int num=0;
 
   REP(ii,-1,2) REP(jj,-1,2){
     nx=i+ii; ny=j+jj;
     if(nx<0 || ny<0 || nx>=x || ny>=y) continue;
     if(now[nx][ny]) num++;
   }
   if(num == mp[i][j]) return 1; return 0;
 }
 
 int rest(int i,int j, int fg){
   int ii,jj;
   int nx,ny;
   int num=0;
 
   REP(ii,-1,2) REP(jj,-1,2){
     nx=i+ii; ny=j+jj;
     if(nx<0 || ny<0 || nx>=x || ny>=y) continue;
     if( (fg==1 && nx==0) || (fg==2 && ny==0) ){
       if(now[nx][ny]) num++;
     }
   }
   return mp[i][j] - num;
 }
 
 int ab(int x){
   if(x<0) return -x; return x;
 }
 
 void solve(int i,int j){
   int a,b,k,tmp;
 
   if(i==x){
     tmp=0;
     rep(a,x) rep(b,y) if(!ok(a,b)) return;
     rep(b,y) tmp += now[x/2][b];
     if(res < tmp) res = tmp;
     return;
   }
 
   if(i==0 && j>2){
     if( ab( rest(0,j-3,1) - rest(0,j-2,1) ) > 1 ) return;
   }
   if(j==0 && i>2){
     if( ab( rest(i-3,0,2) - rest(i-2,0,2) ) > 1 ) return;
   }
   
   if(j==y) {solve(i+1,0); return;}
 
   now[i][j]=1; if(!i || !j || ok(i-1,j-1)) solve(i,j+1);
   now[i][j]=0; if(!i || !j || ok(i-1,j-1)) solve(i,j+1);
 }
 
 int main(){
   int i,j,k,l,m,n;
   int size,count=0;
 
   scanf(α%dα,&size);
   while(size--){
     fprintf(stderr,αrest input = %dnα,size);
     res=0;
     scanf(α%d%dα,&x,&y);
     rep(i,x) rep(j,y) scanf(α%dα,mp[i]+j);
     solve(0,0);
 
     printf(αCase #%d: %dnα,++count,res);
   }
 
   return 0;
 }"
44182,2008,32011,LayCurse,24472,1,a.c,gcj/2008/32011/LayCurse/24472/1/extracted/a.c,"#include<stdio.h>
 #define REP(i,a,b) for(i=a;i<b;i++)
 #define rep(i,n) REP(i,0,n)
 
 int u1[10001],u2[10001],u3[10001];
 int sum[10001][10001];
 
 int aa[5000], bb[5000], cc[5000];
 int ind[10001];
 int hai[100000];
 
 int main(){
   int i,j,k,l,m,n,r,jj;
   int a,b,c;
   int size,count=0;
   int res,add;
 
   scanf(α%dα,&size);
   while(size--){
     fprintf(stderr,αrest input = %dnα,size);
 
     rep(i,10001) rep(j,10001) sum[i][j]=0; add=0;
     scanf(α%dα,&n);
     rep(i,n) scanf(α%d%d%dα,aa+i,bb+i,cc+i);
 
     rep(i,10001) u1[i]=u2[i]=0;
     rep(i,n) u1[aa[i]]=u2[bb[i]]=1;
 
     rep(i,10000) hai[i]=10001;
     rep(i,10001) ind[i]=0;
     if(u2[0]){ ind[0]=1; hai[1]=0; }
     REP(i,1,10001){ ind[i]=ind[i-1]; if(u2[i]) {ind[i]++; hai[ind[i]]=i; } }
 
     rep(r,n){
       a=aa[r], b=bb[r], c=cc[r];
       if(a==0 && b==0 && c==0) {add++; continue;}
       REP(i,a,10001) if(u1[i]) for(jj=ind[b];;jj++){
         j=hai[jj];
         if(10000 - i - j < c) break;
         sum[i][j]++;
       }
     }
     res=0;
     rep(i,10001) rep(j,10001) if(res < sum[i][j]) res=sum[i][j];
     printf(αCase #%d: %dnα,++count,res+add);
   }
 
   return 0;
 }"
44421,2008,32015,ujjwal,24486,1,1.c,gcj/2008/32015/ujjwal/24486/1/extracted/1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 
 void swap(int *x, int i, int j) {
     int t = x[i];
     x[i] = x[j];
     x[j] = t;
 }
 
 int randint(int l, int u) {
     return rand()%(u-l+1)+l;
 }
 
 void quicksort(int *x, int l, int u) {
     int i, m;
     if (l >= u) return;
     swap(x, l, randint(l, u));
     m = l;
     for (i = l+1; i <= u; i++)
         if (x[i] > x[l])
             swap(x, ++m, i);
     swap(x, l, m);
     quicksort(x, l, m-1);
     quicksort(x, m+1, u);
 }
 
 
 int main()
 {
 	int i,j,n,k,p,l,a,b;
 	long long int sum;
 	int freq[2000];
 
 	scanf(α%dα, &n);
 
 	for(i=0;i<n;i++)
 	{
 		scanf(α %d %d %dα, &p, &k, &l);
 
 		for(j=0;j<l;j++)
 			scanf(α %dα, &freq[j]);
 
 		quicksort(freq, 0, l-1);
 
 		for(j=0,sum=0;j<l;j++)
 		{
 //			printf(αXing %d and %dnα, ((j/k)+1), freq[j]);
 			sum += (long long int)((j/k)+1)*freq[j];
 		}
 
 		printf(αCase #%d: %lldnα, i+1, sum);	
 	}
 
 	return 0;
 }"
44547,2008,32015,chin33z,24486,1,mylib.c,gcj/2008/32015/chin33z/24486/1/extracted/mylib.c,"#include <iostream>
 #include <string>
 #include <stdlib.h>
 #include <sstream>
 #include <fstream>
 #include <math.h>
 
 
 #include <utility>
 #include <iterator>
 #include <algorithm>
 #include <assert.h>
 #include <memory>
 #include <iomanip>  //setw()
 
 //STL container
 #include <vector>
 #include <map>
 #include <list>
 #include <deque>
 
 #define For(i,begin,end) for(int i(begin),_b(end); i <= _b; i++)  	//begin ~ end
 #define Ford(i,begin,end) for(int i(begin),_b(end); i >= _b; i--) 	//begin ~ end
 #define Rep(i,num) for(int i(0),_b(num); i < _b; i++) 			//0 ~ num-1
 #define Repd(i,num) for(int i((num)-1),_b(0); i >= _b; i--) 		//num-1 ~ 0
 #define MP(x,y) make_pair((x),(y))
 //#define All(v) (v).begin(),(v).end()
 #define viAll(name,it) for(vector<int>::iterator it((name).begin()); it!=(name).end(); it++ )
 #define vdAll(name,it) for(vector<double>::iterator it((name).begin()); it!=(name).end(); it++ )
 #define vsAll(name,it) for(vector<string>::iterator it((name).begin()); it!=(name).end(); it++ )
 
 #define liAll(name,it) for(list<int>::iterator it((name).begin()); it!=(name).end(); it++ )
 #define ldAll(name,it) for(list<double>::iterator it((name).begin()); it!=(name).end(); it++ )
 #define lsAll(name,it) for(list<string>::iterator it((name).begin()); it!=(name).end(); it++ )
 
 
 using namespace std;
 
 void StringSplit2Long(string, string, vector<long>&);
 void StringSplit2Int(string, string, vector<int>&);
 void StringSplit(string, string, vector<string>&);
 void StringSplit2Doub(string, string, vector<double>&);
 
 /**
 int main(int argc, char *argv[]){
 	string str=α23 54 1 543 86 0 76α;
 	vector<int> numbers;
 	int m(0),a(5);
 	StringSplit2Int(str,α α,numbers);
 	for (int i(0); i<numbers.size(); i++)
 		cout<<numbers[i]<<α α;
 	cout<<endl;
 	return 0;
 }
 **/
 
 
 void StringSplit(string str, string delim, vector<string>& results){
 	results.clear();
 	int cutAt;
 	while ((cutAt = str.find_first_of(delim)) != str.npos ){
 		if (cutAt > 0)	results.push_back(str.substr(0,cutAt));
 		str = str.substr(cutAt+1);
 	}
 	if (str.length() > 0)	results.push_back(str);
 }
 
 void StringSplit2Int(string str, string delim, vector<int>& out){
 	out.clear();
 	vector<string> results;
 	StringSplit(str,delim,results);
 	//string to int
 	for (int i=0;i < results.size(); i++ )	
 		out.push_back(atoi(results[i].c_str()));
 }
 
 void StringSplit2Long(string str, string delim, vector<long>& out){
 	out.clear();
 	vector<string> results;
 	StringSplit(str,delim,results);
 	//string to int
 	for (int i=0;i < results.size(); i++ )	
 		out.push_back(atol(results[i].c_str()));
 }
 
 void StringSplit2Doub(string str, string delim, vector<double>& out){
 	out.clear();
 	vector<string> results;
 	StringSplit(str,delim,results);
 	//string to double
 	for (int i=0;i < results.size(); i++ )	
 		out.push_back(atof(results[i].c_str()));
 }"
44548,2008,32015,chin33z,24486,1,test.c,gcj/2008/32015/chin33z/24486/1/extracted/test.c,"//#define NDEBUG   //disable assert(),must put befor include<assert.h>
 
 //if all the inputs are fix length and tpye known ---> cin
 //if there exist variant inputs length ----> getline(cin,tmp_str) or getline() after each cin
 
 #include α../../../lib/mylib.cα
 
 int main (int argc, char* argv[]){
 	int num;
 	string tmp_str;
 	long max_num,key_num,let_num,tmp_sum,flag,total;
 	vector<long> vec;
 	//redirect (in/out)put stream
 //	freopen(αfile.inα,αrtα,stdin);
 //	freopen(αfile.outα,αwtα,stdout);
 
 	//get cases number
 	cin>>num;		//when fixed format & fixed inputs amount, use this
 	getline(cin,tmp_str);	//must exist, for the next use of getline
 	
 
 	//solve for each cases
 	for(int i=1; i<=num; i++){
 		cin>> max_num>>key_num>>let_num;
 		getline(cin,tmp_str);
 
 		getline(cin,tmp_str);
 		StringSplit2Long(tmp_str,α α,vec);
 
 		sort(vec.begin(),vec.end());
 		reverse(vec.begin(),vec.end());
 	
 	//	Rep(j,vec.size())
 	//		cout<<vec[j]<<α α;
 	//	cout<<endl;
 	
 		tmp_sum=0;
 		total=0;
 		flag=1;
 		Rep(j,let_num){
 			tmp_sum+=vec[j];
 			if (j%key_num == key_num - 1){
 				total+=flag*tmp_sum;
 				tmp_sum=0;
 				flag++;
 			}
 		}
 		total+=flag*tmp_sum;
 	
 		cout<<αCase #α<<i<<α: α<<total<<endl;
 	}
 
 
 	return 0;
 }"
44638,2008,32015,sao3,24486,1,A.c,gcj/2008/32015/sao3/24486/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int p, k, l;
 int x[1001];
 long long ans;
 
 int cmp(const void *a, const void *b){
 	return *(int *)b - *(int *)a;
 }
 
 int go(){
 	int i;
 	ans = 0;
 	scanf(α%d%d%dα, &p, &k, &l);
 	if(p * k < l)
 		return 0;
 	for(i = 0; i < l; i++){
 		scanf(α%dα, &x[i]);
 	}
 	qsort(x, l, sizeof(int), cmp);
 	for(i = 0; i < l; i++){
 		ans += (i / k + 1) * x[i];
 	}
 	return 1;
 }
 
 int main(){
 	int cs, c;
 	freopen(αA.inα, αrα, stdin);
 	freopen(αA.outα, αwα, stdout);
 	scanf(α%dα, &cs);
 	for(c = 1; c <= cs; c++){
 		if(go()){
 			printf(αCase #%d: %I64dnα, c, ans);
 		}
 		else{
 			printf(αCase #%d: Impossiblenα, c);
 		}
 	}
 	return 0;
 }"
44728,2008,32015,zhangjc,24486,1,a.c,gcj/2008/32015/zhangjc/24486/1/extracted/a.c,"#include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 #include<math.h>
 
 //                printf(α%dnα,k);
 //               scanf(α%dα,&n);
 //              printf(αCase #%d: α,i+1);
 
 
 
 int Cmpdep(const void *a,const void *b)
 {
 
 	return *(int *)b-*(int *)a;
 
 }
 
 
 
 int main()
 {
 
 	int n,p,k,l,a[1000],m,t,s,i,j,pp;
 	double sum=0;
 
 	scanf(α%dα,&n);
 
 	for(i=0;i<n;i++)
 	{
 
 		scanf(α%dα,&p);
 
 		scanf(α%dα,&k);
 		scanf(α%dα,&l);
 	for(j=0;j<l;j++)
 		{
 			scanf(α%dα,&a[j]);
 		}
 		qsort(a,l,sizeof(int),Cmpdep);
 		
 		m=l/k;
 		j=1;
 	
 			for(s=0;s<m;s++)
 		{
 			
 		
 			for(pp=s*k;pp<s*k+k;pp++)	
 			sum+=(a[pp]*j);
 			j++;
 		}
 
 		for(t=m*k;t<l;t++)
 			sum+=a[t]*j;
 
 		 printf(αCase #%d: %.0fnα,i+1,sum);
 		 sum=0;
 	}
 
 
 
 
 
 
 
 
 
 	
 
 
 
 
 	return 0;
 }"
45062,2008,32015,joliveirinha,24486,1,a.c,gcj/2008/32015/joliveirinha/24486/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 #define MAX 1000000
 
 int data[MAX];
 
 int cmp(const void *a, const void *b) {
 	int *x = (int *) a;
 	int *y = (int *) b;
 
 	return *y - *x;
 }
 
 int main(void) {
 
 	int i, ncases, p, k, l, j;
 	long long total;
 
 	scanf(α%dα, &ncases);
 
 	for (i=0;i<ncases;i++) {
 		scanf(α%d%d%dα, &p, &k, &l);
 		for (j=0;j<l;j++)
 			scanf(α%dα, &data[j]);
 
 		qsort(data, l, sizeof(int), cmp);
 
 		total = 0;
 		for (j=0;j<l;j++) {
 			total += data[j]*((int)floor(j/k)+1);
 		}
 
 		printf(αCase #%d: %lldnα, i+1, total);
 	}
 
 	return 0;
 }"
45434,2008,32015,PotatoChip,24486,1,TMO.c,gcj/2008/32015/PotatoChip/24486/1/extracted/TMO.c,"/*****************************************************/
 /* Date : 2008.07.27                                 */
 /* Author : HHJeon                                   */
 /* Description : Google Code Jam, Round 1C,          */
 /*               Text Messaging Outrage              */
 /*****************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 #define RET_OK 1
 #define RET_ERROR -1
 
 /*###################################################*/
 #define MAX_SUM_DIGIT 15
 #define MAX_DIGIT 7
 
 int ProcTMO(FILE *fpInFile, FILE *fpOutFile);
 
 #define SWAP(x,y,z) ((z)=(x), (x)=(y), (y)=(z))
 int SimpleSortDSC(long *pFreq, int nCount);
 
 int ConvertDecimal2Array(long nDec, char *arrFreq);
 int MultiplyArray(char *arrFreq, char *arrArg, char *arrMul);
 int SumArray(char *arrMin, char *arrMul);
 /*###################################################*/
 
 int main(int argc, char* argv[])
 {
 	FILE *fpInFile, *fpOutFile;
 	char *sOutFileName = NULL;
 	int nOutFileNameSize = 0;
 	
 	/*+--------------------------------------------------*/
 	if(argc != 2)
 	{
 		if(NULL != strrchr(argv[0], '\'))
 		{
 			printf(αUsage %s input_filenα, strrchr(argv[0], '\') + 1);
 		}
 		else
 		{
 			printf(αUsage %s input_filenα, argv[0]);
 		}
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	nOutFileNameSize = strlen(argv[1]) + 5;
 	sOutFileName = (char *)malloc(sizeof(char) * nOutFileNameSize);
 	if(sOutFileName == NULL)
 	{
 		printf(αInsufficient memory availablenα);
 		return RET_ERROR;
 	}
 	memset(sOutFileName, 0, nOutFileNameSize);
 	sprintf(sOutFileName, α%s.outα, argv[1]);
 	/*---------------------------------------------------*/	
 
 	/*+--------------------------------------------------*/
 	fpInFile = (FILE *)fopen(argv[1], αrα);
 	if(fpInFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, argv[1]);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*+--------------------------------------------------*/
 	fpOutFile = (FILE *)fopen(sOutFileName, αwα);
 	if(fpOutFile == NULL)
 	{
 		printf(αThe file '%s' was not openednα, sOutFileName);
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 
 	/*###################################################*/
 	if(RET_ERROR == ProcTMO(fpInFile, fpOutFile))
 	{
 		printf(αError.nα);
 	}
 	/*###################################################*/
 
 	/*+--------------------------------------------------*/
 	fclose(fpOutFile);
 
 	fclose(fpInFile);
 
 	free(sOutFileName);
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int ProcTMO(FILE *fpInFile, FILE *fpOutFile)
 {
 	int n = 0;
 	int i = 0, j = 0;
 	long nCount = 0;
 	int nP = 0, nK = 0, nL = 0;
 	long *pFreq = NULL;
 //	long nMin = 0;
 	char arrFreq[MAX_DIGIT], arrArg[MAX_DIGIT];
 	char arrMin[MAX_SUM_DIGIT], arrMul[MAX_SUM_DIGIT];
 	int nStartFlag = 0;
 
 	/*+--------------------------------------------------*/
 	if(EOF == fscanf(fpInFile, α%ldnα, &nCount))
 	{
 		return RET_ERROR;
 	}
 	/*---------------------------------------------------*/
 	
 	/*+--------------------------------------------------*/
 	for(n = 0; n < nCount; n++)
 	{
 		fscanf(fpInFile, α%d %d %dnα, &nP, &nK, &nL);
 
 		pFreq = (long*)malloc(sizeof(long) * nL);
 		memset(pFreq, 0x00, sizeof(long) * nL);
 
 		for(i = 0; i < nL; i++)
 		{
 			fscanf(fpInFile, α%dα, &pFreq[i]);
 		}
 
 		SimpleSortDSC(pFreq, nL);
 
 //		nMin = 0;
 		memset(arrMin, 0x00, MAX_SUM_DIGIT);
 		for(i = 0; i < nL; i++)
 		{
 			memset(arrFreq, 0x00, MAX_DIGIT);
 			memset(arrArg, 0x00, MAX_DIGIT);
 			memset(arrMul, 0x00, MAX_SUM_DIGIT);
 
 //			nMin += pFreq[i] * (i/nK + 1);
 			ConvertDecimal2Array(pFreq[i], arrFreq);
 			ConvertDecimal2Array(i/nK + 1, arrArg);
 
 			MultiplyArray(arrFreq, arrArg, arrMul);
 
 			if(i == 0)
 			{
 				memcpy(arrMin, arrMul, MAX_SUM_DIGIT);
 			}
 			else
 			{
 				SumArray(arrMin, arrMul);
 			}	
 		}
 
 //		fprintf(fpOutFile, αCase #%d: %ldnα, n+1, nMin);
 		nStartFlag = 0;
 		fprintf(fpOutFile, αCase #%d: α, n+1);
 		for(i = MAX_SUM_DIGIT - 1; i >= 0; i--)
 		{
 			if(nStartFlag == 0 && arrMin[i] == 0)
 			{
 				//skip
 			}
 			else
 			{
 				nStartFlag = 1;
 				fprintf(fpOutFile, α%dα, (int)arrMin[i]);
 			}
 		}
 		if(nStartFlag == 0)
 		{
 			fprintf(fpOutFile, α0α);
 		}
 		fprintf(fpOutFile, αnα);
 
 		/*+--------------------------------------------------*/
 		if(pFreq != NULL)
 		{
 			free(pFreq);
 			pFreq = NULL;
 		}
 		/*---------------------------------------------------*/
 	}
 	/*---------------------------------------------------*/
 
 	return RET_OK;
 }
 
 int SimpleSortDSC(long *pFreq, int nCount)
 {
     long i, j, temp, flag;
 
     for(i = 0; i < nCount-1; i++)
     {
         flag = 0;
         for(j = 0; j < nCount-1-i; j++)
 		{
             if(pFreq[j] < pFreq[j+1])
             {
                 SWAP(pFreq[j], pFreq[j+1], temp);
 				SWAP(pFreq[j], pFreq[j+1], temp);
 				SWAP(pFreq[j], pFreq[j+1], temp);
                 flag = 1;
             }
 		}
         if(flag == 0)
 		{
 			break;
 		}
     }
 
 	return RET_OK;
 }
 
 int ConvertDecimal2Array(long nDec, char *arrFreq)
 {
 	int i = 0;
 	int nDigit = 0;
 
 	for(i = 0; ; i++)
 	{
 		if(nDec / 10 > 0)
 		{
 			arrFreq[i] = nDec % 10;
 		}
 		else
 		{
 			arrFreq[i] = (char)nDec;
 			break;
 		}
 
 		nDec = nDec / 10;
 	}
 
 	return RET_OK;
 }
 
 int MultiplyArray(char *arrFreq, char *arrArg, char *arrMul)
 {
 	int i = 0, j = 0, k = 0, l = 0;
 	int nFreqDigit = 0, nArgDigit = 0;
 	int nNum = 0;
 
 	for(i = 0; i < MAX_DIGIT; i++)
 	{
 		if(arrFreq[i] != 0)
 		{
 			nFreqDigit = i + 1;
 		}
 	}
 	for(i = 0; i < MAX_DIGIT; i++)
 	{
 		if(arrArg[i] != 0)
 		{
 			nArgDigit = i + 1;
 		}
 	}
 	
 	for(i = 0; i < nFreqDigit; i++)
 	{
 		for(j = 0; j < nArgDigit; j++)
 		{
 			k = i + j;
 			nNum = arrFreq[i] * arrArg[j];
 			if(arrMul[k] + nNum > 9)
 			{
 				nNum += arrMul[k];
 				arrMul[k] = nNum % 10;
 				nNum /= 10;
 				for(l = k+1; l < MAX_SUM_DIGIT; l++)
 				{
 					if(arrMul[l] + nNum > 9)
 					{
 						nNum += arrMul[l];
 						arrMul[l] = nNum % 10;
 						nNum /= 10;
 					}
 					else
 					{
 						arrMul[l] += nNum;
 						break;
 					}
 				}
 			}
 			else
 			{
 				arrMul[k] += nNum;
 			}
 		}
 	}
 
 	return RET_OK;
 }
 
 int SumArray(char *arrMin, char *arrMul)
 {
 	int i = 0, j = 0;
 
 	for(i = 0; i < MAX_SUM_DIGIT; i++)
 	{
 		if(arrMin[i] + arrMul[i] > 9)
 		{
 			arrMin[i] += arrMul[i] - 10;
 			for(j = i; j < MAX_SUM_DIGIT; j++)
 			{
 				if(arrMin[j+1] < 9)
 				{
 					arrMin[j+1]++;
 					break;
 				}
 				else
 				{
 					arrMin[j+1] = 0;
 				}
 			}
 		}
 		else
 		{
 			arrMin[i] += arrMul[i];
 		}		
 	}
 
 	return RET_OK;
 }"
45480,2008,32015,nutki,24488,1,C.c,gcj/2008/32015/nutki/24488/1/extracted/C.c,"#include <stdio.h>
 #define r 1000000007
 #define N (1<<21)
 int w[N*2];
 void ins(int x, int val) {
 	int v = N + x;
 	w[v] = (w[v] + val) % r;
 	while(v!=1) {
 		v/=2;
 		w[v] = (w[2*v] + w[2*v+1]) % r;
 	}
 }
 int query(int a, int b) {
 	int va = N + a, vb = N + b;
 	int wyn = w[va];
 	if(va != vb) wyn += w[vb], wyn %= r;
 	while(va/2 != vb/2) {
 		if(va % 2 == 0) wyn += w[va+1], wyn %= r;
 		if(vb % 2 == 1) wyn += w[vb-1], wyn %= r;
 		va /= 2; vb /= 2;
 	}
 	return wyn;
 }
 int n,c,C,i,m;
 
 
 long long int A[500005],X,Y,Z;
 int B[500005];
 //int D[500005];
 int E[500005];
 int F[500005];
 int cmp(int *a, int *b) { return B[*a]<B[*b]?-1:B[*a]>B[*b]; }
 int main() {
 	scanf(α%dα,&C);
 	for(c=1;c<=C;c++) {
 		int j;
 		long long res1 = 0;
 		scanf(α%d%d%lld%lld%lldα,&n,&m,&X,&Y,&Z);
 		memset(w,0,sizeof(w));
 		for(i=0;i<m;i++) scanf(α%dα,A+i);
 		for(i=0;i<n;i++) {
 			B[i] = A[i%m];
 			E[i] = i;
 //			printf(α%d α,B[i]);
 			A[i%m] = (X * A[i%m] + Y * (i + 1)) % Z;
 		}
 		qsort(E,n,sizeof(int),cmp);
 		int num = 0;
 		F[E[0]] = 0;
 		for(i=1;i<n;i++) {
 			num += B[E[i-1]] < B[E[i]];
 			F[E[i]] = num;
 		}
 		ins(0,1);
 		for(i=0;i<n;i++) {
 			long long res = query(0,F[i]);
 			ins(F[i]+1,res);
 			res1 += res;
 			res1 %= r;
 		}
 		printf(αCase #%d: %lldnα,c,res1);
 	}
 	return 0;
 }"
45483,2008,32015,nutki,24486,1,A.c,gcj/2008/32015/nutki/24486/1/extracted/A.c,"#include <stdio.h>
 int n,c,C,i,t[2000];
 int cmp(int *a, int *b) { return *a>*b?-1:*a<*b; };
 int main() {
 	scanf(α%dα,&C);
 	for(c=1;c<=C;c++) {
 		int p,k,l;
 		long long res = 0;
 		scanf(α%d%d%dα,&p,&k,&l);
 		for(i=0;i<l;i++) scanf(α%dα,t+i);
 		qsort(t,l,sizeof(int),cmp);
 		for(i=0;i<l;i++) res += t[i] * ((i/k)+1);
 		printf(αCase #%d: %lldnα,c,res);
 	}
 	return 0;
 }"
45489,2008,32015,tiagomt,24486,1,a1.c,gcj/2008/32015/tiagomt/24486/1/extracted/a1.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXM		1024
 #define MAXN		1024
 
 int	p;
 
 int	v[MAXN];
 int	n;
 
 int	m;
 
 int int_cmp (const void *e1, const void *e2)
 {
 	int	i1,
 		i2;
 
 	i1 = *((int *)e1);
 	i2 = *((int *)e2);
 
 	if (i1 < i2)
 	{
 		return 1;
 	}
 	if (i1 > i2)
 	{
 		return -1;
 	}
 	return 0;
 }
 
 int main (void)
 {
 	int		nc,
 			h;
 	long long	r;
 	int		i,
 			j,
 			k;
 
 	for (scanf(α%dα, &nc), h = 1; h <= nc; h++)
 	{
 		scanf(α%d%d%dα, &p, &m, &n);
 		for (i = 0; i < n; i++)
 		{
 			scanf(α%dα, &(v[i]));
 		}
 		qsort(v, n, sizeof(v[0]), int_cmp);
 		r = 0;
 		for (i = 0, j = 0, k = 1; i < n; i++)
 		{
 			r += v[i] * (long long)k;
 			j++;
 			if (j == m)
 			{
 				k++;
 				j = 0;
 			}
 		}
 		printf(αCase #%d: %I64dnα, h, r);
 	}
 
 	return 0;
 }"
45578,2008,32015,sszymczy,24486,1,tmo.c,gcj/2008/32015/sszymczy/24486/1/extracted/tmo.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int comparator(const void *e1, const void *e2) {
 	unsigned elem1 = *(unsigned*) e1;
 	unsigned elem2 = *(unsigned*) e2;
 	if(elem1 < elem2) return 1;
 	else if(elem1 > elem2) return -1;
 	else return 0;
 }
 
 int main() {
 	unsigned ncases;
 	unsigned P, K, L;
 	scanf(α%dnα, &ncases);
 	for(int ncase = 1; ncase <= ncases; ncase++) {
 		scanf(α%u %u %unα, &P, &K, &L);
 		unsigned freq[L];
 		for(int i = 0; i < L; i++) scanf(α%uα, &freq[i]);
 		qsort(freq, L, sizeof(unsigned), comparator);
 		unsigned long pushes = 0;
 		if(K * P < L) printf(αCase #%u: impossiblenα, &ncase);
 		else {
 			for(int i = 0; i < L; i++) pushes += freq[i] * (1+i/K);
 			printf(αCase #%u: %lunα, ncase, pushes);
 		}
 	}
 }"
45644,2008,32015,jovimon,24486,1,mensaje.c,gcj/2008/32015/jovimon/24486/1/extracted/mensaje.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int ncasos;
 int teclas, letras, lpt;
 int probs[1005];
 
 
 int compara( const void * a, const void * b ) {
   int * x = (int *) a;
   int * y = (int *) b;
 
   if ( *x > *y ) return -1;
   if ( *x < *y ) return 1; 
   return 0;
 }
 
 void inicializa() {
   int i;
   for ( i = 0 ; i < 1005 ; i++ )
     probs[i] = 0;
   teclas = letras = lpt = 0;
 }
 
 long comprueba() {
   int i, j;
   unsigned long long res = 0;
   for ( i = 0; i < lpt ; i++ ) {
     for ( j = 0 ; j < teclas ; j++ ) {
       if ( i*teclas+j  > letras ) return res;
       res += probs[i*teclas+j]*(i+1);
     }
   }
   return res;
 }
 
 int main ( int argc , char * argv[] ) {
   int i, j;
   unsigned long long res;
 
   scanf(α%dα, &ncasos);
   getchar();
 
   for( i = 1 ; i <= ncasos ; i++ ) {
 
     inicializa();
 
     scanf(α%d %d %dα, &lpt, &teclas, &letras);
     getchar();
 
     for ( j = 0 ; j < letras ; j++ )
       scanf(α%dα, probs+j);
     
     qsort (probs, letras, sizeof(int), compara);
 
     res = comprueba();
 
     printf(αCase #%d: %ldnα, i, res);
   }
 
   return 0;
 }"
45677,2008,32015,mmxd,24486,1,a.c,gcj/2008/32015/mmxd/24486/1/extracted/a.c,"#include <stdio.h>
 int cmp(const void *a, const void *b) {
     int *c, *d;
     c = (int *) a;
     d = (int *) b;
     if (*c > *d)    return -1;
     if (*c < *d)    return 1;
     return 0;
 }
 int main() {
     int i, j, N, P, K, L;
     int f[1000];
     long long ans;
     scanf(α%dα, &N);
     for(i = 1; i <= N; i++) {
 	ans = 0;
 	scanf(α%d %d %dα, &P, &K, &L);
 	for(j = 0; j < L; j++) {
 	    scanf(α%dα, &f[j]);
 	}
 	if (P * K < L) {
 	    printf(αCase #%d: Impossiblenα, i);
 	    continue;
 	}
 	qsort(f, L, sizeof(int), cmp);
 	for(j = 0; j < L; j++) {
 	    ans += (f[j] * (j / K + 1));
 	}
 	printf(αCase #%d: %lldnα, i, ans);
     }
     return 0;
 }"
45765,2008,32015,Chard,24486,1,a.c,gcj/2008/32015/Chard/24486/1/extracted/a.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <math.h>
 
 typedef struct QueEntryStruct
 {
     struct QueEntryStruct *NextPtr;
     struct QueEntryStruct *PrevPtr;
     unsigned long Data;
 } QUE_ENTRY_STRUCT;
 
 typedef struct QueCtrlStruct
 {
     QUE_ENTRY_STRUCT *NextPtr;
     QUE_ENTRY_STRUCT *PrevPtr;
     unsigned long Counter;
 } QUE_CTRL_STRUCT;
 
 void que_init (QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueCtrlPtr->NextPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueCtrlPtr->PrevPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueCtrlPtr->Counter = 0;
 }
 
 void que_insert_before (QUE_ENTRY_STRUCT *QueEntryPtr,
                         QUE_ENTRY_STRUCT *QueMemberPtr,
                         QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr = QueMemberPtr;
     QueEntryPtr->PrevPtr = QueMemberPtr->PrevPtr;
     QueMemberPtr->PrevPtr->NextPtr = QueEntryPtr;
     QueMemberPtr->PrevPtr = QueEntryPtr;
     QueCtrlPtr->Counter++;
 }
 
 void que_insert_at_tail (QUE_ENTRY_STRUCT *QueEntryPtr,
                          QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr = (QUE_ENTRY_STRUCT *)QueCtrlPtr;
     QueEntryPtr->PrevPtr = QueCtrlPtr->PrevPtr;
     QueCtrlPtr->PrevPtr->NextPtr = QueEntryPtr;
     QueCtrlPtr->PrevPtr = QueEntryPtr;
     QueCtrlPtr->Counter++;
 }
 
 void que_remove_from_middle (QUE_ENTRY_STRUCT *QueEntryPtr,
                              QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QueEntryPtr->NextPtr->PrevPtr = QueEntryPtr->PrevPtr;
     QueEntryPtr->PrevPtr->NextPtr = QueEntryPtr->NextPtr;
     QueCtrlPtr->Counter--;
 }
 
 QUE_ENTRY_STRUCT *que_get_head_entry (QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QUE_ENTRY_STRUCT *QueEntryPtr;
     QueEntryPtr = QueCtrlPtr->NextPtr;
     que_remove_from_middle(QueEntryPtr, QueCtrlPtr);
     return QueEntryPtr;
 }
 
 void que_insert_sorted (QUE_ENTRY_STRUCT *QueEntryPtr,
                         QUE_CTRL_STRUCT *QueCtrlPtr)
 {
     QUE_ENTRY_STRUCT *QueMemberPtr;
 
     QueMemberPtr = QueCtrlPtr->NextPtr;
     
     while(QueMemberPtr != (QUE_ENTRY_STRUCT *)QueCtrlPtr)
     {
         if (QueMemberPtr->Data <= QueEntryPtr->Data)
         {
             que_insert_before(QueEntryPtr,
                               QueMemberPtr,
                               QueCtrlPtr);
             return;
         }
         
         QueMemberPtr = QueMemberPtr->NextPtr;
     }
 
     que_insert_before(QueEntryPtr,
                       QueMemberPtr,
                       QueCtrlPtr);
 }
 
 QUE_ENTRY_STRUCT Entry[1002];
 QUE_CTRL_STRUCT List;
 
 void main (void)
 {
     // N - Number of Case
     // X - Case Idx
     unsigned long N, X;
     unsigned long P, K, L;
     unsigned long i, k, j;
     QUE_ENTRY_STRUCT *EntryPtr;
     double M;
     
     scanf(α%liα, &N);
 
     for (X=1; X<=N; X++)
     {
         scanf(α%liα, &P);
         scanf(α%liα, &K);
         scanf(α%liα, &L);
 
         que_init(&List);
 
         M = 0;
         for (i=0; i<L; i++)
         {
             scanf(α%liα, &Entry[i].Data);
             que_insert_sorted(&Entry[i], &List);
         }
             
         k=1;
         j=0;
         for (i=0; i<L; i++)
         {
             EntryPtr = que_get_head_entry(&List);
             M = M + (EntryPtr->Data * k);
             j++;
             if (j>=K)
             {
                 k++;
                 j=0;
             }
         }
 
         printf(αCase #%li: %.0lfnα, X, M);
 
     }
 }"
45886,2008,32015,Sunshi,24486,1,1a.c,gcj/2008/32015/Sunshi/24486/1/extracted/1a.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int compare(const void *a, const void *b)
 {
 	return ( *(int*)b - *(int*)a );
 }
 int main()
 {
 	int i,j,k;
 	int N;
 	int P,K,L;
 	int list[1001];
 	int c1;
 	long long sum;
 	scanf(α%dα,&N);
 	for(i=0;i<N;i++){
 		//
 		memset(list,0,1001);
 		c1=0;
 		sum=0;
 		scanf(α%d %d %dα,&P,&K,&L);
 		for(j=0;j<L;j++){
 			scanf(α%dα,&list[j]);
 			//c1++;
 		}
 		c1 = L;
 		qsort(list,L,sizeof(int),compare);
 		while(c1!=0){
 			for(k=1;k<=P;k++){
 				if(c1==0)
 					break;
 				for(j=0;j<K;j++){
 					if(c1==0)
 						break;
 					sum += (long long)k * (long long)list[L-c1];
 					c1--;
 				}
 			}
 		}
 		printf(αCase #%d: %lldnα,i+1,sum);
 	}
 	return 0;
 }"
46038,2008,32015,tsipi,24486,1,A.c,gcj/2008/32015/tsipi/24486/1/extracted/A.c,"#include <stdio.h>
 
 
 int main(){
   int cases;
   int num, keys, letters;
   int x, y, z, w;
   int pad[1001][1001];
   int letters_list[1001];
   int max, max_id;
   long res;
 
     printf(α********nα);    
   scanf(α%dα, &cases);
 
   for(x=0; x<cases; x++){
     scanf(α%d %d %dα, &num, &keys, &letters);
 
     for(y=0; y<1001; y++){
       for(w=0; w<1001; w++){
 	pad[y][w] = 0;
       }
     }
 
     for(y=0; y<letters; y++){
       scanf(α%dα, &letters_list[y]);
     }
 
     for(y=0; y<letters; y++){
       max = -1;
 
       for(z=0; z<letters; z++){
 	if(letters_list[z]>max){
 	  max = letters_list[z];
 	  max_id = z;
 	}
       }
 	
       w = 0;
       for(z=0; z<keys; z++){
 	if(pad[z][w]==0){
 	  pad[z][w] = max * (w+1);
 	  letters_list[max_id] = -1;
 	  break;
 	}
 	w++;
       }
     }
     
     res = 0;
 
     for(y=0; y<1001; y++){
       for(w=0; w<1001; w++){
 	res += pad[y][w];
       }
     }
 
 
     printf(αCase #%d: %ldnα, x+1, res);
   }
 
   return 1;
 }"
46066,2008,32015,jazzman,24486,1,r1cab.c,gcj/2008/32015/jazzman/24486/1/extracted/r1cab.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define	LMAX	10001
 
 
 long long p, k, l, n;
 long long freq[LMAX];
 long long fact, sol;
 
 
 int lcmp(const void *a, const void *b)
 {
     long long t = *(long long *)a - *(long long *)b;
     
     if (t < 0) return 1;
     if (t > 0) return -1;
     return 0;
 }
 
 void reset()
 {
     fact = 0;
     sol = 0;
 }
 
 
 int main(int argc, char **argv)
 {
     long long tc, ti;
     long long i;
     
     scanf(α%lldα, &tc);
     for (ti = 0; ti < tc; ti++) {
 	reset();
 	
 	scanf(α%lld%lld%lldα, &p, &k, &l);
 	
 	for (i = 0; i < l; i++)
 	    scanf(α%lldα, &freq[i]);
 	
 	if (p * k < l) {
 	    printf(αCase #%lld: Impossiblenα, ti + 1);
 	    continue;
 	}
 	    
 	qsort(freq, l, sizeof(long long), lcmp);
 	
 	
 	for (i = 0; i < l; i++) {
 	    if (!(i % k)) fact++;
 	    
 	    sol += freq[i] * fact;
 	}
 	
 	printf(αCase #%lld: %lldnα, ti + 1, sol);
     }
 
     return 0;
 }"
46224,2008,32015,anhcuong,24486,1,text.c,gcj/2008/32015/anhcuong/24486/1/extracted/text.c,"/* 
  * File:   text.c
  * Author: Duong
  *
  * Created on July 27, 2008, 5:21 PM
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 int N, P, K, L;
 int frequency[1000000];
 int sorted_frequency[1000000];
 int temp_frequency[1000000];
 int keypad[1000][1000];
 
 void sort(int *frequency, int *sorted_frequency) {
   int i, j, temp;
   for (i = 0; i < L; ++i) {
     temp_frequency[i] = frequency[i];
   }
   for (i = 1; i < L; ++i) {
     for (j = i; j > 0; --j) {
       if (temp_frequency[j] > temp_frequency[j - 1]) {
         temp = sorted_frequency[j];
         sorted_frequency[j] = sorted_frequency[j - 1];
         sorted_frequency[j - 1] = temp;
         temp = temp_frequency[j];
         temp_frequency[j] = temp_frequency[j - 1];
         temp_frequency[j - 1] = temp;
       }
     }
   }
 }
 
 int main(int argc, char** argv) {
   int i, j, k;
   double result;
   scanf(α%dnα, &N);
   for (i = 0; i < N; ++i) {
     scanf(α%d %d %dα, &P, &K, &L);
     for (j = 0; j < L; ++j) {
       scanf(α%dα, &frequency[j]);
       sorted_frequency[j] = j;      
     }
     sort(frequency, sorted_frequency);
     /*for (k = 0; k < L; ++k) {
       printf(α%d α, sorted_frequency[k]);
     }
     printf(αnα);*/
     int counter = 0;
     result = 0;
     for (k = 0; k < P; ++k) {
       if (counter >= L) break;
       for (j = 0; j < K; ++j) {
         if (counter >= L) break;        
         keypad[j][k] = sorted_frequency[counter];
         result += frequency[keypad[j][k]] * (k + 1);
         //printf(α%d α, keypad[j][k]);
         counter++;        
       }
       //printf(αnα);
     }
     if (counter < L) {};
     printf(αCase #%d: %0.0fnα, i + 1, result);
   }
   /*L = 3;
   frequency[0] = 4; frequency[1] = 5; frequency[2] = 6;
   sorted_frequency[0] = 0; sorted_frequency[1] = 1; sorted_frequency[2] = 2;
   sort(frequency, sorted_frequency);
   printf(α%d %d %dα, sorted_frequency[0], sorted_frequency[1], sorted_frequency[2]);*/
   return (EXIT_SUCCESS);
 }"
46434,2008,32015,Nevis,24486,1,A.c,gcj/2008/32015/Nevis/24486/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 
 int N;
 int P,K,L;
 int F[1000];
 
 void QuickSort(int A[],int i1,int i2)
 {
 	int i,j;
 	int temp;					
 	if(i1>=i2)return ;
 	for(i=i1,j=i1+1;j<=i2;j++)
 	{
 		if(A[j]>A[i1])			/*С*/
 		{
 			i++;
 			temp=A[i];
 			A[i]=A[j];
 			A[j]=temp;
 		}
 	}
 	temp=A[i1];
 	A[i1]=A[i];
 	A[i]=temp;
 	QuickSort(A,i1,i-1);
 	QuickSort(A,i+1,i2);
 }
 
 
 int main()
 {
 	int No,i,j;
 	long long s;
 	long long t1,t2;
 	scanf(α%dα,&N);
 	for(No=1;No<=N;No++)
 	{
 		scanf(α%d%d%dα,&P,&K,&L);
 		for(i=0;i<L;i++)
 		{
 			scanf(α%dα,F+i);
 		}
 		if(P*K<L)
 		{
 			printf(αCase #%d: Impossiblenα,No);
 			continue;
 		}
 		QuickSort(F,0,L-1);
 		s=0;
 		for(i=0;i<L;i++)
 		{
 			t1=(i/K+1);
 			t2=F[i];
 			s+=t1*t2;
 		}
 		printf(αCase #%d: %lldnα,No,s);
 	}
 	return 0;
 }"
46527,2008,32015,CTB,24486,1,a.c,gcj/2008/32015/CTB/24486/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int p, k, l;
 
 int f[1001];
 int letter[1001];
 int key[1001][1001];
 int lpress[1001];
 
 typedef int (*compfn)(const void*, const void*);
 
 int compare(int *elem1, int *elem2)
 {
   if (f[*elem1] < f[*elem2]) return 1;
   if (f[*elem1] == f[*elem2]) return 0;
   return -1;
 }
 int solve(int c)
 {
   int i, j, x, y, k, n;
   long long cost;
 
   scanf(α%d %d %dnα, &p, &k ,&l);
 
   for (i= 0; i < l; i++)
   {
     letter[i] = i;
     scanf(α%dα, &f[i]);
     lpress[i] = 0;
   }
 
   // sort according to freq
   qsort((void *)&letter, l,  sizeof(int), (compfn) compare);
 
 #ifdef DEBUG
   for (i= 0; i < l; i++)
     printf(α%d %dnα, letter[i], f[letter[i]]);
 
   printf(αnα);
 #endif
 
   for (i=0; i < k; i++)
     for (j=0; j < p; j++)
        key[i][j] = -1;
 
   // assign to key
   i= 0; x = 0; y = 0;
   for (i = 0; i  < l; i++)
   {
     y = i / k ;
     y = y % p;
 #ifdef DEBUG
     printf(α%d %dnα, x, y);
 #endif
     key[x][y] = letter[i];
     lpress[i] = y+1;
     x++;
     x = x % k;
   }
 
 #ifdef DEBUG
   for (i=0; i < k; i++)
   {
     printf(αkey[%d] = α, i);
     for (j=0; j < p; j++)
     {
       if (key[i][j] > -1)
         printf(α%d(%d) α, key[i][j], f[key[i][j]]);
     }
     printf(αnα);
   }
 #endif
 #ifdef DEBUG
   for (i= 0; i < l; i++)
     printf(α%d %d %dnα, letter[i], f[letter[i]], lpress[i]);
 
   printf(αnα);
 #endif
 
   for (i= 0, cost=0; i < l; i++)
     cost += (long long)lpress[i] * (long long)f[letter[i]];
 
   printf(αCase #%d: %lldnα, c, cost);
 }
 
 int main(int argc, char **argv)
 {
   int i, t;
   scanf(α%dα, &t);
   for (i = 1; i <= t; i++) solve(i);
 }"
46587,2008,32015,jchen,24486,1,j1.c,gcj/2008/32015/jchen/24486/1/extracted/j1.c,"long a[1000];
 
 void down(int current, int len)
 {
 	int left, right;
 	long min;
 	left= 2*current+1;
 	while(left<len)
 	{
 		right= left+1;
 		if((right<len)&&(a[right]<a[left]))left= right;
 		if(a[current]>a[left])
 		{
 			min= a[current];
 			a[current]= a[left];
 			a[left]= min;
 		}
 		else break;
 		current= left;
 		left= 2*current+1;
 	}
 }
 
 int main(void)
 {
 	int N,P,K,L;
 	int i,j;
 	int left, right;
 	long min;
 	unsigned long long result;
 	scanf(α%dnα, &N);
 	for(i=1;i<=N;i++)
 	{
 		scanf(α%d %d %dnα,&P, &K, &L);
 		for(j=0;j<L;j++)
 		{
 			scanf(α%ldα,&a[j]);
 		}
 		
 		for(j=L/2-1;j>=0;j--)
 		{
 			left= 2*j+1;
 			right= left+1;
 			if((right<L)&&(a[right]<a[left]))left= right;
 			if(a[j]>a[left])
 			{
 				min= a[j];
 				a[j]= a[left];
 				a[left]= min;
 				down(left, L);
 			}
 		}
 		
 		for(j=L-1;j>0;j--)
 		{
 			min= a[0];
 			a[0]= a[j];
 			a[j]= min;
 			
 			down(0, j);
 		}
 		
 		result= 0; 
 		for(j=0;j<L;j++)
 		{
 			min= 1+j/K;
 			min= a[j]*min;
 			result+= min;
 		}
 		
 		printf(αCase #%d: %lldnα,i, result);
 	}
 	
 	return 0;
 }"
46814,2008,32015,FrozenPinguin,24486,1,probA01.c,gcj/2008/32015/FrozenPinguin/24486/1/extracted/probA01.c,"#include <stdio.h>
 
 //#define DEBUG1
 
 int compneg(const void* a, const void* b);
 
 int main(void)
 {
 	int N, P, K, L;
 	long int freq[1000];
 	long long count;
 	
 	int i, freqCnt, caseCnt;
 	
 	FILE* fin;
 	
 	fin = fopen(αtest.inα, αrtα);
 	
 	fscanf(fin, α%iα, &N);
 #ifdef DEBUG1
 	printf(αN: %inα, N);
 #endif
 	
 	for(caseCnt = 0; caseCnt < N; caseCnt++)
 	{
 		count = 0ll;
 		
 		fscanf(fin, α%i %i %iα, &P, &K, &L);
 #ifdef DEBUG1
 		printf(αP: %i, K: %i, L: %inα, P, K, L);
 #endif
 		
 		for(freqCnt= 0; freqCnt < L; freqCnt++)
 			fscanf(fin, α%liα, &freq[freqCnt]);
 		
 		qsort(freq, L, sizeof(long), compneg);
 #ifdef DEBUG1
 		for(freqCnt= 0; freqCnt < L; freqCnt++)
 			printf(α%li α, freq[freqCnt]);
 		printf(αnα);
 #endif
 		
 		for(i = 0; i < L; i++)
 		{
 			count += (long long)(freq[i] * (i/K + 1) );
 		}
 
 		printf(αCase #%i: %llinα, caseCnt+1, count);
 	}
 	return 0;
 }
 
 
 int compneg(const void* a, const void* b)
 {
 	if		( *( (int*)a) > *( (int*)b) )
 		return -1;
 	else if	( *( (int*)a) < *( (int*)b) )
 		return 1;
 	else
 		return 0;
 }"
46863,2008,32015,Maxime,24486,1,r1.c,gcj/2008/32015/Maxime/24486/1/extracted/r1.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 typedef struct {
   int num;
   long long freq;
 } FREQ;
 
 
 int cmpF(const void *v1, const void *v2) {
   FREQ *e1 = (FREQ*)v1, *e2 = (FREQ*)v2;
   if (e1->freq < e2->freq) return 1;
   if (e1->freq > e2->freq) return -1;
   return 0;
 }
 
 
 main() {
   char str[4096];
   int N, P, K, L;
   int iN, i, impossible, level;
   long long result;
 
   FREQ F[1024];
 
   fgets(str, sizeof(str), stdin);
   sscanf(str, α%dα, &N);
   fprintf(stderr, αN:%dnα, N);
 
   for (iN = 0; iN < N; iN++) {
 
     result = 0;
     bzero(&F, sizeof(F));
 
     fscanf(stdin, α%d %d %dα, &P, &K, &L);
     fprintf(stderr, αP: %d K: %d  L:%d   K*P:%dnα, P, K, L, K * P);
  
  
     for(i = 0; i < L; i++) {
       fscanf(stdin, α%lldα, &F[i].freq);
       F[i].num = i;
     }
     qsort(F, (size_t)L, sizeof(FREQ), &cmpF);
  
     for(i = 0; i < L; i++) {
       level = (int)i / K + 1;
       result += (long long)F[i].freq * (long long) level;
       fprintf(stderr, αi:%d  freq:%lld  level: %dnα, i, F[i].freq, level);
     }
     fprintf(stdout, αCase #%d: %lldnα, iN + 1, result);
 
   }
   return 0;
 }"
46940,2008,32015,Shivani,24486,1,msg.c,gcj/2008/32015/Shivani/24486/1/extracted/msg.c,"#include <stdio.h>
 #include <stdlib.h>
 
 FILE * fp_in;
 FILE * fp_out;
 unsigned int case_cnt;
 long p,k,l;
 long *maxk;
 typedef struct {
 	long fre;
 	int used;
 }fres;
 fres *fr;
 void compute();
 long findmax(long *freq);
 void small_input();
 void large_input();
 void take_input();
 void free_input();
 
 int main(int argc, char * argv[])
 {
     if (argc < 2){
 	     printf (αUsage for small input: nameOfExecutable snα);
 	     printf (αUsage for large input: nameOfExecutable lnα);
              printf(α(Help: first argument should be αsα for small inputs and αlα for large inputs)nα);
 	     printf(αnPlease make sure that the input file is in the current directorynα);
 	     printf(αnPlease make sure that the output file can be created in the current directorynα);
              exit(0);
     }
     if ( 's' == argv[1][0] || 'S' == argv[1][0]){
          small_input();
          return 0;
     }
     else if ('l' == argv[1][0] || 'L' == argv[1][0]){
          large_input();
          return 0;
          }         
 }
 void small_input()
 {
         
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./A-small.inα,αrα);
 
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file A-small.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./A-small.outα,αwα);
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file A-small.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
 	 return;
 }
 void large_input()
 {
      unsigned int count_test_cases = 0;
      
      fp_in = fopen (α./A-large.inα,αrα);
      if (NULL == fp_in)
      {
 	     printf(αPlease ensure that the file A-large.in is placed in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
      fp_out = fopen (α./A-large.outα,αwα);
 
      if (NULL == fp_out)
      {
 	     printf(αPlease ensure that the file A-large.out can be created in the current directorynα);
 	     printf(αExitingnα);
 	     exit(1);
      }
 	 fscanf (fp_in, α%uα,&count_test_cases);
 	 for (case_cnt = 1; case_cnt <= count_test_cases; case_cnt++)
 	 {
         take_input();
         compute();
         free_input();
 	 }
 	 fclose(fp_in);
 	 fclose(fp_out);
         
 }
 void take_input()
 {
 	long i = 0;
 	fscanf(fp_in,α%dα,&p);
 	fscanf(fp_in,α%dα,&k);
 	fscanf(fp_in,α%dα,&l);
 
 	fr=(fres *)malloc (sizeof(fres)*l);
 	
 	for (i=0;i<l;i++ )
 	{
 		fscanf(fp_in,α%ldα,&fr[i].fre);
 		fr[i].used=0;
 	}
 	
 	maxk=(long *)malloc(sizeof(long)*k);
      return;
 }
 
 void free_input()
 {
 	//free(fr);
 	//free(maxk);
 	return;
 
 }
 void compute()
 {
 	
 	long max,freq,i;
 	double sum=0.0;
 	long allk=0;
 	memset((void *)maxk,0,sizeof(long)*k);
 
 	while(1)
 	{
 		max=findmax(&freq);
 		if (-1 == max)
 		{
 			fprintf(fp_out,αCase #%u: %.0lfnα,case_cnt,sum);
 			
 			return;
 		}
 		for (i=0; i<k; i++)
 		{
 			if (maxk[i]==allk)
 			{
 				maxk[i]=allk+1;
 				
 				sum+=(double)freq*maxk[i];
 				if (i==k-1)
 				{
 					allk++;
 				}
 				break;
 			}
 		}
 	}
 
 
 }
 long findmax(long *freq)
 {
 	long i;
 	long max=-1,running;
 	long index=-1;
 	for (i=0; i<l;i++)
 	{
 		running=fr[i].fre;
 		if (fr[i].used==0)
 		{
 			if (running>max)
 			{
 				max=running;
 				index=i;
 			}
 		}
 	}
 	*freq=max;
 	fr[index].used=1;
 	return index;
 	
 }"
47052,2008,32015,igorfr,24486,1,a.c,gcj/2008/32015/igorfr/24486/1/extracted/a.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 int freq[1024];
 char string[2048];
 
 int comp (const void *e1, const void *e2)
 {
 	int a = *((int*)e1);
 	int b = *((int*)e2);
 
 	if (a > b) return -1;
 	if (a < b) return 1;
 	return 0;
 }
 
 int main (void)
 {
 	int i, x, l, p, n, k, m;
 	double presses;
 
 	scanf (α%dα, &n);
 
 	for (x=1; x<=n; x++)
 	{
 		scanf (α%d %d %dα, &p, &k, &l);
 		for (i=0; i<l; i++)
 		{
 			scanf (α %dα, &freq[i]);
 		}
 
 		qsort (freq, l, sizeof(freq[0]), comp);
 
 		presses = 0;
 		m = 0;
 
 		for (i=0; i<l; i++)
 		{
 			if (!(i%k)) m++;
 			presses += freq[i]*m;
 		}
 
 		sprintf (string, αCase #%d: %.0lfα, x, presses);
 		puts (string);
 	}
 
 	return 0;
 }"
47291,2008,32015,JimmyDong,24486,1,A.c,gcj/2008/32015/JimmyDong/24486/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 
 #define input αA-large.inα
 #define output αA-large.outα
 
 FILE *in,*out;
 __int64 N,P,K,L;
 __int64 dat[1001];
 __int64 i,j,k,cnt,kpress;
 
 int comp(const void *, const void *);
 
 int main(){
     in = fopen(input,αrα);
     out = fopen(output,αwα);
     fscanf(in,α%I64dα,&N);
     for(k=0;k<N;k++){
         fprintf(out,αCase #%I64d: α,k+1);
         fscanf(in, α%I64d %I64d %I64dα, &P, &K, &L);
         cnt = 0; kpress = 0;
         for(i=0;i<L;i++)fscanf(in,α%I64dα,&dat[i]);
         qsort(dat, L, sizeof(__int64), &comp);
         for(i=0;i<L;i++){
             if(!(i%K))cnt++;
             kpress += cnt * dat[i];
         }
         fprintf(out,α%I64dnα,kpress);
     }
     system(αpauseα);
     return 0;
 }
 
 int comp(const void * a, const void * b){
     return *(int *)b - *(int *)a;
 }"
47665,2008,32015,sungyz,24486,1,TM.c,gcj/2008/32015/sungyz/24486/1/extracted/TM.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #define MAXTC       100
 #define MAXCHAR     1000000000
 #define MAXALPHA    1000
 
 char    buffer[MAXCHAR];
 int     freq[MAXALPHA];
 
 int main( int argc, char *argv[] )
 {
     FILE    *fp;
     char    *idx;
     int     numCases, num, i, j, k;
     int     P, K, L;
 
     if( argc < 2 )
     {
         fprintf( stderr, αError : No input file!nα );
         fprintf( stderr, αUsage : %s input_file [> output_file]nα, argv[0] );
         return -1;
     }
 
     // Read the number of test cases
     fp = fopen( argv[1], αrtα );
     if( fgets( buffer, MAXCHAR, fp ) == NULL )
     {
         fprintf( stderr, αError : fgets() returns NULL!nα );
         return -1;
     }
 
     numCases = atoi( buffer );
     if( numCases < 1 || numCases > MAXTC )
     {
         fprintf( stderr, αError : Invaid number of test cases (%d)nα, numCases );
         return -1;
     }
 
     // For each test cases...
     for( i = 0 ; i < numCases ; i++ )
     {
         int   temp, push;
         long long   total;
 
         memset( freq, 0, sizeof(int)*MAXALPHA );
 
         if( fgets( buffer, MAXCHAR, fp ) == NULL )
         {
             fprintf( stderr, αError : fgets() returns NULL!nα );
             return -1;
         }
         sscanf( buffer, α%d %d %dα, &P, &K, &L );
 
         if( fgets( buffer, MAXCHAR, fp ) == NULL )
         {
             fprintf( stderr, αError : fgets() returns NULL!nα );
             return -1;
         }
         idx = buffer;
         for( j = 0 ; j < L ; j++ )
         {
             int     f;
             sscanf( idx, α%dα, &f );
             freq[j] = f;
             idx = strstr( idx, α α );
             idx++;
         }
 
         for( j = 0 ; j < L ; j++ )
         {
             for( k = j+1 ; k < L ; k++ )
             {
                 if( freq[j] < freq[k] )
                 {
                     temp = freq[j];
                     freq[j] = freq[k];
                     freq[k] = temp;
                 }
             }
         }
 
         total = 0;
         for( j = 0 ; j < L ; j += K )
         {
             push = (j / K)+1;
             for( k = 0 ; k < K ; k++ )
                 total += (long long)freq[j+k]*push;
         }
 
         fprintf( stdout, αCase #%d: %I64dnα, i+1, total );
     }
 
     fclose( fp );
 
     return 0;
 }"
47716,2008,32015,wmigda,24486,1,tex.c,gcj/2008/32015/wmigda/24486/1/extracted/tex.c,"#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 typedef struct
 {
     int     let;
     int     freq;
 } rec_t;
 
 rec_t   freq[1001];
 
 int
 subsort(const void *a, const void *b)
 {
     rec_t   *aa, *bb;
     aa = (rec_t *)a;
     bb = (rec_t *)b;
     return aa->freq < bb->freq;
 }
 
 void zestaw()
 {
     int     limit, nk, nl;
     int     it;
     long long     suma = 0;
     static int  count = 1;
 
     scanf(α%d %d %dα, &limit, &nk, &nl);
 
     if (0)
     {
         printf(αCase #%d: impossiblenα, count++);
     }
 
     memset(freq, 0, sizeof(freq));
 
     for (it = 0; it < nl; ++it)
     {
         scanf(α%dα, &freq[it].freq);
         freq[it].let = it;
     }
     qsort(freq, nl, sizeof (rec_t), subsort);
 
     for (it = 0; it < nl; ++it)
     {
         suma += freq[it].freq * (it / nk + 1);
     }
     printf(αCase #%d: %lldnα, count++, suma);
 }
 
 int
 main()
 {
     int     ile;
 
     scanf(α%dα, &ile);
 
     while(ile--)
     {
         zestaw();
     }
 
     return 0;
 }"
47887,2008,32015,happyking,24486,1,test.c,gcj/2008/32015/happyking/24486/1/extracted/test.c,"#include<stdio.h>
 #include<stdlib.h>
 
 int cmp1( const void *a , const void *b ) 
 { 
 	return *(__int64 *)b - *(__int64 *)a; 
 }
 
 /* 
 P * K  L 
 0  The frequency of each letter  1 000 000 
 Large dataset
 
 1  N  100
 1  P  1 000
 1  K  1 000
 1  L  1 000
 
 */
 int main()
 {
 	int t,tn;
 	int p,k,l;
 	__int64 x[1001];
 	__int64 re;
 	int i,j,an;
 	
 	freopen(αA-large.in.txtα,αrα,stdin);
 	freopen(αoutput.txtα,αwα,stdout);
 	
 	scanf(α%dα,&t);
 	for(tn=0; tn<t;tn++) {
 		scanf(α%d%d%dα,&p,&k,&l);	
 		for(i=0;i<l;i++) scanf(α%I64dα,&x[i]);
 		qsort(x,l,sizeof(x[0]),cmp1);
 		re = 0; i = 0; an = 1;
 		while(i<l) {
 			for(j = 0;j < k;j++) {
 				re+=x[i]*an;
 				i++;
 				if(i>=l) break;
 			}
 			an++;
 		}
 		printf(αCase #%d: %I64dnα,tn+1,re);		
 	}
 	return 0;
 }"
47958,2008,32015,rafaelim,24486,1,A.c,gcj/2008/32015/rafaelim/24486/1/extracted/A.c,"#include <stdlib.h>
 #include <stdio.h>
 #include αST.hα
 #define DEBUGI(x) printf(#xα: %dnα, x)
 #define DEBUGD(x) printf(#xα: %gnα, x)
 #define DEBUGS(x) printf(#xα: %snα, x)
 #define DEBUGC(x) printf(#xα: %cnα, x)
 int letter[1000];
 
 int compare(const void *x, const void *y)
 {
     int *a, *b;
     
     a = (int *)x;
     b = (int *)y;
 
     return (*b) - (*a);
 }
 
 
 int main(void)
 {
     register int i, j;
     int N, k;
     int P, K, L;
     double total;
     scanf(α%dα, &N);
     k = 1;
     
     while (N > 0)
     {    
         scanf(α%d %d %dα, &P, &K, &L);
 
         total = 0;
 
         for (i = 0; i < L; i++)
             scanf(α%dα, &letter[i]);
 
         qsort(letter, L, sizeof(int), compare);
 
         i = 1;
         j = 0;
         while (L > 0)
         {
             if (j >= i * K)
             {
                 i++;               
             }
             total += (double)(i * letter[j]);
             j++;
             L--;
         }
         
         printf(αCase #%d: %.0fnα, k, total);
         N--;
         k++;
     }
     
     return EXIT_SUCCESS;
 }"
47960,2008,32015,rafaelim,24486,1,ST.c,gcj/2008/32015/rafaelim/24486/1/extracted/ST.c,"#include <stdlib.h>
 #include αST.hα
 
 static int value;   /* Guarda o indice da string procurada */
 static int N;       /* Usado para indexar as strings */
 static STlink head; /* Raiz da arvore */
 
 /**
  * Inicializa a tabela de simbolos
  */
 void STinit(void)
 {
     head = NULL;
     N = 0;
 }
 
 /**
  * Cria um novo no com caracter 'd' e devolve esse no
  */
 STlink stNEW(int d)
 {
     STlink x = malloc(sizeof *x);
     
     x->index = -1;
     x->d = d;
     x->left = NULL;
     x->right = NULL;
     x->middle = NULL;
 
     return x;
 }
 
 /**
  * Funcao recursiva que percorre a TST do no 'h', de acordo com a string 'v' a partir da posicao 'w'. 
  * Se v[w] for igual a '0', define o 'value' como sendo o indice da string e termina a recursao.
  */
 STlink indexR(STlink h, char* v, int w)
 {
     int i = v[w];
  	
     /* Cria um no com o caracter v[w] */
     if (h == NULL)
  	 	h = stNEW(i);
 
     /* Termino da recursao, define o indice se for preciso */
     /* e devolve o no encontrado                           */
     if (i == '0')
     {
         if (h->index == -1)
             h->index = N++;
 
         value = h->index;
 
         return h;
     }
 
     /* Se o caracter v[w] for menor ao caracter do no 'h' tentar procurar */
     /* em h->left.                                                        */
     /* Se o caracter v[w] for igual ao caracter do no 'h' continua no     */
     /* caminho consumindo esse caracter.                                  */
     /* Se o caracter v[w] for maior ao caracter do no 'h' tentar procurar */
     /* em h->right.                                                       */
 
     if (i < h->d)
         h->left = indexR(h->left, v, w);
     else if (i == h->d)
         h->middle = indexR(h->middle, v, w + 1);
     else 
         h->right = indexR(h->right, v, w);
 
     return h;
 }
 
 /**
  * Recebe uma string como chave e devolve o indice dela
  */ 
 int STindex(char* key)
 {
     head = indexR(head, key, 0);
 
     return value;
 }
 
 /**
  * Devolve o tamanho da tabela de simbolos
  */ 
 int STsize(void)
 {
     return N;
 }"
48077,2008,32015,ivanFTW,24486,1,P1.c,gcj/2008/32015/ivanFTW/24486/1/extracted/P1.c,"#include <stdio.h>
 
 int N,P,K,L;
 int frec[1005];
 
 void intercambia(int* a,int* b)
 {
 	int temp;
 	temp=*a; *a=*b; *b=temp;
 }
 
 void ordena(void)
 {
 	int i,j;
 
 	for(i=0;i<L;i++)
 		for(j=i+1;j<L;j++)
 			if(frec[j]>frec[i])
 				intercambia(&frec[i],&frec[j]);
 }
 
 long long int calcula(void){
 	int i;
 	long long int total=0;
 
 	for(i=0;i<L;i++)
 		total+=frec[i]*(1+i/K);
 	return(total);
 }
 
 void main(void)
 {
 	int i,j;
 	long long int res=0;
 
 	scanf(α%dnα,&N);
 	for(i=1;i<=N;i++){
 		scanf(α%d %d %dnα,&P,&K,&L);
 		for(j=0;j<L;j++)
 			scanf(α%dα,&frec[j]);
 		scanf(αnα);
 		ordena();
 		res=calcula();
 		printf(αCase #%d: %lldnα,i,res);
 	}
 }"
48128,2008,32015,groo,24486,1,p1.c,gcj/2008/32015/groo/24486/1/extracted/p1.c,"#include<stdio.h>
 #include<stdlib.h>
 #define MX 2000
 int N, P, K, L;
 int freq[MX];
 int main()
 {
     int cs, i, j, mx, temp;
     unsigned long long int totsum;
     scanf(α%dα,&N);
     for(cs=1; cs<=N; cs++)
     {
               scanf(α%d%d%dα,&P,&K,&L);
               for(i=0;i<L;i++)
               scanf(α%dα,&freq[i]);
               
               for(i=0;i<L;i++)
               {
                mx = i;
                for(j=(i+1);j<L;j++)
                {
                 if(freq[mx]<freq[j])
                 mx = j;
                }
                temp = freq[mx];
                freq[mx] = freq[i];
                freq[i] = temp;
               }
               totsum = 0;
               for(i=0;i<L;i++)
               {
                totsum += (unsigned long long int)freq[i]*((unsigned long long int)(i/K)+1);
               }
               printf(αCase #%d: %llunα,cs, totsum);
     }
     system(αPAUSEα);
     return 0;
 }"
48194,2008,32015,Raim,24486,1,A.c,gcj/2008/32015/Raim/24486/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
 #define debug(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
 
 #define ulong unsigned long long
 #define llong long long
 #define uint unsigned int
 
 ulong freq[1001];
 
 int ulongcmp(const void *aa, const void *bb) {
     ulong *a = (ulong *) aa;
     ulong *b = (ulong *) bb;
 
     return *b - *a;
 }
 
 int main() {
     int cases;
     scanf(α%dα, &cases);
 
     for (unsigned int kase = 1; kase <= cases; kase++) {
         uint p, k, l;
         scanf(α%u %u %uα, &p, &k, &l);
 
         for (uint g = 0; g < l; g++) {
             scanf(α%lluα, &(freq[g]));
         }
 
         if (p * k < l) {
             printf(αCase #%u: Impossiblenα, kase);
             continue;
         }
 
         qsort(freq, l, sizeof(ulong), ulongcmp);
 
         ulong sum = 0;
         uint o = 1;
         for (uint j = 0; j < l; j++) {
             sum += o * freq[j];
             /* debug(α%u * %llunα, o, freq[j]); */
             if ((j+1) % k == 0) o++;
         }
 
         printf(αCase #%u: %llunα, kase, sum);
     }
 
     return 0;
 }"
48214,2008,32015,blackJack,24486,1,A.c,gcj/2008/32015/blackJack/24486/1/extracted/A.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 long int freq[1000];
 int P,K,L;
 long int arr[1000][1000];
 
 void sort(){
   int j,k,temp;
   for(j=L-2;j>=0;j--){
     for(k=0;k<=j;k++){
       if(freq[k] > freq[k+1]){
 	temp = freq[k];
 	freq[k] = freq[k+1];
 	freq[k+1] = temp;
       }
     }
   }
 }
 
 
 int main(){
 
   int k1,p1;
   long long int total,ind;
   int Num,i,j,k;
   scanf(α%dα,&Num);
   //freq = (int *)malloc(1000*sizeof(int));
 /*     arr = (int **)malloc(1000*sizeof(int *)); */
 /*     for(j = 0;j<1000;j++){ */
 /*       arr[j] = (int *)malloc(1000*sizeof(int)); */
 /*     } */
   for(i=1;i<=Num;i++){
     scanf(α%d%d%dα,&P,&K,&L);
 
     for(j=0;j<L;j++)
       scanf(α%ldα,&freq[j]);
     sort();
 
     for(j=0;j<K;j++){
       for(k=0;k<P;k++){
 	arr[k][j] = 0;
       }}
     ind = L-1;p1=0;k1=0;total = 0;
     while(ind >= 0){
       arr[p1][k1] = freq[ind];
       total += ((long long int)arr[p1][k1]*(long long int)(p1+1));
       k1++;
       if(k1>= K){
 	k1 = 0;p1++;}
       ind--;
     }
 /*     total = 0; */
 /*     for(p1 = 0;p1<P;p1++){ */
 /*       for(k1=0;k1<K;k1++){ */
 /* 	total += ((long long int)arr[p1][k1]*(long long int)(p1+1)); */
 /*       } */
 /*     } */
     printf(αCase #%d: %lldnα,i,total);
   }
   return 0;
 }"
48254,2008,32015,Shubham,24486,1,problem.c,gcj/2008/32015/Shubham/24486/1/extracted/problem.c,"/* Header Files */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 /* Typedefs */
 #define U8 unsigned char
 #define S8 signed char
 #define U16 unsigned short
 #define S16 signed short
 #define U32 unsigned long
 #define S32 signed long
 #define FLT float
 #define DBL double
 
 /* Constants */
 
 
 /* Global Data */
 U32 Freq[1000];
 
 
 /* Local Function Declaration */
 S16 process(S8 *, S8 *);
 U8 fgetline(FILE *, S8 *);
 
 void main(int argc, char *argv[])
 {
 
 	U8 u_i;
 	S8 s_InputFile[100], s_OutputFile[100];
 
 	s_InputFile[0] = '0';
 	s_OutputFile[0] = '0';
 
 	for(u_i = 1; u_i < argc; u_i++)
 	{
 
 		if(strncmp(argv[u_i], α-iα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-i%sα, s_InputFile);
 			
 		}
 		else if(strncmp(argv[u_i], α-oα, 2) == 0)
 		{
 			sscanf(argv[u_i], α-o%sα, s_OutputFile);
 			
 		}
 		else
 			printf(αUnsupported input switchnα);
 	}
 
 
 	if(s_InputFile[0] != '0')
 	{
 		if(process(s_InputFile, s_OutputFile) == -1)
 			printf(αFile Errorsnα);
 	}
 }
 
 U32 compare_int(const void *pw_Num1, const void *pw_Num2)
 {
 	U32 w_Word1;
 	U32 w_Word2;
 
 	w_Word1 = *(U32 *)(pw_Num1);
 	w_Word2 = *(U32 *)(pw_Num2);
 
 	if(w_Word1 < w_Word2)
 		return 1;
 	else if(w_Word1 > w_Word2)
 		return -1;
 
 	return 0;
 	
 }
 
 /* Function Definitions */
 S16 process(S8 *p_FileInput, S8 *p_FileOutput)
 {
 	FILE *p_Input;
 	FILE *p_Output;
 	S8 p_InputLine[8192*2];
 	U8 u_NumTests;
 	U8 u_Counter;
 
 
 	u_Counter = 0;
 
 	if( (p_Input = fopen(p_FileInput, αrα)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileInput);
 		return -1;
 	}
 
 	if( (p_Output = fopen(p_FileOutput, αw+α)) == NULL)
 	{
 		printf(αError opening file: %snα, p_FileOutput);
 		return -1;
 	}
 
 
 	/* Get Number of tests */
 	fgetline(p_Input, p_InputLine);
 	sscanf(p_InputLine, α%uα, &u_NumTests);
 
 	while(u_Counter++ != u_NumTests)
 	{
 		U32 P, K, L;
 		U32 w_i;
 		U32 w_KeyPress;
 		U32 q_MaxKeyStrokes;
 		__int64 q_KeyStrokes;
 
 		q_KeyStrokes = 0;
 		for(w_i = 0; w_i < 1000; w_i++)
 			Freq[w_i] = 0;
 
 		/* Extract Test Params */
 		fgetline(p_Input, p_InputLine);
 		sscanf(p_InputLine, α%ld %ld %ldα, &P, &K, &L);
 
 		fgetline(p_Input, p_InputLine);
 		Freq[0] = atoi(strtok(p_InputLine, α α));
 		for(w_i = 1; w_i < L; w_i++)
 		{
 			Freq[w_i] = atoi(strtok(NULL, α α));
 		}
 
 		qsort(Freq, L, sizeof(U32), compare_int);
 
 		q_MaxKeyStrokes = P * K;
 
 		w_KeyPress = 1;
 		w_i = 0;
 
 		while(w_i < L)
 		{
 				q_KeyStrokes += (Freq[w_i++] * w_KeyPress);
 
 				if((w_i % K) == 0)
 				{
 					w_KeyPress++;
 				}
 
 		}
 
 		/* Output the result */
 		printf(αCase #%d: %I64dα, u_Counter, q_KeyStrokes);
 		fprintf(p_Output, αCase #%d: %I64dα, u_Counter, q_KeyStrokes);
 
 		if(u_Counter != u_NumTests)
 		{
 			fprintf(p_Output, αnα);
 			printf(αnα);
 		}
 	}
 
 	/* Close the files */
 	fclose(p_Input);
 	fclose(p_Output);
 
 	return 0;
 }
 
 U8 fgetline(FILE *p_File, S8 *p_Buffer)
 {
 	S32 x_chr;
 
 	while( (x_chr = fgetc(p_File)) != EOF)
 	{
 		if(x_chr == 'n')
 			break;
 		
 		*p_Buffer++ = (U8)x_chr;
 		
 	}
 
 	*p_Buffer = '0';
 
 	if(x_chr == EOF)
 			return 0;
 	else
 		return 1;
 
 
 }"
48495,2008,32015,timerover,24486,1,a(2).c,gcj/2008/32015/timerover/24486/1/extracted/a(2).c,"#include <stdio.h>
 
 int compare(const void *a, const void *b) {
     return *(int *)b - *(int *)a;
 }
 
 int main() {
     int n, p, k, l;
     int i, j, x, y, feq[1000000];
     unsigned int ans;
 
     scanf(α%dα, &n);
 
     for(i = 0; i < n; i++) {
 	scanf(α%d %d %dα, &p, &k, &l);
 	for(j = 0; j < 1000000; j++) feq[j] = 0;
 	for(j = 0; j < l; j++) {
 	    scanf(α%dα, &feq[j]);
 	}
 	qsort(feq, l, sizeof(feq[0]), compare);
 	ans = 0;
 	for(x = 0; x < p; x++) {
 	    for(y = 0; y < k; y++) {
 		ans += (x+1) * feq[(x*k + y)];
 	    }
 	}
 	printf(αCase #%d: %dnα, i+1, ans);
     }
     return 0;
 }"
48556,2008,32015,bubis,24486,1,A.C,gcj/2008/32015/bubis/24486/1/extracted/A.C,"#include <iostream>
 #include <vector>
 #include <list>
 #include <map>
 #include <set>
 #include <algorithm>
 #include <functional>
 
 using namespace std;
 
 typedef unsigned long long Num;
 typedef vector<Num> Vec;
 
 int main()
 {
 	int cases;
 	cin >> cases;
 	for (int ii = 0; ii<cases; ++ii)
 	{
 		Num P,K,L;
 		cin >> P >> K >> L;
 		Vec w;
 		for ( Num i = 0 ; i<L; ++i)
 		{
 			Num fr;
 			cin >> fr;
 			w.push_back(fr);
 		}
 		sort(w.begin(),w.end(),greater<Num>());
 
 		Num presses = 0;
 		for ( Num i = 0 ; i<L; ++i)
 		{
 			presses += w[i]*((i)/K+1);
 		}
 
 		cout << αCase #α << ii+1 << α: α << presses << endl;
 	}
 	return 0;
 }"
48783,2008,32015,fena,24486,1,tmo.c,gcj/2008/32015/fena/24486/1/extracted/tmo.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int compare (const void *x, const void *y);
 
 int main(){
   unsigned long long int ans;
   int p;
   int cases,ccases;
   int l;
   int k;
   int freq[1010];
   int i,j,m;
 
   scanf(α %d α, &cases);
 
   for(ccases=1; ccases<=cases; ccases++){
     ans=0;
     scanf(α %d %d %d α,&p,&k,&l);
     for(i=0;i<l;i++)
       scanf(α %d α,&freq[i]);
 
     qsort(freq,l,sizeof(int),compare);
 
 /*     for(i=0;i<l;i++) */
 /*       printf(α %d α,freq[i]); */
 /*     printf(αnα); */
 
     j=1;
     m=1;
     for(i=0;i<l;i++){
       ans+=freq[i]*m;
       if(j==k){
 	m++;
 	j=0;
       }
       j++;
     }
     printf(αCase #%d: %llunα,ccases,ans);
   }
 
   return 0;
 }
 
 
 int compare (const void *x, const void *y){
   return *(int *)y-*(int *)x;
 }"
48845,2008,32015,bahadir,24486,1,mainA.c,gcj/2008/32015/bahadir/24486/1/extracted/mainA.c,"#include <stdio.h>
 #include <stdlib.h>
 
 int
 compare(const void *first, const void *second)
 {
     return - *(int *) first + *(int *) second;
 }
 
 long long
 solve(int p, int k, int length, int freq[1001])
 {
     int i, press = 1;
     long long retval = 0;
     
     qsort(freq, length, sizeof(int), compare);
     
     for (i = 0; i < length ; i++) {
         retval += freq[i] * press;
         if (i % k == k - 1) {
             press++;
         }
     }
     return retval;
 }
 
 int
 main(int argc, char** argv) 
 {
     int i, j, casenum;
     FILE *in, *out;
     
     if (argc < 3) {
         fprintf(stderr, αWrong number of arguments!nα);
         exit(1);
     }
     
     in = fopen(argv[1], αrα);
     out = fopen(argv[2], αwα);
     
     fscanf(in, α %dα, &casenum);
     for (i = 0; i < casenum; i++) {
         int p, k, length;
         int freq[1001];
         fscanf(in, α %d %d %dα, &p, &k, &length);
         for (j = 0; j < length; j++) {
             fscanf(in, α %dα, &freq[j]);
         }
         fprintf(out, αCase #%d: %lldnα, i + 1, solve(p, k, length, freq));
     }
     
     fclose(in);
     fclose(out);
     
     return 0;
 }"
48873,2008,32015,JeffChen,24486,1,A.c,gcj/2008/32015/JeffChen/24486/1/extracted/A.c,"#include<stdio.h>
 #include<string.h>
 int let[1005];
 int cmp(const void *a,const void *b)
 { 
 	int a1 = *(int *)a; 
 	int a2 = *(int *)b; 
 	return a2 - a1; 
 } 
 
 int main()
 {
 	int n;
 	int p;
 	int k;
 	int l;
 	int i;
 	int j;
 
 	int t;
 	int time;
 	__int64 sum;
 	freopen(αA-large.inα,αrα,stdin);
 	freopen(αAAA_out.outα,αwα,stdout);
 	scanf(α%dα,&n);
 	for(i = 0;i < n;i++)
 	{
 		memset(let,0,sizeof(let));
 		scanf(α%dα,&p);
 		
 		scanf(α%dα,&k);
 		scanf(α%dα,&l);
 		
 		for(j = 1;j <= l;j++)
 		{
 			scanf(α%dα,&let[j]);
 		}
 		//
 		qsort(let+1,l,sizeof(int),cmp);    
 		sum = 0;
 		t = k;
 		time = 1;
 		for(j = 1;j <= l;j++)
 		{
 			//k 
 				sum += let[j] * time;
 				t--;
 				if(t == 0)
 				{
 					t = k;
 					time++;
 				}
 		}
 		printf(αCase #%d: %I64dnα,i+1,sum);
 	}
 	return 0;
 }"
48946,2008,32015,fundoonick,24486,1,gcj.c,gcj/2008/32015/fundoonick/24486/1/extracted/gcj.c,"#include<stdio.h>
 #include<math.h>
 sort(long long int a[], long long int n)
 {
 int i,j,temp;
 for(i=0;i<n;i++)
 for(j=i;j<n;j++)
 if(a[i]<a[j])
 {
 temp=a[i];
 a[i]=a[j];
 a[j]=temp;
 }
 }
 
 main()
 {
 long long int cyt,p,i,j,k,a[1000],l,t,m,n,ctr=0,flag=0;
 scanf(α%lldα,&t);
 for(m=0;m<t;m++)
 {
 for(j=0;j<1000;j++)
 a[j]=0;
 ctr=0;
 scanf(α%lld %lld %lldα,&p,&n,&l);
 for(j=0;j<l;j++)
 {scanf(α%lldα,&a[j]);}
 cyt=1;
 sort(a,l);
 //for(j=0;j<l;j++)
 //printf(α%ld α,a[j]);
 for(j=0;j<l;)
 {
 for(i=0;i<n;i++)
 ctr+=a[j++]*cyt;
 //printf(αcnt %ld α,ctr);
 cyt++;
 }
 printf(αCase #%lld: α,m+1);
 if(cyt>p+1)
 printf(αImpossiblenα);
 else
 printf(α%lldnα,ctr);
 }
 }"
48949,2008,32015,migacr,24486,1,text_messaging_outrage.c,gcj/2008/32015/migacr/24486/1/extracted/text_messaging_outrage.c,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 struct Frequency {
 	int L;
 	int F;
 };
 static struct Frequency *F;
 int readint(char *c) {
 int r,s;
 	r = 0;
 	if (*c == '-') {
 		*c = (char)fgetc(stdin);
 		s = -1;
 	}
 	else {
 		s = 1;
 	}
 	for (; *c >= '0' && *c <= '9'; *c = (char)fgetc(stdin)) {
 		r = r > 0 ? 10*r+(*c-'0'):*c-'0';
 	}
 	return r*s;
 }
 void readend(char *c,char e) {
 	for (; *c != e; *c = (char)fgetc(stdin));
 	*c = (char)fgetc(stdin);
 }
 void swap(int i1,int i2) {
 struct Frequency swap;
 	memcpy(&swap,&F[i1],sizeof(struct Frequency));
 	memcpy(&F[i1],&F[i2],sizeof(struct Frequency));
 	memcpy(&F[i2],&swap,sizeof(struct Frequency));
 }
 void quicksort(int i1,int i2) {
 int i3,i4,pivot;
 	i3 = i1;
 	i4 = i2;
 	if (i2 > i1) {
 		pivot = F[i1].F;
 		while (i4 > i3) {
 			for (; F[i3].F >= pivot && i3 <= i2 && i3 < i4; i3++);
 			for (; F[i4].F < pivot && i4 >= i1 && i4 >= i3; i4--);
 			if (i4 > i3) {
 				swap(i3,i4);
 			}
 		}
 		swap(i1,i4);
 		quicksort(i1,i4-1);
 		quicksort(i4+1,i2);
 	}
 }
 int main() {
 char c;
 int n,P,K,L,i,j;
 long long M;
 	c = (char)fgetc(stdin);
 	n = readint(&c);
 	readend(&c,'n');
 	for (i = 1; i <= n; i++) {
 		P = readint(&c);
 		readend(&c,' ');
 		K = readint(&c);
 		readend(&c,' ');
 		L = readint(&c);
 		readend(&c,'n');
 		F = (struct Frequency *)malloc(sizeof(struct Frequency)*L);
 		for (j = 0; j < L-1; j++) {
 			F[j].L = j;
 			F[j].F = readint(&c);
 			readend(&c,' ');
 		}
 		F[j].L = j;
 		F[j].F = readint(&c);
 		readend(&c,'n');
 		quicksort(0,L-1);
 		M = 0;
 		for (j = 0; j < L; j++) {
 			M += (long long)(F[j].F*((j/K)+1));
 		}
 		fprintf(stdout,αCase #%i: %lldnα,i,M);
 		fflush(stdout);
 		free(F);
 	}
 	return 0;
 }"
48981,2008,32015,HenryW,24487,1,b.c,gcj/2008/32015/HenryW/24487/1/extracted/b.c,"#include<stdio.h>
 #include<string.h>
 
 long long uglies[300][100]; //0 none 1 + 2 -
 long long num[100];
 long long N, len;
 
 long long getnum(long long s, long long e) {
   long long i, rem=0;
   for (i=s;i<=e;i++) {
     rem=rem*10+num[i];
     rem%=210;
   }
 	return rem;
 }
 
 void process() {
   long long i,j,k,num;
   long long added,subtracted;
   long long  source;
   for (i=1;i<len;i++) {
     for (j=0;j<210;j++)
       uglies[j][i]=0;
     
     for (j=0;j<=i;j++) {
       num=getnum(j,i);
       if (j==0) {
 	uglies[num][i]++;
       }
       else {
 	for (k=0;k<210;k++) {
 	  added = (k+num)%210;
 	  subtracted = (k-num+210)%210;
 	  uglies[added][i]+=uglies[k][j-1];
 	  uglies[subtracted][i]+=uglies[k][j-1];
 	}
       }
     }
   }
   return;
 }
 
 long long getCount() {
   long long i;
   long long c=0;
   for (i=0;i<210;i++) {
     if (i%2==0 || i%3 == 0 || i%5 == 0 || i%7 == 0)
       c+= uglies[i][len-1];
   }
   return c;
 }
 
 void main() {
   FILE *in=fopen(αtest.inα,αrα);
   FILE *out=fopen(αtest.outα,αwα);
   long long i,j,count;
   char string[100];
   
   fscanf(in,α%lld α,&N);
   printf(α%lldnα,N);
   
   for (i=0;i<N;i++) {
     fscanf(in,α%sα,string);
     printf(α%snα,string);
     len=strlen(string);
     
     for (j=0;j<len;j++)
  {
       num[j]=string[j]-'0';
     }
     for (j=0;j<300;j++)
       uglies[j][0]=0;
     uglies[num[0]][0]=1;
     
     process();
     count=getCount();
     
     fprintf(out,αCase #%lld: %lldnα,i+1,count);
   }
 }"
48983,2008,32015,HenryW,24486,1,newA.c,gcj/2008/32015/HenryW/24486/1/extracted/newA.c,"#include<stdio.h>
 
 long long N,P,K,L;
 long long freq[2000];
 
 void sort() {
 	long long i,j,temp;
 
 	for (i=0;i<L;i++)
 		for (j=i+1;j<L;j++)
 			if (freq[i]<freq[j]) {
 				temp=freq[i];
 				freq[i]=freq[j];
 				freq[j]=temp;
 			}
 	return;
 }
 
 long long getMin() {
 	long long sum = 0;
 	long long i;
 	for (i=0;i<L;i++) {
 		sum += (((i/K)+1) * freq[i]);
 	}
 	return sum;
 }
 
 void main() {
 	FILE *in=fopen(αinput.txtα,αrα);
 	FILE *out=fopen(αoutput.txtα,αwα);
 	long long i,j;
 	long long min;
 
 	fscanf(in,α%lldα,&N);
 	for (i=0;i<N;i++) {
 		fscanf(in,α%lld %lld %lldα, &P,&K,&L);
 		for (j=0;j<L;j++)
 			fscanf(in,α%lldα,&freq[j]);
 
 		sort();
 		min=getMin();
 
 	   fprintf(out,αCase #%lld: %lldnα,i+1, min);
 	}
 }"
49090,2008,32015,oscarbg,24486,1,text.c,gcj/2008/32015/oscarbg/24486/1/extracted/text.c,"// tren.cpp : Defines the entry point for the console application.
 // Oscar Barenys Garcia
 // Google Code Jam 2008
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #define true 1
 #define false 0
 #include <assert.h>
 typedef unsigned long long ulli;
 
 #include <math.h>
 int compareA(const void *_a, const void *_b) {
  
         int *a, *b;
         
         a = (int *) _a;
         b = (int *) _b;
         
         return (*b - *a);
 }
 
 ulli sol(int P,int K,int L, int *fL)
 {
 	ulli c=0;
 	int i;
 	qsort(fL,L,sizeof(int),compareA);
 	for(i=0; i<L; i++)
 	{
 		c+=fL[i]*((i/K)+1);
 	}
 	return(c);
 }
 
 
 
 void lee(char *in)
 {
 	FILE *fp,*fp2;
 	int i,j,k;
 	ulli  res[3];
 	int N;
 	int P,K,L;
 	int f[2000];
 	ulli kk;
 	char out[100];
 	if((fp=fopen(in,αrtα))==NULL) exit(0);
 	sprintf(out,α%s.outα,in);
 	fp2=fopen(out,αwtα);
 	//while(!feof(fp))
 	{
 		fscanf(fp,α%dnα,&N);
 		for(i=0; i<N; i++)
 		{
 			fscanf(fp,α%d %d %dnα,&P,&K,&L);
 			for(j=0; j<L; j++)
 				fscanf(fp,α%dα,&f[j]);
 			res[0]=sol(P,K,L,f);
 			fprintf(fp2,αCase #%d: %I64dnα,i+1,res[0]);
 			
 		}
 	}
 
 	/*kk=1<<10;
 	kk=kk<<30;
 	printf(αα,kk);*/
 	fclose(fp);
 	fclose(fp2);
 }
 
 int main(int argc, char* argv[])
 {
 	if(argc>1)
 	{
 		lee(argv[1]);
 	}
 	return 0;
 }"
