//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t fprintf(int64_t a1, char * a2, int64_t a3, int64_t a4, int128_t a5);
int64_t free(float64_t (*a1)[1][1]);
void init_array(uint32_t nr, uint32_t nq, uint32_t np, float64_t (*A)[1][1], float64_t (*C4)[1]);
int64_t kernel_doitgen(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t polybench_alloc_data(int64_t a1, int64_t a2);
void print_array(uint32_t nr, uint32_t nq, int32_t np, float64_t (*A)[1][1]);
int64_t strcmp(int64_t a1, int64_t * a2, int32_t a3, float64_t (*a4)[1][1], float64_t (*a5)[1], float64_t * a6);
int32_t submain(int32_t argc, char ** argv);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4e494745423d3d00; // 0x537
int64_t g2 = 0x322e3025000a0041; // 0x55e

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x173
int64_t kernel_doitgen(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x0
    if ((int32_t)a1 <= 0) {
        // 0x171
        return 0;
    }
    int64_t v1 = a3 & 0xffffffff;
    int64_t result = a1 & 0xffffffff;
    int64_t v2 = 0;
    int64_t v3; // 0x0
    int64_t v4; // 0x0
    int64_t v5; // 0x0
    int64_t v6; // 0x0
    int128_t v7; // 0x0
    int128_t v8; // 0x0
    int128_t v9; // 0x0
    while (true) {
        // 0x33
        int128_t v10; // 0x0
        int128_t v11 = v10;
        int64_t v12 = v2;
        v8 = v11;
        if ((int32_t)a2 > 0) {
            int64_t v13 = 0x2bc00 * v12 + a4;
            v4 = 0;
            v7 = v11;
            while (true) {
              lab_0x46:;
                int128_t v14 = v7;
                v5 = v4;
                v9 = v14;
                if ((int32_t)a3 > 0) {
                    // 0x52
                    v6 = v13 + 1280 * v5;
                    int64_t v15 = 0;
                    int128_t v16 = v14; // 0x0
                    while (true) {
                        int128_t v17 = v16;
                        int64_t v18 = __asm_movsd(__asm_xorps(v17, v17)); // 0x5d
                        int64_t v19 = 8 * v15; // 0x5d
                        int64_t * v20 = (int64_t *)(v19 + a6); // 0x5d
                        *v20 = v18;
                        int64_t v21 = 0;
                        int128_t v22 = __asm_movsd_1(*(int64_t *)(8 * v21 + v6)); // 0x99
                        int128_t v23 = __asm_movsd_1(*(int64_t *)(v19 + a5 + 1280 * v21)); // 0xb4
                        int128_t v24 = __asm_addsd(__asm_mulsd(v22, v23), __asm_movsd_1(*v20)); // 0xca
                        *v20 = __asm_movsd(v24);
                        v21++;
                        while (v21 != v1) {
                            // 0x75
                            v22 = __asm_movsd_1(*(int64_t *)(8 * v21 + v6));
                            v23 = __asm_movsd_1(*(int64_t *)(v19 + a5 + 1280 * v21));
                            v24 = __asm_addsd(__asm_mulsd(v22, v23), __asm_movsd_1(*v20));
                            *v20 = __asm_movsd(v24);
                            v21++;
                        }
                        // 0xe6
                        v15++;
                        v16 = v24;
                        v3 = 0;
                        if (v15 == v1) {
                            goto lab_0x107;
                        }
                    }
                }
                goto lab_0x150;
            }
        }
      lab_0x163:
        // 0x163
        v2 = v12 + 1;
        v10 = v8;
        if (v2 == result) {
            // break -> 0x171
            break;
        }
    }
    // 0x171
    return result;
  lab_0x107:;
    int64_t v25 = 8 * v3; // 0x10f
    int128_t v26 = __asm_movsd_1(*(int64_t *)(v25 + a6)); // 0x10f
    *(int64_t *)(v25 + v6) = __asm_movsd(v26);
    int64_t v27 = v3 + 1;
    v3 = v27;
    v9 = v26;
    if (v27 == v1) {
        goto lab_0x150;
    } else {
        goto lab_0x107;
    }
  lab_0x150:;
    int64_t v28 = v5 + 1;
    v4 = v28;
    v7 = v9;
    v8 = v9;
    if (v28 == (a2 & 0xffffffff)) {
        // break -> 0x163
        goto lab_0x163;
    }
    goto lab_0x46;
}

// Address range: 0x180 - 0x268
// Line range:    88 - 127
int32_t submain(int32_t argc, char ** argv) {
    int64_t v1 = polybench_alloc_data(0x334500, 8); // 0x1ae
    int64_t v2 = polybench_alloc_data(160, 8); // 0x1c1
    int64_t v3 = polybench_alloc_data(0x6400, 8); // 0x1d4
    float64_t (*v4)[1][1] = (float64_t (*)[1][1])v3; // 0x1d9
    init_array(150, 140, 160, &((float64_t (*)[1][1][1])v1)[0], v4);
    if (argc < 43) {
        // 0x245
        free(&((float64_t (*)[1][1][1])v1)[0]);
        free((float64_t (*)[1][1])v2);
        free(v4);
        return 0;
    }
    int64_t strcmp_rc = strcmp(140, &g1, 160, (float64_t (*)[1][1])v1, (float64_t (*)[1])v3, (float64_t *)v2); // 0x225
    if ((int32_t)strcmp_rc == 0) {
        // 0x233
        print_array(150, 140, 160, &((float64_t (*)[1][1][1])v1)[0]);
    }
    // 0x245
    free(&((float64_t (*)[1][1][1])v1)[0]);
    free((float64_t (*)[1][1])v2);
    free(v4);
    return 0;
}

// Address range: 0x270 - 0x3b2
// Line range:    26 - 39
void init_array(uint32_t nr, uint32_t nq, uint32_t np, float64_t (*A)[1][1], float64_t (*C4)[1]) {
    if ((int32_t)nr > 0) {
        int64_t v1 = np;
        int64_t v2 = 0;
        int64_t v3; // 0x270
        int64_t v4; // 0x270
        int64_t v5; // 0x270
        int32_t v6; // 0x2c5
        int128_t v7; // 0x2cc
        int64_t v8; // 0x2fd
        int64_t v9; // 0x270
        int32_t v10; // 0x270
        if (nq > 0) {
            // 0x2b2
            v9 = 0x2bc00 * v2 + (int64_t)A;
            v10 = v2;
            v3 = 0;
            if (np > 0) {
                // 0x2be
                v4 = 0;
                v6 = (int32_t)v3 * v10 + (int32_t)v4;
                v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                v4++;
                while (v4 != v1) {
                    // 0x2be
                    v6 = (int32_t)v3 * v10 + (int32_t)v4;
                    v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                    v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                    *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                    v4++;
                }
            }
            // 0x315
            v5 = v3 + 1;
            while (v5 != (int64_t)nq) {
                // 0x2b2
                v3 = v5;
                if (np > 0) {
                    // 0x2be
                    v4 = 0;
                    v6 = (int32_t)v3 * v10 + (int32_t)v4;
                    v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                    v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                    *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                    v4++;
                    while (v4 != v1) {
                        // 0x2be
                        v6 = (int32_t)v3 * v10 + (int32_t)v4;
                        v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                        v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                        *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                        v4++;
                    }
                }
                // 0x315
                v5 = v3 + 1;
            }
        }
        int64_t v11 = v2 + 1;
        while (v11 != (int64_t)nr) {
            // 0x29f
            v2 = v11;
            if (nq > 0) {
                // 0x2b2
                v9 = 0x2bc00 * v2 + (int64_t)A;
                v10 = v2;
                v3 = 0;
                if (np > 0) {
                    // 0x2be
                    v4 = 0;
                    v6 = (int32_t)v3 * v10 + (int32_t)v4;
                    v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                    v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                    *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                    v4++;
                    while (v4 != v1) {
                        // 0x2be
                        v6 = (int32_t)v3 * v10 + (int32_t)v4;
                        v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                        v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                        *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                        v4++;
                    }
                }
                // 0x315
                v5 = v3 + 1;
                while (v5 != (int64_t)nq) {
                    // 0x2b2
                    v3 = v5;
                    if (np > 0) {
                        // 0x2be
                        v4 = 0;
                        v6 = (int32_t)v3 * v10 + (int32_t)v4;
                        v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                        v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                        *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                        v4++;
                        while (v4 != v1) {
                            // 0x2be
                            v6 = (int32_t)v3 * v10 + (int32_t)v4;
                            v7 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % v1));
                            v8 = __asm_movsd(__asm_divsd(v7, __asm_cvtsi2sd(np)));
                            *(int64_t *)(v9 + 1280 * v3 + 8 * v4) = v8;
                            v4++;
                        }
                    }
                    // 0x315
                    v5 = v3 + 1;
                }
            }
            // 0x328
            v11 = v2 + 1;
        }
    }
    if (np <= 0) {
        // 0x3b0
        return;
    }
    int64_t v12 = np;
    int64_t v13 = 0;
    int64_t v14 = 1280 * v13 + (0x100000000 * (int64_t)C4 >> 32);
    int64_t v15 = 0;
    int32_t v16 = (int32_t)v15 * (int32_t)v13; // 0x35f
    int128_t v17 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v16 >> 31) | (int64_t)v16) % v12)); // 0x367
    *(int64_t *)(v14 + 8 * v15) = __asm_movsd(__asm_divsd(v17, __asm_cvtsi2sd(np)));
    v15++;
    while (v15 != v12) {
        // 0x35c
        v16 = (int32_t)v15 * (int32_t)v13;
        v17 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v16 >> 31) | (int64_t)v16) % v12));
        *(int64_t *)(v14 + 8 * v15) = __asm_movsd(__asm_divsd(v17, __asm_cvtsi2sd(np)));
        v15++;
    }
    // 0x3a2
    v13++;
    while (v13 != v12) {
        // 0x35c
        v14 = 1280 * v13 + (0x100000000 * (int64_t)C4 >> 32);
        v15 = 0;
        v16 = (int32_t)v15 * (int32_t)v13;
        v17 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v16 >> 31) | (int64_t)v16) % v12));
        *(int64_t *)(v14 + 8 * v15) = __asm_movsd(__asm_divsd(v17, __asm_cvtsi2sd(np)));
        v15++;
        while (v15 != v12) {
            // 0x35c
            v16 = (int32_t)v15 * (int32_t)v13;
            v17 = __asm_cvtsi2sd((int32_t)((0x100000000 * (int64_t)(v16 >> 31) | (int64_t)v16) % v12));
            *(int64_t *)(v14 + 8 * v15) = __asm_movsd(__asm_divsd(v17, __asm_cvtsi2sd(np)));
            v15++;
        }
        // 0x3a2
        v13++;
    }
}

// Address range: 0x3c0 - 0x537
// Line range:    45 - 60
void print_array(uint32_t nr, uint32_t nq, int32_t np, float64_t (*A)[1][1]) {
    int64_t v1 = (int64_t)A;
    int64_t stream = *(int64_t *)*(int64_t *)988; // 0x3dc
    int128_t v2; // 0x3c0
    fprintf(stream, "==BEGIN DUMP_ARRAYS==\n", (int64_t)np, v1, v2);
    int64_t stream2 = *(int64_t *)*(int64_t *)1012; // 0x3f4
    fprintf(stream2, "begin dump: %s", (int64_t)&g2, v1, v2);
    int64_t v3 = v1; // 0x419
    int128_t v4; // 0x3c0
    if (nr > 0) {
        int64_t v5 = 0;
        int128_t v6; // 0x3c0
        int128_t v7 = v6; // 0x42c
        int64_t v8 = v1; // 0x42c
        int64_t v9; // 0x3c0
        int64_t v10; // 0x3c0
        int64_t v11; // 0x3c0
        int64_t v12; // 0x3c0
        int64_t v13; // 0x3c0
        int64_t v14; // 0x3c0
        int32_t v15; // 0x3c0
        int64_t v16; // 0x3c0
        int32_t v17; // 0x459
        int64_t v18; // 0x462
        int64_t v19; // 0x462
        int128_t v20; // 0x4b3
        int128_t v21; // 0x3c0
        int128_t v22; // 0x3c0
        int128_t v23; // 0x3c0
        int128_t v24; // 0x3c0
        if (nq > 0) {
            // 0x439
            v15 = (int32_t)v5 * nq;
            v16 = 0x2bc00 * v5 + (0x100000000 * v1 >> 32);
            v9 = 0;
            v23 = v6;
            v13 = v1;
            if (np > 0) {
                // 0x445
                v12 = 0;
                v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                v19 = v18 & 0xffffffff;
                if ((int32_t)v18 == 0) {
                    // 0x46d
                    fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v6);
                }
                // 0x485
                v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                v10 = v12 + 1;
                v22 = v20;
                v23 = v20;
                v13 = v12;
                while (v10 != (int64_t)np) {
                    // 0x445
                    v12 = v10;
                    v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                    v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                    v19 = v18 & 0xffffffff;
                    if ((int32_t)v18 == 0) {
                        // 0x46d
                        fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                    }
                    // 0x485
                    v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                    fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                    v10 = v12 + 1;
                    v22 = v20;
                    v23 = v20;
                    v13 = v12;
                }
            }
            // 0x4d9
            v14 = v13;
            v24 = v23;
            v11 = v9 + 1;
            v7 = v24;
            v8 = v14;
            while (v11 != (int64_t)nq) {
                // 0x439
                v21 = v24;
                v9 = v11;
                v23 = v21;
                v13 = v14;
                if (np > 0) {
                    // 0x445
                    v22 = v21;
                    v12 = 0;
                    v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                    v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                    v19 = v18 & 0xffffffff;
                    if ((int32_t)v18 == 0) {
                        // 0x46d
                        fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                    }
                    // 0x485
                    v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                    fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                    v10 = v12 + 1;
                    v22 = v20;
                    v23 = v20;
                    v13 = v12;
                    while (v10 != (int64_t)np) {
                        // 0x445
                        v12 = v10;
                        v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                        v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                        v19 = v18 & 0xffffffff;
                        if ((int32_t)v18 == 0) {
                            // 0x46d
                            fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                        }
                        // 0x485
                        v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                        fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                        v10 = v12 + 1;
                        v22 = v20;
                        v23 = v20;
                        v13 = v12;
                    }
                }
                // 0x4d9
                v14 = v13;
                v24 = v23;
                v11 = v9 + 1;
                v7 = v24;
                v8 = v14;
            }
        }
        int64_t v25 = v8;
        int64_t v26 = v5 + 1;
        v4 = v7;
        v3 = v25;
        while (v26 != (int64_t)nr) {
            int128_t v27 = v7;
            int64_t v28 = v25;
            v5 = v26;
            v7 = v27;
            v8 = v28;
            if (nq > 0) {
                // 0x439
                v15 = (int32_t)v5 * nq;
                v16 = 0x2bc00 * v5 + (0x100000000 * v1 >> 32);
                v21 = v27;
                v9 = 0;
                v23 = v21;
                v13 = v28;
                if (np > 0) {
                    // 0x445
                    v22 = v21;
                    v12 = 0;
                    v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                    v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                    v19 = v18 & 0xffffffff;
                    if ((int32_t)v18 == 0) {
                        // 0x46d
                        fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                    }
                    // 0x485
                    v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                    fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                    v10 = v12 + 1;
                    v22 = v20;
                    v23 = v20;
                    v13 = v12;
                    while (v10 != (int64_t)np) {
                        // 0x445
                        v12 = v10;
                        v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                        v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                        v19 = v18 & 0xffffffff;
                        if ((int32_t)v18 == 0) {
                            // 0x46d
                            fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                        }
                        // 0x485
                        v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                        fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                        v10 = v12 + 1;
                        v22 = v20;
                        v23 = v20;
                        v13 = v12;
                    }
                }
                // 0x4d9
                v14 = v13;
                v24 = v23;
                v11 = v9 + 1;
                v7 = v24;
                v8 = v14;
                while (v11 != (int64_t)nq) {
                    // 0x439
                    v21 = v24;
                    v9 = v11;
                    v23 = v21;
                    v13 = v14;
                    if (np > 0) {
                        // 0x445
                        v22 = v21;
                        v12 = 0;
                        v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                        v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                        v19 = v18 & 0xffffffff;
                        if ((int32_t)v18 == 0) {
                            // 0x46d
                            fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                        }
                        // 0x485
                        v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                        fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                        v10 = v12 + 1;
                        v22 = v20;
                        v23 = v20;
                        v13 = v12;
                        while (v10 != (int64_t)np) {
                            // 0x445
                            v12 = v10;
                            v17 = (v15 + (int32_t)v9) * np + (int32_t)v12;
                            v18 = (0x100000000 * (int64_t)(v17 >> 31) | (int64_t)v17) % 20;
                            v19 = v18 & 0xffffffff;
                            if ((int32_t)v18 == 0) {
                                // 0x46d
                                fprintf(*(int64_t *)*(int64_t *)1140, "\n", v19, 20, v22);
                            }
                            // 0x485
                            v20 = __asm_movsd_1(*(int64_t *)(v16 + 1280 * v9 + 8 * v12));
                            fprintf(*(int64_t *)*(int64_t *)1164, "%0.2lf ", v19, v12, v20);
                            v10 = v12 + 1;
                            v22 = v20;
                            v23 = v20;
                            v13 = v12;
                        }
                    }
                    // 0x4d9
                    v14 = v13;
                    v24 = v23;
                    v11 = v9 + 1;
                    v7 = v24;
                    v8 = v14;
                }
            }
            // 0x4ec
            v25 = v8;
            v26 = v5 + 1;
            v4 = v7;
            v3 = v25;
        }
    }
    int64_t stream3 = *(int64_t *)*(int64_t *)1281; // 0x501
    fprintf(stream3, "\nend   dump: %s\n", (int64_t)&g2, v3, v4);
    int64_t stream4 = *(int64_t *)*(int64_t *)1312; // 0x520
    fprintf(stream4, "==END   DUMP_ARRAYS==\n", (int64_t)&g2, v3, v4);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 4

