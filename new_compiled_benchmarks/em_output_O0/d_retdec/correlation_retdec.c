//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t fprintf(int64_t a1, char * a2, int64_t a3, int64_t a4, int128_t a5);
int64_t free(float64_t (*a1)[1]);
void init_array(int32_t m, int32_t n, float64_t * float_n, float64_t (*data)[1]);
int64_t kernel_correlation(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t polybench_alloc_data(int64_t a1, int64_t a2);
void print_array(uint32_t m, float64_t (*corr)[1]);
int64_t sqrt(int128_t a1);
int64_t strcmp(int64_t a1, int64_t * a2, float64_t (*a3)[1], float64_t (*a4)[1], float64_t * a5, int64_t a6, int128_t a7);
int32_t submain(int32_t argc, char ** argv);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4e494745423d3d00; // 0x740

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x43f
int64_t kernel_correlation(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    int64_t v1 = 0x100000000 * a1;
    int64_t v2 = v1 >> 32; // 0x8
    int64_t v3 = 0x100000000 * a2 >> 32; // 0xb
    int128_t v4; // 0x0
    int64_t v5 = __asm_movsd_1(v4); // 0xe
    int128_t v6 = __asm_movsd(0x3fb999999999999a); // 0x23
    int64_t v7 = __asm_movsd_1(v6); // 0x2b
    int32_t v8 = v2; // 0x3a
    int32_t v9 = v3;
    if (v8 > 0) {
        int64_t v10 = v3 & 0xffffffff;
        int64_t v11 = v2 & 0xffffffff;
        int64_t v12 = 0;
        int128_t v13 = v6;
        int64_t v14 = __asm_movsd_1(__asm_xorps(v13, v13)); // 0x4e
        int64_t v15 = 8 * v12; // 0x4e
        int64_t * v16 = (int64_t *)(v15 + a5); // 0x4e
        *v16 = v14;
        int64_t v17; // 0x0
        int128_t v18; // 0x7c
        if (v9 > 0) {
            // 0x66
            v17 = 0;
            v18 = __asm_movsd(*(int64_t *)(v15 + a3 + 0x2580 * v17));
            *v16 = __asm_movsd_1(__asm_addsd_2(v18, *v16));
            v17++;
            while (v17 != v10) {
                // 0x66
                v18 = __asm_movsd(*(int64_t *)(v15 + a3 + 0x2580 * v17));
                *v16 = __asm_movsd_1(__asm_addsd_2(v18, *v16));
                v17++;
            }
        }
        int128_t v19 = __asm_divsd(__asm_movsd(*v16), __asm_movsd(v5)); // 0xb3
        *v16 = __asm_movsd_1(v19);
        v12++;
        int64_t v20 = 0; // 0x3d
        while (v12 != v11) {
            // 0x43
            v13 = v19;
            v14 = __asm_movsd_1(__asm_xorps(v13, v13));
            v15 = 8 * v12;
            v16 = (int64_t *)(v15 + a5);
            *v16 = v14;
            if (v9 > 0) {
                // 0x66
                v17 = 0;
                v18 = __asm_movsd(*(int64_t *)(v15 + a3 + 0x2580 * v17));
                *v16 = __asm_movsd_1(__asm_addsd_2(v18, *v16));
                v17++;
                while (v17 != v10) {
                    // 0x66
                    v18 = __asm_movsd(*(int64_t *)(v15 + a3 + 0x2580 * v17));
                    *v16 = __asm_movsd_1(__asm_addsd_2(v18, *v16));
                    v17++;
                }
            }
            // 0xa1
            v19 = __asm_divsd(__asm_movsd(*v16), __asm_movsd(v5));
            *v16 = __asm_movsd_1(v19);
            v12++;
            v20 = 0;
        }
        int128_t v21 = v19;
        int64_t v22 = __asm_movsd_1(__asm_xorps(v21, v21)); // 0xe8
        int64_t v23 = 8 * v20; // 0xe8
        int64_t * v24 = (int64_t *)(v23 + a6); // 0xe8
        *v24 = v22;
        int32_t v25 = 0; // 0xfa
        int64_t v26; // 0x0
        int64_t * v27; // 0x0
        int64_t * v28; // 0x116
        int128_t v29; // 0x123
        int128_t v30; // 0x14b
        if (v9 > 0) {
            // 0x100
            v27 = (int64_t *)(v23 + a5);
            v26 = 0;
            v28 = (int64_t *)(v23 + a3 + 0x2580 * v26);
            v29 = __asm_subsd(__asm_movsd(*v28), *v27);
            v30 = __asm_subsd(__asm_movsd(*v28), *v27);
            *v24 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v29, v30), __asm_movsd(*v24)));
            v26++;
            v25 = v9;
            while (v26 != v10) {
                // 0x100
                v28 = (int64_t *)(v23 + a3 + 0x2580 * v26);
                v29 = __asm_subsd(__asm_movsd(*v28), *v27);
                v30 = __asm_subsd(__asm_movsd(*v28), *v27);
                *v24 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v29, v30), __asm_movsd(*v24)));
                v26++;
                v25 = v9;
            }
        }
        int64_t v31 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v24), __asm_movsd(v5))); // 0x18e
        *v24 = v31;
        int128_t v32 = __asm_movsd(v31); // 0x19b
        sqrt(v32);
        int64_t v33 = __asm_movsd_1(v32); // 0x1ad
        *v24 = v33;
        __asm_ucomisd(__asm_movsd(v7), __asm_movsd(v33));
        int64_t v34; // 0x0
        if (v25 < v9) {
            // 0x1e0
            v34 = __asm_movsd_1(__asm_movsd(*v24));
        } else {
            // 0x1ce
            v34 = __asm_movsd_1(__asm_movsd(0x3ff0000000000000));
        }
        int128_t v35 = __asm_movsd(v34); // 0x1f2
        *v24 = __asm_movsd_1(v35);
        int64_t v36 = v20 + 1;
        v20 = v36;
        while (v36 != v11) {
            // 0xdd
            v21 = v35;
            v22 = __asm_movsd_1(__asm_xorps(v21, v21));
            v23 = 8 * v20;
            v24 = (int64_t *)(v23 + a6);
            *v24 = v22;
            v25 = 0;
            if (v9 > 0) {
                // 0x100
                v27 = (int64_t *)(v23 + a5);
                v26 = 0;
                v28 = (int64_t *)(v23 + a3 + 0x2580 * v26);
                v29 = __asm_subsd(__asm_movsd(*v28), *v27);
                v30 = __asm_subsd(__asm_movsd(*v28), *v27);
                *v24 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v29, v30), __asm_movsd(*v24)));
                v26++;
                v25 = v9;
                while (v26 != v10) {
                    // 0x100
                    v28 = (int64_t *)(v23 + a3 + 0x2580 * v26);
                    v29 = __asm_subsd(__asm_movsd(*v28), *v27);
                    v30 = __asm_subsd(__asm_movsd(*v28), *v27);
                    *v24 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v29, v30), __asm_movsd(*v24)));
                    v26++;
                    v25 = v9;
                }
            }
            // 0x178
            v31 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v24), __asm_movsd(v5)));
            *v24 = v31;
            v32 = __asm_movsd(v31);
            sqrt(v32);
            v33 = __asm_movsd_1(v32);
            *v24 = v33;
            __asm_ucomisd(__asm_movsd(v7), __asm_movsd(v33));
            if (v25 < v9) {
                // 0x1e0
                v34 = __asm_movsd_1(__asm_movsd(*v24));
            } else {
                // 0x1ce
                v34 = __asm_movsd_1(__asm_movsd(0x3ff0000000000000));
            }
            // 0x1f2
            v35 = __asm_movsd(v34);
            *v24 = __asm_movsd_1(v35);
            v36 = v20 + 1;
            v20 = v36;
        }
    }
    if (v9 > 0) {
        int64_t v37 = 0;
        int64_t v38; // 0x0
        int64_t v39; // 0x240
        int128_t v40; // 0x240
        int64_t * v41; // 0x25b
        int128_t v42; // 0x269
        int128_t v43; // 0x27e
        if (v8 > 0) {
            // 0x238
            v38 = 0;
            v39 = 8 * v38;
            v40 = __asm_movsd(*(int64_t *)(v39 + a5));
            v41 = (int64_t *)(0x2580 * v37 + a3 + v39);
            *v41 = __asm_movsd_1(__asm_subsd_3(__asm_movsd(*v41), v40));
            v42 = __asm_movsd(v5);
            sqrt(v42);
            v43 = __asm_mulsd_4(__asm_movaps(v42), *(int64_t *)(v39 + a6));
            *v41 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v41), v43));
            v38++;
            while (v38 != (v2 & 0xffffffff)) {
                // 0x238
                v39 = 8 * v38;
                v40 = __asm_movsd(*(int64_t *)(v39 + a5));
                v41 = (int64_t *)(0x2580 * v37 + a3 + v39);
                *v41 = __asm_movsd_1(__asm_subsd_3(__asm_movsd(*v41), v40));
                v42 = __asm_movsd(v5);
                sqrt(v42);
                v43 = __asm_mulsd_4(__asm_movaps(v42), *(int64_t *)(v39 + a6));
                *v41 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v41), v43));
                v38++;
            }
        }
        int64_t v44 = v37 + 1;
        while (v44 != (v3 & 0xffffffff)) {
            // 0x22c
            v37 = v44;
            if (v8 > 0) {
                // 0x238
                v38 = 0;
                v39 = 8 * v38;
                v40 = __asm_movsd(*(int64_t *)(v39 + a5));
                v41 = (int64_t *)(0x2580 * v37 + a3 + v39);
                *v41 = __asm_movsd_1(__asm_subsd_3(__asm_movsd(*v41), v40));
                v42 = __asm_movsd(v5);
                sqrt(v42);
                v43 = __asm_mulsd_4(__asm_movaps(v42), *(int64_t *)(v39 + a6));
                *v41 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v41), v43));
                v38++;
                while (v38 != (v2 & 0xffffffff)) {
                    // 0x238
                    v39 = 8 * v38;
                    v40 = __asm_movsd(*(int64_t *)(v39 + a5));
                    v41 = (int64_t *)(0x2580 * v37 + a3 + v39);
                    *v41 = __asm_movsd_1(__asm_subsd_3(__asm_movsd(*v41), v40));
                    v42 = __asm_movsd(v5);
                    sqrt(v42);
                    v43 = __asm_mulsd_4(__asm_movaps(v42), *(int64_t *)(v39 + a6));
                    *v41 = __asm_movsd_1(__asm_divsd(__asm_movsd(*v41), v43));
                    v38++;
                }
            }
            // 0x2ba
            v44 = v37 + 1;
        }
    }
    uint64_t v45 = v2 + 0xffffffff & 0xffffffff; // 0x2d5
    if (v45 != 0) {
        int64_t v46 = 0;
        int32_t v47 = 0;
        int32_t v48 = 1;
        int64_t v49 = 0x2580 * v46 + a4; // 0x2ef
        int128_t v50 = __asm_movsd(0x3ff0000000000000); // 0x2f6
        int64_t v51 = __asm_movsd_1(v50); // 0x2fe
        int64_t v52 = 8 * v46; // 0x2fe
        *(int64_t *)(v49 + v52) = v51;
        v47++;
        int64_t v53; // 0x0
        int64_t v54; // 0x0
        int64_t v55; // 0x0
        int64_t v56; // 0x0
        int64_t v57; // 0x3a2
        int128_t v58; // 0x3cb
        int64_t v59; // 0x331
        int64_t v60; // 0x331
        int64_t * v61; // 0x331
        int64_t v62; // 0x358
        int128_t v63; // 0x35f
        int128_t v64; // 0x37a
        int128_t v65; // 0x0
        if (v47 < v8) {
            // 0x318
            v55 = v48;
            v65 = v50;
            v59 = __asm_movsd_1(__asm_xorps(v65, v65));
            v60 = 0x100000000 * v55 >> 29;
            v61 = (int64_t *)(v60 + v49);
            *v61 = v59;
            v56 = 0;
            v53 = v59;
            if (v9 > 0) {
                v62 = 0x2580 * v56 + a3;
                v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                *v61 = v57;
                v54 = v56 + 1;
                v56 = v54;
                v53 = v57;
                while (v54 != (v3 & 0xffffffff)) {
                    // 0x349
                    v62 = 0x2580 * v56 + a3;
                    v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                    v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                    v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                    *v61 = v57;
                    v54 = v56 + 1;
                    v56 = v54;
                    v53 = v57;
                }
            }
            // 0x3b5
            v58 = __asm_movsd(v53);
            *(int64_t *)(v52 + a4 + 0x2580 * v55) = __asm_movsd_1(v58);
            v55++;
            while ((int32_t)v55 != v8) {
                // 0x318
                v65 = v58;
                v59 = __asm_movsd_1(__asm_xorps(v65, v65));
                v60 = 0x100000000 * v55 >> 29;
                v61 = (int64_t *)(v60 + v49);
                *v61 = v59;
                v56 = 0;
                v53 = v59;
                if (v9 > 0) {
                    v62 = 0x2580 * v56 + a3;
                    v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                    v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                    v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                    *v61 = v57;
                    v54 = v56 + 1;
                    v56 = v54;
                    v53 = v57;
                    while (v54 != (v3 & 0xffffffff)) {
                        // 0x349
                        v62 = 0x2580 * v56 + a3;
                        v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                        v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                        v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                        *v61 = v57;
                        v54 = v56 + 1;
                        v56 = v54;
                        v53 = v57;
                    }
                }
                // 0x3b5
                v58 = __asm_movsd(v53);
                *(int64_t *)(v52 + a4 + 0x2580 * v55) = __asm_movsd_1(v58);
                v55++;
            }
        }
        // 0x3fe
        v46 = v47;
        int32_t v66 = v48 + 1; // 0x2da
        while ((v46 & 0xffffffff) < v45) {
            // 0x2e0
            v48 = v66;
            v49 = 0x2580 * v46 + a4;
            v50 = __asm_movsd(0x3ff0000000000000);
            v51 = __asm_movsd_1(v50);
            v52 = 8 * v46;
            *(int64_t *)(v49 + v52) = v51;
            v47++;
            if (v47 < v8) {
                // 0x318
                v55 = v48;
                v65 = v50;
                v59 = __asm_movsd_1(__asm_xorps(v65, v65));
                v60 = 0x100000000 * v55 >> 29;
                v61 = (int64_t *)(v60 + v49);
                *v61 = v59;
                v56 = 0;
                v53 = v59;
                if (v9 > 0) {
                    v62 = 0x2580 * v56 + a3;
                    v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                    v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                    v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                    *v61 = v57;
                    v54 = v56 + 1;
                    v56 = v54;
                    v53 = v57;
                    while (v54 != (v3 & 0xffffffff)) {
                        // 0x349
                        v62 = 0x2580 * v56 + a3;
                        v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                        v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                        v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                        *v61 = v57;
                        v54 = v56 + 1;
                        v56 = v54;
                        v53 = v57;
                    }
                }
                // 0x3b5
                v58 = __asm_movsd(v53);
                *(int64_t *)(v52 + a4 + 0x2580 * v55) = __asm_movsd_1(v58);
                v55++;
                while ((int32_t)v55 != v8) {
                    // 0x318
                    v65 = v58;
                    v59 = __asm_movsd_1(__asm_xorps(v65, v65));
                    v60 = 0x100000000 * v55 >> 29;
                    v61 = (int64_t *)(v60 + v49);
                    *v61 = v59;
                    v56 = 0;
                    v53 = v59;
                    if (v9 > 0) {
                        v62 = 0x2580 * v56 + a3;
                        v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                        v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                        v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                        *v61 = v57;
                        v54 = v56 + 1;
                        v56 = v54;
                        v53 = v57;
                        while (v54 != (v3 & 0xffffffff)) {
                            // 0x349
                            v62 = 0x2580 * v56 + a3;
                            v63 = __asm_movsd(*(int64_t *)(v62 + v52));
                            v64 = __asm_movsd(*(int64_t *)(v62 + v60));
                            v57 = __asm_movsd_1(__asm_addsd(__asm_mulsd(v63, v64), __asm_movsd(*v61)));
                            *v61 = v57;
                            v54 = v56 + 1;
                            v56 = v54;
                            v53 = v57;
                        }
                    }
                    // 0x3b5
                    v58 = __asm_movsd(v53);
                    *(int64_t *)(v52 + a4 + 0x2580 * v55) = __asm_movsd_1(v58);
                    v55++;
                }
            }
            // 0x3fe
            v46 = v47;
            v66 = v48 + 1;
        }
    }
    int64_t v67 = v1 - 0x100000000;
    int64_t result = 0x2580 * (v67 >> 32) + a4; // 0x420
    *(int64_t *)(result + (v67 >> 29)) = __asm_movsd_1(__asm_movsd(0x3ff0000000000000));
    return result;
}

// Address range: 0x440 - 0x53a
// Line range:    127 - 167
int32_t submain(int32_t argc, char ** argv) {
    int64_t v1 = polybench_alloc_data(0x19a280, 8); // 0x467
    int64_t v2 = polybench_alloc_data(0x15f900, 8); // 0x47a
    float64_t (*v3)[1][1] = (float64_t (*)[1][1])v2; // 0x47f
    int64_t v4 = polybench_alloc_data(1200, 8); // 0x48d
    int64_t v5 = polybench_alloc_data(1200, 8); // 0x4a0
    float64_t float_n; // bp-40, 0x440
    init_array(1200, 1400, &float_n, &((float64_t (*)[1][1])v1)[0]);
    int128_t v6 = __asm_movsd((int64_t)float_n); // 0x4c2
    if (argc < 43) {
        // 0x50e
        free(&((float64_t (*)[1][1])v1)[0]);
        free(v3);
        free((float64_t (*)[1])v4);
        free((float64_t (*)[1])v5);
        return 0;
    }
    int64_t strcmp_rc = strcmp(1400, &g1, (float64_t (*)[1])v1, (float64_t (*)[1])v2, (float64_t *)v4, v5, v6); // 0x4f4
    if ((int32_t)strcmp_rc == 0) {
        // 0x502
        print_array(1200, v3);
    }
    // 0x50e
    free(&((float64_t (*)[1][1])v1)[0]);
    free(v3);
    free((float64_t (*)[1])v4);
    free((float64_t (*)[1])v5);
    return 0;
}

// Address range: 0x540 - 0x5e8
// Line range:    26 - 39
void init_array(int32_t m, int32_t n, float64_t * float_n, float64_t (*data)[1]) {
    // 0x540
    *float_n = (float64_t)__asm_movsd_1(__asm_movsd(0x4095e00000000000));
    for (int64_t i = 0; i < 1400; i++) {
        int64_t v1 = 0x2580 * i + (0x100000000 * (int64_t)data >> 32);
        for (int64_t j = 0; j < 1200; j++) {
            int128_t v2 = __asm_cvtsi2sd((int32_t)(j * i)); // 0x591
            int128_t v3 = __asm_divsd(v2, __asm_movsd(0x4092c00000000000)); // 0x59d
            int128_t v4 = __asm_cvtsi2sd((int32_t)i); // 0x5a1
            *(int64_t *)(v1 + 8 * j) = __asm_movsd_1(__asm_addsd(v3, v4));
        }
    }
}

// Address range: 0x5f0 - 0x720
// Line range:    45 - 60
void print_array(uint32_t m, float64_t (*corr)[1]) {
    // 0x5f0
    int64_t v1; // 0x5f0
    int128_t v2; // 0x5f0
    fprintf(*(int64_t *)*(int64_t *)1542, "==BEGIN DUMP_ARRAYS==\n", v1, v1, v2);
    int64_t stream = *(int64_t *)*(int64_t *)1566; // 0x61e
    fprintf(stream, "begin dump: %s", (int64_t)"corr", v1, v2);
    int64_t v3; // 0x5f0
    int128_t v4; // 0x5f0
    if (m > 0) {
        int64_t v5 = m;
        int64_t v6 = 0;
        int64_t v7 = 0x2580 * v6 + (0x100000000 * (int64_t)corr >> 32);
        int64_t v8 = 0;
        int32_t v9 = (int32_t)v6 * m + (int32_t)v8; // 0x663
        int64_t v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20; // 0x66c
        int64_t v11 = v10 & 0xffffffff; // 0x66c
        if ((int32_t)v10 == 0) {
            // 0x677
            int128_t v12; // 0x5f0
            fprintf(*(int64_t *)*(int64_t *)1662, "\n", v11, 20, v12);
        }
        int128_t v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8)); // 0x6af
        fprintf(*(int64_t *)*(int64_t *)1686, "%0.2lf ", v11, v8, v13);
        int64_t v14 = v8 + 1;
        int128_t v15 = v13; // 0x656
        while (v14 != v5) {
            // 0x65c
            v8 = v14;
            v9 = (int32_t)v6 * m + (int32_t)v8;
            v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
            v11 = v10 & 0xffffffff;
            if ((int32_t)v10 == 0) {
                // 0x677
                fprintf(*(int64_t *)*(int64_t *)1662, "\n", v11, 20, v15);
            }
            // 0x68f
            v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
            fprintf(*(int64_t *)*(int64_t *)1686, "%0.2lf ", v11, v8, v13);
            v14 = v8 + 1;
            v15 = v13;
        }
        // 0x6d5
        v6++;
        v4 = v13;
        v3 = v8;
        while (v6 != v5) {
            // 0x65c
            v7 = 0x2580 * v6 + (0x100000000 * (int64_t)corr >> 32);
            v15 = v13;
            v8 = 0;
            v9 = (int32_t)v6 * m + (int32_t)v8;
            v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
            v11 = v10 & 0xffffffff;
            if ((int32_t)v10 == 0) {
                // 0x677
                fprintf(*(int64_t *)*(int64_t *)1662, "\n", v11, 20, v15);
            }
            // 0x68f
            v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
            fprintf(*(int64_t *)*(int64_t *)1686, "%0.2lf ", v11, v8, v13);
            v14 = v8 + 1;
            v15 = v13;
            while (v14 != v5) {
                // 0x65c
                v8 = v14;
                v9 = (int32_t)v6 * m + (int32_t)v8;
                v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
                v11 = v10 & 0xffffffff;
                if ((int32_t)v10 == 0) {
                    // 0x677
                    fprintf(*(int64_t *)*(int64_t *)1662, "\n", v11, 20, v15);
                }
                // 0x68f
                v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
                fprintf(*(int64_t *)*(int64_t *)1686, "%0.2lf ", v11, v8, v13);
                v14 = v8 + 1;
                v15 = v13;
            }
            // 0x6d5
            v6++;
            v4 = v13;
            v3 = v8;
        }
    }
    int64_t stream2 = *(int64_t *)*(int64_t *)1770; // 0x6ea
    fprintf(stream2, "\nend   dump: %s\n", (int64_t)"corr", v3, v4);
    int64_t stream3 = *(int64_t *)*(int64_t *)1801; // 0x709
    fprintf(stream3, "==END   DUMP_ARRAYS==\n", (int64_t)"corr", v3, v4);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 4

