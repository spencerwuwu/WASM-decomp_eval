//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t fprintf(int64_t a1, char * a2, int64_t a3, int64_t a4, int128_t a5);
int64_t free(float64_t * a1);
void init_array(uint32_t n, float64_t * A, float64_t * B);
int64_t kernel_jacobi_1d(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t polybench_alloc_data(int64_t a1, int64_t a2);
void print_array(uint32_t n, float64_t * A);
int64_t strcmp(int64_t a1, int64_t * a2, float64_t * a3, float64_t * a4);
int32_t submain(int32_t argc, char ** argv);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4e494745423d3d00; // 0x370
int64_t g2 = 0x322e3025000a0041; // 0x397

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x11a
int64_t kernel_jacobi_1d(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    uint32_t v1 = (int32_t)a1; // 0x1c
    if (v1 <= 0) {
        // 0x118
        return 0;
    }
    uint64_t v2 = a2 + 0xffffffff & 0xffffffff; // 0x32
    int32_t v3 = 0; // 0x10d
    int32_t v4; // 0x0
    while (true) {
      lab_0x2c:;
        int32_t v5 = 1; // 0x37
        if (v2 > 1) {
            while (true) {
                int128_t v6 = __asm_movsd(*(int64_t *)(8 * (int64_t)(v5 - 1) + a3)); // 0x4a
                int64_t v7 = 8 * (int64_t)v5; // 0x57
                int128_t v8 = __asm_addsd_2(v6, *(int64_t *)(v7 + a3)); // 0x57
                int32_t v9 = v5 + 1; // 0x63
                int128_t v10 = __asm_addsd_2(v8, *(int64_t *)(8 * (int64_t)v9 + a3)); // 0x69
                *(int64_t *)(v7 + a4) = __asm_movsd_1(__asm_mulsd(__asm_movsd(0x3fd555475a31a4be), v10));
                v5 = v9;
                v4 = 1;
                if (v2 <= (int64_t)v9) {
                    goto lab_0xad;
                }
            }
        }
        goto lab_0x10a;
    }
    // 0x118
    return a1 & 0xffffffff;
  lab_0xad:;
    int128_t v11 = __asm_movsd(*(int64_t *)(8 * (int64_t)(v4 - 1) + a4)); // 0xba
    int64_t v12 = 8 * (int64_t)v4; // 0xc7
    int128_t v13 = __asm_addsd_2(v11, *(int64_t *)(v12 + a4)); // 0xc7
    int32_t v14 = v4 + 1; // 0xd3
    int128_t v15 = __asm_addsd_2(v13, *(int64_t *)(8 * (int64_t)v14 + a4)); // 0xd9
    *(int64_t *)(v12 + a3) = __asm_movsd_1(__asm_mulsd(__asm_movsd(0x3fd555475a31a4be), v15));
    v4 = v14;
    if (v2 > (int64_t)v14) {
        goto lab_0xad;
    } else {
        goto lab_0x10a;
    }
  lab_0x10a:
    // 0x10a
    v3++;
    if (v3 == v1) {
        return a1 & 0xffffffff;
    }
    goto lab_0x2c;
}

// Address range: 0x120 - 0x1d2
// Line range:    84 - 116
int32_t submain(int32_t argc, char ** argv) {
    int64_t v1 = polybench_alloc_data(2000, 8); // 0x147
    int64_t v2 = polybench_alloc_data(2000, 8); // 0x15a
    init_array(2000, &((float64_t (*)[1])v1)[0], &((float64_t (*)[1])v2)[0]);
    if (argc < 43) {
        // 0x1b8
        free(&((float64_t (*)[1])v1)[0]);
        free(&((float64_t (*)[1])v2)[0]);
        return 0;
    }
    int64_t strcmp_rc = strcmp(2000, &g1, (float64_t *)v1, (float64_t *)v2); // 0x19e
    if ((int32_t)strcmp_rc == 0) {
        // 0x1ac
        print_array(2000, &((float64_t (*)[1])v1)[0]);
    }
    // 0x1b8
    free(&((float64_t (*)[1])v1)[0]);
    free(&((float64_t (*)[1])v2)[0]);
    return 0;
}

// Address range: 0x1e0 - 0x260
// Line range:    26 - 37
void init_array(uint32_t n, float64_t * A, float64_t * B) {
    if (n <= 0) {
        // 0x25e
        return;
    }
    int64_t v1 = 0;
    int32_t v2 = v1;
    int128_t v3 = __asm_addsd(__asm_cvtsi2sd(v2), __asm_movsd(0x4000000000000000)); // 0x20f
    int64_t v4 = __asm_movsd_1(__asm_divsd(v3, __asm_cvtsi2sd(n))); // 0x224
    int64_t v5 = 8 * v1; // 0x224
    *(int64_t *)(v5 + (int64_t)A) = v4;
    int128_t v6 = __asm_addsd(__asm_cvtsi2sd(v2), __asm_movsd(0x4008000000000000)); // 0x236
    *(int64_t *)(v5 + (int64_t)B) = __asm_movsd_1(__asm_divsd(v6, __asm_cvtsi2sd(n)));
    v1++;
    while (v1 != (int64_t)n) {
        // 0x202
        v2 = v1;
        v3 = __asm_addsd(__asm_cvtsi2sd(v2), __asm_movsd(0x4000000000000000));
        v4 = __asm_movsd_1(__asm_divsd(v3, __asm_cvtsi2sd(n)));
        v5 = 8 * v1;
        *(int64_t *)(v5 + (int64_t)A) = v4;
        v6 = __asm_addsd(__asm_cvtsi2sd(v2), __asm_movsd(0x4008000000000000));
        *(int64_t *)(v5 + (int64_t)B) = __asm_movsd_1(__asm_divsd(v6, __asm_cvtsi2sd(n)));
        v1++;
    }
}

// Address range: 0x260 - 0x355
// Line range:    43 - 58
void print_array(uint32_t n, float64_t * A) {
    // 0x260
    int64_t v1; // 0x260
    int128_t v2; // 0x260
    fprintf(*(int64_t *)*(int64_t *)630, "==BEGIN DUMP_ARRAYS==\n", v1, v1, v2);
    int64_t stream = *(int64_t *)*(int64_t *)654; // 0x28e
    fprintf(stream, "begin dump: %s", (int64_t)&g2, v1, v2);
    int64_t v3; // 0x260
    int128_t v4; // 0x260
    if (n > 0) {
        int64_t v5 = 0;
        int64_t v6 = (0x100000000 * (int64_t)((int32_t)v5 >> 31) | v5) % 20; // 0x2c2
        int64_t v7 = v6 & 0xffffffff; // 0x2c2
        int128_t v8; // 0x260
        if ((int32_t)v6 == 0) {
            // 0x2cd
            fprintf(*(int64_t *)*(int64_t *)724, "\n", v7, 20, v8);
        }
        int128_t v9 = __asm_movsd(*(int64_t *)(8 * v5 + (int64_t)A)); // 0x2f7
        fprintf(*(int64_t *)*(int64_t *)748, "%0.2lf ", v7, v5, v9);
        int64_t v10 = v5 + 1;
        v8 = v9;
        v4 = v9;
        v3 = v5;
        while (v10 != (int64_t)n) {
            // 0x2b9
            v5 = v10;
            v6 = (0x100000000 * (int64_t)((int32_t)v5 >> 31) | v5) % 20;
            v7 = v6 & 0xffffffff;
            if ((int32_t)v6 == 0) {
                // 0x2cd
                fprintf(*(int64_t *)*(int64_t *)724, "\n", v7, 20, v8);
            }
            // 0x2e5
            v9 = __asm_movsd(*(int64_t *)(8 * v5 + (int64_t)A));
            fprintf(*(int64_t *)*(int64_t *)748, "%0.2lf ", v7, v5, v9);
            v10 = v5 + 1;
            v8 = v9;
            v4 = v9;
            v3 = v5;
        }
    }
    int64_t stream2 = *(int64_t *)*(int64_t *)799; // 0x31f
    fprintf(stream2, "\nend   dump: %s\n", (int64_t)&g2, v3, v4);
    int64_t stream3 = *(int64_t *)*(int64_t *)830; // 0x33e
    fprintf(stream3, "==END   DUMP_ARRAYS==\n", (int64_t)&g2, v3, v4);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 4

