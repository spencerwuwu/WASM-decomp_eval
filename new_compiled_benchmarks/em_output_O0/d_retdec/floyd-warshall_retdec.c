//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t fprintf(int64_t a1, char * a2, int64_t a3, int64_t a4);
int64_t free(int64_t a1);
void init_array(uint32_t n, int32_t (*path)[1]);
int64_t kernel_floyd_warshall(int64_t a1, int64_t a2);
int64_t polybench_alloc_data(int64_t a1, int64_t a2);
void print_array(uint32_t n, int32_t (*path)[1]);
int64_t strcmp(int64_t a1, int64_t * a2);
int32_t submain(int32_t argc, char ** argv);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4e494745423d3d00; // 0x3ee

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x13f
int64_t kernel_floyd_warshall(int64_t a1, int64_t a2) {
    // 0x0
    if ((int32_t)a1 <= 0) {
        // 0x13d
        return 0;
    }
    int64_t result = a1 & 0xffffffff;
    int64_t v1 = 0;
    int64_t v2 = 0;
    int64_t v3 = 0x2bc0 * v2 + a2; // 0x53
    int64_t v4 = 0;
    int64_t v5 = 4 * v4; // 0x5a
    int32_t * v6 = (int32_t *)(v5 + v3); // 0x5a
    uint32_t v7 = *v6; // 0x5a
    int32_t v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5); // 0x8c
    uint32_t v9 = v8 + *(int32_t *)(v3 + 4 * v1); // 0x8c
    *v6 = v7 < v9 ? v7 : v9;
    v4++;
    while (v4 != result) {
        // 0x44
        v5 = 4 * v4;
        v6 = (int32_t *)(v5 + v3);
        v7 = *v6;
        v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
        v9 = v8 + *(int32_t *)(v3 + 4 * v1);
        *v6 = v7 < v9 ? v7 : v9;
        v4++;
    }
    // 0x11c
    v2++;
    while (v2 != result) {
        // 0x44
        v3 = 0x2bc0 * v2 + a2;
        v4 = 0;
        v5 = 4 * v4;
        v6 = (int32_t *)(v5 + v3);
        v7 = *v6;
        v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
        v9 = v8 + *(int32_t *)(v3 + 4 * v1);
        *v6 = v7 < v9 ? v7 : v9;
        v4++;
        while (v4 != result) {
            // 0x44
            v5 = 4 * v4;
            v6 = (int32_t *)(v5 + v3);
            v7 = *v6;
            v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
            v9 = v8 + *(int32_t *)(v3 + 4 * v1);
            *v6 = v7 < v9 ? v7 : v9;
            v4++;
        }
        // 0x11c
        v2++;
    }
    // 0x12f
    v1++;
    while (v1 != result) {
        // 0x38
        v2 = 0;
        v3 = 0x2bc0 * v2 + a2;
        v4 = 0;
        v5 = 4 * v4;
        v6 = (int32_t *)(v5 + v3);
        v7 = *v6;
        v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
        v9 = v8 + *(int32_t *)(v3 + 4 * v1);
        *v6 = v7 < v9 ? v7 : v9;
        v4++;
        while (v4 != result) {
            // 0x44
            v5 = 4 * v4;
            v6 = (int32_t *)(v5 + v3);
            v7 = *v6;
            v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
            v9 = v8 + *(int32_t *)(v3 + 4 * v1);
            *v6 = v7 < v9 ? v7 : v9;
            v4++;
        }
        // 0x11c
        v2++;
        while (v2 != result) {
            // 0x44
            v3 = 0x2bc0 * v2 + a2;
            v4 = 0;
            v5 = 4 * v4;
            v6 = (int32_t *)(v5 + v3);
            v7 = *v6;
            v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
            v9 = v8 + *(int32_t *)(v3 + 4 * v1);
            *v6 = v7 < v9 ? v7 : v9;
            v4++;
            while (v4 != result) {
                // 0x44
                v5 = 4 * v4;
                v6 = (int32_t *)(v5 + v3);
                v7 = *v6;
                v8 = *(int32_t *)(0x2bc0 * v1 + a2 + v5);
                v9 = v8 + *(int32_t *)(v3 + 4 * v1);
                *v6 = v7 < v9 ? v7 : v9;
                v4++;
            }
            // 0x11c
            v2++;
        }
        // 0x12f
        v1++;
    }
    // 0x13d
    return result;
}

// Address range: 0x140 - 0x1c4
// Line range:    82 - 111
int32_t submain(int32_t argc, char ** argv) {
    int64_t str = polybench_alloc_data(0x77a100, 4); // 0x160
    int32_t (*v1)[1] = (int32_t (*)[1])str; // 0x165
    init_array(2800, v1);
    if (argc < 43) {
        // 0x1b3
        free(str);
        return 0;
    }
    // 0x18b
    if ((int32_t)strcmp(str, &g1) == 0) {
        // 0x1a7
        print_array(2800, v1);
    }
    // 0x1b3
    free(str);
    return 0;
}

// Address range: 0x1d0 - 0x2b6
// Line range:    26 - 37
void init_array(uint32_t n, int32_t (*path)[1]) {
    if (n <= 0) {
        // 0x2b4
        return;
    }
    int64_t v1 = n;
    int64_t v2 = 0;
    int64_t v3; // 0x1d0
    while (true) {
        int64_t v4 = 0x2bc0 * v2 + (int64_t)(0x100000000 * (int64_t)path >> 32); // 0x222
        v3 = 0;
        while (true) {
          lab_0x201:;
            int32_t v5 = (int32_t)v3 * (int32_t)v2; // 0x204
            int32_t * v6 = (int32_t *)(v4 + 4 * v3); // 0x229
            *v6 = (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 7) + 1;
            int64_t v7 = v3 + v2;
            int64_t v8 = 0x100000000 * (int64_t)((int32_t)v7 >> 31) | v7; // 0x238
            if ((int32_t)(v8 % 13) == 0) {
                // 0x271
                *v6 = 999;
                goto lab_0x293;
            } else {
                if ((int32_t)(v8 % 7) == 0) {
                    // 0x271
                    *v6 = 999;
                    goto lab_0x293;
                } else {
                    if ((int32_t)(v8 % 11) != 0) {
                        goto lab_0x293;
                    } else {
                        // 0x271
                        *v6 = 999;
                        goto lab_0x293;
                    }
                }
            }
        }
      lab_0x2a6:
        // 0x2a6
        v2++;
        if (v2 == v1) {
            // break -> 0x2b4
            break;
        }
    }
  lab_0x293:;
    int64_t v9 = v3 + 1;
    v3 = v9;
    if (v9 == v1) {
        // break -> 0x2a6
        goto lab_0x2a6;
    }
    goto lab_0x201;
}

// Address range: 0x2c0 - 0x3ee
// Line range:    43 - 58
void print_array(uint32_t n, int32_t (*path)[1]) {
    // 0x2c0
    int64_t v1; // 0x2c0
    fprintf(*(int64_t *)*(int64_t *)726, "==BEGIN DUMP_ARRAYS==\n", v1, v1);
    int64_t stream = *(int64_t *)*(int64_t *)750; // 0x2ee
    fprintf(stream, "begin dump: %s", (int64_t)"path", v1);
    int64_t v2; // 0x2c0
    if (n > 0) {
        int64_t v3 = 0x100000000 * (int64_t)path >> 32;
        int64_t v4 = n;
        int64_t v5 = 0;
        int64_t v6 = 0;
        int32_t v7 = (int32_t)v5 * n + (int32_t)v6; // 0x333
        int64_t v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 20; // 0x33c
        if ((int32_t)v8 == 0) {
            // 0x347
            fprintf(*(int64_t *)*(int64_t *)846, "\n", v8 & 0xffffffff, 20);
        }
        uint32_t v9 = *(int32_t *)(0x2bc0 * v5 + v3 + 4 * v6); // 0x37f
        fprintf(*(int64_t *)*(int64_t *)870, "%d ", (int64_t)v9, v6);
        int64_t v10 = v6 + 1;
        while (v10 != v4) {
            // 0x32c
            v6 = v10;
            v7 = (int32_t)v5 * n + (int32_t)v6;
            v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 20;
            if ((int32_t)v8 == 0) {
                // 0x347
                fprintf(*(int64_t *)*(int64_t *)846, "\n", v8 & 0xffffffff, 20);
            }
            // 0x35f
            v9 = *(int32_t *)(0x2bc0 * v5 + v3 + 4 * v6);
            fprintf(*(int64_t *)*(int64_t *)870, "%d ", (int64_t)v9, v6);
            v10 = v6 + 1;
        }
        // 0x3a3
        v5++;
        v2 = v6;
        while (v5 != v4) {
            // 0x32c
            v6 = 0;
            v7 = (int32_t)v5 * n + (int32_t)v6;
            v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 20;
            if ((int32_t)v8 == 0) {
                // 0x347
                fprintf(*(int64_t *)*(int64_t *)846, "\n", v8 & 0xffffffff, 20);
            }
            // 0x35f
            v9 = *(int32_t *)(0x2bc0 * v5 + v3 + 4 * v6);
            fprintf(*(int64_t *)*(int64_t *)870, "%d ", (int64_t)v9, v6);
            v10 = v6 + 1;
            while (v10 != v4) {
                // 0x32c
                v6 = v10;
                v7 = (int32_t)v5 * n + (int32_t)v6;
                v8 = (0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 20;
                if ((int32_t)v8 == 0) {
                    // 0x347
                    fprintf(*(int64_t *)*(int64_t *)846, "\n", v8 & 0xffffffff, 20);
                }
                // 0x35f
                v9 = *(int32_t *)(0x2bc0 * v5 + v3 + 4 * v6);
                fprintf(*(int64_t *)*(int64_t *)870, "%d ", (int64_t)v9, v6);
                v10 = v6 + 1;
            }
            // 0x3a3
            v5++;
            v2 = v6;
        }
    }
    int64_t stream2 = *(int64_t *)952; // 0x3b1
    fprintf(*(int64_t *)stream2, "\nend   dump: %s\n", (int64_t)"path", v2);
    int64_t stream3 = *(int64_t *)*(int64_t *)983; // 0x3d7
    fprintf(stream3, "==END   DUMP_ARRAYS==\n", (int64_t)"path", v2);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 4

