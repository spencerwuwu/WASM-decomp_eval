//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <sys/time.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

void decode_motion_vector(int32_t * pred, int32_t r_size, uint32_t motion_code, int32_t motion_residual, int32_t full_pel_vector);
void Fill_Buffer(void);
void Flush_Buffer(int32_t N);
int64_t function_df(int64_t a1);
int32_t Get_Bits(int32_t N);
int32_t Get_Bits1(void);
int32_t Get_dmvector(void);
int32_t Get_motion_code(void);
int64_t gettimeofday(int64_t * a1, int64_t a2);
void Initialize_Buffer(void);
void motion_vector(int32_t * PMV, int32_t * dmvector, int32_t h_r_size, int32_t v_r_size, int32_t dmv, int32_t mvscale, int32_t full_pel_vector);
void motion_vectors(int32_t (*PMV)[1][1], int32_t * dmvector, int32_t (*motion_vertical_field_select)[1], int32_t s, int32_t motion_vector_count, int32_t mv_format, int32_t h_r_size, int32_t v_r_size, int32_t dmv, int32_t mvscale);
int64_t printf(char * a1, int64_t a2, int128_t a3);
int64_t read(int64_t a1, int64_t a2, int64_t a3);
float64_t rtclock(void);
int32_t Show_Bits(int32_t N);
int32_t submain(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x1b840f0038; // 0xb7

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x67
int64_t read(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = 0x100000000 * a3 >> 32; // 0xc
    int64_t v2 = v1; // 0x33
    int64_t v3 = a2; // 0x33
    if ((int32_t)v1 < 1) {
        // 0x62
        return v1 & 0xffffffff;
    }
    int64_t v4 = a1; // 0x33
    v2 = 0x100000000 * v2 - 0x100000000 >> 32;
    *(char *)v4 = *(char *)v3;
    v3++;
    v4++;
    while ((int32_t)v2 >= 1) {
        // 0x39
        v2 = 0x100000000 * v2 - 0x100000000 >> 32;
        *(char *)v4 = *(char *)v3;
        v3++;
        v4++;
    }
    // 0x62
    return v1 & 0xffffffff;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/global.h
// Address range: 0x70 - 0xda
// Line range:    80 - 114
void Fill_Buffer(void) {
    // 0x70
    *(int64_t *)*(int64_t *)165 = *(int64_t *)172;
    if (*(int32_t *)*(int64_t *)182 != 0) {
        int64_t v1 = *(int64_t *)*(int64_t *)198; // 0xc6
        *(int64_t *)*(int64_t *)215 = v1 - 2048;
    }
}

// Address range: 0xdf - 0x1b0
int64_t function_df(int64_t a1) {
    // 0xdf
    int64_t v1; // 0xdf
    char v2 = v1;
    char v3 = 2 * v2; // 0xdf
    *(char *)v1 = v3;
    if (v3 < 0 == (v3 ^ v2) < 0) {
        // 0x1aa
        int64_t result; // 0xdf
        return result;
    }
    int32_t * v4 = (int32_t *)(v1 - 4); // 0xe7
    int32_t v5 = *v4; // 0xe7
    int32_t v6; // 0xdf
    if (v5 >= 0) {
        int32_t v7 = v5; // 0x106
        if ((v5 & 3) != 0) {
            *v4 = v5 + 1;
            *(char *)(*(int64_t *)289 + (int64_t)v5) = 0;
            int32_t v8 = *v4;
            v7 = v8;
            int32_t v9 = v8; // 0x106
            while ((v8 & 3) != 0) {
                // 0x10c
                *v4 = v9 + 1;
                *(char *)(*(int64_t *)289 + (int64_t)v9) = 0;
                v8 = *v4;
                v7 = v8;
                v9 = v8;
            }
        }
        // 0x12f
        v6 = v7;
        if (v7 > 2047) {
            // 0x1aa
            return 0;
        }
    } else {
        // 0x12f
        *v4 = 0;
        v6 = 0;
    }
    // 0x13c
    *v4 = v6 + 1;
    *(char *)(*(int64_t *)337 + (int64_t)v6) = 0;
    int32_t v10 = *v4; // 0x155
    *v4 = v10 + 1;
    *(char *)(*(int64_t *)362 + (int64_t)v10) = 0;
    int32_t v11 = *v4; // 0x16e
    *v4 = v11 + 1;
    *(char *)(*(int64_t *)387 + (int64_t)v11) = 1;
    int32_t v12 = *v4; // 0x187
    *v4 = v12 + 1;
    int64_t result2 = *(int64_t *)412; // 0x195
    *(char *)(result2 + (int64_t)v12) = (char)&g1;
    int32_t v13 = *v4; // 0x12f
    while (v13 <= 2047) {
        // 0x13c
        *v4 = v13 + 1;
        *(char *)(*(int64_t *)337 + (int64_t)v13) = 0;
        v10 = *v4;
        *v4 = v10 + 1;
        *(char *)(*(int64_t *)362 + (int64_t)v10) = 0;
        v11 = *v4;
        *v4 = v11 + 1;
        *(char *)(*(int64_t *)387 + (int64_t)v11) = 1;
        v12 = *v4;
        *v4 = v12 + 1;
        result2 = *(int64_t *)412;
        *(char *)(result2 + (int64_t)v12) = (char)&g1;
        v13 = *v4;
    }
    // 0x1aa
    return result2;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/global.h
// Address range: 0x1b0 - 0x1cf
// Line range:    117 - 120
int32_t Show_Bits(int32_t N) {
    // 0x1b0
    return *(int32_t *)*(int64_t *)446 >> (-N & 31);
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/global.h
// Address range: 0x1d0 - 0x1e0
// Line range:    127 - 129
int32_t Get_Bits1(void) {
    // 0x1d0
    return Get_Bits(1);
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/global.h
// Address range: 0x1e0 - 0x207
// Line range:    190 - 198
int32_t Get_Bits(int32_t N) {
    int32_t result = Show_Bits(N); // 0x1ee
    Flush_Buffer(N);
    return result;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/global.h
// Address range: 0x210 - 0x357
// Line range:    136 - 184
void Flush_Buffer(int32_t N) {
    int32_t v1 = *(int32_t *)*(int64_t *)549; // 0x225
    *(int32_t *)*(int64_t *)562 = v1 << (N & 31);
    int32_t v2 = *(int32_t *)*(int64_t *)574 - N; // 0x240
    *(int32_t *)*(int64_t *)585 = v2;
    if (v2 > 24) {
        // 0x357
        return;
    }
    int32_t v3 = v2; // 0x270
    int32_t v4 = v2; // 0x270
    if (*(int64_t *)*(int64_t *)621 < *(int64_t *)607 + 2044) {
        int64_t v5 = *(int64_t *)*(int64_t *)642; // 0x282
        *(int64_t *)*(int64_t *)659 = v5 + 1;
        int32_t v6 = *(int32_t *)*(int64_t *)684; // 0x2ac
        int64_t v7 = *(int64_t *)693; // 0x2ae
        *(int32_t *)v7 = v6 | (int32_t)*(char *)v5 << (24 - v3 & 31);
        v3 += 8;
        while (v3 < 25) {
            // 0x27b
            v5 = *(int64_t *)*(int64_t *)642;
            *(int64_t *)*(int64_t *)659 = v5 + 1;
            v6 = *(int32_t *)*(int64_t *)684;
            v7 = *(int64_t *)693;
            *(int32_t *)v7 = v6 | (int32_t)*(char *)v5 << (24 - v3 & 31);
            v3 += 8;
        }
        // 0x34b
        *(int32_t *)*(int64_t *)853 = v3;
        // 0x357
        return;
    }
    if (*(int64_t *)*(int64_t *)745 >= *(int64_t *)731 + 2048) {
        // 0x2f2
        Fill_Buffer();
    }
    int64_t v8 = *(int64_t *)*(int64_t *)766; // 0x2fe
    *(int64_t *)*(int64_t *)783 = v8 + 1;
    int32_t v9 = *(int32_t *)*(int64_t *)808; // 0x328
    int64_t v10 = *(int64_t *)817; // 0x32a
    *(int32_t *)v10 = v9 | (int32_t)*(char *)v8 << (24 - v4 & 31);
    v4 += 8;
    while (v4 < 25) {
        // 0x2d4
        if (*(int64_t *)*(int64_t *)745 >= *(int64_t *)731 + 2048) {
            // 0x2f2
            Fill_Buffer();
        }
        // 0x2f7
        v8 = *(int64_t *)*(int64_t *)766;
        *(int64_t *)*(int64_t *)783 = v8 + 1;
        v9 = *(int32_t *)*(int64_t *)808;
        v10 = *(int64_t *)817;
        *(int32_t *)v10 = v9 | (int32_t)*(char *)v8 << (24 - v4 & 31);
        v4 += 8;
    }
    // 0x34b
    *(int32_t *)*(int64_t *)853 = v4;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/getbits.c
// Address range: 0x360 - 0x4e7
// Line range:    49 - 79
int32_t Get_motion_code(void) {
    // 0x360
    if (Get_Bits1() != 0) {
        // 0x3f1
        return 0;
    }
    uint32_t v1 = Show_Bits(9); // 0x387
    int32_t result; // 0x360
    if (v1 >= 64) {
        int64_t v2 = 2 * v1 / 64; // 0x3ac
        Flush_Buffer((int32_t)*(char *)(*(int64_t *)940 + (v2 | 1)));
        if (Get_Bits1() == 0) {
            // 0x3df
            result = (int32_t)*(char *)(*(int64_t *)1002 + v2);
        } else {
            // 0x3c4
            result = -(int32_t)*(char *)(*(int64_t *)975 + v2);
        }
        // 0x3f1
        return result;
    }
    if (v1 >= 24) {
        int64_t v3 = 2 * v1 / 8; // 0x41a
        Flush_Buffer((int32_t)*(char *)(*(int64_t *)1050 + (v3 | 1)));
        if (Get_Bits1() == 0) {
            // 0x44d
            result = (int32_t)*(char *)(*(int64_t *)1112 + v3);
        } else {
            // 0x432
            result = -(int32_t)*(char *)(*(int64_t *)1085 + v3);
        }
        // 0x3f1
        return result;
    }
    int32_t v4 = v1 - 12; // 0x46d
    if (v4 < 0) {
        // 0x3f1
        return 0;
    }
    int64_t v5 = 2 * (int64_t)v4; // 0x493
    Flush_Buffer((int32_t)*(char *)(*(int64_t *)1171 + (v5 | 1)));
    if (Get_Bits1() == 0) {
        // 0x4c6
        result = (int32_t)*(char *)(*(int64_t *)1233 + v5);
    } else {
        // 0x4ab
        result = -(int32_t)*(char *)(*(int64_t *)1206 + v5);
    }
    // 0x3f1
    return result;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/getbits.c
// Address range: 0x4f0 - 0x53f
// Line range:    83 - 94
int32_t Get_dmvector(void) {
    int32_t result = 0; // 0x505
    if (Get_Bits(1) != 0) {
        // 0x50b
        result = Get_Bits(1) != 0 ? -1 : 1;
    }
    // 0x536
    return result;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/getvlc.c
// Address range: 0x540 - 0x6a6
// Line range:    55 - 90
void motion_vectors(int32_t (*PMV)[1][1], int32_t * dmvector, int32_t (*motion_vertical_field_select)[1], int32_t s, int32_t motion_vector_count, int32_t mv_format, int32_t h_r_size, int32_t v_r_size, int32_t dmv, int32_t mvscale) {
    if (motion_vector_count != 1) {
        int32_t v1 = Get_Bits(1); // 0x614
        int64_t v2 = s; // 0x61f
        int64_t v3 = 4 * v2 + (int64_t)motion_vertical_field_select;
        *(int32_t *)v3 = v1;
        int64_t v4 = 8 * v2 + (int64_t)PMV;
        motion_vector((int32_t *)v4, dmvector, h_r_size, v_r_size, dmv, mvscale, 0);
        *(int32_t *)(v3 + 8) = Get_Bits(1);
        motion_vector((int32_t *)(v4 + 16), dmvector, h_r_size, v_r_size, dmv, mvscale, 0);
        // 0x6a0
        return;
    }
    int64_t v5; // 0x540
    if ((dmv || mv_format) == 0) {
        int32_t v6 = Get_Bits(1); // 0x58e
        int64_t v7 = s;
        int64_t v8 = 4 * v7 + (int64_t)motion_vertical_field_select;
        *(int32_t *)v8 = v6;
        *(int32_t *)(v8 + 8) = v6;
        v5 = v7;
    } else {
        // 0x575
        v5 = s;
    }
    int64_t v9 = 8 * v5 + (int64_t)PMV;
    int32_t * v10 = (int32_t *)v9; // 0x5d6
    motion_vector(v10, dmvector, h_r_size, v_r_size, dmv, mvscale, 0);
    *(int32_t *)(v9 + 16) = *v10;
    *(int32_t *)(v9 + 20) = *(int32_t *)(v9 + 4);
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/getvlc.c
// Address range: 0x6b0 - 0x7dc
// Line range:    95 - 139
void motion_vector(int32_t * PMV, int32_t * dmvector, int32_t h_r_size, int32_t v_r_size, int32_t dmv, int32_t mvscale, int32_t full_pel_vector) {
    int32_t v1 = Get_motion_code(); // 0x6d1
    int32_t v2 = 0; // 0x6dd
    if (h_r_size != 0 && v1 != 0) {
        // 0x6ed
        v2 = Get_Bits(h_r_size);
    }
    // 0x707
    decode_motion_vector(PMV, h_r_size, v1, v2, full_pel_vector);
    if (dmv != 0) {
        // 0x72d
        *dmvector = Get_dmvector();
    }
    int32_t v3 = Get_motion_code(); // 0x73a
    int32_t v4 = 0; // 0x746
    if (v_r_size != 0 && v3 != 0) {
        // 0x756
        v4 = Get_Bits(v_r_size);
    }
    int32_t * v5 = (int32_t *)((int64_t)PMV + 4);
    if (mvscale == 0) {
        // 0x78d
        decode_motion_vector(v5, v_r_size, v3, v4, full_pel_vector);
    } else {
        // 0x7b1
        *v5 = *v5 >> 1;
        decode_motion_vector(v5, v_r_size, v3, v4, full_pel_vector);
        *v5 = 2 * *v5;
    }
    if (dmv != 0) {
        // 0x7c8
        *(int32_t *)((int64_t)dmvector + 4) = Get_dmvector();
    }
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/getvlc.c
// Address range: 0x7e0 - 0x8f0
// Line range:    147 - 172
void decode_motion_vector(int32_t * pred, int32_t r_size, uint32_t motion_code, int32_t motion_residual, int32_t full_pel_vector) {
    uint32_t v1 = r_size & 31; // 0x80b
    uint32_t v2 = 16 << v1;
    uint32_t v3 = (int32_t)(full_pel_vector != 0);
    int64_t v4; // 0x7e0
    int32_t v5 = (int32_t)v4 >> v3;
    int32_t v6; // 0x7e0
    if (motion_code >= 1) {
        int32_t v7 = motion_residual + 1 + (motion_code - 1 << v1) + v5; // 0x855
        v6 = v7;
        if (v7 >= v2) {
            // 0x867
            v6 = v7 - 2 * v2;
        }
        // 0x8c7
        *pred = v6 << v3;
        return;
    }
    // 0x87a
    if (motion_code == 0) {
        // 0x8c7
        *pred = v5 << v3;
        return;
    }
    int32_t v8 = v5 + -1 - ((-1 - motion_code << v1) + motion_residual); // 0x89c
    v6 = v8;
    if (v8 < -v2) {
        // 0x8b1
        v6 = v8 + 2 * v2;
    }
    // 0x8c7
    *pred = v6 << v3;
}

// Address range: 0x8f0 - 0x943
// Line range:    358 - 365
void Initialize_Buffer(void) {
    // 0x8f0
    *(int32_t *)*(int64_t *)2299 = 0;
    *(int64_t *)*(int64_t *)2312 = *(int64_t *)2319 + 2048;
    *(int64_t *)*(int64_t *)2346 = *(int64_t *)*(int64_t *)2336;
    *(int32_t *)*(int64_t *)2356 = 0x4100000;
    Flush_Buffer(0);
}

// Address range: 0x950 - 0xc1d
// Line range:    368 - 418
int32_t submain(void) {
    int32_t dmvector[1]; // bp-80, 0x950
    int32_t motion_vertical_field_select[1][1]; // bp-104, 0x950
    int32_t PMV[1][1][1]; // bp-72, 0x950
    int64_t v1 = __asm_movsd((int128_t)(int32_t)(float32_t)rtclock()); // 0x968
    *(int64_t *)*(int64_t *)2408 = v1;
    *(int32_t *)*(int64_t *)2426 = 0;
    *(int32_t *)*(int64_t *)2439 = 0;
    int64_t v2 = (int64_t)&motion_vertical_field_select;
    int64_t v3 = (int64_t)&PMV;
    for (int64_t i = 0; i < 2; i++) {
        // 0x9cf
        int64_t v4; // bp-8, 0x950
        *(int32_t *)((int64_t)&v4 - 72 + 4 * i) = 0;
        for (int64_t j = 0; j < 2; j++) {
            int64_t v5 = 4 * j + 8 * i;
            *(int32_t *)(v5 + v2) = *(int32_t *)(v5 + *(int64_t *)2551);
            for (int64_t k = 0; k < 2; k++) {
                int64_t v6 = 4 * k + 8 * j + 16 * i;
                *(int32_t *)(v6 + v3) = *(int32_t *)(v6 + *(int64_t *)2615);
            }
        }
    }
    // 0xaa5
    Initialize_Buffer();
    motion_vectors(PMV, dmvector, motion_vertical_field_select, 0, 1, 0, 200, 200, 0, 1);
    int32_t result = 0; // 0xba2
    for (int64_t i = 0; i < 2; i++) {
        for (int64_t j = 0; j < 2; j++) {
            int64_t v7 = 4 * j + 8 * i;
            int32_t v8 = *(int32_t *)(v7 + v2); // 0xb1a
            int32_t v9 = *(int32_t *)(v7 + *(int64_t *)2856); // 0xb33
            int64_t v10 = 0;
            int64_t v11 = 4 * v10 + 8 * j + 16 * i;
            int32_t v12 = *(int32_t *)(v11 + v3); // 0xb73
            int32_t v13 = *(int32_t *)(v11 + *(int64_t *)2945); // 0xb97
            result = result + (int32_t)(v8 != v9) + (int32_t)(v12 != v13);
            v10++;
            int32_t v14 = result; // 0xb4f
            while (v10 != 2) {
                // 0xb55
                v11 = 4 * v10 + 8 * j + 16 * i;
                v13 = *(int32_t *)(v11 + *(int64_t *)2945);
                result = v14 + (int32_t)(*(int32_t *)(v11 + v3) != v13);
                v10++;
                v14 = result;
            }
        }
    }
    int64_t v15 = __asm_movsd((int128_t)(int32_t)(float32_t)rtclock()); // 0xbe8
    *(int64_t *)*(int64_t *)3048 = v15;
    int128_t v16 = __asm_movsd_1(*(int64_t *)*(int64_t *)3059); // 0xbf3
    int64_t v17 = *(int64_t *)*(int64_t *)3070; // 0xbfe
    printf("%0.6f\n", (int64_t)&dmvector, __asm_subsd(v16, v17));
    return result;
}

// Address range: 0xc20 - 0xc74
// Line range:    341 - 348
float64_t rtclock(void) {
    // 0xc20
    int64_t Tp; // bp-24, 0xc20
    int64_t v1 = gettimeofday(&Tp, 0); // 0xc30
    if ((int32_t)v1 != 0) {
        // 0xc42
        int128_t v2; // 0xc20
        printf("Error return from gettimeofday: %d", v1 & 0xffffffff, v2);
    }
    int128_t v3 = __asm_cvtsi2sd(Tp); // 0xc53
    int64_t v4; // 0xc20
    int128_t v5 = __asm_mulsd(__asm_cvtsi2sd_2((int32_t)v4), __asm_movsd_1(0x3eb0c6f7a0b5ed8d)); // 0xc66
    return (int64_t)__asm_addsd(v5, v3);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 15

