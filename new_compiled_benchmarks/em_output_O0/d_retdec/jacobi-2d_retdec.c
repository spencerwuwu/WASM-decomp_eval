//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t fprintf(int64_t a1, char * a2, int64_t a3, int64_t a4, int128_t a5);
int64_t free(float64_t (*a1)[1]);
void init_array(uint32_t n, float64_t (*A)[1], float64_t (*B)[1]);
int64_t kernel_jacobi_2d(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t polybench_alloc_data(int64_t a1, int64_t a2);
void print_array(uint32_t n, float64_t (*A)[1]);
int64_t strcmp(int64_t a1, int64_t * a2, float64_t (*a3)[1], float64_t (*a4)[1]);
int32_t submain(int32_t argc, char ** argv);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4e494745423d3d00; // 0x548
int64_t g2 = 0x322e3025000a0041; // 0x56f

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x260
int64_t kernel_jacobi_2d(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    uint32_t v1 = (int32_t)a1; // 0x1c
    if (v1 <= 0) {
        // 0x25e
        return 0;
    }
    uint64_t v2 = a2 + 0xffffffff & 0xffffffff; // 0x32
    int32_t v3 = 0; // 0x253
    while (true) {
      lab_0x2c:;
        int64_t v4 = 1; // 0x37
        int32_t v5 = 1; // 0x37
        if (v2 > 1) {
            while (true) {
                int64_t v6 = 0x28a0 * v4; // 0x5d
                int64_t v7 = v6 + a3; // 0x64
                int64_t v8 = 0x100000000 * v4;
                int32_t v9 = 1; // 0xa5
                int64_t v10 = 8 * (int64_t)v9; // 0x6b
                int128_t v11 = __asm_movsd(*(int64_t *)(v10 + v7)); // 0x6b
                int128_t v12 = __asm_addsd_2(v11, *(int64_t *)(8 * (int64_t)(v9 - 1) + v7)); // 0x8b
                v9++;
                int128_t v13 = __asm_addsd_2(v12, *(int64_t *)(8 * (int64_t)v9 + v7)); // 0xab
                int64_t v14 = v10 + a3;
                int128_t v15 = __asm_addsd_2(v13, *(int64_t *)(v14 + 0x28a0 * (v8 + 0x100000000 >> 32))); // 0xcb
                int128_t v16 = __asm_addsd_2(v15, *(int64_t *)(v14 + 0x28a0 * (v8 - 0x100000000 >> 32))); // 0xeb
                *(int64_t *)(v6 + a4 + v10) = __asm_movsd_1(__asm_mulsd(__asm_movsd(0x3fc999999999999a), v16));
                while (v2 > (int64_t)v9) {
                    // 0x55
                    v10 = 8 * (int64_t)v9;
                    v11 = __asm_movsd(*(int64_t *)(v10 + v7));
                    v12 = __asm_addsd_2(v11, *(int64_t *)(8 * (int64_t)(v9 - 1) + v7));
                    v9++;
                    v13 = __asm_addsd_2(v12, *(int64_t *)(8 * (int64_t)v9 + v7));
                    v14 = v10 + a3;
                    v15 = __asm_addsd_2(v13, *(int64_t *)(v14 + 0x28a0 * (v8 + 0x100000000 >> 32)));
                    v16 = __asm_addsd_2(v15, *(int64_t *)(v14 + 0x28a0 * (v8 - 0x100000000 >> 32)));
                    *(int64_t *)(v6 + a4 + v10) = __asm_movsd_1(__asm_mulsd(__asm_movsd(0x3fc999999999999a), v16));
                }
                int32_t v17 = v5 + 1; // 0x12d
                int64_t v18 = v17;
                v4 = v18;
                v5 = v17;
                if ((v18 & 0xffffffff) >= v2) {
                    goto lab_0x168_2;
                }
            }
        }
        goto lab_0x250;
    }
  lab_0x19:
    // 0x25e
    return a1 & 0xffffffff;
  lab_0x168:
    // 0x168
    goto lab_0x168_2;
  lab_0x250:
    // 0x250
    v3++;
    if (v3 == v1) {
        // break -> 0x19
        goto lab_0x19;
    }
    goto lab_0x2c;
  lab_0x168_2:;
    // 0x168
    int32_t v19; // 0x0
    int32_t v20 = v19;
    int64_t v21 = 8 * (int64_t)v20; // 0x17e
    int64_t v22; // 0x177
    int64_t v23 = *(int64_t *)(v21 + v22); // 0x17e
    int128_t v24 = __asm_movsd(v23); // 0x17e
    int64_t v25 = *(int64_t *)(8 * (int64_t)(v20 - 1) + v22); // 0x19e
    int128_t v26 = __asm_addsd_2(v24, v25); // 0x19e
    int32_t v27 = v20 + 1; // 0x1b8
    int64_t v28 = *(int64_t *)(8 * (int64_t)v27 + v22); // 0x1be
    int128_t v29 = __asm_addsd_2(v26, v28); // 0x1be
    int64_t v30 = v21 + a4;
    int64_t v31; // 0x0
    int64_t v32 = *(int64_t *)(v30 + v31); // 0x1de
    int128_t v33 = __asm_addsd_2(v29, v32); // 0x1de
    int64_t v34; // 0x0
    int64_t v35 = *(int64_t *)(v30 + v34); // 0x1fe
    int128_t v36 = __asm_addsd_2(v33, v35); // 0x1fe
    int128_t v37 = __asm_movsd(0x3fc999999999999a); // 0x203
    int64_t v38 = __asm_movsd_1(__asm_mulsd(v37, v36)); // 0x225
    int64_t v39; // 0x0
    *(int64_t *)(v39 + v21) = v38;
    v19 = v27;
    if (v2 > (int64_t)v27) {
        goto lab_0x168_2;
    } else {
        // 0x23d
        int32_t v40; // 0x0
        int32_t v41 = v40 + 1; // 0x240
        int64_t v42 = v41;
        if ((v42 & 0xffffffff) < v2) {
            goto lab_0x168;
        } else {
            goto lab_0x250;
        }
    }
}

// Address range: 0x260 - 0x312
// Line range:    87 - 119
int32_t submain(int32_t argc, char ** argv) {
    int64_t v1 = polybench_alloc_data(0x19c990, 8); // 0x287
    int64_t v2 = polybench_alloc_data(0x19c990, 8); // 0x29a
    init_array(1300, &((float64_t (*)[1][1])v1)[0], &((float64_t (*)[1][1])v2)[0]);
    if (argc < 43) {
        // 0x2f8
        free(&((float64_t (*)[1][1])v1)[0]);
        free(&((float64_t (*)[1][1])v2)[0]);
        return 0;
    }
    int64_t strcmp_rc = strcmp(1300, &g1, (float64_t (*)[1])v1, (float64_t (*)[1])v2); // 0x2de
    if ((int32_t)strcmp_rc == 0) {
        // 0x2ec
        print_array(1300, &((float64_t (*)[1][1])v1)[0]);
    }
    // 0x2f8
    free(&((float64_t (*)[1][1])v1)[0]);
    free(&((float64_t (*)[1][1])v2)[0]);
    return 0;
}

// Address range: 0x320 - 0x3fe
// Line range:    26 - 38
void init_array(uint32_t n, float64_t (*A)[1], float64_t (*B)[1]) {
    if (n <= 0) {
        // 0x3fc
        return;
    }
    int64_t v1 = n;
    int64_t v2 = 0;
    int32_t v3 = v2;
    int64_t v4 = 0;
    int128_t v5 = __asm_cvtsi2sd(v3); // 0x355
    int32_t v6 = v4;
    int128_t v7 = __asm_addsd(__asm_mulsd(v5, __asm_cvtsi2sd(v6 + 2)), __asm_movsd(0x4000000000000000)); // 0x370
    int64_t v8 = __asm_movsd_1(__asm_divsd(v7, __asm_cvtsi2sd(n))); // 0x393
    int64_t v9 = 8 * v4 + 0x28a0 * v2;
    *(int64_t *)(v9 + (int64_t)A) = v8;
    int128_t v10 = __asm_addsd(__asm_mulsd(__asm_cvtsi2sd(v3), __asm_cvtsi2sd(v6 + 3)), __asm_movsd(0x4008000000000000)); // 0x3b3
    int64_t v11 = __asm_movsd_1(__asm_divsd(v10, __asm_cvtsi2sd(n))); // 0x3d6
    *(int64_t *)(v9 + (0x100000000 * (int64_t)B >> 32)) = v11;
    v4++;
    while (v4 != v1) {
        // 0x355
        v5 = __asm_cvtsi2sd(v3);
        v6 = v4;
        v7 = __asm_addsd(__asm_mulsd(v5, __asm_cvtsi2sd(v6 + 2)), __asm_movsd(0x4000000000000000));
        v8 = __asm_movsd_1(__asm_divsd(v7, __asm_cvtsi2sd(n)));
        v9 = 8 * v4 + 0x28a0 * v2;
        *(int64_t *)(v9 + (int64_t)A) = v8;
        v10 = __asm_addsd(__asm_mulsd(__asm_cvtsi2sd(v3), __asm_cvtsi2sd(v6 + 3)), __asm_movsd(0x4008000000000000));
        v11 = __asm_movsd_1(__asm_divsd(v10, __asm_cvtsi2sd(n)));
        *(int64_t *)(v9 + (0x100000000 * (int64_t)B >> 32)) = v11;
        v4++;
    }
    // 0x3ee
    v2++;
    while (v2 != v1) {
        // 0x355
        v3 = v2;
        v4 = 0;
        v5 = __asm_cvtsi2sd(v3);
        v6 = v4;
        v7 = __asm_addsd(__asm_mulsd(v5, __asm_cvtsi2sd(v6 + 2)), __asm_movsd(0x4000000000000000));
        v8 = __asm_movsd_1(__asm_divsd(v7, __asm_cvtsi2sd(n)));
        v9 = 8 * v4 + 0x28a0 * v2;
        *(int64_t *)(v9 + (int64_t)A) = v8;
        v10 = __asm_addsd(__asm_mulsd(__asm_cvtsi2sd(v3), __asm_cvtsi2sd(v6 + 3)), __asm_movsd(0x4008000000000000));
        v11 = __asm_movsd_1(__asm_divsd(v10, __asm_cvtsi2sd(n)));
        *(int64_t *)(v9 + (0x100000000 * (int64_t)B >> 32)) = v11;
        v4++;
        while (v4 != v1) {
            // 0x355
            v5 = __asm_cvtsi2sd(v3);
            v6 = v4;
            v7 = __asm_addsd(__asm_mulsd(v5, __asm_cvtsi2sd(v6 + 2)), __asm_movsd(0x4000000000000000));
            v8 = __asm_movsd_1(__asm_divsd(v7, __asm_cvtsi2sd(n)));
            v9 = 8 * v4 + 0x28a0 * v2;
            *(int64_t *)(v9 + (int64_t)A) = v8;
            v10 = __asm_addsd(__asm_mulsd(__asm_cvtsi2sd(v3), __asm_cvtsi2sd(v6 + 3)), __asm_movsd(0x4008000000000000));
            v11 = __asm_movsd_1(__asm_divsd(v10, __asm_cvtsi2sd(n)));
            *(int64_t *)(v9 + (0x100000000 * (int64_t)B >> 32)) = v11;
            v4++;
        }
        // 0x3ee
        v2++;
    }
}

// Address range: 0x400 - 0x530
// Line range:    44 - 59
void print_array(uint32_t n, float64_t (*A)[1]) {
    // 0x400
    int64_t v1; // 0x400
    int128_t v2; // 0x400
    fprintf(*(int64_t *)*(int64_t *)1046, "==BEGIN DUMP_ARRAYS==\n", v1, v1, v2);
    int64_t stream = *(int64_t *)*(int64_t *)1070; // 0x42e
    fprintf(stream, "begin dump: %s", (int64_t)&g2, v1, v2);
    int64_t v3; // 0x400
    int128_t v4; // 0x400
    if (n > 0) {
        int64_t v5 = n;
        int64_t v6 = 0;
        int64_t v7 = 0x28a0 * v6 + (0x100000000 * (int64_t)A >> 32);
        int64_t v8 = 0;
        int32_t v9 = (int32_t)v6 * n + (int32_t)v8; // 0x473
        int64_t v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20; // 0x47c
        int64_t v11 = v10 & 0xffffffff; // 0x47c
        if ((int32_t)v10 == 0) {
            // 0x487
            int128_t v12; // 0x400
            fprintf(*(int64_t *)*(int64_t *)1166, "\n", v11, 20, v12);
        }
        int128_t v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8)); // 0x4bf
        fprintf(*(int64_t *)*(int64_t *)1190, "%0.2lf ", v11, v8, v13);
        int64_t v14 = v8 + 1;
        int128_t v15 = v13; // 0x466
        while (v14 != v5) {
            // 0x46c
            v8 = v14;
            v9 = (int32_t)v6 * n + (int32_t)v8;
            v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
            v11 = v10 & 0xffffffff;
            if ((int32_t)v10 == 0) {
                // 0x487
                fprintf(*(int64_t *)*(int64_t *)1166, "\n", v11, 20, v15);
            }
            // 0x49f
            v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
            fprintf(*(int64_t *)*(int64_t *)1190, "%0.2lf ", v11, v8, v13);
            v14 = v8 + 1;
            v15 = v13;
        }
        // 0x4e5
        v6++;
        v4 = v13;
        v3 = v8;
        while (v6 != v5) {
            // 0x46c
            v7 = 0x28a0 * v6 + (0x100000000 * (int64_t)A >> 32);
            v15 = v13;
            v8 = 0;
            v9 = (int32_t)v6 * n + (int32_t)v8;
            v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
            v11 = v10 & 0xffffffff;
            if ((int32_t)v10 == 0) {
                // 0x487
                fprintf(*(int64_t *)*(int64_t *)1166, "\n", v11, 20, v15);
            }
            // 0x49f
            v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
            fprintf(*(int64_t *)*(int64_t *)1190, "%0.2lf ", v11, v8, v13);
            v14 = v8 + 1;
            v15 = v13;
            while (v14 != v5) {
                // 0x46c
                v8 = v14;
                v9 = (int32_t)v6 * n + (int32_t)v8;
                v10 = (0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9) % 20;
                v11 = v10 & 0xffffffff;
                if ((int32_t)v10 == 0) {
                    // 0x487
                    fprintf(*(int64_t *)*(int64_t *)1166, "\n", v11, 20, v15);
                }
                // 0x49f
                v13 = __asm_movsd(*(int64_t *)(v7 + 8 * v8));
                fprintf(*(int64_t *)*(int64_t *)1190, "%0.2lf ", v11, v8, v13);
                v14 = v8 + 1;
                v15 = v13;
            }
            // 0x4e5
            v6++;
            v4 = v13;
            v3 = v8;
        }
    }
    int64_t stream2 = *(int64_t *)*(int64_t *)1274; // 0x4fa
    fprintf(stream2, "\nend   dump: %s\n", (int64_t)&g2, v3, v4);
    int64_t stream3 = *(int64_t *)*(int64_t *)1305; // 0x519
    fprintf(stream3, "==END   DUMP_ARRAYS==\n", (int64_t)&g2, v3, v4);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 4

