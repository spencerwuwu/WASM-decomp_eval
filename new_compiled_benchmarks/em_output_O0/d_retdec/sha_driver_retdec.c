//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <sys/time.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t function_5aa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_6d4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t gettimeofday(int64_t * a1, int64_t a2);
void local_memcpy(int32_t * s1, char * s2, uint32_t n);
int64_t local_memset(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t printf(char * a1, int64_t a2, int128_t a3);
float64_t rtclock(void);
void sha_final(void);
void sha_init(void);
void sha_stream(void);
void sha_transform(void);
void sha_update(char * buffer, int32_t count);
int32_t submain(void);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------------------------ Functions -------------------------

// Address range: 0x0 - 0x86
int64_t local_memset(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t v1 = a1; // 0x3b
    if ((int32_t)a4 >= 1) {
        int64_t v2 = a1; // 0x45
        int64_t v3 = 0x100000000 * a4;
        v3 -= 0x100000000;
        v2 += 4;
        v1 = v2;
        while ((int32_t)(v3 / 0x100000000) >= 1) {
            // 0x41
            v3 -= 0x100000000;
            v2 += 4;
            v1 = v2;
        }
    }
    int64_t v4 = (0x100000000 * (int64_t)((int32_t)a3 >> 31) | a3 & 0xffffffff) / 4; // 0x1a
    int32_t v5 = v4; // 0x1a
    if (v5 < 1) {
        // 0x84
        return v4 & 0xffffffff;
    }
    int64_t v6 = v1; // 0x0
    for (int32_t i = v5; i >= 1; i--) {
        // 0x6b
        *(int32_t *)v6 = (int32_t)a2;
        v6 += 4;
    }
    // 0x84
    return 0;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x90 - 0x171
// Line range:    71 - 91
void local_memcpy(int32_t * s1, char * s2, uint32_t n) {
    int32_t v1 = (0x100000000 * (int64_t)((int32_t)n >> 31) | (int64_t)n) / 4; // 0xa8
    char * v2 = s2; // 0xcb
    int32_t * v3 = s1; // 0xcb
    if (v1 < 1) {
        // 0x16f
        return;
    }
    for (int32_t i = v1; i >= 1; i--) {
        int64_t v4 = (int64_t)v2; // 0xd8
        unsigned char v5 = *v2; // 0xe7
        unsigned char v6 = *(char *)(v4 + 1); // 0x104
        unsigned char v7 = *(char *)(v4 + 2); // 0x124
        unsigned char v8 = *(char *)(v4 + 3); // 0x144
        *v3 = 256 * (int32_t)v6 | (int32_t)v5 | 0x10000 * (int32_t)v7 | 0x1000000 * (int32_t)v8;
        v2 = (char *)(v4 + 4);
        v3 = (int32_t *)((int64_t)v3 + 4);
    }
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x180 - 0x4ee
// Line range:    97 - 138
void sha_transform(void) {
    // 0x180
    int64_t v1; // 0x180
    int32_t temp = v1; // bp-8, 0x180
    int64_t v2 = (int64_t)&temp - 352;
    int64_t v3 = 0;
    int64_t v4 = 4 * v3; // 0x1a7
    *(int32_t *)(v4 + v2) = *(int32_t *)(*(int64_t *)423 + v4);
    v3++;
    int64_t v5 = 16; // 0x196
    while (v3 != 16) {
        // 0x19c
        v4 = 4 * v3;
        *(int32_t *)(v4 + v2) = *(int32_t *)(*(int64_t *)423 + v4);
        v3++;
        v5 = 16;
    }
    int64_t v6 = 4 * v5 + v2;
    int32_t v7 = *(int32_t *)(v6 - 12); // 0x1dc
    int32_t v8 = *(int32_t *)(v6 - 32); // 0x1eb
    int32_t v9 = *(int32_t *)(v6 - 64); // 0x209
    *(int32_t *)v6 = v8 ^ v7 ^ *(int32_t *)(v6 - 56) ^ v9;
    int64_t v10 = v5 + 1;
    v5 = v10;
    while (v10 != 80) {
        // 0x1d4
        v6 = 4 * v5 + v2;
        v7 = *(int32_t *)(v6 - 12);
        v8 = *(int32_t *)(v6 - 32);
        v9 = *(int32_t *)(v6 - 64);
        *(int32_t *)v6 = v8 ^ v7 ^ *(int32_t *)(v6 - 56) ^ v9;
        v10 = v5 + 1;
        v5 = v10;
    }
    int64_t v11 = 0;
    int32_t v12 = *(int32_t *)(*(int64_t *)611 + 16); // 0x180
    int32_t v13 = *(int32_t *)*(int64_t *)560;
    uint32_t v14 = *(int32_t *)(*(int64_t *)572 + 4);
    int32_t v15 = *(int32_t *)(*(int64_t *)585 + 8);
    int32_t v16 = *(int32_t *)(*(int64_t *)598 + 12);
    int32_t v17 = *(int32_t *)(4 * v11 + v2); // 0x2a2
    int32_t v18 = v12 + 0x5a827999 + (v16 & -1 - v14 | v14 & v15) + v17 + (32 * v13 | v13 / 0x8000000); // 0x2ab
    int32_t v19 = 0x40000000 * v14 | v14 / 4; // 0x2cc
    v11++;
    v12 = v16;
    int32_t v20 = v15; // 0x274
    int32_t v21 = v13; // 0x274
    int64_t v22 = 20; // 0x274
    while (v11 != 20) {
        // 0x27a
        v13 = v18;
        v14 = v21;
        v15 = v19;
        v16 = v20;
        v17 = *(int32_t *)(4 * v11 + v2);
        v18 = v12 + 0x5a827999 + (v16 & -1 - v14 | v14 & v15) + v17 + (32 * v13 | v13 / 0x8000000);
        v19 = 0x40000000 * v14 | v14 / 4;
        v11++;
        v12 = v16;
        v20 = v15;
        v21 = v13;
        v22 = 20;
    }
    int32_t v23 = v18;
    uint32_t v24 = v13;
    int32_t v25 = v19;
    int32_t v26 = v15;
    int32_t v27 = *(int32_t *)(4 * v22 + v2); // 0x31c
    int32_t v28 = v16 + 0x6ed9eba1 + (v25 ^ v26 ^ v24) + v27 + (32 * v23 | v23 / 0x8000000); // 0x325
    int32_t v29 = 0x40000000 * v24 | v24 / 4; // 0x346
    int64_t v30 = v22 + 1;
    v22 = v30;
    int32_t v31 = v26; // 0x2f6
    int32_t v32 = v25; // 0x2f6
    int32_t v33 = v23; // 0x2f6
    int64_t v34 = 40; // 0x2f6
    while (v30 != 40) {
        // 0x2fc
        v23 = v28;
        v24 = v33;
        v25 = v29;
        v26 = v32;
        v27 = *(int32_t *)(4 * v22 + v2);
        v28 = v31 + 0x6ed9eba1 + (v25 ^ v26 ^ v24) + v27 + (32 * v23 | v23 / 0x8000000);
        v29 = 0x40000000 * v24 | v24 / 4;
        v30 = v22 + 1;
        v22 = v30;
        v31 = v26;
        v32 = v25;
        v33 = v23;
        v34 = 40;
    }
    int32_t v35 = v28;
    uint32_t v36 = v23;
    int32_t v37 = v29;
    int32_t v38 = v25;
    int32_t v39 = *(int32_t *)(4 * v34 + v2); // 0x3a3
    int32_t v40 = v26 - 0x70e44324 + ((v37 | v38) & v36 | v37 & v38) + v39 + (32 * v35 | v35 / 0x8000000); // 0x3b6
    int32_t v41 = 0x40000000 * v36 | v36 / 4; // 0x3d4
    int64_t v42 = v34 + 1;
    v34 = v42;
    int32_t v43 = v38; // 0x370
    int32_t v44 = v37; // 0x370
    int32_t v45 = v35; // 0x370
    int64_t v46 = 60; // 0x370
    while (v42 != 60) {
        // 0x376
        v35 = v40;
        v36 = v45;
        v37 = v41;
        v38 = v44;
        v39 = *(int32_t *)(4 * v34 + v2);
        v40 = v43 - 0x70e44324 + ((v37 | v38) & v36 | v37 & v38) + v39 + (32 * v35 | v35 / 0x8000000);
        v41 = 0x40000000 * v36 | v36 / 4;
        v42 = v34 + 1;
        v34 = v42;
        v43 = v38;
        v44 = v37;
        v45 = v35;
        v46 = 60;
    }
    int32_t v47 = v40;
    uint32_t v48 = v35;
    int32_t v49 = v41;
    int32_t v50 = v37;
    int32_t v51 = *(int32_t *)(4 * v46 + v2); // 0x424
    int32_t v52 = v38 - 0x359d3e2a + (v49 ^ v50 ^ v48) + v51 + (32 * v47 | v47 / 0x8000000); // 0x437
    int32_t v53 = 0x40000000 * v48 | v48 / 4; // 0x455
    int64_t v54 = v46 + 1;
    v46 = v54;
    int32_t v55 = v50; // 0x3fe
    int32_t v56 = v49; // 0x3fe
    int32_t v57 = v47; // 0x3fe
    while (v54 != 80) {
        // 0x404
        v47 = v52;
        v48 = v57;
        v49 = v53;
        v50 = v56;
        v51 = *(int32_t *)(4 * v46 + v2);
        v52 = v55 - 0x359d3e2a + (v49 ^ v50 ^ v48) + v51 + (32 * v47 | v47 / 0x8000000);
        v53 = 0x40000000 * v48 | v48 / 4;
        v54 = v46 + 1;
        v46 = v54;
        v55 = v50;
        v56 = v49;
        v57 = v47;
    }
    int32_t v58 = *(int32_t *)*(int64_t *)1150; // 0x47e
    *(int32_t *)*(int64_t *)1159 = v58 + v52;
    int32_t v59 = *(int32_t *)(*(int64_t *)1171 + 4); // 0x493
    *(int32_t *)(*(int64_t *)1181 + 4) = v59 + v47;
    int32_t v60 = *(int32_t *)(*(int64_t *)1194 + 8); // 0x4aa
    *(int32_t *)(*(int64_t *)1204 + 8) = v60 + v53;
    int32_t v61 = *(int32_t *)(*(int64_t *)1217 + 12); // 0x4c1
    *(int32_t *)(*(int64_t *)1227 + 12) = v61 + v49;
    int32_t v62 = *(int32_t *)(*(int64_t *)1240 + 16); // 0x4d8
    *(int32_t *)(*(int64_t *)1250 + 16) = v62 + v50;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x4f0 - 0x555
// Line range:    143 - 152
void sha_init(void) {
    // 0x4f0
    *(int32_t *)*(int64_t *)1275 = 0x67452301;
    *(int32_t *)(*(int64_t *)1288 + 4) = -0x10325477;
    *(int32_t *)(*(int64_t *)1302 + 8) = -0x67452302;
    *(int32_t *)(*(int64_t *)1316 + 12) = 0x10325476;
    *(int32_t *)(*(int64_t *)1330 + 16) = -0x3c2d1e10;
    *(int32_t *)*(int64_t *)1344 = 0;
    *(int32_t *)*(int64_t *)1357 = 0;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x560 - 0x5a4
// Line range:    157 - 173
void sha_update(char * buffer, int32_t count) {
    uint32_t v1 = *(int32_t *)*(int64_t *)1415; // 0x587
    if (*(int32_t *)*(int64_t *)1398 + 8 * count < v1) {
        int32_t v2 = *(int32_t *)*(int64_t *)1430; // 0x596
        *(int32_t *)*(int64_t *)1442 = v2 + 1;
    }
}

// Address range: 0x5aa - 0x62b
int64_t function_5aa(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int32_t v1 = *(int32_t *)*(int64_t *)1457; // 0x5b1
    *(int32_t *)*(int64_t *)1466 = v1 + (int32_t)a4;
    int64_t v2; // 0x5aa
    int32_t * v3 = (int32_t *)(v2 - 12); // 0x5bc
    int32_t v4 = *(int32_t *)*(int64_t *)1481; // 0x5c9
    *(int32_t *)*(int64_t *)1490 = v4 + *v3 / 0x20000000;
    int32_t v5 = *v3;
    int64_t * v6 = (int64_t *)(v2 - 8);
    int64_t v7 = *v6;
    if (v5 < 64) {
        // 0x612
        local_memcpy((int32_t *)*(int64_t *)1568, (char *)v7, v5);
        return &g1;
    }
    local_memcpy((int32_t *)*(int64_t *)1513, (char *)v7, 64);
    sha_transform();
    *v6 = *v6 + 64;
    int32_t v8 = *v3 - 64; // 0x607
    *v3 = v8;
    int64_t v9 = *v6;
    int32_t v10 = v8; // 0x5d8
    int64_t v11 = v9; // 0x5d8
    while (v8 >= 64) {
        // 0x5de
        local_memcpy((int32_t *)*(int64_t *)1513, (char *)v9, 64);
        sha_transform();
        *v6 = *v6 + 64;
        v8 = *v3 - 64;
        *v3 = v8;
        v9 = *v6;
        v10 = v8;
        v11 = v9;
    }
    int64_t v12 = *(int64_t *)1568; // 0x619
    local_memcpy((int32_t *)v12, (char *)v11, v10);
    return &g1;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x630 - 0x6d3
// Line range:    178 - 201
void sha_final(void) {
    uint32_t v1 = *(int32_t *)*(int64_t *)1599 / 8 & 63; // 0x656
    *(int32_t *)(*(int64_t *)1649 + (int64_t)(4 * v1)) = 128;
    if (v1 >= 56) {
        // 0x682
        sha_transform();
    }
}

// Address range: 0x6d4 - 0x6f8
int64_t function_6d4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x6d4
    __asm_hlt();
    *(int32_t *)(*(int64_t *)1757 + 56) = (int32_t)a4;
    int64_t v1; // 0x6d4
    *(int32_t *)(*(int64_t *)1770 + 60) = *(int32_t *)(v1 - 8);
    sha_transform();
    return &g1;
}

// From module:   /docker_shared/cs699_webassembly/emscripten_compile/sha.h
// Address range: 0x700 - 0x76a
// Line range:    205 - 218
void sha_stream(void) {
    // 0x700
    sha_init();
    for (int64_t i = 0; i < 2; i++) {
        int32_t v1 = *(int32_t *)(*(int64_t *)1833 + 4 * i); // 0x729
        sha_update((char *)(*(int64_t *)1850 + 0x2000 * i), v1);
    }
    // 0x75f
    sha_final();
}

// Address range: 0x770 - 0x81a
// Line range:    62 - 76
int32_t submain(void) {
    int64_t v1 = __asm_movsd((int128_t)(int32_t)(float32_t)rtclock()); // 0x78b
    *(int64_t *)*(int64_t *)1931 = v1;
    sha_stream();
    int32_t result = 0; // 0x7c9
    for (int64_t i = 0; i < 5; i++) {
        int64_t v2 = 4 * i; // 0x7b0
        int32_t v3 = *(int32_t *)(v2 + *(int64_t *)1968); // 0x7b0
        result += (int32_t)(v3 != *(int32_t *)(v2 + *(int64_t *)1982));
    }
    int64_t v4 = __asm_movsd((int128_t)(int32_t)(float32_t)rtclock()); // 0x7e9
    *(int64_t *)*(int64_t *)2025 = v4;
    int128_t v5 = __asm_movsd_1(*(int64_t *)*(int64_t *)2036); // 0x7f4
    int64_t v6; // 0x770
    printf("%0.6f\n", v6, __asm_subsd(v5, *(int64_t *)*(int64_t *)2047));
    return result;
}

// Address range: 0x820 - 0x874
// Line range:    45 - 52
float64_t rtclock(void) {
    // 0x820
    int64_t Tp; // bp-24, 0x820
    int64_t v1 = gettimeofday(&Tp, 0); // 0x830
    if ((int32_t)v1 != 0) {
        // 0x842
        int128_t v2; // 0x820
        printf("Error return from gettimeofday: %d", v1 & 0xffffffff, v2);
    }
    int128_t v3 = __asm_cvtsi2sd(Tp); // 0x853
    int64_t v4; // 0x820
    int128_t v5 = __asm_mulsd(__asm_cvtsi2sd_2((int32_t)v4), __asm_movsd_1(0x3eb0c6f7a0b5ed8d)); // 0x866
    return (int64_t)__asm_addsd(v5, v3);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (17.0.0)
// Detected functions: 11

